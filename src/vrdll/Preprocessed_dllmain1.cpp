#pragma once
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(pop)
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(pop)
#pragma once
#pragma region Application Family or OneCore Family
#pragma warning(disable : 4514)
#pragma warning(disable : 4103)
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
#pragma once
#pragma once
#pragma once
#pragma region Input Buffer SAL 1 compatibility macros
#pragma endregion Input Buffer SAL 1 compatibility macros
extern "C" {
}
#pragma once
extern "C" {
}
#pragma once
#pragma pack(push, 8)
#pragma warning(push)
#pragma warning(disable : 4514 4820)
extern "C" {
typedef unsigned __int64 uintptr_t;
typedef char* va_list;
void __cdecl __va_start(va_list*, ...);
}
extern "C++" {
template <typename _Ty>
struct __vcrt_va_list_is_reference {
    enum : bool { __the_value = false };
};
template <typename _Ty>
struct __vcrt_va_list_is_reference<_Ty&> {
    enum : bool { __the_value = true };
};
template <typename _Ty>
struct __vcrt_va_list_is_reference<_Ty&&> {
    enum : bool { __the_value = true };
};
template <typename _Ty>
struct __vcrt_assert_va_start_is_not_reference {
    static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
        "va_start argument must not have reference type and must not be parenthesized");
};
}
#pragma warning(pop)
#pragma pack(pop)
#pragma warning(push)
#pragma warning(disable : 4514 4820)
__pragma(pack(push, 8)) extern "C"
{
    typedef unsigned __int64 size_t;
    typedef __int64 ptrdiff_t;
    typedef __int64 intptr_t;
    typedef bool __vcrt_bool;
    extern "C++" {
    template <typename _CountofType, size_t _SizeOfArray>
    char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
    }
    void __cdecl __security_init_cookie(void);
    void __cdecl __security_check_cookie(uintptr_t _StackCookie);
    __declspec(noreturn) void __cdecl __report_gsfailure(uintptr_t _StackCookie);
    extern uintptr_t __security_cookie;
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4514 4820)
    __pragma(pack(push, 8)) extern "C"
{
    typedef enum _EXCEPTION_DISPOSITION {
        ExceptionContinueExecution,
        ExceptionContinueSearch,
        ExceptionNestedException,
        ExceptionCollidedUnwind
    } EXCEPTION_DISPOSITION;
    struct _EXCEPTION_RECORD;
    struct _CONTEXT;
    struct _DISPATCHER_CONTEXT;
    EXCEPTION_DISPOSITION __cdecl __C_specific_handler(
        struct _EXCEPTION_RECORD * ExceptionRecord,
        void* EstablisherFrame,
        struct _CONTEXT* ContextRecord,
        struct _DISPATCHER_CONTEXT* DispatcherContext);
    unsigned long __cdecl _exception_code(void);
    void* __cdecl _exception_info(void);
    int __cdecl _abnormal_termination(void);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4514 4820)
    __pragma(pack(push, 8)) extern "C"
{
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
    extern "C"
{
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4668)
    extern "C" {
    }
#pragma once
#pragma once
    extern "C" {
    }
#pragma warning(pop)
#pragma region Application Family or OneCore Family or Games Family
    extern "C" {
    typedef unsigned long ULONG;
    typedef ULONG* PULONG;
    typedef unsigned short USHORT;
    typedef USHORT* PUSHORT;
    typedef unsigned char UCHAR;
    typedef UCHAR* PUCHAR;
    typedef char* PSZ;
    typedef unsigned long DWORD;
    typedef int BOOL;
    typedef unsigned char BYTE;
    typedef unsigned short WORD;
    typedef float FLOAT;
    typedef FLOAT* PFLOAT;
    typedef BOOL* PBOOL;
    typedef BOOL* LPBOOL;
    typedef BYTE* PBYTE;
    typedef BYTE* LPBYTE;
    typedef int* PINT;
    typedef int* LPINT;
    typedef WORD* PWORD;
    typedef WORD* LPWORD;
    typedef long* LPLONG;
    typedef DWORD* PDWORD;
    typedef DWORD* LPDWORD;
    typedef void* LPVOID;
    typedef const void* LPCVOID;
    typedef int INT;
    typedef unsigned int UINT;
    typedef unsigned int* PUINT;
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
#pragma warning(disable : 4200)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
    extern "C" {
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
    {
        extern "C++" {
        template <bool _Enable, typename _Ty>
        struct _CrtEnableIf;
        template <typename _Ty>
        struct _CrtEnableIf<true, _Ty> {
            typedef _Ty _Type;
        };
        }
        typedef bool __crt_bool;
        __declspec(dllimport) void __cdecl _invalid_parameter(
            wchar_t const*,
            wchar_t const*,
            wchar_t const*,
            unsigned int,
            uintptr_t);
        __declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
        __declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);
        __declspec(noreturn) __declspec(dllimport) void __cdecl _invoke_watson(
            wchar_t const* _Expression,
            wchar_t const* _FunctionName,
            wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);
        typedef int errno_t;
        typedef unsigned short wint_t;
        typedef unsigned short wctype_t;
        typedef long __time32_t;
        typedef __int64 __time64_t;
        typedef struct __crt_locale_data_public {
            unsigned short const* _locale_pctype;
            int _locale_mb_cur_max;
            unsigned int _locale_lc_codepage;
        } __crt_locale_data_public;
        typedef struct __crt_locale_pointers {
            struct __crt_locale_data* locinfo;
            struct __crt_multibyte_data* mbcinfo;
        } __crt_locale_pointers;
        typedef __crt_locale_pointers* _locale_t;
        typedef struct _Mbstatet {
            unsigned long _Wchar;
            unsigned short _Byte, _State;
        } _Mbstatet;
        typedef _Mbstatet mbstate_t;
        typedef __time64_t time_t;
        typedef size_t rsize_t;
    }
    __pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
        __pragma(pack(push, 8)) extern "C"
    {
        __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
        __declspec(dllimport) const wctype_t* __cdecl __pwctype_func(void);
        __declspec(dllimport) int __cdecl iswalnum(wint_t _C);
        __declspec(dllimport) int __cdecl iswalpha(wint_t _C);
        __declspec(dllimport) int __cdecl iswascii(wint_t _C);
        __declspec(dllimport) int __cdecl iswblank(wint_t _C);
        __declspec(dllimport) int __cdecl iswcntrl(wint_t _C);
        __declspec(dllimport) int __cdecl iswdigit(wint_t _C);
        __declspec(dllimport) int __cdecl iswgraph(wint_t _C);
        __declspec(dllimport) int __cdecl iswlower(wint_t _C);
        __declspec(dllimport) int __cdecl iswprint(wint_t _C);
        __declspec(dllimport) int __cdecl iswpunct(wint_t _C);
        __declspec(dllimport) int __cdecl iswspace(wint_t _C);
        __declspec(dllimport) int __cdecl iswupper(wint_t _C);
        __declspec(dllimport) int __cdecl iswxdigit(wint_t _C);
        __declspec(dllimport) int __cdecl __iswcsymf(wint_t _C);
        __declspec(dllimport) int __cdecl __iswcsym(wint_t _C);
        __declspec(dllimport) int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) wint_t __cdecl towupper(wint_t _C);
        __declspec(dllimport) wint_t __cdecl towlower(wint_t _C);
        __declspec(dllimport) int __cdecl iswctype(wint_t _C, wctype_t _Type);
        __declspec(dllimport) wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isleadbyte(int _C);
        __declspec(dllimport) int __cdecl _isleadbyte_l(int _C, _locale_t _Locale);
        __declspec(deprecated("This function or variable has been superceded by newer library "
                              "or operating system functionality. Consider using "
                              "iswctype"
                              " "
                              "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t _C, wctype_t _Type);
    }
    __pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
        __pragma(pack(push, 8)) extern "C"
    {
        __declspec(dllimport) int __cdecl _isctype(int _C, int _Type);
        __declspec(dllimport) int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isalpha(int _C);
        __declspec(dllimport) int __cdecl _isalpha_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isupper(int _C);
        __declspec(dllimport) int __cdecl _isupper_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl islower(int _C);
        __declspec(dllimport) int __cdecl _islower_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isdigit(int _C);
        __declspec(dllimport) int __cdecl _isdigit_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isxdigit(int _C);
        __declspec(dllimport) int __cdecl _isxdigit_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isspace(int _C);
        __declspec(dllimport) int __cdecl _isspace_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl ispunct(int _C);
        __declspec(dllimport) int __cdecl _ispunct_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isblank(int _C);
        __declspec(dllimport) int __cdecl _isblank_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isalnum(int _C);
        __declspec(dllimport) int __cdecl _isalnum_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isprint(int _C);
        __declspec(dllimport) int __cdecl _isprint_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl isgraph(int _C);
        __declspec(dllimport) int __cdecl _isgraph_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl iscntrl(int _C);
        __declspec(dllimport) int __cdecl _iscntrl_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl toupper(int _C);
        __declspec(dllimport) int __cdecl tolower(int _C);
        __declspec(dllimport) int __cdecl _tolower(int _C);
        __declspec(dllimport) int __cdecl _tolower_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl _toupper(int _C);
        __declspec(dllimport) int __cdecl _toupper_l(int _C, _locale_t _Locale);
        __declspec(dllimport) int __cdecl __isascii(int _C);
        __declspec(dllimport) int __cdecl __toascii(int _C);
        __declspec(dllimport) int __cdecl __iscsymf(int _C);
        __declspec(dllimport) int __cdecl __iscsym(int _C);
        __inline int __cdecl __acrt_locale_get_ctype_array_value(
            unsigned short const* const _Locale_pctype_array,
            int const _Char_value,
            int const _Mask)
        {
            if (_Char_value >= -1 && _Char_value <= 255) {
                return _Locale_pctype_array[_Char_value] & _Mask;
            }
            return 0;
        }
        __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
        __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
        __declspec(dllimport) int __cdecl _chvalidator(int _Ch, int _Mask);
        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z') {
                return _C - ('A' - 'a');
            }
            return _C;
        }
        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z') {
                return _C - ('a' - 'A');
            }
            return _C;
        }
        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }
        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }
        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }
        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
        __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
        {
            _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
            return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
        }
        __declspec(dllimport) int __cdecl _chvalidator_l(_locale_t, int _Ch, int _Mask);
        __inline int __cdecl _chvalidchk_l(
            int const _C,
            int const _Mask,
            _locale_t const _Locale)
        {
            return _chvalidator_l(_Locale, _C, _Mask);
        }
        __inline int __cdecl _ischartype_l(
            int const _C,
            int const _Mask,
            _locale_t const _Locale)
        {
            if (!_Locale) {
                return _chvalidchk_l(_C, _Mask, 0);
            }
            if (_C >= -1 && _C <= 255) {
                return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
            }
            if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1) {
                return _isctype_l(_C, _Mask, _Locale);
            }
            return 0;
        }
    }
    __pragma(pack(pop))
#pragma warning(pop)
#pragma once
        extern "C"
    {
    }
#pragma warning(push)
#pragma warning(disable : 4668)
    typedef unsigned __int64 POINTER_64_INT;
#pragma once
    extern "C" {
    typedef signed char INT8, *PINT8;
    typedef signed short INT16, *PINT16;
    typedef signed int INT32, *PINT32;
    typedef signed __int64 INT64, *PINT64;
    typedef unsigned char UINT8, *PUINT8;
    typedef unsigned short UINT16, *PUINT16;
    typedef unsigned int UINT32, *PUINT32;
    typedef unsigned __int64 UINT64, *PUINT64;
    typedef signed int LONG32, *PLONG32;
    typedef unsigned int ULONG32, *PULONG32;
    typedef unsigned int DWORD32, *PDWORD32;
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;
    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
    typedef void* __ptr64 HANDLE64;
    typedef HANDLE64* PHANDLE64;
    typedef __int64 SHANDLE_PTR;
    typedef unsigned __int64 HANDLE_PTR;
    typedef unsigned int UHALF_PTR, *PUHALF_PTR;
    typedef int HALF_PTR, *PHALF_PTR;
    __inline unsigned long
    HandleToULong(
        const void* h)
    {
        return ((unsigned long)(ULONG_PTR)h);
    }
    __inline long
    HandleToLong(
        const void* h)
    {
        return ((long)(LONG_PTR)h);
    }
    __inline void*
    ULongToHandle(
        const unsigned long h)
    {
        return ((void*)(UINT_PTR)h);
    }
    __inline void*
    LongToHandle(
        const long h)
    {
        return ((void*)(INT_PTR)h);
    }
    __inline unsigned long
    PtrToUlong(
        const void* p)
    {
        return ((unsigned long)(ULONG_PTR)p);
    }
    __inline unsigned int
    PtrToUint(
        const void* p)
    {
        return ((unsigned int)(UINT_PTR)p);
    }
    __inline unsigned short
    PtrToUshort(
        const void* p)
    {
        return ((unsigned short)(unsigned long)(ULONG_PTR)p);
    }
    __inline long
    PtrToLong(
        const void* p)
    {
        return ((long)(LONG_PTR)p);
    }
    __inline int
    PtrToInt(
        const void* p)
    {
        return ((int)(INT_PTR)p);
    }
    __inline short
    PtrToShort(
        const void* p)
    {
        return ((short)(long)(LONG_PTR)p);
    }
    __inline void*
    IntToPtr(
        const int i)
    {
        return ((void*)(INT_PTR)i);
    }
    __inline void*
    UIntToPtr(
        const unsigned int ui)
    {
        return ((void*)(UINT_PTR)ui);
    }
    __inline void*
    LongToPtr(
        const long l)
    {
        return ((void*)(LONG_PTR)l);
    }
    __inline void*
    ULongToPtr(
        const unsigned long ul)
    {
        return ((void*)(ULONG_PTR)ul);
    }
    __inline void*
    Ptr32ToPtr(
        const void* __ptr32 p)
    {
        return ((void*)(ULONG_PTR)(unsigned long)p);
    }
    __inline void*
    Handle32ToHandle(
        const void* __ptr32 h)
    {
        return ((void*)(LONG_PTR)(long)h);
    }
    __inline void* __ptr32 PtrToPtr32(
        const void* p)
    {
        return ((void* __ptr32)(unsigned long)(ULONG_PTR)p);
    }
    typedef ULONG_PTR SIZE_T, *PSIZE_T;
    typedef LONG_PTR SSIZE_T, *PSSIZE_T;
    typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
    typedef __int64 LONG64, *PLONG64;
    typedef unsigned __int64 ULONG64, *PULONG64;
    typedef unsigned __int64 DWORD64, *PDWORD64;
    typedef ULONG_PTR KAFFINITY;
    typedef KAFFINITY* PKAFFINITY;
    }
#pragma warning(pop)
    typedef void* PVOID;
    typedef void* __ptr64 PVOID64;
    typedef char CHAR;
    typedef short SHORT;
    typedef long LONG;
    typedef int INT;
    typedef wchar_t WCHAR;
    typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
    typedef const WCHAR *LPCWCH, *PCWCH;
    typedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;
    typedef PWSTR* PZPWSTR;
    typedef const PWSTR* PCZPWSTR;
    typedef WCHAR __unaligned *LPUWSTR, *PUWSTR;
    typedef const WCHAR *LPCWSTR, *PCWSTR;
    typedef PCWSTR* PZPCWSTR;
    typedef const PCWSTR* PCZPCWSTR;
    typedef const WCHAR __unaligned *LPCUWSTR, *PCUWSTR;
    typedef WCHAR* PZZWSTR;
    typedef const WCHAR* PCZZWSTR;
    typedef WCHAR __unaligned* PUZZWSTR;
    typedef const WCHAR __unaligned* PCUZZWSTR;
    typedef WCHAR* PNZWCH;
    typedef const WCHAR* PCNZWCH;
    typedef WCHAR __unaligned* PUNZWCH;
    typedef const WCHAR __unaligned* PCUNZWCH;
    typedef const WCHAR *LPCWCHAR, *PCWCHAR;
    typedef const WCHAR __unaligned *LPCUWCHAR, *PCUWCHAR;
    typedef unsigned long UCSCHAR;
    typedef UCSCHAR* PUCSCHAR;
    typedef const UCSCHAR* PCUCSCHAR;
    typedef UCSCHAR* PUCSSTR;
    typedef UCSCHAR __unaligned* PUUCSSTR;
    typedef const UCSCHAR* PCUCSSTR;
    typedef const UCSCHAR __unaligned* PCUUCSSTR;
    typedef UCSCHAR __unaligned* PUUCSCHAR;
    typedef const UCSCHAR __unaligned* PCUUCSCHAR;
    typedef CHAR *PCHAR, *LPCH, *PCH;
    typedef const CHAR *LPCCH, *PCCH;
    typedef CHAR *NPSTR, *LPSTR, *PSTR;
    typedef PSTR* PZPSTR;
    typedef const PSTR* PCZPSTR;
    typedef const CHAR *LPCSTR, *PCSTR;
    typedef PCSTR* PZPCSTR;
    typedef const PCSTR* PCZPCSTR;
    typedef CHAR* PZZSTR;
    typedef const CHAR* PCZZSTR;
    typedef CHAR* PNZCH;
    typedef const CHAR* PCNZCH;
    typedef WCHAR TCHAR, *PTCHAR;
    typedef WCHAR TBYTE, *PTBYTE;
    typedef LPWCH LPTCH, PTCH;
    typedef LPCWCH LPCTCH, PCTCH;
    typedef LPWSTR PTSTR, LPTSTR;
    typedef LPCWSTR PCTSTR, LPCTSTR;
    typedef LPUWSTR PUTSTR, LPUTSTR;
    typedef LPCUWSTR PCUTSTR, LPCUTSTR;
    typedef LPWSTR LP;
    typedef PZZWSTR PZZTSTR;
    typedef PCZZWSTR PCZZTSTR;
    typedef PUZZWSTR PUZZTSTR;
    typedef PCUZZWSTR PCUZZTSTR;
    typedef PZPWSTR PZPTSTR;
    typedef PNZWCH PNZTCH;
    typedef PCNZWCH PCNZTCH;
    typedef PUNZWCH PUNZTCH;
    typedef PCUNZWCH PCUNZTCH;
    typedef SHORT* PSHORT;
    typedef LONG* PLONG;
    typedef struct _PROCESSOR_NUMBER {
        WORD Group;
        BYTE Number;
        BYTE Reserved;
    } PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
    typedef struct _GROUP_AFFINITY {
        KAFFINITY Mask;
        WORD Group;
        WORD Reserved[3];
    } GROUP_AFFINITY, *PGROUP_AFFINITY;
    typedef void* HANDLE;
    typedef HANDLE* PHANDLE;
    typedef BYTE FCHAR;
    typedef WORD FSHORT;
    typedef DWORD FLONG;
    typedef long HRESULT;
    typedef char CCHAR;
    typedef DWORD LCID;
    typedef PDWORD PLCID;
    typedef WORD LANGID;
    typedef enum {
        UNSPECIFIED_COMPARTMENT_ID = 0,
        DEFAULT_COMPARTMENT_ID
    } COMPARTMENT_ID,
        *PCOMPARTMENT_ID;
    typedef struct _FLOAT128 {
        __int64 LowPart;
        __int64 HighPart;
    } FLOAT128;
    typedef FLOAT128* PFLOAT128;
    typedef __int64 LONGLONG;
    typedef unsigned __int64 ULONGLONG;
    typedef LONGLONG* PLONGLONG;
    typedef ULONGLONG* PULONGLONG;
    typedef LONGLONG USN;
    typedef union _LARGE_INTEGER {
        struct {
            DWORD LowPart;
            LONG HighPart;
        };
        struct {
            DWORD LowPart;
            LONG HighPart;
        } u;
        LONGLONG QuadPart;
    } LARGE_INTEGER;
    typedef LARGE_INTEGER* PLARGE_INTEGER;
    typedef union _ULARGE_INTEGER {
        struct {
            DWORD LowPart;
            DWORD HighPart;
        };
        struct {
            DWORD LowPart;
            DWORD HighPart;
        } u;
        ULONGLONG QuadPart;
    } ULARGE_INTEGER;
    typedef ULARGE_INTEGER* PULARGE_INTEGER;
    typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;
    typedef LONG RTL_REFERENCE_COUNT32, *PRTL_REFERENCE_COUNT32;
    typedef struct _LUID {
        DWORD LowPart;
        LONG HighPart;
    } LUID, *PLUID;
    typedef ULONGLONG DWORDLONG;
    typedef DWORDLONG* PDWORDLONG;
    extern "C" {
    unsigned char __cdecl _rotl8(
        unsigned char Value,
        unsigned char Shift);
    unsigned short __cdecl _rotl16(
        unsigned short Value,
        unsigned char Shift);
    unsigned char __cdecl _rotr8(
        unsigned char Value,
        unsigned char Shift);
    unsigned short __cdecl _rotr16(
        unsigned short Value,
        unsigned char Shift);
#pragma intrinsic(_rotl8)
#pragma intrinsic(_rotl16)
#pragma intrinsic(_rotr8)
#pragma intrinsic(_rotr16)
    unsigned int __cdecl _rotl(
        unsigned int Value,
        int Shift);
    unsigned __int64 __cdecl _rotl64(
        unsigned __int64 Value,
        int Shift);
    unsigned int __cdecl _rotr(
        unsigned int Value,
        int Shift);
    unsigned __int64 __cdecl _rotr64(
        unsigned __int64 Value,
        int Shift);
#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)
    }
    typedef BYTE BOOLEAN;
    typedef BOOLEAN* PBOOLEAN;
    typedef struct _LIST_ENTRY {
        struct _LIST_ENTRY* Flink;
        struct _LIST_ENTRY* Blink;
    } LIST_ENTRY, *PLIST_ENTRY, *PRLIST_ENTRY;
    typedef struct _SINGLE_LIST_ENTRY {
        struct _SINGLE_LIST_ENTRY* Next;
    } SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
    typedef struct LIST_ENTRY32 {
        DWORD Flink;
        DWORD Blink;
    } LIST_ENTRY32;
    typedef LIST_ENTRY32* PLIST_ENTRY32;
    typedef struct LIST_ENTRY64 {
        ULONGLONG Flink;
        ULONGLONG Blink;
    } LIST_ENTRY64;
    typedef LIST_ENTRY64* PLIST_ENTRY64;
    typedef struct _GUID {
        unsigned long Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char Data4[8];
    } GUID;
    typedef GUID* LPGUID;
    typedef const GUID* LPCGUID;
    typedef GUID IID;
    typedef IID* LPIID;
    typedef GUID CLSID;
    typedef CLSID* LPCLSID;
    typedef GUID FMTID;
    typedef FMTID* LPFMTID;
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
    {
        __declspec(dllimport) int* __cdecl _errno(void);
        __declspec(dllimport) errno_t __cdecl _set_errno(int _Value);
        __declspec(dllimport) errno_t __cdecl _get_errno(int* _Value);
        __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
        __declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value);
        __declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long* _Value);
    }
    __pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4514 4820)
        __pragma(pack(push, 8)) extern "C"
    {
        [[nodiscard]] void const* __cdecl memchr(
            void const* _Buf,
            int _Val,
            size_t _MaxCount);
        [[nodiscard]] int __cdecl memcmp(
            void const* _Buf1,
            void const* _Buf2,
            size_t _Size);
        void* __cdecl memcpy(
            void* _Dst,
            void const* _Src,
            size_t _Size);
        void* __cdecl memmove(
            void* _Dst,
            void const* _Src,
            size_t _Size);
        void* __cdecl memset(
            void* _Dst,
            int _Val,
            size_t _Size);
        [[nodiscard]] char const* __cdecl strchr(
            char const* _Str,
            int _Val);
        [[nodiscard]] char const* __cdecl strrchr(
            char const* _Str,
            int _Ch);
        [[nodiscard]] char const* __cdecl strstr(
            char const* _Str,
            char const* _SubStr);
        [[nodiscard]] wchar_t const* __cdecl wcschr(
            wchar_t const* _Str,
            wchar_t _Ch);
        [[nodiscard]] wchar_t const* __cdecl wcsrchr(
            wchar_t const* _Str,
            wchar_t _Ch);
        [[nodiscard]] wchar_t const* __cdecl wcsstr(
            wchar_t const* _Str,
            wchar_t const* _SubStr);
    }
    __pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
        __pragma(pack(push, 8)) extern "C" {
            static __inline errno_t __cdecl memcpy_s(
                void* const _Destination,
                rsize_t const _DestinationSize,
                void const* const _Source,
                rsize_t const _SourceSize) {
                if (_SourceSize == 0) {
                    return 0;
    }
    {
        int _Expr_val = !!(_Destination != 0);
        if (!(_Expr_val)) {
            (*_errno()) = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    };
    if (_Source == 0 || _DestinationSize < _SourceSize) {
        memset(_Destination, 0, _DestinationSize);
        {
            int _Expr_val = !!(_Source != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        };
        {
            int _Expr_val = !!(_DestinationSize >= _SourceSize);
            if (!(_Expr_val)) {
                (*_errno()) = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        };
        return 22;
    }
    memcpy(_Destination, _Source, _SourceSize);
    return 0;
    }
    static __inline errno_t __cdecl memmove_s(
        void* const _Destination,
        rsize_t const _DestinationSize,
        void const* const _Source,
        rsize_t const _SourceSize)
    {
        if (_SourceSize == 0) {
            return 0;
        }
        {
            int _Expr_val = !!(_Destination != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        };
        {
            int _Expr_val = !!(_Source != 0);
            if (!(_Expr_val)) {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        };
        {
            int _Expr_val = !!(_DestinationSize >= _SourceSize);
            if (!(_Expr_val)) {
                (*_errno()) = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        };
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }
#pragma warning(pop)
}
__pragma(pack(pop))
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) int __cdecl _memicmp(
        void const* _Buf1,
        void const* _Buf2,
        size_t _Size);
    __declspec(dllimport) int __cdecl _memicmp_l(
        void const* _Buf1,
        void const* _Buf2,
        size_t _Size,
        _locale_t _Locale);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_memccpy"
                          ". See online help for details.")) __declspec(dllimport) void* __cdecl memccpy(void* _Dst,
        void const* _Src,
        int _Val,
        size_t _Size);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_memicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl memicmp(void const* _Buf1,
        void const* _Buf2,
        size_t _Size);
    extern "C++" inline void* __cdecl memchr(
        void* _Pv,
        int _C,
        size_t _N)
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl wcscat_s(
        wchar_t * _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source);
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
        wchar_t * _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source);
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
        wchar_t * _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source,
        rsize_t _MaxCount);
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
        wchar_t * _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source,
        rsize_t _MaxCount);
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
        wchar_t * _String,
        wchar_t const* _Delimiter,
        wchar_t** _Context);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
        wchar_t const* _String);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcscat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat(wchar_t * _Destination, wchar_t const* _Source);
    __declspec(dllimport) int __cdecl wcscmp(
        wchar_t const* _String1,
        wchar_t const* _String2);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcscpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy(wchar_t * _Destination, wchar_t const* _Source);
    __declspec(dllimport) size_t __cdecl wcscspn(
        wchar_t const* _String,
        wchar_t const* _Control);
    __declspec(dllimport) size_t __cdecl wcslen(
        wchar_t const* _String);
    __declspec(dllimport) size_t __cdecl wcsnlen(
        wchar_t const* _Source,
        size_t _MaxCount);
    static __inline size_t __cdecl wcsnlen_s(
        wchar_t const* _Source,
        size_t _MaxCount)
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcsncat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(wchar_t * _Destination, wchar_t const* _Source, size_t _Count);
    __declspec(dllimport) int __cdecl wcsncmp(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcsncpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(wchar_t * _Destination, wchar_t const* _Source, size_t _Count);
    __declspec(dllimport) wchar_t const* __cdecl wcspbrk(
        wchar_t const* _String,
        wchar_t const* _Control);
    __declspec(dllimport) size_t __cdecl wcsspn(
        wchar_t const* _String,
        wchar_t const* _Control);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcstok_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcstok(wchar_t * _String,
        wchar_t const* _Delimiter,
        wchar_t** _Context);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcstok_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline wchar_t* __cdecl _wcstok(wchar_t* const _String,
        wchar_t const* const _Delimiter)
    {
        return wcstok(_String, _Delimiter, 0);
    }
    extern "C++" __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, "
                                       "adding an extra context parameter. To use the legacy Microsoft "
                                       "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")) inline wchar_t* __cdecl wcstok(wchar_t * _String,
        wchar_t const* _Delimiter) throw()
    {
        return wcstok(_String, _Delimiter, 0);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcserror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcserror(int _ErrorNumber);
    __declspec(dllimport) errno_t __cdecl _wcserror_s(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        int _ErrorNumber);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "__wcserror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl __wcserror(wchar_t const* _String);
    __declspec(dllimport) errno_t __cdecl __wcserror_s(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        wchar_t const* _ErrorMessage);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); }
    }
    __declspec(dllimport) int __cdecl _wcsicmp(
        wchar_t const* _String1,
        wchar_t const* _String2);
    __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _wcsnicmp(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _wcsnicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl _wcsnset_s(
        wchar_t * _Destination,
        size_t _SizeInWords,
        wchar_t _Value,
        size_t _MaxCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsnset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(wchar_t * _String, wchar_t _Value, size_t _MaxCount);
    __declspec(dllimport) wchar_t* __cdecl _wcsrev(
        wchar_t * _String);
    __declspec(dllimport) errno_t __cdecl _wcsset_s(
        wchar_t * _Destination,
        size_t _SizeInWords,
        wchar_t _Value);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(wchar_t * _String, wchar_t _Value);
    __declspec(dllimport) errno_t __cdecl _wcslwr_s(
        wchar_t * _String,
        size_t _SizeInWords);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcslwr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr(wchar_t * _String);
    __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
        wchar_t * _String,
        size_t _SizeInWords,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcslwr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(wchar_t * _String, _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl _wcsupr_s(
        wchar_t * _String,
        size_t _Size);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsupr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr(wchar_t * _String);
    __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
        wchar_t * _String,
        size_t _Size,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsupr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(wchar_t * _String, _locale_t _Locale);
    __declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t * _Destination,
        wchar_t const* _Source,
        size_t _MaxCount);
    __declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t * _Destination,
        wchar_t const* _Source,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl wcscoll(
        wchar_t const* _String1,
        wchar_t const* _String2);
    __declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _wcsicoll(
        wchar_t const* _String1,
        wchar_t const* _String2);
    __declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _wcsncoll(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _wcsncoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _wcsnicoll(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _wcsnicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount,
        _locale_t _Locale);
    extern "C++" {
    inline wchar_t* __cdecl wcschr(wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }
    inline wchar_t* __cdecl wcspbrk(wchar_t* _String, wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }
    inline wchar_t* __cdecl wcsrchr(wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }
    inline wchar_t* __cdecl wcsstr(wchar_t* _String, wchar_t const* _SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }
    }
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsdup"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsdup(wchar_t const* _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp(wchar_t const* _String1,
        wchar_t const* _String2);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsnicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp(wchar_t const* _String1,
        wchar_t const* _String2,
        size_t _MaxCount);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsnset"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsnset(wchar_t * _String,
        wchar_t _Value,
        size_t _MaxCount);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsrev"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsrev(wchar_t * _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsset"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsset(wchar_t * _String,
        wchar_t _Value);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcslwr"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcslwr(wchar_t * _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsupr"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsupr(wchar_t * _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsicoll"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll(wchar_t const* _String1,
        wchar_t const* _String2);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl strcpy_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source);
    __declspec(dllimport) errno_t __cdecl strcat_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source);
    __declspec(dllimport) errno_t __cdecl strerror_s(
        char* _Buffer,
        size_t _SizeInBytes,
        int _ErrorNumber);
    __declspec(dllimport) errno_t __cdecl strncat_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source,
        rsize_t _MaxCount);
    __declspec(dllimport) errno_t __cdecl strncpy_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source,
        rsize_t _MaxCount);
    __declspec(dllimport) char* __cdecl strtok_s(
        char* _String,
        char const* _Delimiter,
        char** _Context);
    __declspec(dllimport) void* __cdecl _memccpy(
        void* _Dst,
        void const* _Src,
        int _Val,
        size_t _MaxCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strcat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) char* __cdecl strcat(char* _Destination, char const* _Source);
    int __cdecl strcmp(
        char const* _Str1,
        char const* _Str2);
    __declspec(dllimport) int __cdecl _strcmpi(
        char const* _String1,
        char const* _String2);
    __declspec(dllimport) int __cdecl strcoll(
        char const* _String1,
        char const* _String2);
    __declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strcpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) char* __cdecl strcpy(char* _Destination, char const* _Source);
    __declspec(dllimport) size_t __cdecl strcspn(
        char const* _Str,
        char const* _Control);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
        char const* _Source);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strerror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strerror(char const* _ErrorMessage);
    __declspec(dllimport) errno_t __cdecl _strerror_s(
        char* _Buffer,
        size_t _SizeInBytes,
        char const* _ErrorMessage);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strerror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strerror(int _ErrorMessage);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); }
    }
    __declspec(dllimport) int __cdecl _stricmp(
        char const* _String1,
        char const* _String2);
    __declspec(dllimport) int __cdecl _stricoll(
        char const* _String1,
        char const* _String2);
    __declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
        _locale_t _Locale);
    size_t __cdecl strlen(
        char const* _Str);
    __declspec(dllimport) errno_t __cdecl _strlwr_s(
        char* _String,
        size_t _Size);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strlwr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr(char* _String);
    __declspec(dllimport) errno_t __cdecl _strlwr_s_l(
        char* _String,
        size_t _Size,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strlwr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(char* _String, _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strncat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(char* _Destination, char const* _Source, size_t _Count);
    __declspec(dllimport) int __cdecl strncmp(
        char const* _Str1,
        char const* _Str2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _strnicmp(
        char const* _String1,
        char const* _String2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _strnicmp_l(
        char const* _String1,
        char const* _String2,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _strnicoll(
        char const* _String1,
        char const* _String2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _strnicoll_l(
        char const* _String1,
        char const* _String2,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _strncoll(
        char const* _String1,
        char const* _String2,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _strncoll_l(
        char const* _String1,
        char const* _String2,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) size_t __cdecl __strncnt(
        char const* _String,
        size_t _Count);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strncpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(char* _Destination, char const* _Source, size_t _Count);
    __declspec(dllimport) size_t __cdecl strnlen(
        char const* _String,
        size_t _MaxCount);
    static __inline size_t __cdecl strnlen_s(
        char const* _String,
        size_t _MaxCount)
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }
    __declspec(dllimport) errno_t __cdecl _strnset_s(
        char* _String,
        size_t _SizeInBytes,
        int _Value,
        size_t _MaxCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strnset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(char* _Destination, int _Value, size_t _Count);
    __declspec(dllimport) char const* __cdecl strpbrk(
        char const* _Str,
        char const* _Control);
    __declspec(dllimport) char* __cdecl _strrev(
        char* _Str);
    __declspec(dllimport) errno_t __cdecl _strset_s(
        char* _Destination,
        size_t _DestinationSize,
        int _Value);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw() { return _strset_s(_Destination, _Size, _Value); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) char* __cdecl _strset(char* _Destination, int _Value);
    __declspec(dllimport) size_t __cdecl strspn(
        char const* _Str,
        char const* _Control);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strtok_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strtok(char* _String,
        char const* _Delimiter);
    __declspec(dllimport) errno_t __cdecl _strupr_s(
        char* _String,
        size_t _Size);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strupr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr(char* _String);
    __declspec(dllimport) errno_t __cdecl _strupr_s_l(
        char* _String,
        size_t _Size,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strupr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(char* _String, _locale_t _Locale);
    __declspec(dllimport) size_t __cdecl strxfrm(
        char* _Destination,
        char const* _Source,
        size_t _MaxCount);
    __declspec(dllimport) size_t __cdecl _strxfrm_l(
        char* _Destination,
        char const* _Source,
        size_t _MaxCount,
        _locale_t _Locale);
    extern "C++" {
    inline char* __cdecl strchr(char* const _String, int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }
    inline char* __cdecl strpbrk(char* const _String, char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }
    inline char* __cdecl strrchr(char* const _String, int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }
    inline char* __cdecl strstr(char* const _String, char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
    }
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strdup"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strdup(char const* _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strcmpi"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl strcmpi(char const* _String1,
        char const* _String2);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_stricmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl stricmp(char const* _String1,
        char const* _String2);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strlwr"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strlwr(char* _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strnicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl strnicmp(char const* _String1,
        char const* _String2,
        size_t _MaxCount);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strnset"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strnset(char* _String,
        int _Value,
        size_t _MaxCount);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strrev"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strrev(char* _String);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strset"
                          ". See online help for details.")) char* __cdecl strset(char* _String,
        int _Value);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strupr"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strupr(char* _String);
}
__pragma(pack(pop))
#pragma warning(pop)
    __inline int InlineIsEqualGUID(const GUID& rguid1, const GUID& rguid2)
{
    return (
        ((unsigned long*)&rguid1)[0] == ((unsigned long*)&rguid2)[0] && ((unsigned long*)&rguid1)[1] == ((unsigned long*)&rguid2)[1] && ((unsigned long*)&rguid1)[2] == ((unsigned long*)&rguid2)[2] && ((unsigned long*)&rguid1)[3] == ((unsigned long*)&rguid2)[3]);
}
__inline int IsEqualGUID(const GUID& rguid1, const GUID& rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
__inline bool operator==(const GUID& guidOne, const GUID& guidOther)
{
    return !!IsEqualGUID(guidOne, guidOther);
}
__inline bool operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}
typedef struct _OBJECTID {
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#pragma region Application Family or OneCore Family Or Game Family
extern "C++" template <typename T, size_t N>
char (*RtlpNumberOf(__unaligned T (&)[N]))[N];
#pragma endregion
typedef EXCEPTION_DISPOSITION __stdcall EXCEPTION_ROUTINE(
    struct _EXCEPTION_RECORD* ExceptionRecord,
    PVOID EstablisherFrame,
    struct _CONTEXT* ContextRecord,
    PVOID DispatcherContext);
typedef EXCEPTION_ROUTINE* PEXCEPTION_ROUTINE;
extern "C++" {
template <size_t S>
struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<1> {
    typedef INT8 type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<2> {
    typedef INT16 type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<4> {
    typedef INT32 type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<8> {
    typedef INT64 type;
};
template <class T>
struct _ENUM_FLAG_SIZED_INTEGER {
    typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
};
}
static_assert(__alignof(LARGE_INTEGER) == 8, "Windows headers require the default packing option. Changing this can lead to memory corruption."
                                             " This diagnostic can be disabled by building with WINDOWS_IGNORE_PACKING_MISMATCH defined.");
typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK* PKSPIN_LOCK;
typedef struct __declspec(align(16)) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;
typedef struct __declspec(align(16)) _XSAVE_FORMAT {
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];
    M128A XmmRegisters[16];
    BYTE Reserved4[96];
} XSAVE_FORMAT, *PXSAVE_FORMAT;
typedef struct _XSAVE_CET_U_FORMAT {
    DWORD64 Ia32CetUMsr;
    DWORD64 Ia32Pl3SspMsr;
} XSAVE_CET_U_FORMAT, *PXSAVE_CET_U_FORMAT;
typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 CompactionMask;
    DWORD64 Reserved2[6];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;
typedef struct __declspec(align(16)) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;
typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
    PXSAVE_AREA Area;
    PVOID Buffer;
} XSTATE_CONTEXT, *PXSTATE_CONTEXT;
typedef struct _KERNEL_CET_CONTEXT {
    DWORD64 Ssp;
    DWORD64 Rip;
    WORD SegCs;
    union {
        WORD AllFlags;
        struct {
            WORD UseWrss : 1;
            WORD PopShadowStackOne : 1;
            WORD Unused : 14;
        };
    };
    WORD Fill[2];
} KERNEL_CET_CONTEXT, *PKERNEL_CET_CONTEXT;
typedef char __C_ASSERT__[(sizeof(KERNEL_CET_CONTEXT) == (3 * sizeof(DWORD64))) ? 1 : -1];
typedef struct _SCOPE_TABLE_AMD64 {
    DWORD Count;
    struct {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;
extern "C" {
BOOLEAN
_bittest(
    LONG const* Base,
    LONG Offset);
BOOLEAN
_bittestandcomplement(
    LONG* Base,
    LONG Offset);
BOOLEAN
_bittestandset(
    LONG* Base,
    LONG Offset);
BOOLEAN
_bittestandreset(
    LONG* Base,
    LONG Offset);
BOOLEAN
_interlockedbittestandset(
    LONG volatile* Base,
    LONG Offset);
BOOLEAN
_interlockedbittestandreset(
    LONG volatile* Base,
    LONG Offset);
BOOLEAN
_bittest64(
    LONG64 const* Base,
    LONG64 Offset);
BOOLEAN
_bittestandcomplement64(
    LONG64* Base,
    LONG64 Offset);
BOOLEAN
_bittestandset64(
    LONG64* Base,
    LONG64 Offset);
BOOLEAN
_bittestandreset64(
    LONG64* Base,
    LONG64 Offset);
BOOLEAN
_interlockedbittestandset64(
    LONG64 volatile* Base,
    LONG64 Offset);
BOOLEAN
_interlockedbittestandreset64(
    LONG64 volatile* Base,
    LONG64 Offset);
#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)
#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)
BOOLEAN
_BitScanForward(
    DWORD* Index,
    DWORD Mask);
BOOLEAN
_BitScanReverse(
    DWORD* Index,
    DWORD Mask);
BOOLEAN
_BitScanForward64(
    DWORD* Index,
    DWORD64 Mask);
BOOLEAN
_BitScanReverse64(
    DWORD* Index,
    DWORD64 Mask);
#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)
SHORT
_InterlockedIncrement16(
    SHORT volatile* Addend);
SHORT
_InterlockedDecrement16(
    SHORT volatile* Addend);
SHORT
_InterlockedCompareExchange16(
    SHORT volatile* Destination,
    SHORT ExChange,
    SHORT Comperand);
LONG _InterlockedAnd(
    LONG volatile* Destination,
    LONG Value);
LONG _InterlockedOr(
    LONG volatile* Destination,
    LONG Value);
LONG _InterlockedXor(
    LONG volatile* Destination,
    LONG Value);
LONG64
_InterlockedAnd64(
    LONG64 volatile* Destination,
    LONG64 Value);
LONG64
_InterlockedOr64(
    LONG64 volatile* Destination,
    LONG64 Value);
LONG64
_InterlockedXor64(
    LONG64 volatile* Destination,
    LONG64 Value);
LONG _InterlockedIncrement(
    LONG volatile* Addend);
LONG _InterlockedDecrement(
    LONG volatile* Addend);
LONG _InterlockedExchange(
    LONG volatile* Target,
    LONG Value);
LONG _InterlockedExchangeAdd(
    LONG volatile* Addend,
    LONG Value);
__forceinline LONG
_InlineInterlockedAdd(
    LONG volatile* Addend,
    LONG Value)
{
    return _InterlockedExchangeAdd(Addend, Value) + Value;
}
LONG _InterlockedCompareExchange(
    LONG volatile* Destination,
    LONG ExChange,
    LONG Comperand);
LONG64
_InterlockedIncrement64(
    LONG64 volatile* Addend);
LONG64
_InterlockedDecrement64(
    LONG64 volatile* Addend);
LONG64
_InterlockedExchange64(
    LONG64 volatile* Target,
    LONG64 Value);
LONG64
_InterlockedExchangeAdd64(
    LONG64 volatile* Addend,
    LONG64 Value);
__forceinline LONG64
_InlineInterlockedAdd64(
    LONG64 volatile* Addend,
    LONG64 Value)
{
    return _InterlockedExchangeAdd64(Addend, Value) + Value;
}
LONG64
_InterlockedCompareExchange64(
    LONG64 volatile* Destination,
    LONG64 ExChange,
    LONG64 Comperand);
BOOLEAN
_InterlockedCompareExchange128(
    LONG64 volatile* Destination,
    LONG64 ExchangeHigh,
    LONG64 ExchangeLow,
    LONG64* ComparandResult);
PVOID
_InterlockedCompareExchangePointer(
    PVOID volatile* Destination,
    PVOID Exchange,
    PVOID Comperand);
PVOID
_InterlockedExchangePointer(
    PVOID volatile* Target,
    PVOID Value);
#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange128)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
CHAR _InterlockedExchange8(
    CHAR volatile* Target,
    CHAR Value);
SHORT
_InterlockedExchange16(
    SHORT volatile* Destination,
    SHORT ExChange);
#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)
char _InterlockedExchangeAdd8(
    char volatile* _Addend,
    char _Value);
char _InterlockedAnd8(
    char volatile* Destination,
    char Value);
char _InterlockedOr8(
    char volatile* Destination,
    char Value);
char _InterlockedXor8(
    char volatile* Destination,
    char Value);
SHORT
_InterlockedAnd16(
    SHORT volatile* Destination,
    SHORT Value);
SHORT
_InterlockedOr16(
    SHORT volatile* Destination,
    SHORT Value);
SHORT
_InterlockedXor16(
    SHORT volatile* Destination,
    SHORT Value);
#pragma intrinsic(_InterlockedExchangeAdd8)
#pragma intrinsic(_InterlockedAnd8)
#pragma intrinsic(_InterlockedOr8)
#pragma intrinsic(_InterlockedXor8)
#pragma intrinsic(_InterlockedAnd16)
#pragma intrinsic(_InterlockedOr16)
#pragma intrinsic(_InterlockedXor16)
void __cpuidex(
    int CPUInfo[4],
    int Function,
    int SubLeaf);
#pragma intrinsic(__cpuidex)
void _mm_clflush(
    void const* Address);
#pragma intrinsic(_mm_clflush)
void _ReadWriteBarrier(
    void);
#pragma intrinsic(_ReadWriteBarrier)
void __faststorefence(
    void);
void _mm_lfence(
    void);
void _mm_mfence(
    void);
void _mm_sfence(
    void);
void _mm_pause(
    void);
void _mm_prefetch(
    CHAR const* a,
    int sel);
void _m_prefetchw(
    volatile const void* Source);
#pragma intrinsic(__faststorefence)
#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)
unsigned int
_mm_getcsr(
    void);
void _mm_setcsr(
    unsigned int MxCsr);
#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)
unsigned __int32
__getcallerseflags(
    void);
#pragma intrinsic(__getcallerseflags)
DWORD
__segmentlimit(
    DWORD Selector);
#pragma intrinsic(__segmentlimit)
DWORD64
__readpmc(
    DWORD Counter);
#pragma intrinsic(__readpmc)
DWORD64
__rdtsc(
    void);
#pragma intrinsic(__rdtsc)
void __movsb(
    PBYTE Destination,
    BYTE const* Source,
    SIZE_T Count);
void __movsw(
    PWORD Destination,
    WORD const* Source,
    SIZE_T Count);
void __movsd(
    PDWORD Destination,
    DWORD const* Source,
    SIZE_T Count);
void __movsq(
    PDWORD64 Destination,
    DWORD64 const* Source,
    SIZE_T Count);
#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)
void __stosb(
    PBYTE Destination,
    BYTE Value,
    SIZE_T Count);
void __stosw(
    PWORD Destination,
    WORD Value,
    SIZE_T Count);
void __stosd(
    PDWORD Destination,
    DWORD Value,
    SIZE_T Count);
void __stosq(
    PDWORD64 Destination,
    DWORD64 Value,
    SIZE_T Count);
#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)
LONGLONG
__mulh(
    LONG64 Multiplier,
    LONG64 Multiplicand);
ULONGLONG
__umulh(
    DWORD64 Multiplier,
    DWORD64 Multiplicand);
#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)
DWORD64
__popcnt64(
    DWORD64 operand);
#pragma intrinsic(__popcnt64)
DWORD64
__shiftleft128(
    DWORD64 LowPart,
    DWORD64 HighPart,
    BYTE Shift);
DWORD64
__shiftright128(
    DWORD64 LowPart,
    DWORD64 HighPart,
    BYTE Shift);
#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)
LONG64
_mul128(
    LONG64 Multiplier,
    LONG64 Multiplicand,
    LONG64* HighProduct);
#pragma intrinsic(_mul128)
DWORD64
UnsignedMultiply128(
    DWORD64 Multiplier,
    DWORD64 Multiplicand,
    DWORD64* HighProduct);
DWORD64
_umul128(
    DWORD64 Multiplier,
    DWORD64 Multiplicand,
    DWORD64* HighProduct);
LONG64
_mul128(
    LONG64 Multiplier,
    LONG64 Multiplicand,
    LONG64* HighProduct);
#pragma intrinsic(_umul128)
__forceinline LONG64
MultiplyExtract128(
    LONG64 Multiplier,
    LONG64 Multiplicand,
    BYTE Shift)
{
    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    DWORD64 uhighProduct;
    DWORD64 ulowProduct;
    lowProduct = _mul128(Multiplier, Multiplicand, &highProduct);
    negate = 0;
    uhighProduct = (DWORD64)highProduct;
    ulowProduct = (DWORD64)lowProduct;
    if (highProduct < 0) {
        negate = 1;
        uhighProduct = (DWORD64)(-highProduct);
        ulowProduct = (DWORD64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }
    extractedProduct = (LONG64)__shiftright128(ulowProduct, uhighProduct, Shift);
    if (negate != 0) {
        extractedProduct = -extractedProduct;
    }
    return extractedProduct;
}
__forceinline DWORD64
UnsignedMultiplyExtract128(
    DWORD64 Multiplier,
    DWORD64 Multiplicand,
    BYTE Shift)
{
    DWORD64 extractedProduct;
    DWORD64 highProduct;
    DWORD64 lowProduct;
    lowProduct = _umul128(Multiplier, Multiplicand, &highProduct);
    extractedProduct = __shiftright128(lowProduct, highProduct, Shift);
    return extractedProduct;
}
BYTE __readgsbyte(
    DWORD Offset);
WORD __readgsword(
    DWORD Offset);
DWORD
__readgsdword(
    DWORD Offset);
DWORD64
__readgsqword(
    DWORD Offset);
void __writegsbyte(
    DWORD Offset,
    BYTE Data);
void __writegsword(
    DWORD Offset,
    WORD Data);
void __writegsdword(
    DWORD Offset,
    DWORD Data);
void __writegsqword(
    DWORD Offset,
    DWORD64 Data);
#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)
void __incgsbyte(
    DWORD Offset);
void __addgsbyte(
    DWORD Offset,
    BYTE Value);
void __incgsword(
    DWORD Offset);
void __addgsword(
    DWORD Offset,
    WORD Value);
void __incgsdword(
    DWORD Offset);
void __addgsdword(
    DWORD Offset,
    DWORD Value);
void __incgsqword(
    DWORD Offset);
void __addgsqword(
    DWORD Offset,
    DWORD64 Value);
}
typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;
typedef struct __declspec(align(16)) __pragma(warning(push)) __pragma(warning(disable : 4845)) __declspec(no_init_all) __pragma(warning(pop)) _CONTEXT
{
    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;
    DWORD ContextFlags;
    DWORD MxCsr;
    WORD SegCs;
    WORD SegDs;
    WORD SegEs;
    WORD SegFs;
    WORD SegGs;
    WORD SegSs;
    DWORD EFlags;
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD64 Rip;
    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        };
    };
    M128A VectorRegister[26];
    DWORD64 VectorControl;
    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
}
CONTEXT, *PCONTEXT;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
typedef SCOPE_TABLE_AMD64 SCOPE_TABLE, *PSCOPE_TABLE;
typedef PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK(
    DWORD64 ControlPc,
    PVOID Context);
typedef GET_RUNTIME_FUNCTION_CALLBACK* PGET_RUNTIME_FUNCTION_CALLBACK;
typedef DWORD
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK(
    HANDLE Process,
    PVOID TableAddress,
    PDWORD Entries,
    PRUNTIME_FUNCTION* Functions);
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK* POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;
typedef struct _DISPATCHER_CONTEXT {
    DWORD64 ControlPc;
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    DWORD64 EstablisherFrame;
    DWORD64 TargetIp;
    PCONTEXT ContextRecord;
    PEXCEPTION_ROUTINE LanguageHandler;
    PVOID HandlerData;
    struct _UNWIND_HISTORY_TABLE* HistoryTable;
    DWORD ScopeIndex;
    DWORD Fill0;
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;
struct _EXCEPTION_POINTERS;
typedef LONG (*PEXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS* ExceptionPointers,
    PVOID EstablisherFrame);
typedef void (*PTERMINATION_HANDLER)(
    BOOLEAN _abnormal_termination,
    PVOID EstablisherFrame);
typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    union {
        PM128A FloatingContext[16];
        struct {
            PM128A Xmm0;
            PM128A Xmm1;
            PM128A Xmm2;
            PM128A Xmm3;
            PM128A Xmm4;
            PM128A Xmm5;
            PM128A Xmm6;
            PM128A Xmm7;
            PM128A Xmm8;
            PM128A Xmm9;
            PM128A Xmm10;
            PM128A Xmm11;
            PM128A Xmm12;
            PM128A Xmm13;
            PM128A Xmm14;
            PM128A Xmm15;
        };
    };
    union {
        PDWORD64 IntegerContext[16];
        struct {
            PDWORD64 Rax;
            PDWORD64 Rcx;
            PDWORD64 Rdx;
            PDWORD64 Rbx;
            PDWORD64 Rsp;
            PDWORD64 Rbp;
            PDWORD64 Rsi;
            PDWORD64 Rdi;
            PDWORD64 R8;
            PDWORD64 R9;
            PDWORD64 R10;
            PDWORD64 R11;
            PDWORD64 R12;
            PDWORD64 R13;
            PDWORD64 R14;
            PDWORD64 R15;
        };
    };
} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;
typedef struct _SCOPE_TABLE_ARM {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;
typedef struct _SCOPE_TABLE_ARM64 {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM64, *PSCOPE_TABLE_ARM64;
typedef union _ARM64_NT_NEON128 {
    struct {
        ULONGLONG Low;
        LONGLONG High;
    };
    double D[2];
    float S[4];
    WORD H[8];
    BYTE B[16];
} ARM64_NT_NEON128, *PARM64_NT_NEON128;
typedef struct __declspec(align(16)) __pragma(warning(push)) __pragma(warning(disable : 4845)) __declspec(no_init_all) __pragma(warning(pop)) _ARM64_NT_CONTEXT
{
    DWORD ContextFlags;
    DWORD Cpsr;
    union {
        struct {
            DWORD64 X0;
            DWORD64 X1;
            DWORD64 X2;
            DWORD64 X3;
            DWORD64 X4;
            DWORD64 X5;
            DWORD64 X6;
            DWORD64 X7;
            DWORD64 X8;
            DWORD64 X9;
            DWORD64 X10;
            DWORD64 X11;
            DWORD64 X12;
            DWORD64 X13;
            DWORD64 X14;
            DWORD64 X15;
            DWORD64 X16;
            DWORD64 X17;
            DWORD64 X18;
            DWORD64 X19;
            DWORD64 X20;
            DWORD64 X21;
            DWORD64 X22;
            DWORD64 X23;
            DWORD64 X24;
            DWORD64 X25;
            DWORD64 X26;
            DWORD64 X27;
            DWORD64 X28;
            DWORD64 Fp;
            DWORD64 Lr;
        };
        DWORD64 X[31];
    };
    DWORD64 Sp;
    DWORD64 Pc;
    ARM64_NT_NEON128 V[32];
    DWORD Fpcr;
    DWORD Fpsr;
    DWORD Bcr[8];
    DWORD64 Bvr[8];
    DWORD Wcr[2];
    DWORD64 Wvr[2];
}
ARM64_NT_CONTEXT, *PARM64_NT_CONTEXT;
typedef struct __declspec(align(16)) __pragma(warning(push)) __pragma(warning(disable : 4845)) __declspec(no_init_all) __pragma(warning(pop)) _ARM64EC_NT_CONTEXT
{
    union {
        struct {
            DWORD64 AMD64_P1Home;
            DWORD64 AMD64_P2Home;
            DWORD64 AMD64_P3Home;
            DWORD64 AMD64_P4Home;
            DWORD64 AMD64_P5Home;
            DWORD64 AMD64_P6Home;
            DWORD ContextFlags;
            DWORD AMD64_MxCsr_copy;
            WORD AMD64_SegCs;
            WORD AMD64_SegDs;
            WORD AMD64_SegEs;
            WORD AMD64_SegFs;
            WORD AMD64_SegGs;
            WORD AMD64_SegSs;
            DWORD AMD64_EFlags;
            DWORD64 AMD64_Dr0;
            DWORD64 AMD64_Dr1;
            DWORD64 AMD64_Dr2;
            DWORD64 AMD64_Dr3;
            DWORD64 AMD64_Dr6;
            DWORD64 AMD64_Dr7;
            DWORD64 X8;
            DWORD64 X0;
            DWORD64 X1;
            DWORD64 X27;
            DWORD64 Sp;
            DWORD64 Fp;
            DWORD64 X25;
            DWORD64 X26;
            DWORD64 X2;
            DWORD64 X3;
            DWORD64 X4;
            DWORD64 X5;
            DWORD64 X19;
            DWORD64 X20;
            DWORD64 X21;
            DWORD64 X22;
            DWORD64 Pc;
            struct {
                WORD AMD64_ControlWord;
                WORD AMD64_StatusWord;
                BYTE AMD64_TagWord;
                BYTE AMD64_Reserved1;
                WORD AMD64_ErrorOpcode;
                DWORD AMD64_ErrorOffset;
                WORD AMD64_ErrorSelector;
                WORD AMD64_Reserved2;
                DWORD AMD64_DataOffset;
                WORD AMD64_DataSelector;
                WORD AMD64_Reserved3;
                DWORD AMD64_MxCsr;
                DWORD AMD64_MxCsr_Mask;
                DWORD64 Lr;
                WORD X16_0;
                WORD AMD64_St0_Reserved1;
                DWORD AMD64_St0_Reserved2;
                DWORD64 X6;
                WORD X16_1;
                WORD AMD64_St1_Reserved1;
                DWORD AMD64_St1_Reserved2;
                DWORD64 X7;
                WORD X16_2;
                WORD AMD64_St2_Reserved1;
                DWORD AMD64_St2_Reserved2;
                DWORD64 X9;
                WORD X16_3;
                WORD AMD64_St3_Reserved1;
                DWORD AMD64_St3_Reserved2;
                DWORD64 X10;
                WORD X17_0;
                WORD AMD64_St4_Reserved1;
                DWORD AMD64_St4_Reserved2;
                DWORD64 X11;
                WORD X17_1;
                WORD AMD64_St5_Reserved1;
                DWORD AMD64_St5_Reserved2;
                DWORD64 X12;
                WORD X17_2;
                WORD AMD64_St6_Reserved1;
                DWORD AMD64_St6_Reserved2;
                DWORD64 X15;
                WORD X17_3;
                WORD AMD64_St7_Reserved1;
                DWORD AMD64_St7_Reserved2;
                ARM64_NT_NEON128 V[16];
                BYTE AMD64_XSAVE_FORMAT_Reserved4[96];
            };
            ARM64_NT_NEON128 AMD64_VectorRegister[26];
            DWORD64 AMD64_VectorControl;
            DWORD64 AMD64_DebugControl;
            DWORD64 AMD64_LastBranchToRip;
            DWORD64 AMD64_LastBranchFromRip;
            DWORD64 AMD64_LastExceptionToRip;
            DWORD64 AMD64_LastExceptionFromRip;
        };
    };
}
ARM64EC_NT_CONTEXT, *PARM64EC_NT_CONTEXT;
typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY ARM64_RUNTIME_FUNCTION, *PARM64_RUNTIME_FUNCTION;
typedef union _DISPATCHER_CONTEXT_NONVOLREG_ARM64 {
    BYTE Buffer[((11) * sizeof(DWORD64)) + ((8) * sizeof(double))];
    struct {
        DWORD64 GpNvRegs[(11)];
        double FpNvRegs[(8)];
    };
} DISPATCHER_CONTEXT_NONVOLREG_ARM64;
typedef char __C_ASSERT__[(sizeof(DISPATCHER_CONTEXT_NONVOLREG_ARM64) == (((11) * sizeof(DWORD64)) + ((8) * sizeof(double)))) ? 1 : -1];
typedef struct _DISPATCHER_CONTEXT_ARM64 {
    ULONG_PTR ControlPc;
    ULONG_PTR ImageBase;
    PARM64_RUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;
    ULONG_PTR TargetPc;
    PARM64_NT_CONTEXT ContextRecord;
    PEXCEPTION_ROUTINE LanguageHandler;
    PVOID HandlerData;
    struct _UNWIND_HISTORY_TABLE* HistoryTable;
    DWORD ScopeIndex;
    BOOLEAN ControlPcIsUnwound;
    PBYTE NonVolatileRegisters;
} DISPATCHER_CONTEXT_ARM64, *PDISPATCHER_CONTEXT_ARM64;
typedef struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    PDWORD64 X19;
    PDWORD64 X20;
    PDWORD64 X21;
    PDWORD64 X22;
    PDWORD64 X23;
    PDWORD64 X24;
    PDWORD64 X25;
    PDWORD64 X26;
    PDWORD64 X27;
    PDWORD64 X28;
    PDWORD64 Fp;
    PDWORD64 Lr;
    PDWORD64 D8;
    PDWORD64 D9;
    PDWORD64 D10;
    PDWORD64 D11;
    PDWORD64 D12;
    PDWORD64 D13;
    PDWORD64 D14;
    PDWORD64 D15;
} KNONVOLATILE_CONTEXT_POINTERS_ARM64, *PKNONVOLATILE_CONTEXT_POINTERS_ARM64;
extern "C" {
void __int2c(
    void);
#pragma intrinsic(__int2c)
}
typedef struct _LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1;
            BYTE Flags2;
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;
extern "C" {
__forceinline CHAR
ReadAcquire8(
    CHAR const volatile* Source)
{
    CHAR Value;
    Value = *Source;
    return Value;
}
__forceinline CHAR
ReadNoFence8(
    CHAR const volatile* Source)
{
    CHAR Value;
    Value = *Source;
    return Value;
}
__forceinline void
WriteRelease8(
    CHAR volatile* Destination,
    CHAR Value)
{
    *Destination = Value;
    return;
}
__forceinline void
WriteNoFence8(
    CHAR volatile* Destination,
    CHAR Value)
{
    *Destination = Value;
    return;
}
__forceinline SHORT
ReadAcquire16(
    SHORT const volatile* Source)
{
    SHORT Value;
    Value = *Source;
    return Value;
}
__forceinline SHORT
ReadNoFence16(
    SHORT const volatile* Source)
{
    SHORT Value;
    Value = *Source;
    return Value;
}
__forceinline void
WriteRelease16(
    SHORT volatile* Destination,
    SHORT Value)
{
    *Destination = Value;
    return;
}
__forceinline void
WriteNoFence16(
    SHORT volatile* Destination,
    SHORT Value)
{
    *Destination = Value;
    return;
}
__forceinline LONG
ReadAcquire(
    LONG const volatile* Source)
{
    LONG Value;
    Value = *Source;
    return Value;
}
__forceinline LONG
ReadNoFence(
    LONG const volatile* Source)
{
    LONG Value;
    Value = *Source;
    return Value;
}
__forceinline void
WriteRelease(
    LONG volatile* Destination,
    LONG Value)
{
    *Destination = Value;
    return;
}
__forceinline void
WriteNoFence(
    LONG volatile* Destination,
    LONG Value)
{
    *Destination = Value;
    return;
}
__forceinline LONG64
ReadAcquire64(
    LONG64 const volatile* Source)
{
    LONG64 Value;
    Value = *Source;
    return Value;
}
__forceinline LONG64
ReadNoFence64(
    LONG64 const volatile* Source)
{
    LONG64 Value;
    Value = *Source;
    return Value;
}
__forceinline void
WriteRelease64(
    LONG64 volatile* Destination,
    LONG64 Value)
{
    *Destination = Value;
    return;
}
__forceinline void
WriteNoFence64(
    LONG64 volatile* Destination,
    LONG64 Value)
{
    *Destination = Value;
    return;
}
}
__forceinline CHAR
ReadRaw8(
    CHAR const volatile* Source)
{
    CHAR Value;
    Value = *(CHAR*)Source;
    return Value;
}
__forceinline void
WriteRaw8(
    CHAR volatile* Destination,
    CHAR Value)
{
    *(CHAR*)Destination = Value;
    return;
}
__forceinline SHORT
ReadRaw16(
    SHORT const volatile* Source)
{
    SHORT Value;
    Value = *(SHORT*)Source;
    return Value;
}
__forceinline void
WriteRaw16(
    SHORT volatile* Destination,
    SHORT Value)
{
    *(SHORT*)Destination = Value;
    return;
}
__forceinline LONG
ReadRaw(
    LONG const volatile* Source)
{
    LONG Value;
    Value = *(LONG*)Source;
    return Value;
}
__forceinline void
WriteRaw(
    LONG volatile* Destination,
    LONG Value)
{
    *(LONG*)Destination = Value;
    return;
}
__forceinline LONG64
ReadRaw64(
    LONG64 const volatile* Source)
{
    LONG64 Value;
    Value = *(LONG64*)Source;
    return Value;
}
__forceinline void
WriteRaw64(
    LONG64 volatile* Destination,
    LONG64 Value)
{
    *(LONG64*)Destination = Value;
    return;
}
__forceinline BYTE
ReadUCharAcquire(
    BYTE const volatile* Source)
{
    return (BYTE)ReadAcquire8((PCHAR)Source);
}
__forceinline BYTE
ReadUCharNoFence(
    BYTE const volatile* Source)
{
    return (BYTE)ReadNoFence8((PCHAR)Source);
}
__forceinline BYTE
ReadBooleanAcquire(
    BOOLEAN const volatile* Source)
{
    return (BOOLEAN)ReadAcquire8((PCHAR)Source);
}
__forceinline BYTE
ReadBooleanNoFence(
    BOOLEAN const volatile* Source)
{
    return (BOOLEAN)ReadNoFence8((PCHAR)Source);
}
__forceinline BYTE
ReadUCharRaw(
    BYTE const volatile* Source)
{
    return (BYTE)ReadRaw8((PCHAR)Source);
}
__forceinline void
WriteUCharRelease(
    BYTE volatile* Destination,
    BYTE Value)
{
    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}
__forceinline void
WriteUCharNoFence(
    BYTE volatile* Destination,
    BYTE Value)
{
    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}
__forceinline void
WriteBooleanRelease(
    BOOLEAN volatile* Destination,
    BOOLEAN Value)
{
    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}
__forceinline void
WriteBooleanNoFence(
    BOOLEAN volatile* Destination,
    BOOLEAN Value)
{
    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}
__forceinline void
WriteUCharRaw(
    BYTE volatile* Destination,
    BYTE Value)
{
    WriteRaw8((PCHAR)Destination, (CHAR)Value);
    return;
}
__forceinline WORD
ReadUShortAcquire(
    WORD const volatile* Source)
{
    return (WORD)ReadAcquire16((PSHORT)Source);
}
__forceinline WORD
ReadUShortNoFence(
    WORD const volatile* Source)
{
    return (WORD)ReadNoFence16((PSHORT)Source);
}
__forceinline WORD
ReadUShortRaw(
    WORD const volatile* Source)
{
    return (WORD)ReadRaw16((PSHORT)Source);
}
__forceinline void
WriteUShortRelease(
    WORD volatile* Destination,
    WORD Value)
{
    WriteRelease16((PSHORT)Destination, (SHORT)Value);
    return;
}
__forceinline void
WriteUShortNoFence(
    WORD volatile* Destination,
    WORD Value)
{
    WriteNoFence16((PSHORT)Destination, (SHORT)Value);
    return;
}
__forceinline void
WriteUShortRaw(
    WORD volatile* Destination,
    WORD Value)
{
    WriteRaw16((PSHORT)Destination, (SHORT)Value);
    return;
}
__forceinline DWORD
ReadULongAcquire(
    DWORD const volatile* Source)
{
    return (DWORD)ReadAcquire((PLONG)Source);
}
__forceinline DWORD
ReadULongNoFence(
    DWORD const volatile* Source)
{
    return (DWORD)ReadNoFence((PLONG)Source);
}
__forceinline DWORD
ReadULongRaw(
    DWORD const volatile* Source)
{
    return (DWORD)ReadRaw((PLONG)Source);
}
__forceinline void
WriteULongRelease(
    DWORD volatile* Destination,
    DWORD Value)
{
    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline void
WriteULongNoFence(
    DWORD volatile* Destination,
    DWORD Value)
{
    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline void
WriteULongRaw(
    DWORD volatile* Destination,
    DWORD Value)
{
    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline INT32
ReadInt32Acquire(
    INT32 const volatile* Source)
{
    return (INT32)ReadAcquire((PLONG)Source);
}
__forceinline INT32
ReadInt32NoFence(
    INT32 const volatile* Source)
{
    return (INT32)ReadNoFence((PLONG)Source);
}
__forceinline INT32
ReadInt32Raw(
    INT32 const volatile* Source)
{
    return (INT32)ReadRaw((PLONG)Source);
}
__forceinline void
WriteInt32Release(
    INT32 volatile* Destination,
    INT32 Value)
{
    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline void
WriteInt32NoFence(
    INT32 volatile* Destination,
    INT32 Value)
{
    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline void
WriteInt32Raw(
    INT32 volatile* Destination,
    INT32 Value)
{
    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline UINT32
ReadUInt32Acquire(
    UINT32 const volatile* Source)
{
    return (UINT32)ReadAcquire((PLONG)Source);
}
__forceinline UINT32
ReadUInt32NoFence(
    UINT32 const volatile* Source)
{
    return (UINT32)ReadNoFence((PLONG)Source);
}
__forceinline UINT32
ReadUInt32Raw(
    UINT32 const volatile* Source)
{
    return (UINT32)ReadRaw((PLONG)Source);
}
__forceinline void
WriteUInt32Release(
    UINT32 volatile* Destination,
    UINT32 Value)
{
    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline void
WriteUInt32NoFence(
    UINT32 volatile* Destination,
    UINT32 Value)
{
    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline void
WriteUInt32Raw(
    UINT32 volatile* Destination,
    UINT32 Value)
{
    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}
__forceinline DWORD64
ReadULong64Acquire(
    DWORD64 const volatile* Source)
{
    return (DWORD64)ReadAcquire64((PLONG64)Source);
}
__forceinline DWORD64
ReadULong64NoFence(
    DWORD64 const volatile* Source)
{
    return (DWORD64)ReadNoFence64((PLONG64)Source);
}
__forceinline DWORD64
ReadULong64Raw(
    DWORD64 const volatile* Source)
{
    return (DWORD64)ReadRaw64((PLONG64)Source);
}
__forceinline void
WriteULong64Release(
    DWORD64 volatile* Destination,
    DWORD64 Value)
{
    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}
__forceinline void
WriteULong64NoFence(
    DWORD64 volatile* Destination,
    DWORD64 Value)
{
    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}
__forceinline void
WriteULong64Raw(
    DWORD64 volatile* Destination,
    DWORD64 Value)
{
    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}
__forceinline PVOID
ReadPointerAcquire(
    PVOID const volatile* Source)
{
    return (PVOID)ReadAcquire64((PLONG64)Source);
}
__forceinline PVOID
ReadPointerNoFence(
    PVOID const volatile* Source)
{
    return (PVOID)ReadNoFence64((PLONG64)Source);
}
__forceinline PVOID
ReadPointerRaw(
    PVOID const volatile* Source)
{
    return (PVOID)ReadRaw64((PLONG64)Source);
}
__forceinline void
WritePointerRelease(
    PVOID volatile* Destination,
    PVOID Value)
{
    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}
__forceinline void
WritePointerNoFence(
    PVOID volatile* Destination,
    PVOID Value)
{
    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}
__forceinline void
WritePointerRaw(
    PVOID volatile* Destination,
    PVOID Value)
{
    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}
#pragma warning(push)
#pragma warning(disable : 4214)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;
typedef WOW64_FLOATING_SAVE_AREA* PWOW64_FLOATING_SAVE_AREA;
#pragma warning(disable : 4103)
#pragma pack(push, 4)
typedef struct _WOW64_CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    WOW64_FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
} WOW64_CONTEXT;
typedef WOW64_CONTEXT* PWOW64_CONTEXT;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct _WOW64_LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1;
            BYTE Flags2;
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;
typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;
#pragma warning(pop)
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD* ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
} EXCEPTION_RECORD;
typedef EXCEPTION_RECORD* PEXCEPTION_RECORD;
typedef struct _EXCEPTION_RECORD32 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;
typedef struct _EXCEPTION_RECORD64 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;
typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef PVOID PSID;
typedef PVOID PCLAIMS_BLOB;
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK* PACCESS_MASK;
typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING* PGENERIC_MAPPING;
#pragma warning(disable : 4103)
#pragma pack(push, 4)
typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY* PLUID_AND_ATTRIBUTES_ARRAY;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
typedef struct _SID {
    BYTE Revision;
    BYTE SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    DWORD SubAuthority[1];
} SID, *PISID;
typedef union _SE_SID {
    SID Sid;
    BYTE Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
} SE_SID, *PSE_SID;
typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    SidTypeLogonSession
} SID_NAME_USE,
    *PSID_NAME_USE;
typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    DWORD Attributes;
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY* PSID_AND_ATTRIBUTES_ARRAY;
typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;
typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;
typedef enum {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
    WinBuiltinDeviceOwnersSid = 119,
} WELL_KNOWN_SID_TYPE;
typedef struct _ACL {
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
} ACL;
typedef ACL* PACL;
typedef struct _ACE_HEADER {
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
} ACE_HEADER;
typedef ACE_HEADER* PACE_HEADER;
typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;
typedef ACCESS_ALLOWED_ACE* PACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE* PACCESS_DENIED_ACE;
typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE* PSYSTEM_AUDIT_ACE;
typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE* PSYSTEM_ALARM_ACE;
typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;
typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;
typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;
typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;
typedef struct _SYSTEM_ACCESS_FILTER_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ACCESS_FILTER_ACE, *PSYSTEM_ACCESS_FILTER_ACE;
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;
typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;
typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;
typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;
typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;
typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;
typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;
typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;
typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;
typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;
typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;
typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION* PACL_REVISION_INFORMATION;
typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION* PACL_SIZE_INFORMATION;
typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
} SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;
typedef struct _SECURITY_DESCRIPTOR {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;
typedef struct _SECURITY_OBJECT_AI_PARAMS {
    DWORD Size;
    DWORD ConstraintMask;
} SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;
typedef struct _OBJECT_TYPE_LIST {
    WORD Level;
    WORD Sbz;
    GUID* ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;
typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE,
    *PAUDIT_EVENT_TYPE;
typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
} PRIVILEGE_SET, *PPRIVILEGE_SET;
typedef enum _ACCESS_REASON_TYPE {
    AccessReasonNone = 0x00000000,
    AccessReasonAllowedAce = 0x00010000,
    AccessReasonDeniedAce = 0x00020000,
    AccessReasonAllowedParentAce = 0x00030000,
    AccessReasonDeniedParentAce = 0x00040000,
    AccessReasonNotGrantedByCape = 0x00050000,
    AccessReasonNotGrantedByParentCape = 0x00060000,
    AccessReasonNotGrantedToAppContainer = 0x00070000,
    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,
    AccessReasonIntegrityLevel = 0x00300000,
    AccessReasonOwnership = 0x00400000,
    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,
    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000,
    AccessReasonTrustLabel = 0x00900000,
    AccessReasonFilterAce = 0x00a00000
} ACCESS_REASON_TYPE;
typedef DWORD ACCESS_REASON;
typedef struct _ACCESS_REASONS {
    ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;
typedef struct _SE_SECURITY_DESCRIPTOR {
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;
typedef struct _SE_ACCESS_REQUEST {
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;
typedef struct _SE_ACCESS_REPLY {
    DWORD Size;
    DWORD ResultListCount;
    PACCESS_MASK GrantedAccess;
    PDWORD AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;
typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL,
    *PSECURITY_IMPERSONATION_LEVEL;
typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
} TOKEN_TYPE;
typedef TOKEN_TYPE* PTOKEN_TYPE;
typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE,
    *PTOKEN_ELEVATION_TYPE;
typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    TokenPrivateNameSpace,
    TokenSingletonAttributes,
    TokenBnoIsolation,
    TokenChildProcessFlags,
    TokenIsLessPrivilegedAppContainer,
    TokenIsSandboxed,
    MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS,
    *PTOKEN_INFORMATION_CLASS;
typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;
typedef struct _SE_TOKEN_USER {
    union {
        TOKEN_USER TokenUser;
        SID_AND_ATTRIBUTES User;
    };
    union {
        SID Sid;
        BYTE Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
    };
} SE_TOKEN_USER, PSE_TOKEN_USER;
typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES Groups[1];
} TOKEN_GROUPS, *PTOKEN_GROUPS;
typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;
typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;
typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;
typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;
typedef struct _TOKEN_USER_CLAIMS {
    PCLAIMS_BLOB UserClaims;
} TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;
typedef struct _TOKEN_DEVICE_CLAIMS {
    PCLAIMS_BLOB DeviceClaims;
} TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;
typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;
typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;
typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;
typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;
typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;
typedef PVOID PSECURITY_ATTRIBUTES_OPAQUE;
typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
    DWORD AppContainerNumber;
    PSID PackageSid;
    PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    PSID TrustLevelSid;
    PSECURITY_ATTRIBUTES_OPAQUE SecurityAttributes;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;
typedef struct _TOKEN_AUDIT_POLICY {
    BYTE PerUserPolicy[(((59)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;
typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;
typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;
typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;
typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession;
} TOKEN_ORIGIN, *PTOKEN_ORIGIN;
typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL,
    *PMANDATORY_LEVEL;
typedef struct _TOKEN_APPCONTAINER_INFORMATION {
    PSID TokenAppContainer;
} TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;
typedef struct _TOKEN_SID_INFORMATION {
    PSID Sid;
} TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;
typedef struct _TOKEN_BNO_ISOLATION_INFORMATION {
    PWSTR IsolationPrefix;
    BOOLEAN IsolationEnabled;
} TOKEN_BNO_ISOLATION_INFORMATION, *PTOKEN_BNO_ISOLATION_INFORMATION;
typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    DWORD64 Version;
    PWSTR Name;
} CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    PVOID pValue;
    DWORD ValueLength;
} CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
    PWSTR Name;
    WORD ValueType;
    WORD Reserved;
    DWORD Flags;
    DWORD ValueCount;
    union {
        PLONG64 pInt64;
        PDWORD64 pUint64;
        PWSTR* ppString;
        PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;
typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    DWORD Name;
    WORD ValueType;
    WORD Reserved;
    DWORD Flags;
    DWORD ValueCount;
    union {
        DWORD pInt64[1];
        DWORD pUint64[1];
        DWORD ppString[1];
        DWORD pFqbn[1];
        DWORD pOctetString[1];
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    WORD Version;
    WORD Reserved;
    DWORD AttributeCount;
    union {
        PCLAIM_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
    *PSECURITY_CONTEXT_TRACKING_MODE;
typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE, *PSECURITY_QUALITY_OF_SERVICE;
typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;
typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
typedef BYTE SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;
typedef enum _SE_IMAGE_SIGNATURE_TYPE {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded,
    SeImageSignatureCache,
    SeImageSignatureCatalogCached,
    SeImageSignatureCatalogNotCached,
    SeImageSignatureCatalogHint,
    SeImageSignaturePackageCatalog,
    SeImageSignaturePplMitigated
} SE_IMAGE_SIGNATURE_TYPE,
    *PSE_IMAGE_SIGNATURE_TYPE;
typedef enum _SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
} SE_LEARNING_MODE_DATA_TYPE;
typedef struct _SECURITY_CAPABILITIES {
    PSID AppContainerSid;
    PSID_AND_ATTRIBUTES Capabilities;
    DWORD CapabilityCount;
    DWORD Reserved;
} SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;
typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;
    DWORD MemberLevel;
    DWORD Flags;
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;
typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD* Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;
typedef EXCEPTION_REGISTRATION_RECORD* PEXCEPTION_REGISTRATION_RECORD;
typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    union {
        PVOID FiberData;
        DWORD Version;
    };
    PVOID ArbitraryUserPointer;
    struct _NT_TIB* Self;
} NT_TIB;
typedef NT_TIB* PNT_TIB;
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;
typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {
    DWORD UmsVersion;
    PVOID UmsContext;
    PVOID UmsCompletionList;
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES;
typedef struct _COMPONENT_FILTER {
    DWORD ComponentFlags;
} COMPONENT_FILTER, *PCOMPONENT_FILTER;
typedef struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    ULONG_PTR TargetAddress;
    ULONG_PTR Flags;
} PROCESS_DYNAMIC_EH_CONTINUATION_TARGET, *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
typedef struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    WORD NumberOfTargets;
    WORD Reserved;
    DWORD Reserved2;
    PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets;
} PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION, *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    ULONG_PTR BaseAddress;
    SIZE_T Size;
    DWORD Flags;
} PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE, *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    WORD NumberOfRanges;
    WORD Reserved;
    DWORD Reserved2;
    PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges;
} PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION, *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;
typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0 : 25;
    };
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;
typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;
typedef struct _IO_COUNTERS {
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS* PIO_COUNTERS;
typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE,
    *PHARDWARE_COUNTER_TYPE;
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    ProcessSideChannelIsolationPolicy,
    ProcessUserShadowStackPolicy,
    ProcessRedirectionTrustPolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY,
    *PPROCESS_MITIGATION_POLICY;
typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;
typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        };
    };
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;
typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD RaiseExceptionOnInvalidHandleReference : 1;
            DWORD HandleExceptionsPermanentlyEnabled : 1;
            DWORD ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableExtensionPoints : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD EnableXfg : 1;
            DWORD EnableXfgAuditMode : 1;
            DWORD ReservedFlags : 27;
        };
    };
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        };
    };
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_FONT_DISABLE_POLICY, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY;
typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        };
    };
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY;
typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD FilterId : 4;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
typedef struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableExportAddressFilter : 1;
            DWORD AuditExportAddressFilter : 1;
            DWORD EnableExportAddressFilterPlus : 1;
            DWORD AuditExportAddressFilterPlus : 1;
            DWORD EnableImportAddressFilter : 1;
            DWORD AuditImportAddressFilter : 1;
            DWORD EnableRopStackPivot : 1;
            DWORD AuditRopStackPivot : 1;
            DWORD EnableRopCallerCheck : 1;
            DWORD AuditRopCallerCheck : 1;
            DWORD EnableRopSimExec : 1;
            DWORD AuditRopSimExec : 1;
            DWORD ReservedFlags : 20;
        };
    };
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
typedef struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoChildProcessCreation : 1;
            DWORD AuditNoChildProcessCreation : 1;
            DWORD AllowSecureProcessCreation : 1;
            DWORD ReservedFlags : 29;
        };
    };
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY;
typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD SmtBranchTargetIsolation : 1;
            DWORD IsolateSecurityDomain : 1;
            DWORD DisablePageCombine : 1;
            DWORD SpeculativeStoreBypassDisable : 1;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
typedef struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableUserShadowStack : 1;
            DWORD AuditUserShadowStack : 1;
            DWORD SetContextIpValidation : 1;
            DWORD AuditSetContextIpValidation : 1;
            DWORD EnableUserShadowStackStrictMode : 1;
            DWORD BlockNonCetBinaries : 1;
            DWORD BlockNonCetBinariesNonEhcont : 1;
            DWORD AuditBlockNonCetBinaries : 1;
            DWORD CetDynamicApisOutOfProcOnly : 1;
            DWORD SetContextIpValidationRelaxedMode : 1;
            DWORD ReservedFlags : 22;
        };
    };
} PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY, *PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
typedef struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnforceRedirectionTrust : 1;
            DWORD AuditRedirectionTrust : 1;
            DWORD ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY, *PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags;
    HANDLE JobToken;
    PTOKEN_GROUPS SidsToDisable;
    PTOKEN_PRIVILEGES PrivilegesToDelete;
    PTOKEN_GROUPS RestrictedSids;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;
typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;
typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;
typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
} JOBOBJECT_RATE_CONTROL_TOLERANCE,
    *PJOBOBJECT_RATE_CONTROL_TOLERANCE;
typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
} JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    DWORD LimitFlags;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
typedef struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    };
    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    };
    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
        CpuRateControlToleranceInterval;
    };
    DWORD LimitFlags;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL IoRateControlToleranceInterval;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL NetRateControlToleranceInterval;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2;
typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;
typedef struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    };
    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    };
    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlToleranceLimit;
    };
    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlToleranceLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2;
typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    DWORD ControlFlags;
    union {
        DWORD CpuRate;
        DWORD Weight;
        struct {
            WORD MinRate;
            WORD MaxRate;
        };
    };
} JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
typedef enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
} JOB_OBJECT_NET_RATE_CONTROL_FLAGS;
extern "C++" {
inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator|(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) noexcept { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); }
inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS& operator|=(JOB_OBJECT_NET_RATE_CONTROL_FLAGS& a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) noexcept { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); }
inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator&(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) noexcept { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); }
inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS& operator&=(JOB_OBJECT_NET_RATE_CONTROL_FLAGS& a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) noexcept { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); }
inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator~(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a) noexcept { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)); }
inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator^(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) noexcept { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); }
inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS& operator^=(JOB_OBJECT_NET_RATE_CONTROL_FLAGS& a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) noexcept { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); }
}
typedef char __C_ASSERT__[(JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS == (JOB_OBJECT_NET_RATE_CONTROL_ENABLE + JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH + JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG)) ? 1 : -1];
typedef struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    DWORD64 MaxBandwidth;
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    BYTE DscpTag;
} JOBOBJECT_NET_RATE_CONTROL_INFORMATION;
typedef enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 0x4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE | JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME | JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL | JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP
} JOB_OBJECT_IO_RATE_CONTROL_FLAGS;
extern "C++" {
inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator|(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) noexcept { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); }
inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS& operator|=(JOB_OBJECT_IO_RATE_CONTROL_FLAGS& a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) noexcept { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); }
inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator&(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) noexcept { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); }
inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS& operator&=(JOB_OBJECT_IO_RATE_CONTROL_FLAGS& a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) noexcept { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); }
inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator~(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a) noexcept { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)); }
inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator^(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) noexcept { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); }
inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS& operator^=(JOB_OBJECT_IO_RATE_CONTROL_FLAGS& a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) noexcept { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); }
}
typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD VolumeNameLength;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
typedef JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1;
typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;
typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
    LONG64 SoftMaxIops;
    LONG64 SoftMaxBandwidth;
    LONG64 SoftMaxTimePercent;
    LONG64 LimitExcessNotifyIops;
    LONG64 LimitExcessNotifyBandwidth;
    LONG64 LimitExcessNotifyTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;
typedef enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
} JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS;
typedef struct _JOBOBJECT_IO_ATTRIBUTION_STATS {
    ULONG_PTR IoCount;
    ULONGLONG TotalNonOverlappedQueueTime;
    ULONGLONG TotalNonOverlappedServiceTime;
    ULONGLONG TotalSize;
} JOBOBJECT_IO_ATTRIBUTION_STATS, *PJOBOBJECT_IO_ATTRIBUTION_STATS;
typedef struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    DWORD ControlFlags;
    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;
} JOBOBJECT_IO_ATTRIBUTION_INFORMATION, *PJOBOBJECT_IO_ATTRIBUTION_INFORMATION;
typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    JobObjectReserved10Information,
    JobObjectReserved11Information,
    JobObjectReserved12Information,
    JobObjectReserved13Information,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation,
    JobObjectNotificationLimitInformation2,
    JobObjectLimitViolationInformation2,
    JobObjectCreateSilo,
    JobObjectSiloBasicInformation,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;
typedef struct _SILOOBJECT_BASIC_INFORMATION {
    DWORD SiloId;
    DWORD SiloParentId;
    DWORD NumberOfProcesses;
    BOOLEAN IsInServerSilo;
    BYTE Reserved[3];
} SILOOBJECT_BASIC_INFORMATION, *PSILOOBJECT_BASIC_INFORMATION;
typedef enum _SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED,
    SERVERSILO_SHUTTING_DOWN,
    SERVERSILO_TERMINATING,
    SERVERSILO_TERMINATED,
} SERVERSILO_STATE,
    *PSERVERSILO_STATE;
typedef struct _SERVERSILO_BASIC_INFORMATION {
    DWORD ServiceSessionId;
    SERVERSILO_STATE State;
    DWORD ExitStatus;
    BOOLEAN IsDownlevelContainer;
    PVOID ApiSetSchema;
    PVOID HostApiSetSchema;
} SERVERSILO_BASIC_INFORMATION, *PSERVERSILO_BASIC_INFORMATION;
typedef enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
} FIRMWARE_TYPE,
    *PFIRMWARE_TYPE;
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationProcessorDie,
    RelationNumaNodeEx,
    RelationProcessorModule,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;
typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;
typedef struct _CACHE_DESCRIPTOR {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;
typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG Reserved[2];
    };
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;
typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE Flags;
    BYTE EfficiencyClass;
    BYTE Reserved[20];
    WORD GroupCount;
    GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;
typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE Reserved[18];
    WORD GroupCount;
    union {
        GROUP_AFFINITY GroupMask;
        GROUP_AFFINITY GroupMasks[1];
    };
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;
typedef struct _CACHE_RELATIONSHIP {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[18];
    WORD GroupCount;
    union {
        GROUP_AFFINITY GroupMask;
        GROUP_AFFINITY GroupMasks[1];
    };
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;
typedef struct _PROCESSOR_GROUP_INFO {
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;
typedef struct _GROUP_RELATIONSHIP {
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;
struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    };
};
typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
typedef enum _CPU_SET_INFORMATION_TYPE {
    CpuSetInformation
} CPU_SET_INFORMATION_TYPE,
    *PCPU_SET_INFORMATION_TYPE;
struct _SYSTEM_CPU_SET_INFORMATION {
    DWORD Size;
    CPU_SET_INFORMATION_TYPE Type;
    union {
        struct {
            DWORD Id;
            WORD Group;
            BYTE LogicalProcessorIndex;
            BYTE CoreIndex;
            BYTE LastLevelCacheIndex;
            BYTE NumaNodeIndex;
            BYTE EfficiencyClass;
            union {
                BYTE AllFlags;
                struct {
                    BYTE Parked : 1;
                    BYTE Allocated : 1;
                    BYTE AllocatedToTargetProcess : 1;
                    BYTE RealTime : 1;
                    BYTE ReservedFlags : 4;
                };
            };
            union {
                DWORD Reserved;
                BYTE SchedulingClass;
            };
            DWORD64 AllocationTag;
        } CpuSet;
    };
};
typedef struct _SYSTEM_CPU_SET_INFORMATION SYSTEM_CPU_SET_INFORMATION, *PSYSTEM_CPU_SET_INFORMATION;
typedef struct _SYSTEM_POOL_ZEROING_INFORMATION {
    BOOLEAN PoolZeroingSupportPresent;
} SYSTEM_POOL_ZEROING_INFORMATION, *PSYSTEM_POOL_ZEROING_INFORMATION;
typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
typedef struct _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    DWORD Machine : 16;
    DWORD KernelMode : 1;
    DWORD UserMode : 1;
    DWORD Native : 1;
    DWORD Process : 1;
    DWORD WoW64Container : 1;
    DWORD ReservedZero0 : 11;
} SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION;
typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;
typedef struct _XSTATE_CONFIGURATION {
    DWORD64 EnabledFeatures;
    DWORD64 EnabledVolatileFeatures;
    DWORD Size;
    union {
        DWORD ControlFlags;
        struct
        {
            DWORD OptimizedSave : 1;
            DWORD CompactionEnabled : 1;
            DWORD ExtendedFeatureDisable : 1;
        };
    };
    XSTATE_FEATURE Features[(64)];
    DWORD64 EnabledSupervisorFeatures;
    DWORD64 AlignedFeatures;
    DWORD AllFeatureSize;
    DWORD AllFeatures[(64)];
    DWORD64 EnabledUserVisibleSupervisorFeatures;
    DWORD64 ExtendedFeatureDisableFeatures;
    DWORD AllNonLargeFeatureSize;
    DWORD Spare;
} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    WORD PartitionId;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;
typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD AllocationProtect;
    DWORD __alignment1;
    ULONGLONG RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
    DWORD __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
typedef struct _CFG_CALL_TARGET_INFO {
    ULONG_PTR Offset;
    ULONG_PTR Flags;
} CFG_CALL_TARGET_INFO, *PCFG_CALL_TARGET_INFO;
typedef struct _MEM_ADDRESS_REQUIREMENTS {
    PVOID LowestStartingAddress;
    PVOID HighestEndingAddress;
    SIZE_T Alignment;
} MEM_ADDRESS_REQUIREMENTS, *PMEM_ADDRESS_REQUIREMENTS;
typedef enum MEM_EXTENDED_PARAMETER_TYPE {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements,
    MemExtendedParameterNumaNode,
    MemExtendedParameterPartitionHandle,
    MemExtendedParameterUserPhysicalHandle,
    MemExtendedParameterAttributeFlags,
    MemExtendedParameterImageMachine,
    MemExtendedParameterMax
} MEM_EXTENDED_PARAMETER_TYPE,
    *PMEM_EXTENDED_PARAMETER_TYPE;
typedef struct __declspec(align(8)) MEM_EXTENDED_PARAMETER {
    struct {
        DWORD64 Type : 8;
        DWORD64 Reserved : 64 - 8;
    };
    union {
        DWORD64 ULong64;
        PVOID Pointer;
        SIZE_T Size;
        HANDLE Handle;
        DWORD ULong;
    };
} MEM_EXTENDED_PARAMETER, *PMEM_EXTENDED_PARAMETER;
typedef enum _MEM_DEDICATED_ATTRIBUTE_TYPE {
    MemDedicatedAttributeReadBandwidth = 0,
    MemDedicatedAttributeReadLatency,
    MemDedicatedAttributeWriteBandwidth,
    MemDedicatedAttributeWriteLatency,
    MemDedicatedAttributeMax
} MEM_DEDICATED_ATTRIBUTE_TYPE,
    *PMEM_DEDICATED_ATTRIBUTE_TYPE;
typedef enum MEM_SECTION_EXTENDED_PARAMETER_TYPE {
    MemSectionExtendedParameterInvalidType = 0,
    MemSectionExtendedParameterUserPhysicalFlags,
    MemSectionExtendedParameterNumaNode,
    MemSectionExtendedParameterSigningLevel,
    MemSectionExtendedParameterMax
} MEM_SECTION_EXTENDED_PARAMETER_TYPE,
    *PMEM_SECTION_EXTENDED_PARAMETER_TYPE;
typedef struct _ENCLAVE_CREATE_INFO_SGX {
    BYTE Secs[4096];
} ENCLAVE_CREATE_INFO_SGX, *PENCLAVE_CREATE_INFO_SGX;
typedef struct _ENCLAVE_INIT_INFO_SGX {
    BYTE SigStruct[1808];
    BYTE Reserved1[240];
    BYTE EInitToken[304];
    BYTE Reserved2[1744];
} ENCLAVE_INIT_INFO_SGX, *PENCLAVE_INIT_INFO_SGX;
typedef struct _ENCLAVE_CREATE_INFO_VBS {
    DWORD Flags;
    BYTE OwnerID[32];
} ENCLAVE_CREATE_INFO_VBS, *PENCLAVE_CREATE_INFO_VBS;
typedef struct _ENCLAVE_CREATE_INFO_VBS_BASIC {
    DWORD Flags;
    BYTE OwnerID[32];
} ENCLAVE_CREATE_INFO_VBS_BASIC, *PENCLAVE_CREATE_INFO_VBS_BASIC;
typedef struct _ENCLAVE_LOAD_DATA_VBS_BASIC {
    DWORD PageType;
} ENCLAVE_LOAD_DATA_VBS_BASIC, *PENCLAVE_LOAD_DATA_VBS_BASIC;
typedef struct _ENCLAVE_INIT_INFO_VBS_BASIC {
    BYTE FamilyId[16];
    BYTE ImageId[16];
    ULONGLONG EnclaveSize;
    DWORD EnclaveSvn;
    DWORD Reserved;
    union {
        HANDLE SignatureInfoHandle;
        ULONGLONG Unused;
    };
} ENCLAVE_INIT_INFO_VBS_BASIC, *PENCLAVE_INIT_INFO_VBS_BASIC;
typedef struct _ENCLAVE_INIT_INFO_VBS {
    DWORD Length;
    DWORD ThreadCount;
} ENCLAVE_INIT_INFO_VBS, *PENCLAVE_INIT_INFO_VBS;
typedef PVOID(ENCLAVE_TARGET_FUNCTION)(PVOID);
typedef ENCLAVE_TARGET_FUNCTION(*PENCLAVE_TARGET_FUNCTION);
typedef PENCLAVE_TARGET_FUNCTION LPENCLAVE_TARGET_FUNCTION;
typedef struct __declspec(align(8)) _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    MEM_DEDICATED_ATTRIBUTE_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE, *PMEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE;
typedef struct __declspec(align(8)) _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD SizeOfInformation;
    DWORD Flags;
    DWORD AttributesOffset;
    DWORD AttributeCount;
    DWORD Reserved;
    DWORD64 TypeId;
} MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION, *PMEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION;
typedef struct _FILE_ID_128 {
    BYTE Identifier[16];
} FILE_ID_128, *PFILE_ID_128;
typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;
typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastModificationTime;
    LARGE_INTEGER LastChangeTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER AllocatedLength;
    LARGE_INTEGER FileSize;
    DWORD FileAttributes;
    DWORD ReparsePointTag;
    LARGE_INTEGER FileId;
    LARGE_INTEGER ParentFileId;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;
typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
} FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD ReparseTag;
    WORD ReparseDataLength;
    WORD Reserved;
    GUID ReparseGuid;
    struct {
        BYTE DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;
typedef struct _SCRUB_DATA_INPUT {
    DWORD Size;
    DWORD Flags;
    DWORD MaximumIos;
    DWORD ObjectId[4];
    DWORD Reserved[41];
    BYTE ResumeContext[1040];
} SCRUB_DATA_INPUT, *PSCRUB_DATA_INPUT;
typedef struct _SCRUB_PARITY_EXTENT {
    LONGLONG Offset;
    ULONGLONG Length;
} SCRUB_PARITY_EXTENT, *PSCRUB_PARITY_EXTENT;
typedef struct _SCRUB_PARITY_EXTENT_DATA {
    WORD Size;
    WORD Flags;
    WORD NumberOfParityExtents;
    WORD MaximumNumberOfParityExtents;
    SCRUB_PARITY_EXTENT ParityExtents[1];
} SCRUB_PARITY_EXTENT_DATA, *PSCRUB_PARITY_EXTENT_DATA;
typedef struct _SCRUB_DATA_OUTPUT {
    DWORD Size;
    DWORD Flags;
    DWORD Status;
    ULONGLONG ErrorFileOffset;
    ULONGLONG ErrorLength;
    ULONGLONG NumberOfBytesRepaired;
    ULONGLONG NumberOfBytesFailed;
    ULONGLONG InternalFileReference;
    WORD ResumeContextLength;
    WORD ParityExtentDataOffset;
    DWORD Reserved[9];
    ULONGLONG NumberOfMetadataBytesProcessed;
    ULONGLONG NumberOfDataBytesProcessed;
    ULONGLONG TotalNumberOfMetadataBytesInUse;
    ULONGLONG TotalNumberOfDataBytesInUse;
    ULONGLONG DataBytesSkippedDueToNoAllocation;
    ULONGLONG DataBytesSkippedDueToInvalidRun;
    ULONGLONG DataBytesSkippedDueToIntegrityStream;
    ULONGLONG DataBytesSkippedDueToRegionBeingClean;
    ULONGLONG DataBytesSkippedDueToLockConflict;
    ULONGLONG DataBytesSkippedDueToNoScrubDataFlag;
    ULONGLONG DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag;
    ULONGLONG DataBytesScrubbed;
    BYTE ResumeContext[1040];
} SCRUB_DATA_OUTPUT, *PSCRUB_DATA_OUTPUT;
typedef enum _SharedVirtualDiskSupportType {
    SharedVirtualDisksUnsupported = 0,
    SharedVirtualDisksSupported = 1,
    SharedVirtualDiskSnapshotsSupported = 3,
    SharedVirtualDiskCDPSnapshotsSupported = 7
} SharedVirtualDiskSupportType;
typedef enum _SharedVirtualDiskHandleState {
    SharedVirtualDiskHandleStateNone = 0,
    SharedVirtualDiskHandleStateFileShared = 1,
    SharedVirtualDiskHandleStateHandleShared = 3
} SharedVirtualDiskHandleState;
typedef struct _SHARED_VIRTUAL_DISK_SUPPORT {
    SharedVirtualDiskSupportType SharedVirtualDiskSupport;
    SharedVirtualDiskHandleState HandleState;
} SHARED_VIRTUAL_DISK_SUPPORT, *PSHARED_VIRTUAL_DISK_SUPPORT;
typedef struct _REARRANGE_FILE_DATA {
    ULONGLONG SourceStartingOffset;
    ULONGLONG TargetOffset;
    HANDLE SourceFileHandle;
    DWORD Length;
    DWORD Flags;
} REARRANGE_FILE_DATA, *PREARRANGE_FILE_DATA;
typedef struct _REARRANGE_FILE_DATA32 {
    ULONGLONG SourceStartingOffset;
    ULONGLONG TargetOffset;
    UINT32 SourceFileHandle;
    DWORD Length;
    DWORD Flags;
} REARRANGE_FILE_DATA32, *PREARRANGE_FILE_DATA32;
typedef struct _SHUFFLE_FILE_DATA {
    LONGLONG StartingOffset;
    LONGLONG Length;
    DWORD Flags;
} SHUFFLE_FILE_DATA, *PSHUFFLE_FILE_DATA;
typedef struct _NETWORK_APP_INSTANCE_EA {
    GUID AppInstanceID;
    DWORD CsvFlags;
} NETWORK_APP_INSTANCE_EA, *PNETWORK_APP_INSTANCE_EA;
extern "C" const GUID GUID_MAX_POWER_SAVINGS;
extern "C" const GUID GUID_MIN_POWER_SAVINGS;
extern "C" const GUID GUID_TYPICAL_POWER_SAVINGS;
extern "C" const GUID NO_SUBGROUP_GUID;
extern "C" const GUID ALL_POWERSCHEMES_GUID;
extern "C" const GUID GUID_POWERSCHEME_PERSONALITY;
extern "C" const GUID GUID_ACTIVE_POWERSCHEME;
extern "C" const GUID GUID_IDLE_RESILIENCY_SUBGROUP;
extern "C" const GUID GUID_IDLE_RESILIENCY_PERIOD;
extern "C" const GUID GUID_DEEP_SLEEP_ENABLED;
extern "C" const GUID GUID_DEEP_SLEEP_PLATFORM_STATE;
extern "C" const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT;
extern "C" const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT;
extern "C" const GUID GUID_VIDEO_SUBGROUP;
extern "C" const GUID GUID_VIDEO_POWERDOWN_TIMEOUT;
extern "C" const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT;
extern "C" const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;
extern "C" const GUID GUID_VIDEO_DIM_TIMEOUT;
extern "C" const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN;
extern "C" const GUID GUID_MONITOR_POWER_ON;
extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;
extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;
extern "C" const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;
extern "C" const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;
extern "C" const GUID GUID_CONSOLE_DISPLAY_STATE;
extern "C" const GUID GUID_ALLOW_DISPLAY_REQUIRED;
extern "C" const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT;
extern "C" const GUID GUID_ADVANCED_COLOR_QUALITY_BIAS;
extern "C" const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP;
extern "C" const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT;
extern "C" const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE;
extern "C" const GUID GUID_DISK_SUBGROUP;
extern "C" const GUID GUID_DISK_MAX_POWER;
extern "C" const GUID GUID_DISK_POWERDOWN_TIMEOUT;
extern "C" const GUID GUID_DISK_IDLE_TIMEOUT;
extern "C" const GUID GUID_DISK_BURST_IGNORE_THRESHOLD;
extern "C" const GUID GUID_DISK_ADAPTIVE_POWERDOWN;
extern "C" const GUID GUID_DISK_NVME_NOPPME;
extern "C" const GUID GUID_SLEEP_SUBGROUP;
extern "C" const GUID GUID_SLEEP_IDLE_THRESHOLD;
extern "C" const GUID GUID_STANDBY_TIMEOUT;
extern "C" const GUID GUID_UNATTEND_SLEEP_TIMEOUT;
extern "C" const GUID GUID_HIBERNATE_TIMEOUT;
extern "C" const GUID GUID_HIBERNATE_FASTS4_POLICY;
extern "C" const GUID GUID_CRITICAL_POWER_TRANSITION;
extern "C" const GUID GUID_SYSTEM_AWAYMODE;
extern "C" const GUID GUID_ALLOW_AWAYMODE;
extern "C" const GUID GUID_USER_PRESENCE_PREDICTION;
extern "C" const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD;
extern "C" const GUID GUID_STANDBY_BUDGET_PERCENT;
extern "C" const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD;
extern "C" const GUID GUID_STANDBY_RESERVE_TIME;
extern "C" const GUID GUID_STANDBY_RESET_PERCENT;
extern "C" const GUID GUID_HUPR_ADAPTIVE_DISPLAY_TIMEOUT;
extern "C" const GUID GUID_ALLOW_STANDBY_STATES;
extern "C" const GUID GUID_ALLOW_RTC_WAKE;
extern "C" const GUID GUID_LEGACY_RTC_MITIGATION;
extern "C" const GUID GUID_ALLOW_SYSTEM_REQUIRED;
extern "C" const GUID GUID_POWER_SAVING_STATUS;
extern "C" const GUID GUID_ENERGY_SAVER_SUBGROUP;
extern "C" const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD;
extern "C" const GUID GUID_ENERGY_SAVER_BRIGHTNESS;
extern "C" const GUID GUID_ENERGY_SAVER_POLICY;
extern "C" const GUID GUID_SYSTEM_BUTTON_SUBGROUP;
extern "C" const GUID GUID_POWERBUTTON_ACTION;
extern "C" const GUID GUID_SLEEPBUTTON_ACTION;
extern "C" const GUID GUID_USERINTERFACEBUTTON_ACTION;
extern "C" const GUID GUID_LIDCLOSE_ACTION;
extern "C" const GUID GUID_LIDOPEN_POWERSTATE;
extern "C" const GUID GUID_BATTERY_SUBGROUP;
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_3;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_3;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_3;
extern "C" const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP;
extern "C" const GUID GUID_PROCESSOR_THROTTLE_POLICY;
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM;
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1;
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM;
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM_1;
extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT;
extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT_1;
extern "C" const GUID GUID_PROCESSOR_ALLOW_THROTTLING;
extern "C" const GUID GUID_PROCESSOR_IDLESTATE_POLICY;
extern "C" const GUID GUID_PROCESSOR_PERFSTATE_POLICY;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY_1;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY_1;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME_1;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME_1;
extern "C" const GUID GUID_PROCESSOR_PERF_TIME_CHECK;
extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_POLICY;
extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_MODE;
extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_MODE;
extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE;
extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1;
extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW;
extern "C" const GUID GUID_PROCESSOR_DUTY_CYCLING;
extern "C" const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING;
extern "C" const GUID GUID_PROCESSOR_IDLE_DISABLE;
extern "C" const GUID GUID_PROCESSOR_IDLE_STATE_MAXIMUM;
extern "C" const GUID GUID_PROCESSOR_IDLE_TIME_CHECK;
extern "C" const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE;
extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE;
extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE_1;
extern "C" const GUID GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_SOFT_PARKING_LATENCY;
extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY;
extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY_1;
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_HISTORY;
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_HISTORY;
extern "C" const GUID GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY;
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT;
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF;
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1;
extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK;
extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1;
extern "C" const GUID GUID_PROCESSOR_DISTRIBUTE_UTILITY;
extern "C" const GUID GUID_PROCESSOR_HETEROGENEOUS_POLICY;
extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_TIME;
extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_TIME;
extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_CLASS0_FLOOR_PERF;
extern "C" const GUID GUID_PROCESSOR_CLASS1_INITIAL_PERF;
extern "C" const GUID GUID_PROCESSOR_THREAD_SCHEDULING_POLICY;
extern "C" const GUID GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY;
extern "C" const GUID GUID_PROCESSOR_SHORT_THREAD_RUNTIME_THRESHOLD;
extern "C" const GUID GUID_SYSTEM_COOLING_POLICY;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR;
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1;
extern "C" const GUID GUID_LOCK_CONSOLE_ON_WAKE;
extern "C" const GUID GUID_DEVICE_IDLE_POLICY;
extern "C" const GUID GUID_CONNECTIVITY_IN_STANDBY;
extern "C" const GUID GUID_DISCONNECTED_STANDBY_MODE;
extern "C" const GUID GUID_ACDC_POWER_SOURCE;
extern "C" const GUID GUID_LIDSWITCH_STATE_CHANGE;
extern "C" const GUID GUID_LIDSWITCH_STATE_RELIABILITY;
extern "C" const GUID GUID_BATTERY_PERCENTAGE_REMAINING;
extern "C" const GUID GUID_BATTERY_COUNT;
extern "C" const GUID GUID_GLOBAL_USER_PRESENCE;
extern "C" const GUID GUID_SESSION_DISPLAY_STATUS;
extern "C" const GUID GUID_SESSION_USER_PRESENCE;
extern "C" const GUID GUID_IDLE_BACKGROUND_TASK;
extern "C" const GUID GUID_BACKGROUND_TASK_NOTIFICATION;
extern "C" const GUID GUID_APPLAUNCH_BUTTON;
extern "C" const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP;
extern "C" const GUID GUID_PCIEXPRESS_ASPM_POLICY;
extern "C" const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;
extern "C" const GUID GUID_INTSTEER_SUBGROUP;
extern "C" const GUID GUID_INTSTEER_MODE;
extern "C" const GUID GUID_INTSTEER_LOAD_PER_PROC_TRIGGER;
extern "C" const GUID GUID_INTSTEER_TIME_UNPARK_TRIGGER;
extern "C" const GUID GUID_GRAPHICS_SUBGROUP;
extern "C" const GUID GUID_GPU_PREFERENCE_POLICY;
extern "C" const GUID GUID_MIXED_REALITY_MODE;
extern "C" const GUID GUID_SPR_ACTIVE_SESSION_CHANGE;
typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} SYSTEM_POWER_STATE,
    *PSYSTEM_POWER_STATE;
typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
    PowerActionDisplayOff
} POWER_ACTION,
    *PPOWER_ACTION;
typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE,
    *PDEVICE_POWER_STATE;
typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE,
    *PMONITOR_DISPLAY_STATE;
typedef enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
} USER_ACTIVITY_PRESENCE,
    *PUSER_ACTIVITY_PRESENCE;
typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;
typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;
typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
} POWER_REQUEST_TYPE,
    *PPOWER_REQUEST_TYPE;
typedef struct CM_Power_Data_s {
    DWORD PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    DWORD PD_Capabilities;
    DWORD PD_D1Latency;
    DWORD PD_D2Latency;
    DWORD PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;
typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,
    LastSleepTime,
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    SystemMonitorHiberBootPowerOff,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    ProcessorIdleStatesHv,
    ProcessorPerfStatesHv,
    ProcessorPerfCapHv,
    ProcessorSetIdle,
    LogicalProcessorIdling,
    UserPresence,
    PowerSettingNotificationName,
    GetPowerSettingValue,
    IdleResiliency,
    SessionRITState,
    SessionConnectNotification,
    SessionPowerCleanup,
    SessionLockState,
    SystemHiberbootState,
    PlatformInformation,
    PdcInvocation,
    MonitorInvocation,
    FirmwareTableInformationRegistered,
    SetShutdownSelectedTime,
    SuspendResumeInvocation,
    PlmPowerRequestCreate,
    ScreenOff,
    CsDeviceNotification,
    PlatformRole,
    LastResumePerformance,
    DisplayBurst,
    ExitLatencySamplingPercentage,
    RegisterSpmPowerSettings,
    PlatformIdleStates,
    ProcessorIdleVeto,
    PlatformIdleVeto,
    SystemBatteryStatePrecise,
    ThermalEvent,
    PowerRequestActionInternal,
    BatteryDeviceState,
    PowerInformationInternal,
    ThermalStandby,
    SystemHiberFileType,
    PhysicalPowerButtonPress,
    QueryPotentialDripsConstraint,
    EnergyTrackerCreate,
    EnergyTrackerQuery,
    UpdateBlackBoxRecorder,
    SessionAllowExternalDmaDevices,
    SendSuspendResumeNotification,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;
typedef enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
} POWER_USER_PRESENCE_TYPE,
    *PPOWER_USER_PRESENCE_TYPE;
typedef struct _POWER_USER_PRESENCE {
    POWER_USER_PRESENCE_TYPE UserPresence;
} POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;
typedef struct _POWER_SESSION_CONNECT {
    BOOLEAN Connected;
    BOOLEAN Console;
} POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;
typedef struct _POWER_SESSION_TIMEOUTS {
    DWORD InputTimeout;
    DWORD DisplayTimeout;
} POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;
typedef struct _POWER_SESSION_RIT_STATE {
    BOOLEAN Active;
    DWORD64 LastInputTime;
} POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;
typedef struct _POWER_SESSION_WINLOGON {
    DWORD SessionId;
    BOOLEAN Console;
    BOOLEAN Locked;
} POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;
typedef struct _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    BOOLEAN IsAllowed;
} POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES, *PPOWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
typedef struct _POWER_IDLE_RESILIENCY {
    DWORD CoalescingTimeout;
    DWORD IdleResiliencyPeriod;
} POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;
typedef enum {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonGracePeriod,
    MonitorRequestReasonPnP,
    MonitorRequestReasonDP,
    MonitorRequestReasonSxTransition,
    MonitorRequestReasonSystemIdle,
    MonitorRequestReasonNearProximity,
    MonitorRequestReasonThermalStandby,
    MonitorRequestReasonResumePdc,
    MonitorRequestReasonResumeS4,
    MonitorRequestReasonTerminal,
    MonitorRequestReasonPdcSignal,
    MonitorRequestReasonAcDcDisplayBurstSuppressed,
    MonitorRequestReasonSystemStateEntered,
    MonitorRequestReasonWinrt,
    MonitorRequestReasonUserInputKeyboard,
    MonitorRequestReasonUserInputMouse,
    MonitorRequestReasonUserInputTouchpad,
    MonitorRequestReasonUserInputPen,
    MonitorRequestReasonUserInputAccelerometer,
    MonitorRequestReasonUserInputHid,
    MonitorRequestReasonUserInputPoUserPresent,
    MonitorRequestReasonUserInputSessionSwitch,
    MonitorRequestReasonUserInputInitialization,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,
    MonitorRequestReasonPdcSignalWindowsMobileShell,
    MonitorRequestReasonPdcSignalHeyCortana,
    MonitorRequestReasonPdcSignalHolographicShell,
    MonitorRequestReasonPdcSignalFingerprint,
    MonitorRequestReasonDirectedDrips,
    MonitorRequestReasonDim,
    MonitorRequestReasonBuiltinPanel,
    MonitorRequestReasonDisplayRequiredUnDim,
    MonitorRequestReasonBatteryCountChangeSuppressed,
    MonitorRequestReasonResumeModernStandby,
    MonitorRequestReasonTerminalInit,
    MonitorRequestReasonPdcSignalSensorsHumanPresence,
    MonitorRequestReasonBatteryPreCritical,
    MonitorRequestReasonUserInputTouch,
    MonitorRequestReasonMax
} POWER_MONITOR_REQUEST_REASON;
typedef enum _POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn
} POWER_MONITOR_REQUEST_TYPE;
typedef struct _POWER_MONITOR_INVOCATION {
    BOOLEAN Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;
typedef struct _RESUME_PERFORMANCE {
    DWORD PostTimeMs;
    ULONGLONG TotalResumeTimeMs;
    ULONGLONG ResumeCompleteTimestamp;
} RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;
typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;
typedef struct {
    DWORD Version;
    GUID Guid;
    SYSTEM_POWER_CONDITION PowerCondition;
    DWORD DataLength;
    BYTE Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;
typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {
    LARGE_INTEGER ActivationTime;
    DWORD Flags;
    DWORD ButtonInstanceID;
} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;
typedef enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleSlate,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE,
    *PPOWER_PLATFORM_ROLE;
typedef struct _POWER_PLATFORM_INFORMATION {
    BOOLEAN AoAc;
} POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;
typedef enum POWER_SETTING_ALTITUDE {
    ALTITUDE_GROUP_POLICY,
    ALTITUDE_USER,
    ALTITUDE_RUNTIME_OVERRIDE,
    ALTITUDE_PROVISIONING,
    ALTITUDE_OEM_CUSTOMIZATION,
    ALTITUDE_INTERNAL_OVERRIDE,
    ALTITUDE_OS_DEFAULT,
} POWER_SETTING_ALTITUDE,
    *PPOWER_SETTING_ALTITUDE;
typedef struct {
    DWORD Granularity;
    DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
typedef struct {
    DWORD Frequency;
    DWORD Flags;
    DWORD PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;
typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE PromotePercent;
    BYTE DemotePercent;
    BYTE StateType;
    BYTE Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;
typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;
    DWORD OldState;
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;
typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;
    DWORD OldState;
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;
typedef struct {
    DWORD Frequency;
    DWORD Power;
    BYTE PercentFrequency;
    BYTE IncreaseLevel;
    BYTE DecreaseLevel;
    BYTE Type;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD64 Control;
    DWORD64 Status;
    DWORD HitCount;
    DWORD Reserved1;
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;
typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;
    DWORD MaxPerfState;
    DWORD MinPerfState;
    DWORD LowestPerfState;
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType;
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;
typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;
    DWORD MaxPerfState;
    DWORD MinPerfState;
    DWORD LowestPerfState;
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType;
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;
typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;
typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;
typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;
typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;
typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD AbortCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;
extern "C" const GUID PPM_PERFSTATE_CHANGE_GUID;
extern "C" const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID;
extern "C" const GUID PPM_IDLESTATE_CHANGE_GUID;
extern "C" const GUID PPM_PERFSTATES_DATA_GUID;
extern "C" const GUID PPM_IDLESTATES_DATA_GUID;
extern "C" const GUID PPM_IDLE_ACCOUNTING_GUID;
extern "C" const GUID PPM_IDLE_ACCOUNTING_EX_GUID;
extern "C" const GUID PPM_THERMALCONSTRAINT_GUID;
extern "C" const GUID PPM_PERFMON_PERFSTATE_GUID;
extern "C" const GUID PPM_THERMAL_POLICY_CHANGE_GUID;
typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;
typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;
typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;
typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;
#pragma warning(push)
#pragma warning(disable : 4121)
typedef struct {
    BYTE Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;
#pragma warning(pop)
typedef struct {
    POWER_ACTION Action;
    DWORD Flags;
    DWORD EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
typedef struct {
    BOOLEAN Enable;
    BYTE Spare[3];
    DWORD BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;
typedef struct _SYSTEM_POWER_POLICY {
    DWORD Revision;
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    DWORD Reserved;
    POWER_ACTION_POLICY Idle;
    DWORD IdleTimeout;
    BYTE IdleSensitivity;
    BYTE DynamicThrottle;
    BYTE Spare2[2];
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    DWORD WinLogonFlags;
    DWORD Spare3;
    DWORD DozeS4Timeout;
    DWORD BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy[4];
    DWORD VideoTimeout;
    BOOLEAN VideoDimDisplay;
    DWORD VideoReserved[3];
    DWORD SpindownTimeout;
    BOOLEAN OptimizeForPower;
    BYTE FanThrottleTolerance;
    BYTE ForcedThrottle;
    BYTE MinThrottle;
    POWER_ACTION_POLICY OverThrottled;
} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;
typedef struct {
    DWORD TimeCheck;
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;
typedef struct {
    WORD Revision;
    union {
        WORD AsWORD;
        struct {
            WORD AllowScaling : 1;
            WORD Disabled : 1;
            WORD Reserved : 14;
        };
    } Flags;
    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;
typedef struct _PROCESSOR_POWER_POLICY_INFO {
    DWORD TimeCheck;
    DWORD DemoteLimit;
    DWORD PromoteLimit;
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
    DWORD AllowDemotion : 1;
    DWORD AllowPromotion : 1;
    DWORD Reserved : 30;
} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;
typedef struct _PROCESSOR_POWER_POLICY {
    DWORD Revision;
    BYTE DynamicThrottle;
    BYTE Spare[3];
    DWORD DisableCStates : 1;
    DWORD Reserved : 31;
    DWORD PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];
} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;
typedef struct {
    DWORD Revision;
    BYTE MaxThrottle;
    BYTE MinThrottle;
    BYTE BusyAdjThreshold;
    union {
        BYTE Spare;
        union {
            BYTE AsBYTE;
            struct {
                BYTE NoDomainAccounting : 1;
                BYTE IncreasePolicy : 2;
                BYTE DecreasePolicy : 2;
                BYTE Reserved : 3;
            };
        } Flags;
    };
    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;
typedef struct _ADMINISTRATOR_POWER_POLICY {
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    DWORD MinVideoTimeout;
    DWORD MaxVideoTimeout;
    DWORD MinSpindownTimeout;
    DWORD MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;
typedef enum _HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB,
    HiberFileBucket4GB,
    HiberFileBucket8GB,
    HiberFileBucket16GB,
    HiberFileBucket32GB,
    HiberFileBucketUnlimited,
    HiberFileBucketMax
} HIBERFILE_BUCKET_SIZE,
    *PHIBERFILE_BUCKET_SIZE;
typedef struct _HIBERFILE_BUCKET {
    DWORD64 MaxPhysicalMemory;
    DWORD PhysicalMemoryPercent[0x03];
} HIBERFILE_BUCKET, *PHIBERFILE_BUCKET;
typedef struct {
    BOOLEAN PowerButtonPresent;
    BOOLEAN SleepButtonPresent;
    BOOLEAN LidPresent;
    BOOLEAN SystemS1;
    BOOLEAN SystemS2;
    BOOLEAN SystemS3;
    BOOLEAN SystemS4;
    BOOLEAN SystemS5;
    BOOLEAN HiberFilePresent;
    BOOLEAN FullWake;
    BOOLEAN VideoDimPresent;
    BOOLEAN ApmPresent;
    BOOLEAN UpsPresent;
    BOOLEAN ThermalControl;
    BOOLEAN ProcessorThrottle;
    BYTE ProcessorMinThrottle;
    BYTE ProcessorMaxThrottle;
    BOOLEAN FastSystemS4;
    BOOLEAN Hiberboot;
    BOOLEAN WakeAlarmPresent;
    BOOLEAN AoAc;
    BOOLEAN DiskSpinDown;
    BYTE HiberFileType;
    BOOLEAN AoAcConnectivitySupported;
    BYTE spare3[6];
    BOOLEAN SystemBatteriesPresent;
    BOOLEAN BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];
    SYSTEM_POWER_STATE AcOnLineWake;
    SYSTEM_POWER_STATE SoftLidWake;
    SYSTEM_POWER_STATE RtcWake;
    SYSTEM_POWER_STATE MinDeviceWakeState;
    SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;
typedef struct {
    BOOLEAN AcOnLine;
    BOOLEAN BatteryPresent;
    BOOLEAN Charging;
    BOOLEAN Discharging;
    BOOLEAN Spare1[3];
    BYTE Tag;
    DWORD MaxCapacity;
    DWORD RemainingCapacity;
    DWORD Rate;
    DWORD EstimatedTime;
    DWORD DefaultAlert1;
    DWORD DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;
#pragma warning(disable : 4103)
#pragma pack(push, 4)
#pragma warning(disable : 4103)
#pragma pack(push, 2)
typedef struct _IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
typedef struct _IMAGE_OS2_HEADER {
    WORD ne_magic;
    CHAR ne_ver;
    CHAR ne_rev;
    WORD ne_enttab;
    WORD ne_cbenttab;
    LONG ne_crc;
    WORD ne_flags;
    WORD ne_autodata;
    WORD ne_heap;
    WORD ne_stack;
    LONG ne_csip;
    LONG ne_sssp;
    WORD ne_cseg;
    WORD ne_cmod;
    WORD ne_cbnrestab;
    WORD ne_segtab;
    WORD ne_rsrctab;
    WORD ne_restab;
    WORD ne_modtab;
    WORD ne_imptab;
    LONG ne_nrestab;
    WORD ne_cmovent;
    WORD ne_align;
    WORD ne_cres;
    BYTE ne_exetyp;
    BYTE ne_flagsothers;
    WORD ne_pretthunks;
    WORD ne_psegrefbytes;
    WORD ne_swaparea;
    WORD ne_expver;
} IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
typedef struct _IMAGE_VXD_HEADER {
    WORD e32_magic;
    BYTE e32_border;
    BYTE e32_worder;
    DWORD e32_level;
    WORD e32_cpu;
    WORD e32_os;
    DWORD e32_ver;
    DWORD e32_mflags;
    DWORD e32_mpages;
    DWORD e32_startobj;
    DWORD e32_eip;
    DWORD e32_stackobj;
    DWORD e32_esp;
    DWORD e32_pagesize;
    DWORD e32_lastpagesize;
    DWORD e32_fixupsize;
    DWORD e32_fixupsum;
    DWORD e32_ldrsize;
    DWORD e32_ldrsum;
    DWORD e32_objtab;
    DWORD e32_objcnt;
    DWORD e32_objmap;
    DWORD e32_itermap;
    DWORD e32_rsrctab;
    DWORD e32_rsrccnt;
    DWORD e32_restab;
    DWORD e32_enttab;
    DWORD e32_dirtab;
    DWORD e32_dircnt;
    DWORD e32_fpagetab;
    DWORD e32_frectab;
    DWORD e32_impmod;
    DWORD e32_impmodcnt;
    DWORD e32_impproc;
    DWORD e32_pagesum;
    DWORD e32_datapage;
    DWORD e32_preload;
    DWORD e32_nrestab;
    DWORD e32_cbnrestab;
    DWORD e32_nressum;
    DWORD e32_autodata;
    DWORD e32_debuginfo;
    DWORD e32_debuglen;
    DWORD e32_instpreload;
    DWORD e32_instdemand;
    DWORD e32_heapsize;
    BYTE e32_res3[12];
    DWORD e32_winresoff;
    DWORD e32_winreslen;
    WORD e32_devid;
    WORD e32_ddkver;
} IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADER {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD BaseOfBss;
    DWORD GprMask;
    DWORD CprMask[4];
    DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;
typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
typedef struct ANON_OBJECT_HEADER {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
} ANON_OBJECT_HEADER;
typedef struct ANON_OBJECT_HEADER_V2 {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
    DWORD Flags;
    DWORD MetaDataSize;
    DWORD MetaDataOffset;
} ANON_OBJECT_HEADER_V2;
typedef struct ANON_OBJECT_HEADER_BIGOBJ {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
    DWORD Flags;
    DWORD MetaDataSize;
    DWORD MetaDataOffset;
    DWORD NumberOfSections;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;
typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union {
        DWORD PhysicalAddress;
        DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
#pragma warning(disable : 4103)
#pragma pack(push, 2)
typedef struct _IMAGE_SYMBOL {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short;
            DWORD Long;
        } Name;
        DWORD LongName[2];
    } N;
    DWORD Value;
    SHORT SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL __unaligned* PIMAGE_SYMBOL;
typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short;
            DWORD Long;
        } Name;
        DWORD LongName[2];
    } N;
    DWORD Value;
    LONG SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX __unaligned* PIMAGE_SYMBOL_EX;
#pragma warning(disable : 4103)
#pragma pack(push, 2)
typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE bAuxType;
    BYTE bReserved;
    DWORD SymbolTableIndex;
    BYTE rgbReserved[12];
} IMAGE_AUX_SYMBOL_TOKEN_DEF;
typedef IMAGE_AUX_SYMBOL_TOKEN_DEF __unaligned* PIMAGE_AUX_SYMBOL_TOKEN_DEF;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD TagIndex;
        union {
            struct {
                WORD Linenumber;
                WORD Size;
            } LnSz;
            DWORD TotalSize;
        } Misc;
        union {
            struct {
                DWORD PointerToLinenumber;
                DWORD PointerToNextFunction;
            } Function;
            struct {
                WORD Dimension[4];
            } Array;
        } FcnAry;
        WORD TvIndex;
    } Sym;
    struct {
        BYTE Name[18];
    } File;
    struct {
        DWORD Length;
        WORD NumberOfRelocations;
        WORD NumberOfLinenumbers;
        DWORD CheckSum;
        SHORT Number;
        BYTE Selection;
        BYTE bReserved;
        SHORT HighNumber;
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL __unaligned* PIMAGE_AUX_SYMBOL;
typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD WeakDefaultSymIndex;
        DWORD WeakSearchType;
        BYTE rgbReserved[12];
    } Sym;
    struct {
        BYTE Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD Length;
        WORD NumberOfRelocations;
        WORD NumberOfLinenumbers;
        DWORD CheckSum;
        SHORT Number;
        BYTE Selection;
        BYTE bReserved;
        SHORT HighNumber;
        BYTE rgbReserved[2];
    } Section;
    struct {
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE rgbReserved[2];
    };
    struct {
        DWORD crc;
        BYTE rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX __unaligned* PIMAGE_AUX_SYMBOL_EX;
typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;
typedef struct _IMAGE_RELOCATION {
    union {
        DWORD VirtualAddress;
        DWORD RelocCount;
    };
    DWORD SymbolTableIndex;
    WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION __unaligned* PIMAGE_RELOCATION;
typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD SymbolTableIndex;
        DWORD VirtualAddress;
    } Type;
    WORD Linenumber;
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER __unaligned* PIMAGE_LINENUMBER;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION __unaligned* PIMAGE_BASE_RELOCATION;
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE Name[16];
    BYTE Date[12];
    BYTE UserID[6];
    BYTE GroupID[6];
    BYTE Mode[8];
    BYTE Size[10];
    BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    CHAR Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
#pragma warning(disable : 4103)
#pragma pack(push, 8)
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64* PIMAGE_THUNK_DATA64;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32* PIMAGE_THUNK_DATA32;
typedef void(__stdcall* PIMAGE_TLS_CALLBACK)(
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved);
typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;
    ULONGLONG AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        };
    };
} IMAGE_TLS_DIRECTORY64;
typedef IMAGE_TLS_DIRECTORY64* PIMAGE_TLS_DIRECTORY64;
typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD StartAddressOfRawData;
    DWORD EndAddressOfRawData;
    DWORD AddressOfIndex;
    DWORD AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        };
    };
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32* PIMAGE_TLS_DIRECTORY32;
typedef IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64 PIMAGE_THUNK_DATA;
typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    };
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR __unaligned* PIMAGE_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD NumberOfModuleForwarderRefs;
} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;
typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;
            DWORD ReservedAttributes : 31;
        };
    } Attributes;
    DWORD DllNameRVA;
    DWORD ModuleHandleRVA;
    DWORD ImportAddressTableRVA;
    DWORD ImportNameTableRVA;
    DWORD BoundImportAddressTableRVA;
    DWORD UnloadInformationTableRVA;
    DWORD TimeDateStamp;
} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;
typedef const IMAGE_DELAYLOAD_DESCRIPTOR* PCIMAGE_DELAYLOAD_DESCRIPTOR;
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    WORD NumberOfNamedEntries;
    WORD NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset : 31;
            DWORD NameIsString : 1;
        };
        DWORD Name;
        WORD Id;
    };
    union {
        DWORD OffsetToData;
        struct {
            DWORD OffsetToDirectory : 31;
            DWORD DataIsDirectory : 1;
        };
    };
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD Length;
    CHAR NameString[1];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD Length;
    WCHAR NameString[1];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;
typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    WORD Flags;
    WORD Catalog;
    DWORD CatalogOffset;
    DWORD Reserved;
} IMAGE_LOAD_CONFIG_CODE_INTEGRITY, *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY;
typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
    DWORD Version;
    DWORD Size;
} IMAGE_DYNAMIC_RELOCATION_TABLE, *PIMAGE_DYNAMIC_RELOCATION_TABLE;
#pragma warning(disable : 4103)
#pragma pack(push, 1)
typedef struct _IMAGE_DYNAMIC_RELOCATION32 {
    DWORD Symbol;
    DWORD BaseRelocSize;
} IMAGE_DYNAMIC_RELOCATION32, *PIMAGE_DYNAMIC_RELOCATION32;
typedef struct _IMAGE_DYNAMIC_RELOCATION64 {
    ULONGLONG Symbol;
    DWORD BaseRelocSize;
} IMAGE_DYNAMIC_RELOCATION64, *PIMAGE_DYNAMIC_RELOCATION64;
typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
    DWORD HeaderSize;
    DWORD FixupInfoSize;
    DWORD Symbol;
    DWORD SymbolGroup;
    DWORD Flags;
} IMAGE_DYNAMIC_RELOCATION32_V2, *PIMAGE_DYNAMIC_RELOCATION32_V2;
typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
    DWORD HeaderSize;
    DWORD FixupInfoSize;
    ULONGLONG Symbol;
    DWORD SymbolGroup;
    DWORD Flags;
} IMAGE_DYNAMIC_RELOCATION64_V2, *PIMAGE_DYNAMIC_RELOCATION64_V2;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef IMAGE_DYNAMIC_RELOCATION64 IMAGE_DYNAMIC_RELOCATION;
typedef PIMAGE_DYNAMIC_RELOCATION64 PIMAGE_DYNAMIC_RELOCATION;
typedef IMAGE_DYNAMIC_RELOCATION64_V2 IMAGE_DYNAMIC_RELOCATION_V2;
typedef PIMAGE_DYNAMIC_RELOCATION64_V2 PIMAGE_DYNAMIC_RELOCATION_V2;
#pragma warning(disable : 4103)
#pragma pack(push, 1)
typedef struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    BYTE PrologueByteCount;
} IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER __unaligned* PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
typedef struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    DWORD EpilogueCount;
    BYTE EpilogueByteCount;
    BYTE BranchDescriptorElementSize;
    WORD BranchDescriptorCount;
} IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER __unaligned* PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
typedef struct _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    DWORD PageRelativeOffset : 12;
    DWORD IndirectCall : 1;
    DWORD IATIndex : 19;
} IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
typedef IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION __unaligned* PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
typedef struct _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    WORD PageRelativeOffset : 12;
    WORD IndirectCall : 1;
    WORD RexWPrefix : 1;
    WORD CfgCheck : 1;
    WORD Reserved : 1;
} IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
typedef IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION __unaligned* PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
typedef struct _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    WORD PageRelativeOffset : 12;
    WORD RegisterNumber : 4;
} IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
typedef IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION __unaligned* PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    DWORD DeCommitFreeBlockThreshold;
    DWORD DeCommitTotalFreeThreshold;
    DWORD LockPrefixTable;
    DWORD MaximumAllocationSize;
    DWORD VirtualMemoryThreshold;
    DWORD ProcessHeapFlags;
    DWORD ProcessAffinityMask;
    WORD CSDVersion;
    WORD DependentLoadFlags;
    DWORD EditList;
    DWORD SecurityCookie;
    DWORD SEHandlerTable;
    DWORD SEHandlerCount;
    DWORD GuardCFCheckFunctionPointer;
    DWORD GuardCFDispatchFunctionPointer;
    DWORD GuardCFFunctionTable;
    DWORD GuardCFFunctionCount;
    DWORD GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    DWORD GuardAddressTakenIatEntryTable;
    DWORD GuardAddressTakenIatEntryCount;
    DWORD GuardLongJumpTargetTable;
    DWORD GuardLongJumpTargetCount;
    DWORD DynamicValueRelocTable;
    DWORD CHPEMetadataPointer;
    DWORD GuardRFFailureRoutine;
    DWORD GuardRFFailureRoutineFunctionPointer;
    DWORD DynamicValueRelocTableOffset;
    WORD DynamicValueRelocTableSection;
    WORD Reserved2;
    DWORD GuardRFVerifyStackPointerFunctionPointer;
    DWORD HotPatchTableOffset;
    DWORD Reserved3;
    DWORD EnclaveConfigurationPointer;
    DWORD VolatileMetadataPointer;
    DWORD GuardEHContinuationTable;
    DWORD GuardEHContinuationCount;
    DWORD GuardXFGCheckFunctionPointer;
    DWORD GuardXFGDispatchFunctionPointer;
    DWORD GuardXFGTableDispatchFunctionPointer;
    DWORD CastGuardOsDeterminedFailureMode;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    ULONGLONG DeCommitFreeBlockThreshold;
    ULONGLONG DeCommitTotalFreeThreshold;
    ULONGLONG LockPrefixTable;
    ULONGLONG MaximumAllocationSize;
    ULONGLONG VirtualMemoryThreshold;
    ULONGLONG ProcessAffinityMask;
    DWORD ProcessHeapFlags;
    WORD CSDVersion;
    WORD DependentLoadFlags;
    ULONGLONG EditList;
    ULONGLONG SecurityCookie;
    ULONGLONG SEHandlerTable;
    ULONGLONG SEHandlerCount;
    ULONGLONG GuardCFCheckFunctionPointer;
    ULONGLONG GuardCFDispatchFunctionPointer;
    ULONGLONG GuardCFFunctionTable;
    ULONGLONG GuardCFFunctionCount;
    DWORD GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    ULONGLONG GuardAddressTakenIatEntryTable;
    ULONGLONG GuardAddressTakenIatEntryCount;
    ULONGLONG GuardLongJumpTargetTable;
    ULONGLONG GuardLongJumpTargetCount;
    ULONGLONG DynamicValueRelocTable;
    ULONGLONG CHPEMetadataPointer;
    ULONGLONG GuardRFFailureRoutine;
    ULONGLONG GuardRFFailureRoutineFunctionPointer;
    DWORD DynamicValueRelocTableOffset;
    WORD DynamicValueRelocTableSection;
    WORD Reserved2;
    ULONGLONG GuardRFVerifyStackPointerFunctionPointer;
    DWORD HotPatchTableOffset;
    DWORD Reserved3;
    ULONGLONG EnclaveConfigurationPointer;
    ULONGLONG VolatileMetadataPointer;
    ULONGLONG GuardEHContinuationTable;
    ULONGLONG GuardEHContinuationCount;
    ULONGLONG GuardXFGCheckFunctionPointer;
    ULONGLONG GuardXFGDispatchFunctionPointer;
    ULONGLONG GuardXFGTableDispatchFunctionPointer;
    ULONGLONG CastGuardOsDeterminedFailureMode;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;
typedef IMAGE_LOAD_CONFIG_DIRECTORY64 IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64 PIMAGE_LOAD_CONFIG_DIRECTORY;
typedef struct _IMAGE_HOT_PATCH_INFO {
    DWORD Version;
    DWORD Size;
    DWORD SequenceNumber;
    DWORD BaseImageList;
    DWORD BaseImageCount;
    DWORD BufferOffset;
    DWORD ExtraPatchSize;
} IMAGE_HOT_PATCH_INFO, *PIMAGE_HOT_PATCH_INFO;
typedef struct _IMAGE_HOT_PATCH_BASE {
    DWORD SequenceNumber;
    DWORD Flags;
    DWORD OriginalTimeDateStamp;
    DWORD OriginalCheckSum;
    DWORD CodeIntegrityInfo;
    DWORD CodeIntegritySize;
    DWORD PatchTable;
    DWORD BufferOffset;
} IMAGE_HOT_PATCH_BASE, *PIMAGE_HOT_PATCH_BASE;
typedef struct _IMAGE_HOT_PATCH_HASHES {
    BYTE SHA256[32];
    BYTE SHA1[20];
} IMAGE_HOT_PATCH_HASHES, *PIMAGE_HOT_PATCH_HASHES;
typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD Ret : 2;
            DWORD H : 1;
            DWORD Reg : 3;
            DWORD R : 1;
            DWORD L : 1;
            DWORD C : 1;
            DWORD StackAdjust : 10;
        };
    };
} IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
typedef enum ARM64_FNPDATA_FLAGS {
    PdataRefToFullXdata = 0,
    PdataPackedUnwindFunction = 1,
    PdataPackedUnwindFragment = 2,
} ARM64_FNPDATA_FLAGS;
typedef enum ARM64_FNPDATA_CR {
    PdataCrUnchained = 0,
    PdataCrUnchainedSavedLr = 1,
    PdataCrChainedWithPac = 2,
    PdataCrChained = 3,
} ARM64_FNPDATA_CR;
typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD RegF : 3;
            DWORD RegI : 4;
            DWORD H : 1;
            DWORD CR : 2;
            DWORD FrameSize : 9;
        };
    };
} IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
typedef union IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    DWORD HeaderData;
    struct {
        DWORD FunctionLength : 18;
        DWORD Version : 2;
        DWORD ExceptionDataPresent : 1;
        DWORD EpilogInHeader : 1;
        DWORD EpilogCount : 5;
        DWORD CodeWords : 5;
    };
} IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA;
typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    };
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_AMD64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_AMD64_RUNTIME_FUNCTION_ENTRY;
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_ENCLAVE_CONFIG32 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE FamilyID[16];
    BYTE ImageID[16];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    DWORD EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG32, *PIMAGE_ENCLAVE_CONFIG32;
typedef struct _IMAGE_ENCLAVE_CONFIG64 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE FamilyID[16];
    BYTE ImageID[16];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    ULONGLONG EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG64, *PIMAGE_ENCLAVE_CONFIG64;
typedef IMAGE_ENCLAVE_CONFIG64 IMAGE_ENCLAVE_CONFIG;
typedef PIMAGE_ENCLAVE_CONFIG64 PIMAGE_ENCLAVE_CONFIG;
typedef struct _IMAGE_ENCLAVE_IMPORT {
    DWORD MatchType;
    DWORD MinimumSecurityVersion;
    BYTE UniqueOrAuthorID[32];
    BYTE FamilyID[16];
    BYTE ImageID[16];
    DWORD ImportName;
    DWORD Reserved;
} IMAGE_ENCLAVE_IMPORT, *PIMAGE_ENCLAVE_IMPORT;
typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Type;
    DWORD SizeOfData;
    DWORD AddressOfRawData;
    DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD NumberOfSymbols;
    DWORD LvaToFirstSymbol;
    DWORD NumberOfLinenumbers;
    DWORD LvaToFirstLinenumber;
    DWORD RvaToFirstByteOfCode;
    DWORD RvaToLastByteOfCode;
    DWORD RvaToFirstByteOfData;
    DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;
typedef struct _FPO_DATA {
    DWORD ulOffStart;
    DWORD cbProcSize;
    DWORD cdwLocals;
    WORD cdwParams;
    WORD cbProlog : 8;
    WORD cbRegs : 3;
    WORD fHasSEH : 1;
    WORD fUseBP : 1;
    WORD reserved : 1;
    WORD cbFrame : 2;
} FPO_DATA, *PFPO_DATA;
typedef struct _IMAGE_DEBUG_MISC {
    DWORD DataType;
    DWORD Length;
    BOOLEAN Unicode;
    BYTE Reserved[3];
    BYTE Data[1];
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;
typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;
typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG StartingAddress;
    ULONGLONG EndingAddress;
    union {
        ULONGLONG EndOfPrologue;
        ULONGLONG UnwindInfoAddress;
    };
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD Signature;
    WORD Flags;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;
    DWORD NumberOfSections;
    DWORD ExportedNamesSize;
    DWORD DebugDirectorySize;
    DWORD SectionAlignment;
    DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;
typedef struct _NON_PAGED_DEBUG_INFO {
    WORD Signature;
    WORD Flags;
    DWORD Size;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD SizeOfImage;
    ULONGLONG ImageBase;
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;
typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue : 1;
    int : 7;
    unsigned int AmaskShift : 8;
    int : 16;
    DWORD FirstEntryRVA;
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;
typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;
    DWORD NewInst;
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;
#pragma warning(disable : 4103)
#pragma pack(pop)
typedef struct IMPORT_OBJECT_HEADER {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    DWORD SizeOfData;
    union {
        WORD Ordinal;
        WORD Hint;
    };
    WORD Type : 2;
    WORD NameType : 3;
    WORD Reserved : 11;
} IMPORT_OBJECT_HEADER;
typedef enum IMPORT_OBJECT_TYPE {
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;
typedef enum IMPORT_OBJECT_NAME_TYPE {
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,
    IMPORT_OBJECT_NAME_EXPORTAS = 4,
} IMPORT_OBJECT_NAME_TYPE;
typedef enum ReplacesCorHdrNumericDefines {
    COMIMAGE_FLAGS_ILONLY = 0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED = 0x00020000,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR = 5,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF,
    IMAGE_COR_MIH_METHODRVA = 0x01,
    IMAGE_COR_MIH_EHRVA = 0x02,
    IMAGE_COR_MIH_BASICBLOCK = 0x08,
    COR_VTABLE_32BIT = 0x01,
    COR_VTABLE_64BIT = 0x02,
    COR_VTABLE_FROM_UNMANAGED = 0x04,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 0x08,
    COR_VTABLE_CALL_MOST_DERIVED = 0x10,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024,
} ReplacesCorHdrNumericDefines;
typedef struct IMAGE_COR20_HEADER {
    DWORD cb;
    WORD MajorRuntimeVersion;
    WORD MinorRuntimeVersion;
    IMAGE_DATA_DIRECTORY MetaData;
    DWORD Flags;
    union {
        DWORD EntryPointToken;
        DWORD EntryPointRVA;
    };
    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;
    IMAGE_DATA_DIRECTORY CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
    IMAGE_DATA_DIRECTORY ManagedNativeHeader;
} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;
#pragma region Application or OneCore or Games Family
__declspec(dllimport)
    WORD
    __stdcall RtlCaptureStackBackTrace(
        DWORD FramesToSkip,
        DWORD FramesToCapture,
        PVOID* BackTrace,
        PDWORD BackTraceHash);
__declspec(dllimport) void __stdcall RtlCaptureContext(
    PCONTEXT ContextRecord);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall RtlCaptureContext2(
    PCONTEXT ContextRecord);
#pragma endregion
typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    ULONG_PTR ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;
typedef struct _UNWIND_HISTORY_TABLE {
    DWORD Count;
    BYTE LocalHint;
    BYTE GlobalHint;
    BYTE Search;
    BYTE Once;
    ULONG_PTR LowAddress;
    ULONG_PTR HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[12];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;
#pragma region Application or OneCore Family or Games Family
__declspec(dllimport) void __stdcall RtlUnwind(
    PVOID TargetFrame,
    PVOID TargetIp,
    PEXCEPTION_RECORD ExceptionRecord,
    PVOID ReturnValue);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOLEAN
    __cdecl RtlAddFunctionTable(
        PRUNTIME_FUNCTION FunctionTable,
        DWORD EntryCount,
        DWORD64 BaseAddress);
__declspec(dllimport)
    BOOLEAN
    __cdecl RtlDeleteFunctionTable(
        PRUNTIME_FUNCTION FunctionTable);
__declspec(dllimport)
    BOOLEAN
    __cdecl RtlInstallFunctionTableCallback(
        DWORD64 TableIdentifier,
        DWORD64 BaseAddress,
        DWORD Length,
        PGET_RUNTIME_FUNCTION_CALLBACK Callback,
        PVOID Context,
        PCWSTR OutOfProcessCallbackDll);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall RtlAddGrowableFunctionTable(
        PVOID* DynamicTable,
        PRUNTIME_FUNCTION FunctionTable,
        DWORD EntryCount,
        DWORD MaximumEntryCount,
        ULONG_PTR RangeBase,
        ULONG_PTR RangeEnd);
__declspec(dllimport) void __stdcall RtlGrowFunctionTable(
    PVOID DynamicTable,
    DWORD NewEntryCount);
__declspec(dllimport) void __stdcall RtlDeleteGrowableFunctionTable(
    PVOID DynamicTable);
#pragma endregion
#pragma region Application or OneCore Family or Games Family
__declspec(dllimport)
    PRUNTIME_FUNCTION
    __stdcall RtlLookupFunctionEntry(
        DWORD64 ControlPc,
        PDWORD64 ImageBase,
        PUNWIND_HISTORY_TABLE HistoryTable);
__declspec(dllimport) void __cdecl RtlRestoreContext(
    PCONTEXT ContextRecord,
    struct _EXCEPTION_RECORD* ExceptionRecord);
__declspec(dllimport) void __stdcall RtlUnwindEx(
    PVOID TargetFrame,
    PVOID TargetIp,
    PEXCEPTION_RECORD ExceptionRecord,
    PVOID ReturnValue,
    PCONTEXT ContextRecord,
    PUNWIND_HISTORY_TABLE HistoryTable);
__declspec(dllimport)
    PEXCEPTION_ROUTINE
    __stdcall RtlVirtualUnwind(
        DWORD HandlerType,
        DWORD64 ImageBase,
        DWORD64 ControlPc,
        PRUNTIME_FUNCTION FunctionEntry,
        PCONTEXT ContextRecord,
        PVOID* HandlerData,
        PDWORD64 EstablisherFrame,
        PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall RtlRaiseException(
    PEXCEPTION_RECORD ExceptionRecord);
__declspec(dllimport)
    PVOID
    __stdcall RtlPcToFileHeader(
        PVOID PcValue,
        PVOID* BaseOfImage);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    SIZE_T
    __stdcall RtlCompareMemory(
        const void* Source1,
        const void* Source2,
        SIZE_T Length);
#pragma endregion
#pragma warning(push)
#pragma warning(disable : 4324)
typedef struct __declspec(align(16)) _SLIST_ENTRY {
    struct _SLIST_ENTRY* Next;
} SLIST_ENTRY, *PSLIST_ENTRY;
#pragma warning(pop)
typedef union __declspec(align(16)) _SLIST_HEADER {
    struct {
        ULONGLONG Alignment;
        ULONGLONG Region;
    };
    struct {
        ULONGLONG Depth : 16;
        ULONGLONG Sequence : 48;
        ULONGLONG Reserved : 4;
        ULONGLONG NextEntry : 60;
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) void __stdcall RtlInitializeSListHead(
    PSLIST_HEADER ListHead);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall RtlFirstEntrySList(
        const SLIST_HEADER* ListHead);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall RtlInterlockedPopEntrySList(
        PSLIST_HEADER ListHead);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall RtlInterlockedPushEntrySList(
        PSLIST_HEADER ListHead,
        PSLIST_ENTRY ListEntry);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall RtlInterlockedPushListSListEx(
        PSLIST_HEADER ListHead,
        PSLIST_ENTRY List,
        PSLIST_ENTRY ListEnd,
        DWORD Count);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall RtlInterlockedFlushSList(
        PSLIST_HEADER ListHead);
__declspec(dllimport)
    WORD
    __stdcall RtlQueryDepthSList(
        PSLIST_HEADER ListHead);
__declspec(dllimport)
    ULONG_PTR
    __stdcall RtlGetReturnAddressHijackTarget(
        void);
#pragma endregion
typedef union _RTL_RUN_ONCE {
    PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;
typedef struct _RTL_BARRIER {
    DWORD Reserved1;
    DWORD Reserved2;
    ULONG_PTR Reserved3[2];
    DWORD Reserved4;
    DWORD Reserved5;
} RTL_BARRIER, *PRTL_BARRIER;
__declspec(noreturn) void __fastfail(
    unsigned int Code);
#pragma intrinsic(__fastfail)
#pragma region Desktop Family
__forceinline DWORD
HEAP_MAKE_TAG_FLAGS(
    DWORD TagBase,
    DWORD Tag)
{
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}
#pragma endregion
__forceinline PVOID
RtlSecureZeroMemory(
    PVOID ptr,
    SIZE_T cnt)
{
    volatile char* vptr = (volatile char*)ptr;
    __stosb((PBYTE)((DWORD64)vptr), 0, cnt);
    return ptr;
}
typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD Length;
    WORD Flags;
    BYTE Text[1];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;
typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;
typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[1];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;
typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[128];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[128];
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[128];
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[128];
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    ULONGLONG
    __stdcall VerSetConditionMask(
        ULONGLONG ConditionMask,
        DWORD TypeMask,
        BYTE Condition);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOLEAN
    __stdcall RtlGetProductInfo(
        DWORD OSMajorVersion,
        DWORD OSMinorVersion,
        DWORD SpMajorVersion,
        DWORD SpMinorVersion,
        PDWORD ReturnedProductType);
#pragma endregion
typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS,
    *PRTL_UMS_THREAD_INFO_CLASS;
typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON,
    *PRTL_UMS_SCHEDULER_REASON;
typedef void __stdcall RTL_UMS_SCHEDULER_ENTRY_POINT(
    RTL_UMS_SCHEDULER_REASON Reason,
    ULONG_PTR ActivationPayload,
    PVOID SchedulerParam);
typedef RTL_UMS_SCHEDULER_ENTRY_POINT* PRTL_UMS_SCHEDULER_ENTRY_POINT;
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall RtlCrc32(
        const void* Buffer,
        size_t Size,
        DWORD InitialCrc);
__declspec(dllimport)
    ULONGLONG
    __stdcall RtlCrc64(
        const void* Buffer,
        size_t Size,
        ULONGLONG InitialCrc);
#pragma endregion
typedef enum _OS_DEPLOYEMENT_STATE_VALUES {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT
} OS_DEPLOYEMENT_STATE_VALUES;
__declspec(dllimport)
    OS_DEPLOYEMENT_STATE_VALUES
    __stdcall RtlOsDeploymentState(
        DWORD Flags);
typedef struct _NV_MEMORY_RANGE {
    void* BaseAddress;
    SIZE_T Length;
} NV_MEMORY_RANGE, *PNV_MEMORY_RANGE;
__declspec(dllimport)
    DWORD
    __stdcall RtlGetNonVolatileToken(
        PVOID NvBuffer,
        SIZE_T Size,
        PVOID* NvToken);
__declspec(dllimport)
    DWORD
    __stdcall RtlFreeNonVolatileToken(
        PVOID NvToken);
__declspec(dllimport)
    DWORD
    __stdcall RtlFlushNonVolatileMemory(
        PVOID NvToken,
        PVOID NvBuffer,
        SIZE_T Size,
        DWORD Flags);
__declspec(dllimport)
    DWORD
    __stdcall RtlDrainNonVolatileFlush(
        PVOID NvToken);
__declspec(dllimport)
    DWORD
    __stdcall RtlWriteNonVolatileMemory(
        PVOID NvToken,
        void __unaligned* NvDestination,
        const void __unaligned* Source,
        SIZE_T Size,
        DWORD Flags);
__declspec(dllimport)
    DWORD
    __stdcall RtlFillNonVolatileMemory(
        PVOID NvToken,
        void __unaligned* NvDestination,
        SIZE_T Size,
        const BYTE Value,
        DWORD Flags);
__declspec(dllimport)
    DWORD
    __stdcall RtlFlushNonVolatileMemoryRanges(
        PVOID NvToken,
        PNV_MEMORY_RANGE NvRanges,
        SIZE_T NumRanges,
        DWORD Flags);
typedef struct CORRELATION_VECTOR {
    CHAR Version;
    CHAR Vector[129];
} CORRELATION_VECTOR;
typedef CORRELATION_VECTOR* PCORRELATION_VECTOR;
__declspec(dllimport)
    DWORD
    __stdcall RtlInitializeCorrelationVector(
        PCORRELATION_VECTOR CorrelationVector,
        int Version,
        const GUID* Guid);
__declspec(dllimport)
    DWORD
    __stdcall RtlIncrementCorrelationVector(
        PCORRELATION_VECTOR CorrelationVector);
__declspec(dllimport)
    DWORD
    __stdcall RtlExtendCorrelationVector(
        PCORRELATION_VECTOR CorrelationVector);
__declspec(dllimport)
    DWORD
    __stdcall RtlValidateCorrelationVector(
        PCORRELATION_VECTOR Vector);
typedef struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    DWORD Size;
    PCWSTR TriggerId;
} CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG, *PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
__forceinline void
CUSTOM_SYSTEM_EVENT_TRIGGER_INIT(
    PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG Config,
    PCWSTR TriggerId)
{
    memset((Config), 0, (sizeof(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG)));
    Config->Size = sizeof(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG);
    Config->TriggerId = TriggerId;
}
DWORD
__stdcall RtlRaiseCustomSystemEventTrigger(
    PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig);
typedef enum _IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool,
    ImagePolicyEntryTypeInt8,
    ImagePolicyEntryTypeUInt8,
    ImagePolicyEntryTypeInt16,
    ImagePolicyEntryTypeUInt16,
    ImagePolicyEntryTypeInt32,
    ImagePolicyEntryTypeUInt32,
    ImagePolicyEntryTypeInt64,
    ImagePolicyEntryTypeUInt64,
    ImagePolicyEntryTypeAnsiString,
    ImagePolicyEntryTypeUnicodeString,
    ImagePolicyEntryTypeOverride,
    ImagePolicyEntryTypeMaximum
} IMAGE_POLICY_ENTRY_TYPE;
typedef enum _IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw,
    ImagePolicyIdDebug,
    ImagePolicyIdCrashDump,
    ImagePolicyIdCrashDumpKey,
    ImagePolicyIdCrashDumpKeyGuid,
    ImagePolicyIdParentSd,
    ImagePolicyIdParentSdRev,
    ImagePolicyIdSvn,
    ImagePolicyIdDeviceId,
    ImagePolicyIdCapability,
    ImagePolicyIdScenarioId,
    ImagePolicyIdMaximum
} IMAGE_POLICY_ID;
typedef struct _IMAGE_POLICY_ENTRY {
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
    union {
        const void* None;
        BOOLEAN BoolValue;
        INT8 Int8Value;
        UINT8 UInt8Value;
        INT16 Int16Value;
        UINT16 UInt16Value;
        INT32 Int32Value;
        UINT32 UInt32Value;
        INT64 Int64Value;
        UINT64 UInt64Value;
        PCSTR AnsiStringValue;
        PCWSTR UnicodeStringValue;
    } u;
} IMAGE_POLICY_ENTRY;
typedef const IMAGE_POLICY_ENTRY* PCIMAGE_POLICY_ENTRY;
#pragma warning(push)
#pragma warning(disable : 4200)
typedef struct _IMAGE_POLICY_METADATA {
    BYTE Version;
    BYTE Reserved0[7];
    ULONGLONG ApplicationId;
    IMAGE_POLICY_ENTRY Policies[];
} IMAGE_POLICY_METADATA;
typedef const IMAGE_POLICY_METADATA* PCIMAGE_POLICY_METADATA;
#pragma warning(pop)
__declspec(dllimport)
    BOOLEAN
    __stdcall RtlIsZeroMemory(
        PVOID Buffer,
        SIZE_T Length);
__declspec(dllimport)
    BOOLEAN
    __stdcall RtlNormalizeSecurityDescriptor(
        PSECURITY_DESCRIPTOR* SecurityDescriptor,
        DWORD SecurityDescriptorLength,
        PSECURITY_DESCRIPTOR* NewSecurityDescriptor,
        PDWORD NewSecurityDescriptorLength,
        BOOLEAN CheckOnly);
typedef enum _RTL_SYSTEM_GLOBAL_DATA_ID {
    GlobalDataIdUnknown = 0,
    GlobalDataIdRngSeedVersion,
    GlobalDataIdInterruptTime,
    GlobalDataIdTimeZoneBias,
    GlobalDataIdImageNumberLow,
    GlobalDataIdImageNumberHigh,
    GlobalDataIdTimeZoneId,
    GlobalDataIdNtMajorVersion,
    GlobalDataIdNtMinorVersion,
    GlobalDataIdSystemExpirationDate,
    GlobalDataIdKdDebuggerEnabled,
    GlobalDataIdCyclesPerYield,
    GlobalDataIdSafeBootMode,
    GlobalDataIdLastSystemRITEventTickCount
} RTL_SYSTEM_GLOBAL_DATA_ID,
    *PRTL_SYSTEM_GLOBAL_DATA_ID;
__declspec(dllimport)
    DWORD
    __stdcall RtlGetSystemGlobalData(
        RTL_SYSTEM_GLOBAL_DATA_ID DataId,
        PVOID Buffer,
        DWORD Size);
__declspec(dllimport)
    DWORD
    __stdcall RtlSetSystemGlobalData(
        RTL_SYSTEM_GLOBAL_DATA_ID DataId,
        PVOID Buffer,
        DWORD Size);
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION* CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;
#pragma pack(push, 8)
typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
#pragma pack(pop)
typedef struct _RTL_SRWLOCK {
    PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;
typedef struct _RTL_CONDITION_VARIABLE {
    PVOID Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;
typedef void(__stdcall* PAPCFUNC)(
    ULONG_PTR Parameter);
typedef LONG(__stdcall* PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS* ExceptionInfo);
typedef enum _HEAP_INFORMATION_CLASS {
    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1,
    HeapOptimizeResources = 3,
    HeapTag = 7
} HEAP_INFORMATION_CLASS;
typedef struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    DWORD Version;
    DWORD Flags;
} HEAP_OPTIMIZE_RESOURCES_INFORMATION, *PHEAP_OPTIMIZE_RESOURCES_INFORMATION;
typedef void(__stdcall* WAITORTIMERCALLBACKFUNC)(PVOID, BOOLEAN);
typedef void(__stdcall* WORKERCALLBACKFUNC)(PVOID);
typedef void(__stdcall* APC_CALLBACK_FUNCTION)(DWORD, PVOID, PVOID);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;
typedef void(__stdcall* PFLS_CALLBACK_FUNCTION)(
    PVOID lpFlsData);
typedef BOOLEAN(__stdcall* PSECURE_MEMORY_CACHE_CALLBACK)(
    PVOID Addr,
    SIZE_T Range);
typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
} ACTIVATION_CONTEXT_INFO_CLASS;
typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, *PACTIVATION_CONTEXT_QUERY_INDEX;
typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX* PCACTIVATION_CONTEXT_QUERY_INDEX;
typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;
    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION* PCASSEMBLY_FILE_DETAILED_INFORMATION;
typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;
    DWORD ulManifestPathType;
    DWORD ulManifestPathLength;
    LARGE_INTEGER liManifestLastWriteTime;
    DWORD ulPolicyPathType;
    DWORD ulPolicyPathLength;
    LARGE_INTEGER liPolicyLastWriteTime;
    DWORD ulMetadataSatelliteRosterIndex;
    DWORD ulManifestVersionMajor;
    DWORD ulManifestVersionMinor;
    DWORD ulPolicyVersionMajor;
    DWORD ulPolicyVersionMinor;
    DWORD ulAssemblyDirectoryNameLength;
    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;
    DWORD ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION* PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
typedef enum {
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;
typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, *PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION* PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
typedef enum {
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;
typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
    ULONGLONG MaxVersionTested;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;
typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT* PCCOMPATIBILITY_CONTEXT_ELEMENT;
#pragma warning(push)
#pragma warning(disable : 4200)
typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, *PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
#pragma warning(pop)
typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION* PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
typedef struct _SUPPORTED_OS_INFO {
    WORD MajorVersion;
    WORD MinorVersion;
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;
typedef struct _MAXVERSIONTESTED_INFO {
    ULONGLONG MaxVersionTested;
} MAXVERSIONTESTED_INFO, *PMAXVERSIONTESTED_INFO;
typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION* PCACTIVATION_CONTEXT_DETAILED_INFORMATION;
typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;
typedef struct _PERFORMANCE_DATA {
    WORD Size;
    BYTE Version;
    BYTE HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;
#pragma region Desktop Family
void __stdcall RtlGetDeviceFamilyInfoEnum(
    ULONGLONG* pullUAPInfo,
    DWORD* pulDeviceFamily,
    DWORD* pulDeviceForm);
DWORD
__stdcall RtlConvertDeviceFamilyInfoToString(
    PDWORD pulDeviceFamilyBufferSize,
    PDWORD pulDeviceFormBufferSize,
    PWSTR DeviceFamily,
    PWSTR DeviceForm);
DWORD
__stdcall RtlSwitchedVVI(
    PRTL_OSVERSIONINFOEXW VersionInfo,
    DWORD TypeMask,
    ULONGLONG ConditionMask);
#pragma endregion
typedef struct _EVENTLOGRECORD {
    DWORD Length;
    DWORD Reserved;
    DWORD RecordNumber;
    DWORD TimeGenerated;
    DWORD TimeWritten;
    DWORD EventID;
    WORD EventType;
    WORD NumStrings;
    WORD EventCategory;
    WORD ReservedFlags;
    DWORD ClosingRecordNumber;
    DWORD StringOffset;
    DWORD UserSidLength;
    DWORD UserSidOffset;
    DWORD DataLength;
    DWORD DataOffset;
} EVENTLOGRECORD, *PEVENTLOGRECORD;
#pragma warning(push)
#pragma warning(disable : 4200)
struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;
struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;
struct _EVENTSFORLOGFILE {
    DWORD ulSize;
    WCHAR szLogicalLogFile[256];
    DWORD ulNumRecords;
    EVENTLOGRECORD pEventLogRecords[];
};
struct _PACKEDEVENTINFO {
    DWORD ulSize;
    DWORD ulNumEventsForLogFile;
    DWORD ulOffsets[];
};
#pragma warning(pop)
typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
} SERVICE_NODE_TYPE;
typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;
typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;
typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;
typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;
typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;
typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;
typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;
typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;
typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;
typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;
typedef struct _TAPE_WMI_OPERATIONS {
    DWORD Method;
    DWORD DataBufferSize;
    PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
    TapeDriveProblemNone,
    TapeDriveReadWriteWarning,
    TapeDriveReadWriteError,
    TapeDriveReadWarning,
    TapeDriveWriteWarning,
    TapeDriveReadError,
    TapeDriveWriteError,
    TapeDriveHardwareError,
    TapeDriveUnsupportedMedia,
    TapeDriveScsiConnectionError,
    TapeDriveTimetoClean,
    TapeDriveCleanDriveNow,
    TapeDriveMediaLifeExpired,
    TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;
extern "C" {
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;
typedef ULONG NOTIFICATION_MASK;
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID TransactionKey;
    ULONG TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;
typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID EnlistmentId;
    UOW UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;
typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID UOW;
    GUID TmIdentity;
    ULONG BufferLength;
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;
typedef struct _KCRM_MARSHAL_HEADER {
    ULONG VersionMajor;
    ULONG VersionMinor;
    ULONG NumProtocols;
    ULONG Unused;
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, *PRKCRM_MARSHAL_HEADER;
typedef struct _KCRM_TRANSACTION_BLOB {
    UOW UOW;
    GUID TmIdentity;
    ULONG IsolationLevel;
    ULONG IsolationFlags;
    ULONG Timeout;
    WCHAR Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, *PRKCRM_TRANSACTION_BLOB;
typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID ProtocolId;
    ULONG StaticInfoLength;
    ULONG TransactionIdInfoLength;
    ULONG Unused1;
    ULONG Unused2;
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, *PRKCRM_PROTOCOL_BLOB;
#pragma warning(pop)
}
#pragma warning(push)
#pragma warning(disable : 4820)
typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;
typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;
typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID TransactionId;
    DWORD State;
    DWORD Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;
typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;
typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;
typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
    WCHAR LogPath[1];
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;
typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;
typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;
typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD IsolationLevel;
    DWORD IsolationFlags;
    LARGE_INTEGER Timeout;
    DWORD Outcome;
    DWORD DescriptionLength;
    WCHAR Description[1];
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;
typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;
typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID EnlistmentId;
    GUID ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;
typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;
typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID ResourceManagerId;
    DWORD DescriptionLength;
    WCHAR Description[1];
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;
typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;
typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation,
    TransactionBindInformation,
    TransactionDTCPrivateInformation,
} TRANSACTION_INFORMATION_CLASS;
typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4,
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
} TRANSACTIONMANAGER_INFORMATION_CLASS;
typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;
typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;
typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;
typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;
typedef struct _TRANSACTION_LIST_ENTRY {
    UOW UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;
typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1];
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;
typedef enum _KTMOBJECT_TYPE {
    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID
} KTMOBJECT_TYPE,
    *PKTMOBJECT_TYPE;
typedef struct _KTMOBJECT_CURSOR {
    GUID LastQuery;
    DWORD ObjectIdCount;
    GUID ObjectIds[1];
} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;
#pragma warning(pop)
}
typedef DWORD TP_VERSION, *PTP_VERSION;
typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;
typedef void(__stdcall* PTP_SIMPLE_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context);
typedef struct _TP_POOL TP_POOL, *PTP_POOL;
typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;
typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
} TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;
typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
typedef void(__stdcall* PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
    PVOID ObjectContext,
    PVOID CleanupContext);
typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION Version;
    PTP_POOL Pool;
    PTP_CLEANUP_GROUP CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    PVOID RaceDll;
    struct _ACTIVATION_CONTEXT* ActivationContext;
    PTP_SIMPLE_CALLBACK FinalizationCallback;
    union {
        DWORD Flags;
        struct {
            DWORD LongFunction : 1;
            DWORD Persistent : 1;
            DWORD Private : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY CallbackPriority;
    DWORD Size;
} TP_CALLBACK_ENVIRON_V3;
typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;
__forceinline void
TpInitializeCallbackEnviron(
    PTP_CALLBACK_ENVIRON CallbackEnviron)
{
    CallbackEnviron->Version = 3;
    CallbackEnviron->Pool = 0;
    CallbackEnviron->CleanupGroup = 0;
    CallbackEnviron->CleanupGroupCancelCallback = 0;
    CallbackEnviron->RaceDll = 0;
    CallbackEnviron->ActivationContext = 0;
    CallbackEnviron->FinalizationCallback = 0;
    CallbackEnviron->u.Flags = 0;
    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);
}
__forceinline void
TpSetCallbackThreadpool(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_POOL Pool)
{
    CallbackEnviron->Pool = Pool;
}
__forceinline void
TpSetCallbackCleanupGroup(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_CLEANUP_GROUP CleanupGroup,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback)
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}
__forceinline void
TpSetCallbackActivationContext(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    struct _ACTIVATION_CONTEXT* ActivationContext)
{
    CallbackEnviron->ActivationContext = ActivationContext;
}
__forceinline void
TpSetCallbackNoActivationContext(
    PTP_CALLBACK_ENVIRON CallbackEnviron)
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT*)(LONG_PTR)-1;
}
__forceinline void
TpSetCallbackLongFunction(
    PTP_CALLBACK_ENVIRON CallbackEnviron)
{
    CallbackEnviron->u.s.LongFunction = 1;
}
__forceinline void
TpSetCallbackRaceWithDll(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PVOID DllHandle)
{
    CallbackEnviron->RaceDll = DllHandle;
}
__forceinline void
TpSetCallbackFinalizationCallback(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_SIMPLE_CALLBACK FinalizationCallback)
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}
__forceinline void
TpSetCallbackPriority(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    TP_CALLBACK_PRIORITY Priority)
{
    CallbackEnviron->CallbackPriority = Priority;
}
__forceinline void
TpSetCallbackPersistent(
    PTP_CALLBACK_ENVIRON CallbackEnviron)
{
    CallbackEnviron->u.s.Persistent = 1;
}
__forceinline void
TpDestroyCallbackEnviron(
    PTP_CALLBACK_ENVIRON CallbackEnviron)
{
    (CallbackEnviron);
}
typedef struct _TP_WORK TP_WORK, *PTP_WORK;
typedef void(__stdcall* PTP_WORK_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_WORK Work);
typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;
typedef void(__stdcall* PTP_TIMER_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_TIMER Timer);
typedef DWORD TP_WAIT_RESULT;
typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;
typedef void(__stdcall* PTP_WAIT_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_WAIT Wait,
    TP_WAIT_RESULT WaitResult);
typedef struct _TP_IO TP_IO, *PTP_IO;
__forceinline struct _TEB*
NtCurrentTeb(
    void)
{
    return (struct _TEB*)__readgsqword(((LONG)(LONG_PTR) & (((NT_TIB*)0)->Self)));
}
__forceinline PVOID
GetCurrentFiber(
    void)
{
    return (PVOID)__readgsqword(((LONG)(LONG_PTR) & (((NT_TIB*)0)->FiberData)));
}
__forceinline PVOID
GetFiberData(
    void)
{
    return *(PVOID*)GetCurrentFiber();
}
}
#pragma warning(pop)
typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;
typedef HANDLE* SPHANDLE;
typedef HANDLE* LPHANDLE;
typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;
#pragma warning(push)
#pragma warning(disable : 4255)
typedef INT_PTR(__stdcall* FARPROC)();
typedef INT_PTR(__stdcall* NEARPROC)();
typedef INT_PTR(__stdcall* PROC)();
#pragma warning(pop)
typedef WORD ATOM;
struct HKEY__ {
    int unused;
};
typedef struct HKEY__* HKEY;
typedef HKEY* PHKEY;
struct HMETAFILE__ {
    int unused;
};
typedef struct HMETAFILE__* HMETAFILE;
struct HINSTANCE__ {
    int unused;
};
typedef struct HINSTANCE__* HINSTANCE;
typedef HINSTANCE HMODULE;
struct HRGN__ {
    int unused;
};
typedef struct HRGN__* HRGN;
struct HRSRC__ {
    int unused;
};
typedef struct HRSRC__* HRSRC;
struct HSPRITE__ {
    int unused;
};
typedef struct HSPRITE__* HSPRITE;
struct HLSURF__ {
    int unused;
};
typedef struct HLSURF__* HLSURF;
struct HSTR__ {
    int unused;
};
typedef struct HSTR__* HSTR;
struct HTASK__ {
    int unused;
};
typedef struct HTASK__* HTASK;
struct HWINSTA__ {
    int unused;
};
typedef struct HWINSTA__* HWINSTA;
struct HKL__ {
    int unused;
};
typedef struct HKL__* HKL;
typedef int HFILE;
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;
}
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
struct HWND__ {
    int unused;
};
typedef struct HWND__* HWND;
struct HHOOK__ {
    int unused;
};
typedef struct HHOOK__* HHOOK;
#pragma endregion
#pragma region Application Family
typedef void* HGDIOBJ;
struct HACCEL__ {
    int unused;
};
typedef struct HACCEL__* HACCEL;
struct HBITMAP__ {
    int unused;
};
typedef struct HBITMAP__* HBITMAP;
struct HBRUSH__ {
    int unused;
};
typedef struct HBRUSH__* HBRUSH;
struct HCOLORSPACE__ {
    int unused;
};
typedef struct HCOLORSPACE__* HCOLORSPACE;
struct HDC__ {
    int unused;
};
typedef struct HDC__* HDC;
struct HGLRC__ {
    int unused;
};
typedef struct HGLRC__* HGLRC;
struct HDESK__ {
    int unused;
};
typedef struct HDESK__* HDESK;
struct HENHMETAFILE__ {
    int unused;
};
typedef struct HENHMETAFILE__* HENHMETAFILE;
struct HFONT__ {
    int unused;
};
typedef struct HFONT__* HFONT;
struct HICON__ {
    int unused;
};
typedef struct HICON__* HICON;
struct HMENU__ {
    int unused;
};
typedef struct HMENU__* HMENU;
struct HPALETTE__ {
    int unused;
};
typedef struct HPALETTE__* HPALETTE;
struct HPEN__ {
    int unused;
};
typedef struct HPEN__* HPEN;
struct HWINEVENTHOOK__ {
    int unused;
};
typedef struct HWINEVENTHOOK__* HWINEVENTHOOK;
#pragma endregion
#pragma region Application Family
struct HMONITOR__ {
    int unused;
};
typedef struct HMONITOR__* HMONITOR;
#pragma endregion
#pragma region Desktop Family
struct HUMPD__ {
    int unused;
};
typedef struct HUMPD__* HUMPD;
#pragma endregion
#pragma region Application Family
typedef HICON HCURSOR;
typedef DWORD COLORREF;
#pragma endregion
#pragma region Desktop Family
typedef DWORD* LPCOLORREF;
#pragma endregion
#pragma region Application Family or Games Family
typedef struct tagRECT {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT, *PRECT, *NPRECT, *LPRECT;
typedef const RECT* LPCRECT;
typedef struct _RECTL {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECTL, *PRECTL, *LPRECTL;
typedef const RECTL* LPCRECTL;
typedef struct tagPOINT {
    LONG x;
    LONG y;
} POINT, *PPOINT, *NPPOINT, *LPPOINT;
typedef struct _POINTL {
    LONG x;
    LONG y;
} POINTL, *PPOINTL;
typedef struct tagSIZE {
    LONG cx;
    LONG cy;
} SIZE, *PSIZE, *LPSIZE;
typedef SIZE SIZEL;
typedef SIZE *PSIZEL, *LPSIZEL;
typedef struct tagPOINTS {
    SHORT x;
    SHORT y;
} POINTS, *PPOINTS, *LPPOINTS;
typedef struct APP_LOCAL_DEVICE_ID {
    BYTE value[32];
} APP_LOCAL_DEVICE_ID;
#pragma endregion
}
#pragma region Desktop Family
struct DPI_AWARENESS_CONTEXT__ {
    int unused;
};
typedef struct DPI_AWARENESS_CONTEXT__* DPI_AWARENESS_CONTEXT;
typedef enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
} DPI_AWARENESS;
typedef enum DPI_HOSTING_BEHAVIOR {
    DPI_HOSTING_BEHAVIOR_INVALID = -1,
    DPI_HOSTING_BEHAVIOR_DEFAULT = 0,
    DPI_HOSTING_BEHAVIOR_MIXED = 1
} DPI_HOSTING_BEHAVIOR;
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4668)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
#pragma once
#pragma warning(disable : 4514)
#pragma warning(disable : 4103)
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
extern "C" {
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        };
        PVOID Pointer;
    };
    HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;
typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;
typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[260];
    CHAR cAlternateFileName[14];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[260];
    WCHAR cAlternateFileName[14];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;
typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
typedef enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
    ReadDirectoryNotifyInformation = 1,
    ReadDirectoryNotifyExtendedInformation
} READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
    *PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS;
typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;
typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,
    FileStorageInfo,
    FileAlignmentInfo,
    FileIdInfo,
    FileIdExtdDirectoryInfo,
    FileIdExtdDirectoryRestartInfo,
    FileDispositionInfoEx,
    FileRenameInfoEx,
    FileCaseSensitiveInfo,
    FileNormalizedNameInfo,
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS,
    *PFILE_INFO_BY_HANDLE_CLASS;
typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;
typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;
typedef void(__stdcall* LPOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped);
typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[3];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    };
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;
typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR* ReasonStrings;
        } Detailed;
        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;
typedef DWORD(__stdcall* PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter);
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;
typedef LPVOID(__stdcall* PENCLAVE_ROUTINE)(
    LPVOID lpThreadParameter);
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;
typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;
typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;
typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;
typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;
typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;
typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;
typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;
typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;
typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;
typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;
typedef PCONTEXT LPCONTEXT;
}
#pragma warning(pop)
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
BOOL __stdcall IsApiSetImplemented(
    PCSTR Contract);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetEnvironmentStringsW(
        LPWCH NewEnvironment);
#pragma endregion
#pragma region PC Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall GetStdHandle(
        DWORD nStdHandle);
__declspec(dllimport)
    BOOL
    __stdcall SetStdHandle(
        DWORD nStdHandle,
        HANDLE hHandle);
__declspec(dllimport)
    BOOL
    __stdcall SetStdHandleEx(
        DWORD nStdHandle,
        HANDLE hHandle,
        PHANDLE phPrevValue);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LPSTR
    __stdcall GetCommandLineA(
        void);
__declspec(dllimport)
    LPWSTR
    __stdcall GetCommandLineW(
        void);
__declspec(dllimport)
    LPCH
    __stdcall GetEnvironmentStrings(
        void);
__declspec(dllimport)
    LPWCH
    __stdcall GetEnvironmentStringsW(
        void);
__declspec(dllimport)
    BOOL
    __stdcall FreeEnvironmentStringsA(
        LPCH penv);
__declspec(dllimport)
    BOOL
    __stdcall FreeEnvironmentStringsW(
        LPWCH penv);
__declspec(dllimport)
    DWORD
    __stdcall GetEnvironmentVariableA(
        LPCSTR lpName,
        LPSTR lpBuffer,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetEnvironmentVariableW(
        LPCWSTR lpName,
        LPWSTR lpBuffer,
        DWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall SetEnvironmentVariableA(
        LPCSTR lpName,
        LPCSTR lpValue);
__declspec(dllimport)
    BOOL
    __stdcall SetEnvironmentVariableW(
        LPCWSTR lpName,
        LPCWSTR lpValue);
__declspec(dllimport)
    DWORD
    __stdcall ExpandEnvironmentStringsA(
        LPCSTR lpSrc,
        LPSTR lpDst,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall ExpandEnvironmentStringsW(
        LPCWSTR lpSrc,
        LPWSTR lpDst,
        DWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall SetCurrentDirectoryA(
        LPCSTR lpPathName);
__declspec(dllimport)
    BOOL
    __stdcall SetCurrentDirectoryW(
        LPCWSTR lpPathName);
__declspec(dllimport)
    DWORD
    __stdcall GetCurrentDirectoryA(
        DWORD nBufferLength,
        LPSTR lpBuffer);
__declspec(dllimport)
    DWORD
    __stdcall GetCurrentDirectoryW(
        DWORD nBufferLength,
        LPWSTR lpBuffer);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall SearchPathW(
        LPCWSTR lpPath,
        LPCWSTR lpFileName,
        LPCWSTR lpExtension,
        DWORD nBufferLength,
        LPWSTR lpBuffer,
        LPWSTR* lpFilePart);
__declspec(dllimport)
    DWORD
    __stdcall SearchPathA(
        LPCSTR lpPath,
        LPCSTR lpFileName,
        LPCSTR lpExtension,
        DWORD nBufferLength,
        LPSTR lpBuffer,
        LPSTR* lpFilePart);
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall NeedCurrentDirectoryForExePathA(
        LPCSTR ExeName);
__declspec(dllimport)
    BOOL
    __stdcall NeedCurrentDirectoryForExePathW(
        LPCWSTR ExeName);
#pragma endregion
}
#pragma once
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LONG
    __stdcall CompareFileTime(
        const FILETIME* lpFileTime1,
        const FILETIME* lpFileTime2);
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryA(
        LPCSTR lpPathName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryW(
        LPCWSTR lpPathName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileA(
        LPCSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile);
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileW(
        LPCWSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DefineDosDeviceW(
        DWORD dwFlags,
        LPCWSTR lpDeviceName,
        LPCWSTR lpTargetPath);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall DeleteFileA(
        LPCSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall DeleteFileW(
        LPCWSTR lpFileName);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DeleteVolumeMountPointW(
        LPCWSTR lpszVolumeMountPoint);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall FileTimeToLocalFileTime(
        const FILETIME* lpFileTime,
        LPFILETIME lpLocalFileTime);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall FindClose(
        HANDLE hFindFile);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall FindCloseChangeNotification(
        HANDLE hChangeHandle);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstChangeNotificationA(
        LPCSTR lpPathName,
        BOOL bWatchSubtree,
        DWORD dwNotifyFilter);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstChangeNotificationW(
        LPCWSTR lpPathName,
        BOOL bWatchSubtree,
        DWORD dwNotifyFilter);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileA(
        LPCSTR lpFileName,
        LPWIN32_FIND_DATAA lpFindFileData);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileW(
        LPCWSTR lpFileName,
        LPWIN32_FIND_DATAW lpFindFileData);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileExA(
        LPCSTR lpFileName,
        FINDEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFindFileData,
        FINDEX_SEARCH_OPS fSearchOp,
        LPVOID lpSearchFilter,
        DWORD dwAdditionalFlags);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileExW(
        LPCWSTR lpFileName,
        FINDEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFindFileData,
        FINDEX_SEARCH_OPS fSearchOp,
        LPVOID lpSearchFilter,
        DWORD dwAdditionalFlags);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstVolumeW(
        LPWSTR lpszVolumeName,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall FindNextChangeNotification(
        HANDLE hChangeHandle);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall FindNextFileA(
        HANDLE hFindFile,
        LPWIN32_FIND_DATAA lpFindFileData);
__declspec(dllimport)
    BOOL
    __stdcall FindNextFileW(
        HANDLE hFindFile,
        LPWIN32_FIND_DATAW lpFindFileData);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall FindNextVolumeW(
        HANDLE hFindVolume,
        LPWSTR lpszVolumeName,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall FindVolumeClose(
        HANDLE hFindVolume);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall FlushFileBuffers(
        HANDLE hFile);
__declspec(dllimport)
    BOOL
    __stdcall GetDiskFreeSpaceA(
        LPCSTR lpRootPathName,
        LPDWORD lpSectorsPerCluster,
        LPDWORD lpBytesPerSector,
        LPDWORD lpNumberOfFreeClusters,
        LPDWORD lpTotalNumberOfClusters);
__declspec(dllimport)
    BOOL
    __stdcall GetDiskFreeSpaceW(
        LPCWSTR lpRootPathName,
        LPDWORD lpSectorsPerCluster,
        LPDWORD lpBytesPerSector,
        LPDWORD lpNumberOfFreeClusters,
        LPDWORD lpTotalNumberOfClusters);
__declspec(dllimport)
    BOOL
    __stdcall GetDiskFreeSpaceExA(
        LPCSTR lpDirectoryName,
        PULARGE_INTEGER lpFreeBytesAvailableToCaller,
        PULARGE_INTEGER lpTotalNumberOfBytes,
        PULARGE_INTEGER lpTotalNumberOfFreeBytes);
__declspec(dllimport)
    BOOL
    __stdcall GetDiskFreeSpaceExW(
        LPCWSTR lpDirectoryName,
        PULARGE_INTEGER lpFreeBytesAvailableToCaller,
        PULARGE_INTEGER lpTotalNumberOfBytes,
        PULARGE_INTEGER lpTotalNumberOfFreeBytes);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct DISK_SPACE_INFORMATION {
    ULONGLONG ActualTotalAllocationUnits;
    ULONGLONG ActualAvailableAllocationUnits;
    ULONGLONG ActualPoolUnavailableAllocationUnits;
    ULONGLONG CallerTotalAllocationUnits;
    ULONGLONG CallerAvailableAllocationUnits;
    ULONGLONG CallerPoolUnavailableAllocationUnits;
    ULONGLONG UsedAllocationUnits;
    ULONGLONG TotalReservedAllocationUnits;
    ULONGLONG VolumeStorageReserveAllocationUnits;
    ULONGLONG AvailableCommittedAllocationUnits;
    ULONGLONG PoolAvailableAllocationUnits;
    DWORD SectorsPerAllocationUnit;
    DWORD BytesPerSector;
} DISK_SPACE_INFORMATION;
__declspec(dllimport)
    HRESULT
    __stdcall GetDiskSpaceInformationA(
        LPCSTR rootPath,
        DISK_SPACE_INFORMATION* diskSpaceInfo);
__declspec(dllimport)
    HRESULT
    __stdcall GetDiskSpaceInformationW(
        LPCWSTR rootPath,
        DISK_SPACE_INFORMATION* diskSpaceInfo);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    UINT
    __stdcall GetDriveTypeA(
        LPCSTR lpRootPathName);
__declspec(dllimport)
    UINT
    __stdcall GetDriveTypeW(
        LPCWSTR lpRootPathName);
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;
__declspec(dllimport)
    DWORD
    __stdcall GetFileAttributesA(
        LPCSTR lpFileName);
__declspec(dllimport)
    DWORD
    __stdcall GetFileAttributesW(
        LPCWSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall GetFileAttributesExA(
        LPCSTR lpFileName,
        GET_FILEEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFileInformation);
__declspec(dllimport)
    BOOL
    __stdcall GetFileAttributesExW(
        LPCWSTR lpFileName,
        GET_FILEEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFileInformation);
typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;
__declspec(dllimport)
    BOOL
    __stdcall GetFileInformationByHandle(
        HANDLE hFile,
        LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetFileSize(
        HANDLE hFile,
        LPDWORD lpFileSizeHigh);
#pragma endregion
#pragma region Application Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetFileSizeEx(
        HANDLE hFile,
        PLARGE_INTEGER lpFileSize);
__declspec(dllimport)
    DWORD
    __stdcall GetFileType(
        HANDLE hFile);
__declspec(dllimport)
    DWORD
    __stdcall GetFinalPathNameByHandleA(
        HANDLE hFile,
        LPSTR lpszFilePath,
        DWORD cchFilePath,
        DWORD dwFlags);
__declspec(dllimport)
    DWORD
    __stdcall GetFinalPathNameByHandleW(
        HANDLE hFile,
        LPWSTR lpszFilePath,
        DWORD cchFilePath,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall GetFileTime(
        HANDLE hFile,
        LPFILETIME lpCreationTime,
        LPFILETIME lpLastAccessTime,
        LPFILETIME lpLastWriteTime);
__declspec(dllimport)
    DWORD
    __stdcall GetFullPathNameW(
        LPCWSTR lpFileName,
        DWORD nBufferLength,
        LPWSTR lpBuffer,
        LPWSTR* lpFilePart);
__declspec(dllimport)
    DWORD
    __stdcall GetFullPathNameA(
        LPCSTR lpFileName,
        DWORD nBufferLength,
        LPSTR lpBuffer,
        LPSTR* lpFilePart);
__declspec(dllimport)
    DWORD
    __stdcall GetLogicalDrives(
        void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall GetLogicalDriveStringsW(
        DWORD nBufferLength,
        LPWSTR lpBuffer);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall GetLongPathNameA(
        LPCSTR lpszShortPath,
        LPSTR lpszLongPath,
        DWORD cchBuffer);
__declspec(dllimport)
    DWORD
    __stdcall GetLongPathNameW(
        LPCWSTR lpszShortPath,
        LPWSTR lpszLongPath,
        DWORD cchBuffer);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AreShortNamesEnabled(
        HANDLE Handle,
        BOOL* Enabled);
__declspec(dllimport)
    DWORD
    __stdcall GetShortPathNameW(
        LPCWSTR lpszLongPath,
        LPWSTR lpszShortPath,
        DWORD cchBuffer);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetTempFileNameW(
        LPCWSTR lpPathName,
        LPCWSTR lpPrefixString,
        UINT uUnique,
        LPWSTR lpTempFileName);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumeInformationByHandleW(
        HANDLE hFile,
        LPWSTR lpVolumeNameBuffer,
        DWORD nVolumeNameSize,
        LPDWORD lpVolumeSerialNumber,
        LPDWORD lpMaximumComponentLength,
        LPDWORD lpFileSystemFlags,
        LPWSTR lpFileSystemNameBuffer,
        DWORD nFileSystemNameSize);
__declspec(dllimport)
    BOOL
    __stdcall GetVolumeInformationW(
        LPCWSTR lpRootPathName,
        LPWSTR lpVolumeNameBuffer,
        DWORD nVolumeNameSize,
        LPDWORD lpVolumeSerialNumber,
        LPDWORD lpMaximumComponentLength,
        LPDWORD lpFileSystemFlags,
        LPWSTR lpFileSystemNameBuffer,
        DWORD nFileSystemNameSize);
__declspec(dllimport)
    BOOL
    __stdcall GetVolumePathNameW(
        LPCWSTR lpszFileName,
        LPWSTR lpszVolumePathName,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall LocalFileTimeToFileTime(
        const FILETIME* lpLocalFileTime,
        LPFILETIME lpFileTime);
__declspec(dllimport)
    BOOL
    __stdcall LockFile(
        HANDLE hFile,
        DWORD dwFileOffsetLow,
        DWORD dwFileOffsetHigh,
        DWORD nNumberOfBytesToLockLow,
        DWORD nNumberOfBytesToLockHigh);
__declspec(dllimport)
    BOOL
    __stdcall LockFileEx(
        HANDLE hFile,
        DWORD dwFlags,
        DWORD dwReserved,
        DWORD nNumberOfBytesToLockLow,
        DWORD nNumberOfBytesToLockHigh,
        LPOVERLAPPED lpOverlapped);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall QueryDosDeviceW(
        LPCWSTR lpDeviceName,
        LPWSTR lpTargetPath,
        DWORD ucchMax);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall ReadFile(
        HANDLE hFile,
        LPVOID lpBuffer,
        DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    BOOL
    __stdcall ReadFileEx(
        HANDLE hFile,
        LPVOID lpBuffer,
        DWORD nNumberOfBytesToRead,
        LPOVERLAPPED lpOverlapped,
        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
__declspec(dllimport)
    BOOL
    __stdcall ReadFileScatter(
        HANDLE hFile,
        FILE_SEGMENT_ELEMENT aSegmentArray[],
        DWORD nNumberOfBytesToRead,
        LPDWORD lpReserved,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    BOOL
    __stdcall RemoveDirectoryA(
        LPCSTR lpPathName);
__declspec(dllimport)
    BOOL
    __stdcall RemoveDirectoryW(
        LPCWSTR lpPathName);
__declspec(dllimport)
    BOOL
    __stdcall SetEndOfFile(
        HANDLE hFile);
__declspec(dllimport)
    BOOL
    __stdcall SetFileAttributesA(
        LPCSTR lpFileName,
        DWORD dwFileAttributes);
__declspec(dllimport)
    BOOL
    __stdcall SetFileAttributesW(
        LPCWSTR lpFileName,
        DWORD dwFileAttributes);
__declspec(dllimport)
    BOOL
    __stdcall SetFileInformationByHandle(
        HANDLE hFile,
        FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
        LPVOID lpFileInformation,
        DWORD dwBufferSize);
__declspec(dllimport)
    DWORD
    __stdcall SetFilePointer(
        HANDLE hFile,
        LONG lDistanceToMove,
        PLONG lpDistanceToMoveHigh,
        DWORD dwMoveMethod);
__declspec(dllimport)
    BOOL
    __stdcall SetFilePointerEx(
        HANDLE hFile,
        LARGE_INTEGER liDistanceToMove,
        PLARGE_INTEGER lpNewFilePointer,
        DWORD dwMoveMethod);
__declspec(dllimport)
    BOOL
    __stdcall SetFileTime(
        HANDLE hFile,
        const FILETIME* lpCreationTime,
        const FILETIME* lpLastAccessTime,
        const FILETIME* lpLastWriteTime);
__declspec(dllimport)
    BOOL
    __stdcall SetFileValidData(
        HANDLE hFile,
        LONGLONG ValidDataLength);
__declspec(dllimport)
    BOOL
    __stdcall UnlockFile(
        HANDLE hFile,
        DWORD dwFileOffsetLow,
        DWORD dwFileOffsetHigh,
        DWORD nNumberOfBytesToUnlockLow,
        DWORD nNumberOfBytesToUnlockHigh);
__declspec(dllimport)
    BOOL
    __stdcall UnlockFileEx(
        HANDLE hFile,
        DWORD dwReserved,
        DWORD nNumberOfBytesToUnlockLow,
        DWORD nNumberOfBytesToUnlockHigh,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    BOOL
    __stdcall WriteFile(
        HANDLE hFile,
        LPCVOID lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPDWORD lpNumberOfBytesWritten,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    BOOL
    __stdcall WriteFileEx(
        HANDLE hFile,
        LPCVOID lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPOVERLAPPED lpOverlapped,
        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
__declspec(dllimport)
    BOOL
    __stdcall WriteFileGather(
        HANDLE hFile,
        FILE_SEGMENT_ELEMENT aSegmentArray[],
        DWORD nNumberOfBytesToWrite,
        LPDWORD lpReserved,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    DWORD
    __stdcall GetTempPathW(
        DWORD nBufferLength,
        LPWSTR lpBuffer);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumeNameForVolumeMountPointW(
        LPCWSTR lpszVolumeMountPoint,
        LPWSTR lpszVolumeName,
        DWORD cchBufferLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumePathNamesForVolumeNameW(
        LPCWSTR lpszVolumeName,
        LPWCH lpszVolumePathNames,
        DWORD cchBufferLength,
        PDWORD lpcchReturnLength);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
    DWORD dwSize;
    DWORD dwFileAttributes;
    DWORD dwFileFlags;
    DWORD dwSecurityQosFlags;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;
    HANDLE hTemplateFile;
} CREATEFILE2_EXTENDED_PARAMETERS, *PCREATEFILE2_EXTENDED_PARAMETERS, *LPCREATEFILE2_EXTENDED_PARAMETERS;
__declspec(dllimport)
    HANDLE
    __stdcall CreateFile2(
        LPCWSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetFileIoOverlappedRange(
        HANDLE FileHandle,
        PUCHAR OverlappedRangeStart,
        ULONG Length);
__declspec(dllimport)
    DWORD
    __stdcall GetCompressedFileSizeA(
        LPCSTR lpFileName,
        LPDWORD lpFileSizeHigh);
__declspec(dllimport)
    DWORD
    __stdcall GetCompressedFileSizeW(
        LPCWSTR lpFileName,
        LPDWORD lpFileSizeHigh);
typedef enum _STREAM_INFO_LEVELS {
    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel
} STREAM_INFO_LEVELS;
typedef struct _WIN32_FIND_STREAM_DATA {
    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[260 + 36];
} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstStreamW(
        LPCWSTR lpFileName,
        STREAM_INFO_LEVELS InfoLevel,
        LPVOID lpFindStreamData,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall FindNextStreamW(
        HANDLE hFindStream,
        LPVOID lpFindStreamData);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall AreFileApisANSI(
        void);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetTempPathA(
        DWORD nBufferLength,
        LPSTR lpBuffer);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileNameW(
        LPCWSTR lpFileName,
        DWORD dwFlags,
        LPDWORD StringLength,
        PWSTR LinkName);
__declspec(dllimport)
    BOOL
    __stdcall FindNextFileNameW(
        HANDLE hFindStream,
        LPDWORD StringLength,
        PWSTR LinkName);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumeInformationA(
        LPCSTR lpRootPathName,
        LPSTR lpVolumeNameBuffer,
        DWORD nVolumeNameSize,
        LPDWORD lpVolumeSerialNumber,
        LPDWORD lpMaximumComponentLength,
        LPDWORD lpFileSystemFlags,
        LPSTR lpFileSystemNameBuffer,
        DWORD nFileSystemNameSize);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetTempFileNameA(
        LPCSTR lpPathName,
        LPCSTR lpPrefixString,
        UINT uUnique,
        LPSTR lpTempFileName);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) void __stdcall SetFileApisToOEM(
    void);
__declspec(dllimport) void __stdcall SetFileApisToANSI(
    void);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetTempPath2W(
        DWORD BufferLength,
        LPWSTR Buffer);
__declspec(dllimport)
    DWORD
    __stdcall GetTempPath2A(
        DWORD BufferLength,
        LPSTR Buffer);
#pragma endregion
}
extern "C" {
#pragma region Application Family
__declspec(dllimport)
    BOOL
    __stdcall CopyFileFromAppW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        BOOL bFailIfExists) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryFromAppW(
        LPCWSTR lpPathName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes) noexcept;
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileFromAppW(
        LPCWSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile) noexcept;
__declspec(dllimport)
    HANDLE
    __stdcall CreateFile2FromAppW(
        LPCWSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall DeleteFileFromAppW(
        LPCWSTR lpFileName) noexcept;
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileExFromAppW(
        LPCWSTR lpFileName,
        FINDEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFindFileData,
        FINDEX_SEARCH_OPS fSearchOp,
        LPVOID lpSearchFilter,
        DWORD dwAdditionalFlags) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall GetFileAttributesExFromAppW(
        LPCWSTR lpFileName,
        GET_FILEEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFileInformation) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall MoveFileFromAppW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall RemoveDirectoryFromAppW(
        LPCWSTR lpPathName) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall ReplaceFileFromAppW(
        LPCWSTR lpReplacedFileName,
        LPCWSTR lpReplacementFileName,
        LPCWSTR lpBackupFileName,
        DWORD dwReplaceFlags,
        LPVOID lpExclude,
        LPVOID lpReserved) noexcept;
__declspec(dllimport)
    BOOL
    __stdcall SetFileAttributesFromAppW(
        LPCWSTR lpFileName,
        DWORD dwFileAttributes) noexcept;
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall IsDebuggerPresent(
        void);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall DebugBreak(
    void);
__declspec(dllimport) void __stdcall OutputDebugStringA(
    LPCSTR lpOutputString);
__declspec(dllimport) void __stdcall OutputDebugStringW(
    LPCWSTR lpOutputString);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall ContinueDebugEvent(
        DWORD dwProcessId,
        DWORD dwThreadId,
        DWORD dwContinueStatus);
__declspec(dllimport)
    BOOL
    __stdcall WaitForDebugEvent(
        LPDEBUG_EVENT lpDebugEvent,
        DWORD dwMilliseconds);
__declspec(dllimport)
    BOOL
    __stdcall DebugActiveProcess(
        DWORD dwProcessId);
__declspec(dllimport)
    BOOL
    __stdcall DebugActiveProcessStop(
        DWORD dwProcessId);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CheckRemoteDebuggerPresent(
        HANDLE hProcess,
        PBOOL pbDebuggerPresent);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall WaitForDebugEventEx(
        LPDEBUG_EVENT lpDebugEvent,
        DWORD dwMilliseconds);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    PVOID
    __stdcall EncodePointer(
        PVOID Ptr);
__declspec(dllimport)
    PVOID
    __stdcall DecodePointer(
        PVOID Ptr);
__declspec(dllimport)
    PVOID
    __stdcall EncodeSystemPointer(
        PVOID Ptr);
__declspec(dllimport)
    PVOID
    __stdcall DecodeSystemPointer(
        PVOID Ptr);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HRESULT
    __stdcall EncodeRemotePointer(
        HANDLE ProcessHandle,
        PVOID Ptr,
        PVOID* EncodedPtr);
__declspec(dllimport)
    HRESULT
    __stdcall DecodeRemotePointer(
        HANDLE ProcessHandle,
        PVOID Ptr,
        PVOID* DecodedPtr);
#pragma endregion
#pragma region PC Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall Beep(
        DWORD dwFreq,
        DWORD dwDuration);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall CloseHandle(
        HANDLE hObject);
__declspec(dllimport)
    BOOL
    __stdcall DuplicateHandle(
        HANDLE hSourceProcessHandle,
        HANDLE hSourceHandle,
        HANDLE hTargetProcessHandle,
        LPHANDLE lpTargetHandle,
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        DWORD dwOptions);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CompareObjectHandles(
        HANDLE hFirstObjectHandle,
        HANDLE hSecondObjectHandle);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetHandleInformation(
        HANDLE hObject,
        LPDWORD lpdwFlags);
__declspec(dllimport)
    BOOL
    __stdcall SetHandleInformation(
        HANDLE hObject,
        DWORD dwMask,
        DWORD dwFlags);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
typedef LONG(__stdcall* PTOP_LEVEL_EXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS* ExceptionInfo);
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
__declspec(dllimport) void __stdcall RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    const ULONG_PTR* lpArguments);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    LONG
    __stdcall UnhandledExceptionFilter(
        struct _EXCEPTION_POINTERS* ExceptionInfo);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LPTOP_LEVEL_EXCEPTION_FILTER
    __stdcall SetUnhandledExceptionFilter(
        LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
__declspec(dllimport)
    DWORD
    __stdcall GetLastError(
        void);
__declspec(dllimport) void __stdcall SetLastError(
    DWORD dwErrCode);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    UINT
    __stdcall GetErrorMode(
        void);
__declspec(dllimport)
    UINT
    __stdcall SetErrorMode(
        UINT uMode);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    PVOID
    __stdcall AddVectoredExceptionHandler(
        ULONG First,
        PVECTORED_EXCEPTION_HANDLER Handler);
__declspec(dllimport)
    ULONG
    __stdcall RemoveVectoredExceptionHandler(
        PVOID Handle);
__declspec(dllimport)
    PVOID
    __stdcall AddVectoredContinueHandler(
        ULONG First,
        PVECTORED_EXCEPTION_HANDLER Handler);
__declspec(dllimport)
    ULONG
    __stdcall RemoveVectoredContinueHandler(
        PVOID Handle);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall RaiseFailFastException(
    PEXCEPTION_RECORD pExceptionRecord,
    PCONTEXT pContextRecord,
    DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText);
__declspec(dllimport) void __stdcall FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall GetThreadErrorMode(
        void);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadErrorMode(
        DWORD dwNewMode,
        LPDWORD lpOldMode);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) void __stdcall TerminateProcessOnMemoryExhaustion(
    SIZE_T FailedAllocationSize);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall FlsAlloc(
        PFLS_CALLBACK_FUNCTION lpCallback);
__declspec(dllimport)
    PVOID
    __stdcall FlsGetValue(
        DWORD dwFlsIndex);
__declspec(dllimport)
    BOOL
    __stdcall FlsSetValue(
        DWORD dwFlsIndex,
        PVOID lpFlsData);
__declspec(dllimport)
    BOOL
    __stdcall FlsFree(
        DWORD dwFlsIndex);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall IsThreadAFiber(
        void);
#pragma endregion
}
#pragma once
extern "C" {
__declspec(dllimport)
    BOOL
    __stdcall CreatePipe(
        PHANDLE hReadPipe,
        PHANDLE hWritePipe,
        LPSECURITY_ATTRIBUTES lpPipeAttributes,
        DWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall ConnectNamedPipe(
        HANDLE hNamedPipe,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    BOOL
    __stdcall DisconnectNamedPipe(
        HANDLE hNamedPipe);
__declspec(dllimport)
    BOOL
    __stdcall SetNamedPipeHandleState(
        HANDLE hNamedPipe,
        LPDWORD lpMode,
        LPDWORD lpMaxCollectionCount,
        LPDWORD lpCollectDataTimeout);
__declspec(dllimport)
    BOOL
    __stdcall PeekNamedPipe(
        HANDLE hNamedPipe,
        LPVOID lpBuffer,
        DWORD nBufferSize,
        LPDWORD lpBytesRead,
        LPDWORD lpTotalBytesAvail,
        LPDWORD lpBytesLeftThisMessage);
__declspec(dllimport)
    BOOL
    __stdcall TransactNamedPipe(
        HANDLE hNamedPipe,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesRead,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    HANDLE
    __stdcall CreateNamedPipeW(
        LPCWSTR lpName,
        DWORD dwOpenMode,
        DWORD dwPipeMode,
        DWORD nMaxInstances,
        DWORD nOutBufferSize,
        DWORD nInBufferSize,
        DWORD nDefaultTimeOut,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    BOOL
    __stdcall WaitNamedPipeW(
        LPCWSTR lpNamedPipeName,
        DWORD nTimeOut);
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeClientComputerNameW(
        HANDLE Pipe,
        LPWSTR ClientComputerName,
        ULONG ClientComputerNameLength);
__declspec(dllimport)
    BOOL
    __stdcall ImpersonateNamedPipeClient(
        HANDLE hNamedPipe);
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeInfo(
        HANDLE hNamedPipe,
        LPDWORD lpFlags,
        LPDWORD lpOutBufferSize,
        LPDWORD lpInBufferSize,
        LPDWORD lpMaxInstances);
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeHandleStateW(
        HANDLE hNamedPipe,
        LPDWORD lpState,
        LPDWORD lpCurInstances,
        LPDWORD lpMaxCollectionCount,
        LPDWORD lpCollectDataTimeout,
        LPWSTR lpUserName,
        DWORD nMaxUserNameSize);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CallNamedPipeW(
        LPCWSTR lpNamedPipeName,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesRead,
        DWORD nTimeOut);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall QueryPerformanceCounter(
        LARGE_INTEGER* lpPerformanceCount);
__declspec(dllimport)
    BOOL
    __stdcall QueryPerformanceFrequency(
        LARGE_INTEGER* lpFrequency);
#pragma endregion
}
#pragma once
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Application Family or OneCore Family or Games Family
typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;
__declspec(dllimport)
    HANDLE
    __stdcall HeapCreate(
        DWORD flOptions,
        SIZE_T dwInitialSize,
        SIZE_T dwMaximumSize);
__declspec(dllimport)
    BOOL
    __stdcall HeapDestroy(
        HANDLE hHeap);
__declspec(dllimport) __declspec(allocator)
    LPVOID
    __stdcall HeapAlloc(
        HANDLE hHeap,
        DWORD dwFlags,
        SIZE_T dwBytes);
__declspec(dllimport) __declspec(allocator)
    LPVOID
    __stdcall HeapReAlloc(
        HANDLE hHeap,
        DWORD dwFlags,
        LPVOID lpMem,
        SIZE_T dwBytes);
__declspec(dllimport)
    BOOL
    __stdcall HeapFree(
        HANDLE hHeap,
        DWORD dwFlags,
        LPVOID lpMem);
__declspec(dllimport)
    SIZE_T
    __stdcall HeapSize(
        HANDLE hHeap,
        DWORD dwFlags,
        LPCVOID lpMem);
__declspec(dllimport)
    HANDLE
    __stdcall GetProcessHeap(
        void);
__declspec(dllimport)
    SIZE_T
    __stdcall HeapCompact(
        HANDLE hHeap,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall HeapSetInformation(
        HANDLE HeapHandle,
        HEAP_INFORMATION_CLASS HeapInformationClass,
        PVOID HeapInformation,
        SIZE_T HeapInformationLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall HeapValidate(
        HANDLE hHeap,
        DWORD dwFlags,
        LPCVOID lpMem);
#pragma endregion
#pragma region Application Family
BOOL __stdcall HeapSummary(
    HANDLE hHeap,
    DWORD dwFlags,
    LPHEAP_SUMMARY lpSummary);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetProcessHeaps(
        DWORD NumberOfHeaps,
        PHANDLE ProcessHeaps);
__declspec(dllimport)
    BOOL
    __stdcall HeapLock(
        HANDLE hHeap);
__declspec(dllimport)
    BOOL
    __stdcall HeapUnlock(
        HANDLE hHeap);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall HeapWalk(
        HANDLE hHeap,
        LPPROCESS_HEAP_ENTRY lpEntry);
__declspec(dllimport)
    BOOL
    __stdcall HeapQueryInformation(
        HANDLE HeapHandle,
        HEAP_INFORMATION_CLASS HeapInformationClass,
        PVOID HeapInformation,
        SIZE_T HeapInformationLength,
        PSIZE_T ReturnLength);
#pragma endregion
#pragma warning(pop)
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateIoCompletionPort(
        HANDLE FileHandle,
        HANDLE ExistingCompletionPort,
        ULONG_PTR CompletionKey,
        DWORD NumberOfConcurrentThreads);
__declspec(dllimport)
    BOOL
    __stdcall GetQueuedCompletionStatus(
        HANDLE CompletionPort,
        LPDWORD lpNumberOfBytesTransferred,
        PULONG_PTR lpCompletionKey,
        LPOVERLAPPED* lpOverlapped,
        DWORD dwMilliseconds);
__declspec(dllimport)
    BOOL
    __stdcall GetQueuedCompletionStatusEx(
        HANDLE CompletionPort,
        LPOVERLAPPED_ENTRY lpCompletionPortEntries,
        ULONG ulCount,
        PULONG ulNumEntriesRemoved,
        DWORD dwMilliseconds,
        BOOL fAlertable);
__declspec(dllimport)
    BOOL
    __stdcall PostQueuedCompletionStatus(
        HANDLE CompletionPort,
        DWORD dwNumberOfBytesTransferred,
        ULONG_PTR dwCompletionKey,
        LPOVERLAPPED lpOverlapped);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Application Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall DeviceIoControl(
        HANDLE hDevice,
        DWORD dwIoControlCode,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesReturned,
        LPOVERLAPPED lpOverlapped);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetOverlappedResult(
        HANDLE hFile,
        LPOVERLAPPED lpOverlapped,
        LPDWORD lpNumberOfBytesTransferred,
        BOOL bWait);
__declspec(dllimport)
    BOOL
    __stdcall CancelIoEx(
        HANDLE hFile,
        LPOVERLAPPED lpOverlapped);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall CancelIo(
        HANDLE hFile);
__declspec(dllimport)
    BOOL
    __stdcall GetOverlappedResultEx(
        HANDLE hFile,
        LPOVERLAPPED lpOverlapped,
        LPDWORD lpNumberOfBytesTransferred,
        DWORD dwMilliseconds,
        BOOL bAlertable);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall CancelSynchronousIo(
        HANDLE hThread);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application or OneCore Family or Games Family
typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
__declspec(dllimport) void __stdcall InitializeSRWLock(
    PSRWLOCK SRWLock);
__declspec(dllimport) void __stdcall ReleaseSRWLockExclusive(
    PSRWLOCK SRWLock);
__declspec(dllimport) void __stdcall ReleaseSRWLockShared(
    PSRWLOCK SRWLock);
__declspec(dllimport) void __stdcall AcquireSRWLockExclusive(
    PSRWLOCK SRWLock);
__declspec(dllimport) void __stdcall AcquireSRWLockShared(
    PSRWLOCK SRWLock);
__declspec(dllimport)
    BOOLEAN
    __stdcall TryAcquireSRWLockExclusive(
        PSRWLOCK SRWLock);
__declspec(dllimport)
    BOOLEAN
    __stdcall TryAcquireSRWLockShared(
        PSRWLOCK SRWLock);
__declspec(dllimport) void __stdcall InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection);
__declspec(dllimport) void __stdcall EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection);
__declspec(dllimport) void __stdcall LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection);
__declspec(dllimport)
    BOOL
    __stdcall InitializeCriticalSectionAndSpinCount(
        LPCRITICAL_SECTION lpCriticalSection,
        DWORD dwSpinCount);
__declspec(dllimport)
    BOOL
    __stdcall InitializeCriticalSectionEx(
        LPCRITICAL_SECTION lpCriticalSection,
        DWORD dwSpinCount,
        DWORD Flags);
__declspec(dllimport)
    DWORD
    __stdcall SetCriticalSectionSpinCount(
        LPCRITICAL_SECTION lpCriticalSection,
        DWORD dwSpinCount);
__declspec(dllimport)
    BOOL
    __stdcall TryEnterCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection);
__declspec(dllimport) void __stdcall DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection);
typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;
typedef BOOL(__stdcall* PINIT_ONCE_FN)(
    PINIT_ONCE InitOnce,
    PVOID Parameter,
    PVOID* Context);
__declspec(dllimport) void __stdcall InitOnceInitialize(
    PINIT_ONCE InitOnce);
__declspec(dllimport)
    BOOL
    __stdcall InitOnceExecuteOnce(
        PINIT_ONCE InitOnce,
        PINIT_ONCE_FN InitFn,
        PVOID Parameter,
        LPVOID* Context);
__declspec(dllimport)
    BOOL
    __stdcall InitOnceBeginInitialize(
        LPINIT_ONCE lpInitOnce,
        DWORD dwFlags,
        PBOOL fPending,
        LPVOID* lpContext);
__declspec(dllimport)
    BOOL
    __stdcall InitOnceComplete(
        LPINIT_ONCE lpInitOnce,
        DWORD dwFlags,
        LPVOID lpContext);
typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;
__declspec(dllimport) void __stdcall InitializeConditionVariable(
    PCONDITION_VARIABLE ConditionVariable);
__declspec(dllimport) void __stdcall WakeConditionVariable(
    PCONDITION_VARIABLE ConditionVariable);
__declspec(dllimport) void __stdcall WakeAllConditionVariable(
    PCONDITION_VARIABLE ConditionVariable);
__declspec(dllimport)
    BOOL
    __stdcall SleepConditionVariableCS(
        PCONDITION_VARIABLE ConditionVariable,
        PCRITICAL_SECTION CriticalSection,
        DWORD dwMilliseconds);
__declspec(dllimport)
    BOOL
    __stdcall SleepConditionVariableSRW(
        PCONDITION_VARIABLE ConditionVariable,
        PSRWLOCK SRWLock,
        DWORD dwMilliseconds,
        ULONG Flags);
__declspec(dllimport)
    BOOL
    __stdcall SetEvent(
        HANDLE hEvent);
__declspec(dllimport)
    BOOL
    __stdcall ResetEvent(
        HANDLE hEvent);
__declspec(dllimport)
    BOOL
    __stdcall ReleaseSemaphore(
        HANDLE hSemaphore,
        LONG lReleaseCount,
        LPLONG lpPreviousCount);
__declspec(dllimport)
    BOOL
    __stdcall ReleaseMutex(
        HANDLE hMutex);
__declspec(dllimport)
    DWORD
    __stdcall WaitForSingleObject(
        HANDLE hHandle,
        DWORD dwMilliseconds);
__declspec(dllimport)
    DWORD
    __stdcall SleepEx(
        DWORD dwMilliseconds,
        BOOL bAlertable);
__declspec(dllimport)
    DWORD
    __stdcall WaitForSingleObjectEx(
        HANDLE hHandle,
        DWORD dwMilliseconds,
        BOOL bAlertable);
__declspec(dllimport)
    DWORD
    __stdcall WaitForMultipleObjectsEx(
        DWORD nCount,
        const HANDLE* lpHandles,
        BOOL bWaitAll,
        DWORD dwMilliseconds,
        BOOL bAlertable);
__declspec(dllimport)
    HANDLE
    __stdcall CreateMutexA(
        LPSECURITY_ATTRIBUTES lpMutexAttributes,
        BOOL bInitialOwner,
        LPCSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall CreateMutexW(
        LPSECURITY_ATTRIBUTES lpMutexAttributes,
        BOOL bInitialOwner,
        LPCWSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenMutexW(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCWSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall CreateEventA(
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        BOOL bManualReset,
        BOOL bInitialState,
        LPCSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall CreateEventW(
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        BOOL bManualReset,
        BOOL bInitialState,
        LPCWSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenEventA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenEventW(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCWSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenSemaphoreW(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCWSTR lpName);
typedef void(__stdcall* PTIMERAPCROUTINE)(
    LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue);
__declspec(dllimport)
    HANDLE
    __stdcall OpenWaitableTimerW(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCWSTR lpTimerName);
BOOL __stdcall SetWaitableTimerEx(
    HANDLE hTimer,
    const LARGE_INTEGER* lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    PREASON_CONTEXT WakeContext,
    ULONG TolerableDelay);
__declspec(dllimport)
    BOOL
    __stdcall SetWaitableTimer(
        HANDLE hTimer,
        const LARGE_INTEGER* lpDueTime,
        LONG lPeriod,
        PTIMERAPCROUTINE pfnCompletionRoutine,
        LPVOID lpArgToCompletionRoutine,
        BOOL fResume);
__declspec(dllimport)
    BOOL
    __stdcall CancelWaitableTimer(
        HANDLE hTimer);
__declspec(dllimport)
    HANDLE
    __stdcall CreateMutexExA(
        LPSECURITY_ATTRIBUTES lpMutexAttributes,
        LPCSTR lpName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    HANDLE
    __stdcall CreateMutexExW(
        LPSECURITY_ATTRIBUTES lpMutexAttributes,
        LPCWSTR lpName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    HANDLE
    __stdcall CreateEventExA(
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        LPCSTR lpName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    HANDLE
    __stdcall CreateEventExW(
        LPSECURITY_ATTRIBUTES lpEventAttributes,
        LPCWSTR lpName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    HANDLE
    __stdcall CreateSemaphoreExW(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
        LONG lInitialCount,
        LONG lMaximumCount,
        LPCWSTR lpName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    HANDLE
    __stdcall CreateWaitableTimerExW(
        LPSECURITY_ATTRIBUTES lpTimerAttributes,
        LPCWSTR lpTimerName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;
BOOL __stdcall EnterSynchronizationBarrier(
    LPSYNCHRONIZATION_BARRIER lpBarrier,
    DWORD dwFlags);
BOOL __stdcall InitializeSynchronizationBarrier(
    LPSYNCHRONIZATION_BARRIER lpBarrier,
    LONG lTotalThreads,
    LONG lSpinCount);
BOOL __stdcall DeleteSynchronizationBarrier(
    LPSYNCHRONIZATION_BARRIER lpBarrier);
__declspec(dllimport) void __stdcall Sleep(
    DWORD dwMilliseconds);
BOOL __stdcall WaitOnAddress(
    volatile void* Address,
    PVOID CompareAddress,
    SIZE_T AddressSize,
    DWORD dwMilliseconds);
void __stdcall WakeByAddressSingle(
    PVOID Address);
void __stdcall WakeByAddressAll(
    PVOID Address);
#pragma endregion
#pragma region Desktop or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall SignalObjectAndWait(
        HANDLE hObjectToSignal,
        HANDLE hObjectToWaitOn,
        DWORD dwMilliseconds,
        BOOL bAlertable);
#pragma endregion
#pragma region Application or OneCore Family or Games Partition
__declspec(dllimport)
    DWORD
    __stdcall WaitForMultipleObjects(
        DWORD nCount,
        const HANDLE* lpHandles,
        BOOL bWaitAll,
        DWORD dwMilliseconds);
__declspec(dllimport)
    HANDLE
    __stdcall CreateSemaphoreW(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
        LONG lInitialCount,
        LONG lMaximumCount,
        LPCWSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall CreateWaitableTimerW(
        LPSECURITY_ATTRIBUTES lpTimerAttributes,
        BOOL bManualReset,
        LPCWSTR lpTimerName);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall InitializeSListHead(
    PSLIST_HEADER ListHead);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall InterlockedPopEntrySList(
        PSLIST_HEADER ListHead);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall InterlockedPushEntrySList(
        PSLIST_HEADER ListHead,
        PSLIST_ENTRY ListEntry);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall InterlockedPushListSListEx(
        PSLIST_HEADER ListHead,
        PSLIST_ENTRY List,
        PSLIST_ENTRY ListEnd,
        ULONG Count);
__declspec(dllimport)
    PSLIST_ENTRY
    __stdcall InterlockedFlushSList(
        PSLIST_HEADER ListHead);
__declspec(dllimport)
    USHORT
    __stdcall QueryDepthSList(
        PSLIST_HEADER ListHead);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
typedef struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall QueueUserAPC(
        PAPCFUNC pfnAPC,
        HANDLE hThread,
        ULONG_PTR dwData);
typedef enum _QUEUE_USER_APC_FLAGS {
    QUEUE_USER_APC_FLAGS_NONE = 0x0,
    QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = 0x1,
} QUEUE_USER_APC_FLAGS;
__declspec(dllimport)
    BOOL
    __stdcall QueueUserAPC2(
        PAPCFUNC ApcRoutine,
        HANDLE Thread,
        ULONG_PTR Data,
        QUEUE_USER_APC_FLAGS Flags);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessTimes(
        HANDLE hProcess,
        LPFILETIME lpCreationTime,
        LPFILETIME lpExitTime,
        LPFILETIME lpKernelTime,
        LPFILETIME lpUserTime);
__declspec(dllimport)
    HANDLE
    __stdcall GetCurrentProcess(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetCurrentProcessId(
        void);
__declspec(dllimport) __declspec(noreturn) void __stdcall ExitProcess(
    UINT uExitCode);
__declspec(dllimport)
    BOOL
    __stdcall TerminateProcess(
        HANDLE hProcess,
        UINT uExitCode);
__declspec(dllimport)
    BOOL
    __stdcall GetExitCodeProcess(
        HANDLE hProcess,
        LPDWORD lpExitCode);
__declspec(dllimport)
    BOOL
    __stdcall SwitchToThread(
        void);
__declspec(dllimport)
    HANDLE
    __stdcall CreateThread(
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        SIZE_T dwStackSize,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        DWORD dwCreationFlags,
        LPDWORD lpThreadId);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateRemoteThread(
        HANDLE hProcess,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        SIZE_T dwStackSize,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        DWORD dwCreationFlags,
        LPDWORD lpThreadId);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall GetCurrentThread(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetCurrentThreadId(
        void);
__declspec(dllimport)
    HANDLE
    __stdcall OpenThread(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        DWORD dwThreadId);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadPriority(
        HANDLE hThread,
        int nPriority);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadPriorityBoost(
        HANDLE hThread,
        BOOL bDisablePriorityBoost);
__declspec(dllimport)
    BOOL
    __stdcall GetThreadPriorityBoost(
        HANDLE hThread,
        PBOOL pDisablePriorityBoost);
__declspec(dllimport) int __stdcall GetThreadPriority(
    HANDLE hThread);
__declspec(dllimport) __declspec(noreturn) void __stdcall ExitThread(
    DWORD dwExitCode);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall TerminateThread(
        HANDLE hThread,
        DWORD dwExitCode);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetExitCodeThread(
        HANDLE hThread,
        LPDWORD lpExitCode);
__declspec(dllimport)
    DWORD
    __stdcall SuspendThread(
        HANDLE hThread);
__declspec(dllimport)
    DWORD
    __stdcall ResumeThread(
        HANDLE hThread);
__declspec(dllimport)
    DWORD
    __stdcall TlsAlloc(
        void);
__declspec(dllimport)
    LPVOID
    __stdcall TlsGetValue(
        DWORD dwTlsIndex);
__declspec(dllimport)
    BOOL
    __stdcall TlsSetValue(
        DWORD dwTlsIndex,
        LPVOID lpTlsValue);
__declspec(dllimport)
    BOOL
    __stdcall TlsFree(
        DWORD dwTlsIndex);
__declspec(dllimport)
    BOOL
    __stdcall CreateProcessA(
        LPCSTR lpApplicationName,
        LPSTR lpCommandLine,
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        BOOL bInheritHandles,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCSTR lpCurrentDirectory,
        LPSTARTUPINFOA lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation);
__declspec(dllimport)
    BOOL
    __stdcall CreateProcessW(
        LPCWSTR lpApplicationName,
        LPWSTR lpCommandLine,
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        BOOL bInheritHandles,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
        LPSTARTUPINFOW lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetProcessShutdownParameters(
        DWORD dwLevel,
        DWORD dwFlags);
__declspec(dllimport)
    DWORD
    __stdcall GetProcessVersion(
        DWORD ProcessId);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CreateProcessAsUserW(
        HANDLE hToken,
        LPCWSTR lpApplicationName,
        LPWSTR lpCommandLine,
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        BOOL bInheritHandles,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
        LPSTARTUPINFOW lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation);
#pragma endregion
#pragma region Application Family or OneCore Family
__forceinline HANDLE
GetCurrentProcessToken(
    void)
{
    return (HANDLE)(LONG_PTR)-4;
}
__forceinline HANDLE
GetCurrentThreadToken(
    void)
{
    return (HANDLE)(LONG_PTR)-5;
}
__forceinline HANDLE
GetCurrentThreadEffectiveToken(
    void)
{
    return (HANDLE)(LONG_PTR)-6;
}
__declspec(dllimport)
    BOOL
    __stdcall SetThreadToken(
        PHANDLE Thread,
        HANDLE Token);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall OpenProcessToken(
        HANDLE ProcessHandle,
        DWORD DesiredAccess,
        PHANDLE TokenHandle);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall OpenThreadToken(
        HANDLE ThreadHandle,
        DWORD DesiredAccess,
        BOOL OpenAsSelf,
        PHANDLE TokenHandle);
__declspec(dllimport)
    BOOL
    __stdcall SetPriorityClass(
        HANDLE hProcess,
        DWORD dwPriorityClass);
__declspec(dllimport)
    DWORD
    __stdcall GetPriorityClass(
        HANDLE hProcess);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetThreadStackGuarantee(
        PULONG StackSizeInBytes);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall ProcessIdToSessionId(
        DWORD dwProcessId,
        DWORD* pSessionId);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetProcessId(
        HANDLE Process);
__declspec(dllimport)
    DWORD
    __stdcall GetThreadId(
        HANDLE Thread);
__declspec(dllimport) void __stdcall FlushProcessWriteBuffers(
    void);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetProcessIdOfThread(
        HANDLE Thread);
__declspec(dllimport)
    BOOL
    __stdcall InitializeProcThreadAttributeList(
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
        DWORD dwAttributeCount,
        DWORD dwFlags,
        PSIZE_T lpSize);
__declspec(dllimport) void __stdcall DeleteProcThreadAttributeList(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);
__declspec(dllimport)
    BOOL
    __stdcall UpdateProcThreadAttribute(
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
        DWORD dwFlags,
        DWORD_PTR Attribute,
        PVOID lpValue,
        SIZE_T cbSize,
        PVOID lpPreviousValue,
        PSIZE_T lpReturnSize);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessDynamicEHContinuationTargets(
        HANDLE Process,
        USHORT NumberOfTargets,
        PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessDynamicEnforcedCetCompatibleRanges(
        HANDLE Process,
        USHORT NumberOfRanges,
        PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetProcessAffinityUpdateMode(
        HANDLE hProcess,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall QueryProcessAffinityUpdateMode(
        HANDLE hProcess,
        LPDWORD lpdwFlags);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateRemoteThreadEx(
        HANDLE hProcess,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        SIZE_T dwStackSize,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        DWORD dwCreationFlags,
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
        LPDWORD lpThreadId);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall GetCurrentThreadStackLimits(
    PULONG_PTR LowLimit,
    PULONG_PTR HighLimit);
__declspec(dllimport)
    BOOL
    __stdcall GetThreadContext(
        HANDLE hThread,
        LPCONTEXT lpContext);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetProcessMitigationPolicy(
        HANDLE hProcess,
        PROCESS_MITIGATION_POLICY MitigationPolicy,
        PVOID lpBuffer,
        SIZE_T dwLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetThreadContext(
        HANDLE hThread,
        const CONTEXT* lpContext);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetProcessMitigationPolicy(
        PROCESS_MITIGATION_POLICY MitigationPolicy,
        PVOID lpBuffer,
        SIZE_T dwLength);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall FlushInstructionCache(
        HANDLE hProcess,
        LPCVOID lpBaseAddress,
        SIZE_T dwSize);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetThreadTimes(
        HANDLE hThread,
        LPFILETIME lpCreationTime,
        LPFILETIME lpExitTime,
        LPFILETIME lpKernelTime,
        LPFILETIME lpUserTime);
__declspec(dllimport)
    HANDLE
    __stdcall OpenProcess(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        DWORD dwProcessId);
__declspec(dllimport)
    BOOL
    __stdcall IsProcessorFeaturePresent(
        DWORD ProcessorFeature);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetProcessHandleCount(
        HANDLE hProcess,
        PDWORD pdwHandleCount);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetCurrentProcessorNumber(
        void);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetThreadIdealProcessorEx(
        HANDLE hThread,
        PPROCESSOR_NUMBER lpIdealProcessor,
        PPROCESSOR_NUMBER lpPreviousIdealProcessor);
__declspec(dllimport)
    BOOL
    __stdcall GetThreadIdealProcessorEx(
        HANDLE hThread,
        PPROCESSOR_NUMBER lpIdealProcessor);
__declspec(dllimport) void __stdcall GetCurrentProcessorNumberEx(
    PPROCESSOR_NUMBER ProcNumber);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetProcessPriorityBoost(
        HANDLE hProcess,
        PBOOL pDisablePriorityBoost);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessPriorityBoost(
        HANDLE hProcess,
        BOOL bDisablePriorityBoost);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetThreadIOPendingFlag(
        HANDLE hThread,
        PBOOL lpIOIsPending);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetSystemTimes(
        PFILETIME lpIdleTime,
        PFILETIME lpKernelTime,
        PFILETIME lpUserTime);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax
} THREAD_INFORMATION_CLASS;
typedef struct _MEMORY_PRIORITY_INFORMATION {
    ULONG MemoryPriority;
} MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;
__declspec(dllimport)
    BOOL
    __stdcall GetThreadInformation(
        HANDLE hThread,
        THREAD_INFORMATION_CLASS ThreadInformationClass,
        LPVOID ThreadInformation,
        DWORD ThreadInformationSize);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadInformation(
        HANDLE hThread,
        THREAD_INFORMATION_CLASS ThreadInformationClass,
        LPVOID ThreadInformation,
        DWORD ThreadInformationSize);
typedef struct _THREAD_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} THREAD_POWER_THROTTLING_STATE;
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsProcessCritical(
        HANDLE hProcess,
        PBOOL Critical);
__declspec(dllimport)
    BOOL
    __stdcall SetProtectedPolicy(
        LPCGUID PolicyGuid,
        ULONG_PTR PolicyValue,
        PULONG_PTR OldPolicyValue);
__declspec(dllimport)
    BOOL
    __stdcall QueryProtectedPolicy(
        LPCGUID PolicyGuid,
        PULONG_PTR PolicyValue);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall SetThreadIdealProcessor(
        HANDLE hThread,
        DWORD dwIdealProcessor);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessLeapSecondInfo,
    ProcessMachineTypeInfo,
    ProcessInformationClassMax
} PROCESS_INFORMATION_CLASS;
typedef struct _APP_MEMORY_INFORMATION {
    ULONG64 AvailableCommit;
    ULONG64 PrivateCommitUsage;
    ULONG64 PeakPrivateCommitUsage;
    ULONG64 TotalCommitUsage;
} APP_MEMORY_INFORMATION, *PAPP_MEMORY_INFORMATION;
typedef enum _MACHINE_ATTRIBUTES {
    UserEnabled = 0x00000001,
    KernelEnabled = 0x00000002,
    Wow64Container = 0x00000004
} MACHINE_ATTRIBUTES;
extern "C++" {
inline constexpr MACHINE_ATTRIBUTES operator|(MACHINE_ATTRIBUTES a, MACHINE_ATTRIBUTES b) noexcept { return MACHINE_ATTRIBUTES(((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)b)); }
inline MACHINE_ATTRIBUTES& operator|=(MACHINE_ATTRIBUTES& a, MACHINE_ATTRIBUTES b) noexcept { return (MACHINE_ATTRIBUTES&)(((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)b)); }
inline constexpr MACHINE_ATTRIBUTES operator&(MACHINE_ATTRIBUTES a, MACHINE_ATTRIBUTES b) noexcept { return MACHINE_ATTRIBUTES(((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)b)); }
inline MACHINE_ATTRIBUTES& operator&=(MACHINE_ATTRIBUTES& a, MACHINE_ATTRIBUTES b) noexcept { return (MACHINE_ATTRIBUTES&)(((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)b)); }
inline constexpr MACHINE_ATTRIBUTES operator~(MACHINE_ATTRIBUTES a) noexcept { return MACHINE_ATTRIBUTES(~((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)a)); }
inline constexpr MACHINE_ATTRIBUTES operator^(MACHINE_ATTRIBUTES a, MACHINE_ATTRIBUTES b) noexcept { return MACHINE_ATTRIBUTES(((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)b)); }
inline MACHINE_ATTRIBUTES& operator^=(MACHINE_ATTRIBUTES& a, MACHINE_ATTRIBUTES b) noexcept { return (MACHINE_ATTRIBUTES&)(((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<MACHINE_ATTRIBUTES>::type)b)); }
};
typedef struct _PROCESS_MACHINE_INFORMATION {
    USHORT ProcessMachine;
    USHORT Res0;
    MACHINE_ATTRIBUTES MachineAttributes;
} PROCESS_MACHINE_INFORMATION;
typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax
} PROCESS_MEMORY_EXHAUSTION_TYPE,
    *PPROCESS_MEMORY_EXHAUSTION_TYPE;
typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
    USHORT Version;
    USHORT Reserved;
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ULONG_PTR Value;
} PROCESS_MEMORY_EXHAUSTION_INFO, *PPROCESS_MEMORY_EXHAUSTION_INFO;
typedef struct _PROCESS_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} PROCESS_POWER_THROTTLING_STATE, *PPROCESS_POWER_THROTTLING_STATE;
typedef struct PROCESS_PROTECTION_LEVEL_INFORMATION {
    DWORD ProtectionLevel;
} PROCESS_PROTECTION_LEVEL_INFORMATION;
typedef struct _PROCESS_LEAP_SECOND_INFO {
    ULONG Flags;
    ULONG Reserved;
} PROCESS_LEAP_SECOND_INFO, *PPROCESS_LEAP_SECOND_INFO;
__declspec(dllimport)
    BOOL
    __stdcall SetProcessInformation(
        HANDLE hProcess,
        PROCESS_INFORMATION_CLASS ProcessInformationClass,
        LPVOID ProcessInformation,
        DWORD ProcessInformationSize);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessInformation(
        HANDLE hProcess,
        PROCESS_INFORMATION_CLASS ProcessInformationClass,
        LPVOID ProcessInformation,
        DWORD ProcessInformationSize);
BOOL __stdcall GetSystemCpuSetInformation(
    PSYSTEM_CPU_SET_INFORMATION Information,
    ULONG BufferLength,
    PULONG ReturnedLength,
    HANDLE Process,
    ULONG Flags);
BOOL __stdcall GetProcessDefaultCpuSets(
    HANDLE Process,
    PULONG CpuSetIds,
    ULONG CpuSetIdCount,
    PULONG RequiredIdCount);
BOOL __stdcall SetProcessDefaultCpuSets(
    HANDLE Process,
    const ULONG* CpuSetIds,
    ULONG CpuSetIdCount);
BOOL __stdcall GetThreadSelectedCpuSets(
    HANDLE Thread,
    PULONG CpuSetIds,
    ULONG CpuSetIdCount,
    PULONG RequiredIdCount);
BOOL __stdcall SetThreadSelectedCpuSets(
    HANDLE Thread,
    const ULONG* CpuSetIds,
    ULONG CpuSetIdCount);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CreateProcessAsUserA(
        HANDLE hToken,
        LPCSTR lpApplicationName,
        LPSTR lpCommandLine,
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        BOOL bInheritHandles,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCSTR lpCurrentDirectory,
        LPSTARTUPINFOA lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessShutdownParameters(
        LPDWORD lpdwLevel,
        LPDWORD lpdwFlags);
#pragma endregion
#pragma region Application Family or OneCore Family
BOOL __stdcall GetProcessDefaultCpuSetMasks(
    HANDLE Process,
    PGROUP_AFFINITY CpuSetMasks,
    USHORT CpuSetMaskCount,
    PUSHORT RequiredMaskCount);
BOOL __stdcall SetProcessDefaultCpuSetMasks(
    HANDLE Process,
    PGROUP_AFFINITY CpuSetMasks,
    USHORT CpuSetMaskCount);
BOOL __stdcall GetThreadSelectedCpuSetMasks(
    HANDLE Thread,
    PGROUP_AFFINITY CpuSetMasks,
    USHORT CpuSetMaskCount,
    PUSHORT RequiredMaskCount);
BOOL __stdcall SetThreadSelectedCpuSetMasks(
    HANDLE Thread,
    PGROUP_AFFINITY CpuSetMasks,
    USHORT CpuSetMaskCount);
#pragma endregion
#pragma region Application Family or OneCore Family
HRESULT
__stdcall GetMachineTypeAttributes(
    USHORT Machine,
    MACHINE_ATTRIBUTES* MachineTypeAttributes);
#pragma endregion
__declspec(dllimport)
    HRESULT
    __stdcall SetThreadDescription(
        HANDLE hThread,
        PCWSTR lpThreadDescription);
__declspec(dllimport)
    HRESULT
    __stdcall GetThreadDescription(
        HANDLE hThread,
        PWSTR* ppszThreadDescription);
}
#pragma once
#pragma warning(disable : 4514)
#pragma warning(disable : 4103)
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;
typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;
__declspec(dllimport)
    BOOL
    __stdcall GlobalMemoryStatusEx(
        LPMEMORYSTATUSEX lpBuffer);
__declspec(dllimport) void __stdcall GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo);
__declspec(dllimport) void __stdcall GetSystemTime(
    LPSYSTEMTIME lpSystemTime);
__declspec(dllimport) void __stdcall GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime);
__declspec(dllimport) void __stdcall GetLocalTime(
    LPSYSTEMTIME lpSystemTime);
__declspec(dllimport)
    BOOL
    __stdcall IsUserCetAvailableInEnvironment(
        DWORD UserCetEnvironment);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetSystemLeapSecondInformation(
        PBOOL Enabled,
        PDWORD Flags);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(deprecated) __declspec(dllimport)
    DWORD
    __stdcall GetVersion(
        void);
__declspec(dllimport)
    BOOL
    __stdcall SetLocalTime(
        const SYSTEMTIME* lpSystemTime);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetTickCount(
        void);
__declspec(dllimport)
    ULONGLONG
    __stdcall GetTickCount64(
        void);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetSystemTimeAdjustment(
        PDWORD lpTimeAdjustment,
        PDWORD lpTimeIncrement,
        PBOOL lpTimeAdjustmentDisabled);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetSystemTimeAdjustmentPrecise(
        PDWORD64 lpTimeAdjustment,
        PDWORD64 lpTimeIncrement,
        PBOOL lpTimeAdjustmentDisabled);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    UINT
    __stdcall GetSystemDirectoryA(
        LPSTR lpBuffer,
        UINT uSize);
__declspec(dllimport)
    UINT
    __stdcall GetSystemDirectoryW(
        LPWSTR lpBuffer,
        UINT uSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    UINT
    __stdcall GetWindowsDirectoryA(
        LPSTR lpBuffer,
        UINT uSize);
__declspec(dllimport)
    UINT
    __stdcall GetWindowsDirectoryW(
        LPWSTR lpBuffer,
        UINT uSize);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    UINT
    __stdcall GetSystemWindowsDirectoryA(
        LPSTR lpBuffer,
        UINT uSize);
__declspec(dllimport)
    UINT
    __stdcall GetSystemWindowsDirectoryW(
        LPWSTR lpBuffer,
        UINT uSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT;
__declspec(dllimport)
    BOOL
    __stdcall GetComputerNameExA(
        COMPUTER_NAME_FORMAT NameType,
        LPSTR lpBuffer,
        LPDWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall GetComputerNameExW(
        COMPUTER_NAME_FORMAT NameType,
        LPWSTR lpBuffer,
        LPDWORD nSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetComputerNameExW(
        COMPUTER_NAME_FORMAT NameType,
        LPCWSTR lpBuffer);
__declspec(dllimport)
    BOOL
    __stdcall SetSystemTime(
        const SYSTEMTIME* lpSystemTime);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(deprecated) __declspec(dllimport)
    BOOL
    __stdcall GetVersionExA(
        LPOSVERSIONINFOA lpVersionInformation);
__declspec(deprecated) __declspec(dllimport)
    BOOL
    __stdcall GetVersionExW(
        LPOSVERSIONINFOW lpVersionInformation);
__declspec(dllimport)
    BOOL
    __stdcall GetLogicalProcessorInformation(
        PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
        PDWORD ReturnedLength);
__declspec(dllimport)
    BOOL
    __stdcall GetLogicalProcessorInformationEx(
        LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
        PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
        PDWORD ReturnedLength);
__declspec(dllimport) void __stdcall GetNativeSystemInfo(
    LPSYSTEM_INFO lpSystemInfo);
__declspec(dllimport) void __stdcall GetSystemTimePreciseAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetProductInfo(
        DWORD dwOSMajorVersion,
        DWORD dwOSMinorVersion,
        DWORD dwSpMajorVersion,
        DWORD dwSpMinorVersion,
        PDWORD pdwReturnedProductType);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    ULONGLONG
    __stdcall VerSetConditionMask(
        ULONGLONG ConditionMask,
        ULONG TypeMask,
        UCHAR Condition);
__declspec(dllimport)
    BOOL
    __stdcall GetOsSafeBootMode(
        PDWORD Flags);
#pragma endregion
#pragma region OneCore Family or App Family
__declspec(dllimport)
    UINT
    __stdcall EnumSystemFirmwareTables(
        DWORD FirmwareTableProviderSignature,
        PVOID pFirmwareTableEnumBuffer,
        DWORD BufferSize);
__declspec(dllimport)
    UINT
    __stdcall GetSystemFirmwareTable(
        DWORD FirmwareTableProviderSignature,
        DWORD FirmwareTableID,
        PVOID pFirmwareTableBuffer,
        DWORD BufferSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DnsHostnameToComputerNameExW(
        LPCWSTR Hostname,
        LPWSTR ComputerName,
        LPDWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall GetPhysicallyInstalledSystemMemory(
        PULONGLONG TotalMemoryInKilobytes);
__declspec(dllimport)
    BOOL
    __stdcall SetComputerNameEx2W(
        COMPUTER_NAME_FORMAT NameType,
        DWORD Flags,
        LPCWSTR lpBuffer);
__declspec(dllimport)
    BOOL
    __stdcall SetSystemTimeAdjustment(
        DWORD dwTimeAdjustment,
        BOOL bTimeAdjustmentDisabled);
__declspec(dllimport)
    BOOL
    __stdcall SetSystemTimeAdjustmentPrecise(
        DWORD64 dwTimeAdjustment,
        BOOL bTimeAdjustmentDisabled);
__declspec(dllimport)
    BOOL
    __stdcall InstallELAMCertificateInfo(
        HANDLE ELAMFile);
#pragma endregion
__declspec(dllimport)
    BOOL
    __stdcall GetProcessorSystemCycleTime(
        USHORT Group,
        PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
        PDWORD ReturnedLength);
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetOsManufacturingMode(
        PBOOL pbEnabled);
#pragma endregion
#pragma region App Family or OneCore Family
__declspec(dllimport)
    HRESULT
    __stdcall GetIntegratedDisplaySize(
        double* sizeInInches);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetComputerNameA(
        LPCSTR lpComputerName);
__declspec(dllimport)
    BOOL
    __stdcall SetComputerNameW(
        LPCWSTR lpComputerName);
__declspec(dllimport)
    BOOL
    __stdcall SetComputerNameExA(
        COMPUTER_NAME_FORMAT NameType,
        LPCSTR lpBuffer);
#pragma endregion
}
#pragma warning(pop)
#pragma once
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma region Application Family or OneCore Family or Games Family
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    LPVOID
    __stdcall VirtualAlloc(
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flAllocationType,
        DWORD flProtect);
__declspec(dllimport)
    BOOL
    __stdcall VirtualProtect(
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flNewProtect,
        PDWORD lpflOldProtect);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall VirtualFree(
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD dwFreeType);
__declspec(dllimport)
    SIZE_T
    __stdcall VirtualQuery(
        LPCVOID lpAddress,
        PMEMORY_BASIC_INFORMATION lpBuffer,
        SIZE_T dwLength);
__declspec(dllimport)
    LPVOID
    __stdcall VirtualAllocEx(
        HANDLE hProcess,
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flAllocationType,
        DWORD flProtect);
__declspec(dllimport)
    BOOL
    __stdcall VirtualProtectEx(
        HANDLE hProcess,
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flNewProtect,
        PDWORD lpflOldProtect);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    SIZE_T
    __stdcall VirtualQueryEx(
        HANDLE hProcess,
        LPCVOID lpAddress,
        PMEMORY_BASIC_INFORMATION lpBuffer,
        SIZE_T dwLength);
__declspec(dllimport)
    BOOL
    __stdcall ReadProcessMemory(
        HANDLE hProcess,
        LPCVOID lpBaseAddress,
        LPVOID lpBuffer,
        SIZE_T nSize,
        SIZE_T* lpNumberOfBytesRead);
__declspec(dllimport)
    BOOL
    __stdcall WriteProcessMemory(
        HANDLE hProcess,
        LPVOID lpBaseAddress,
        LPCVOID lpBuffer,
        SIZE_T nSize,
        SIZE_T* lpNumberOfBytesWritten);
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileMappingW(
        HANDLE hFile,
        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
        DWORD flProtect,
        DWORD dwMaximumSizeHigh,
        DWORD dwMaximumSizeLow,
        LPCWSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenFileMappingW(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCWSTR lpName);
__declspec(dllimport)
    LPVOID
    __stdcall MapViewOfFile(
        HANDLE hFileMappingObject,
        DWORD dwDesiredAccess,
        DWORD dwFileOffsetHigh,
        DWORD dwFileOffsetLow,
        SIZE_T dwNumberOfBytesToMap);
__declspec(dllimport)
    LPVOID
    __stdcall MapViewOfFileEx(
        HANDLE hFileMappingObject,
        DWORD dwDesiredAccess,
        DWORD dwFileOffsetHigh,
        DWORD dwFileOffsetLow,
        SIZE_T dwNumberOfBytesToMap,
        LPVOID lpBaseAddress);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall VirtualFreeEx(
        HANDLE hProcess,
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD dwFreeType);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall FlushViewOfFile(
        LPCVOID lpBaseAddress,
        SIZE_T dwNumberOfBytesToFlush);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall UnmapViewOfFile(
        LPCVOID lpBaseAddress);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    SIZE_T
    __stdcall GetLargePageMinimum(
        void);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessWorkingSetSize(
        HANDLE hProcess,
        PSIZE_T lpMinimumWorkingSetSize,
        PSIZE_T lpMaximumWorkingSetSize);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessWorkingSetSizeEx(
        HANDLE hProcess,
        PSIZE_T lpMinimumWorkingSetSize,
        PSIZE_T lpMaximumWorkingSetSize,
        PDWORD Flags);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessWorkingSetSize(
        HANDLE hProcess,
        SIZE_T dwMinimumWorkingSetSize,
        SIZE_T dwMaximumWorkingSetSize);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessWorkingSetSizeEx(
        HANDLE hProcess,
        SIZE_T dwMinimumWorkingSetSize,
        SIZE_T dwMaximumWorkingSetSize,
        DWORD Flags);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall VirtualLock(
        LPVOID lpAddress,
        SIZE_T dwSize);
__declspec(dllimport)
    BOOL
    __stdcall VirtualUnlock(
        LPVOID lpAddress,
        SIZE_T dwSize);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetWriteWatch(
        DWORD dwFlags,
        PVOID lpBaseAddress,
        SIZE_T dwRegionSize,
        PVOID* lpAddresses,
        ULONG_PTR* lpdwCount,
        LPDWORD lpdwGranularity);
__declspec(dllimport)
    UINT
    __stdcall ResetWriteWatch(
        LPVOID lpBaseAddress,
        SIZE_T dwRegionSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;
__declspec(dllimport)
    HANDLE
    __stdcall CreateMemoryResourceNotification(
        MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
__declspec(dllimport)
    BOOL
    __stdcall QueryMemoryResourceNotification(
        HANDLE ResourceNotificationHandle,
        PBOOL ResourceState);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetSystemFileCacheSize(
        PSIZE_T lpMinimumFileCacheSize,
        PSIZE_T lpMaximumFileCacheSize,
        PDWORD lpFlags);
__declspec(dllimport)
    BOOL
    __stdcall SetSystemFileCacheSize(
        SIZE_T MinimumFileCacheSize,
        SIZE_T MaximumFileCacheSize,
        DWORD Flags);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileMappingNumaW(
        HANDLE hFile,
        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
        DWORD flProtect,
        DWORD dwMaximumSizeHigh,
        DWORD dwMaximumSizeLow,
        LPCWSTR lpName,
        DWORD nndPreferred);
typedef struct _WIN32_MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} WIN32_MEMORY_RANGE_ENTRY, *PWIN32_MEMORY_RANGE_ENTRY;
__declspec(dllimport)
    BOOL
    __stdcall PrefetchVirtualMemory(
        HANDLE hProcess,
        ULONG_PTR NumberOfEntries,
        PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses,
        ULONG Flags);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileMappingFromApp(
        HANDLE hFile,
        PSECURITY_ATTRIBUTES SecurityAttributes,
        ULONG PageProtection,
        ULONG64 MaximumSize,
        PCWSTR Name);
__declspec(dllimport)
    PVOID
    __stdcall MapViewOfFileFromApp(
        HANDLE hFileMappingObject,
        ULONG DesiredAccess,
        ULONG64 FileOffset,
        SIZE_T NumberOfBytesToMap);
__declspec(dllimport)
    BOOL
    __stdcall UnmapViewOfFileEx(
        PVOID BaseAddress,
        ULONG UnmapFlags);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AllocateUserPhysicalPages(
        HANDLE hProcess,
        PULONG_PTR NumberOfPages,
        PULONG_PTR PageArray);
__declspec(dllimport)
    BOOL
    __stdcall FreeUserPhysicalPages(
        HANDLE hProcess,
        PULONG_PTR NumberOfPages,
        PULONG_PTR PageArray);
__declspec(dllimport)
    BOOL
    __stdcall MapUserPhysicalPages(
        PVOID VirtualAddress,
        ULONG_PTR NumberOfPages,
        PULONG_PTR PageArray);
__declspec(dllimport)
    BOOL
    __stdcall AllocateUserPhysicalPagesNuma(
        HANDLE hProcess,
        PULONG_PTR NumberOfPages,
        PULONG_PTR PageArray,
        DWORD nndPreferred);
__declspec(dllimport)
    LPVOID
    __stdcall VirtualAllocExNuma(
        HANDLE hProcess,
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flAllocationType,
        DWORD flProtect,
        DWORD nndPreferred);
__declspec(dllimport)
    BOOL
    __stdcall GetMemoryErrorHandlingCapabilities(
        PULONG Capabilities);
typedef void __stdcall BAD_MEMORY_CALLBACK_ROUTINE(
    void);
typedef BAD_MEMORY_CALLBACK_ROUTINE* PBAD_MEMORY_CALLBACK_ROUTINE;
__declspec(dllimport)
    PVOID
    __stdcall RegisterBadMemoryNotification(
        PBAD_MEMORY_CALLBACK_ROUTINE Callback);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterBadMemoryNotification(
        PVOID RegistrationHandle);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef enum OFFER_PRIORITY {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow,
    VmOfferPriorityBelowNormal,
    VmOfferPriorityNormal
} OFFER_PRIORITY;
DWORD
__stdcall OfferVirtualMemory(
    PVOID VirtualAddress,
    SIZE_T Size,
    OFFER_PRIORITY Priority);
DWORD
__stdcall ReclaimVirtualMemory(
    void const* VirtualAddress,
    SIZE_T Size);
DWORD
__stdcall DiscardVirtualMemory(
    PVOID VirtualAddress,
    SIZE_T Size);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessValidCallTargets(
        HANDLE hProcess,
        PVOID VirtualAddress,
        SIZE_T RegionSize,
        ULONG NumberOfOffsets,
        PCFG_CALL_TARGET_INFO OffsetInformation);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessValidCallTargetsForMappedView(
        HANDLE Process,
        PVOID VirtualAddress,
        SIZE_T RegionSize,
        ULONG NumberOfOffsets,
        PCFG_CALL_TARGET_INFO OffsetInformation,
        HANDLE Section,
        ULONG64 ExpectedFileOffset);
__declspec(dllimport)
    PVOID
    __stdcall VirtualAllocFromApp(
        PVOID BaseAddress,
        SIZE_T Size,
        ULONG AllocationType,
        ULONG Protection);
__declspec(dllimport)
    BOOL
    __stdcall VirtualProtectFromApp(
        PVOID Address,
        SIZE_T Size,
        ULONG NewProtection,
        PULONG OldProtection);
__declspec(dllimport)
    HANDLE
    __stdcall OpenFileMappingFromApp(
        ULONG DesiredAccess,
        BOOL InheritHandle,
        PCWSTR Name);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef enum WIN32_MEMORY_INFORMATION_CLASS {
    MemoryRegionInfo
} WIN32_MEMORY_INFORMATION_CLASS;
#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
typedef struct WIN32_MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union {
        ULONG Flags;
        struct {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG Reserved : 26;
        };
    };
    SIZE_T RegionSize;
    SIZE_T CommitSize;
} WIN32_MEMORY_REGION_INFORMATION;
#pragma warning(pop)
__declspec(dllimport)
    BOOL
    __stdcall QueryVirtualMemoryInformation(
        HANDLE Process,
        const void* VirtualAddress,
        WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass,
        PVOID MemoryInformation,
        SIZE_T MemoryInformationSize,
        PSIZE_T ReturnSize);
__declspec(dllimport)
    PVOID
    __stdcall MapViewOfFileNuma2(
        HANDLE FileMappingHandle,
        HANDLE ProcessHandle,
        ULONG64 Offset,
        PVOID BaseAddress,
        SIZE_T ViewSize,
        ULONG AllocationType,
        ULONG PageProtection,
        ULONG PreferredNode);
__forceinline PVOID
MapViewOfFile2(
    HANDLE FileMappingHandle,
    HANDLE ProcessHandle,
    ULONG64 Offset,
    PVOID BaseAddress,
    SIZE_T ViewSize,
    ULONG AllocationType,
    ULONG PageProtection)
{
    return MapViewOfFileNuma2(FileMappingHandle,
        ProcessHandle,
        Offset,
        BaseAddress,
        ViewSize,
        AllocationType,
        PageProtection,
        ((DWORD)-1));
}
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall UnmapViewOfFile2(
        HANDLE Process,
        PVOID BaseAddress,
        ULONG UnmapFlags);
__declspec(dllimport)
    BOOL
    __stdcall VirtualUnlockEx(
        HANDLE Process,
        LPVOID Address,
        SIZE_T Size);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    PVOID
    __stdcall VirtualAlloc2(
        HANDLE Process,
        PVOID BaseAddress,
        SIZE_T Size,
        ULONG AllocationType,
        ULONG PageProtection,
        MEM_EXTENDED_PARAMETER* ExtendedParameters,
        ULONG ParameterCount);
__declspec(dllimport)
    PVOID
    __stdcall MapViewOfFile3(
        HANDLE FileMapping,
        HANDLE Process,
        PVOID BaseAddress,
        ULONG64 Offset,
        SIZE_T ViewSize,
        ULONG AllocationType,
        ULONG PageProtection,
        MEM_EXTENDED_PARAMETER* ExtendedParameters,
        ULONG ParameterCount);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    PVOID
    __stdcall VirtualAlloc2FromApp(
        HANDLE Process,
        PVOID BaseAddress,
        SIZE_T Size,
        ULONG AllocationType,
        ULONG PageProtection,
        MEM_EXTENDED_PARAMETER* ExtendedParameters,
        ULONG ParameterCount);
__declspec(dllimport)
    PVOID
    __stdcall MapViewOfFile3FromApp(
        HANDLE FileMapping,
        HANDLE Process,
        PVOID BaseAddress,
        ULONG64 Offset,
        SIZE_T ViewSize,
        ULONG AllocationType,
        ULONG PageProtection,
        MEM_EXTENDED_PARAMETER* ExtendedParameters,
        ULONG ParameterCount);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileMapping2(
        HANDLE File,
        SECURITY_ATTRIBUTES* SecurityAttributes,
        ULONG DesiredAccess,
        ULONG PageProtection,
        ULONG AllocationAttributes,
        ULONG64 MaximumSize,
        PCWSTR Name,
        MEM_EXTENDED_PARAMETER* ExtendedParameters,
        ULONG ParameterCount);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AllocateUserPhysicalPages2(
        HANDLE ObjectHandle,
        PULONG_PTR NumberOfPages,
        PULONG_PTR PageArray,
        PMEM_EXTENDED_PARAMETER ExtendedParameters,
        ULONG ExtendedParameterCount);
typedef enum WIN32_MEMORY_PARTITION_INFORMATION_CLASS {
    MemoryPartitionInfo,
    MemoryPartitionDedicatedMemoryInfo
} WIN32_MEMORY_PARTITION_INFORMATION_CLASS;
typedef struct __declspec(align(8)) WIN32_MEMORY_PARTITION_INFORMATION {
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG64 ResidentAvailablePages;
    ULONG64 CommittedPages;
    ULONG64 CommitLimit;
    ULONG64 PeakCommitment;
    ULONG64 TotalNumberOfPages;
    ULONG64 AvailablePages;
    ULONG64 ZeroPages;
    ULONG64 FreePages;
    ULONG64 StandbyPages;
    ULONG64 Reserved[16];
    ULONG64 MaximumCommitLimit;
    ULONG64 Reserved2;
    ULONG PartitionId;
} WIN32_MEMORY_PARTITION_INFORMATION;
__declspec(dllimport)
    HANDLE
    __stdcall OpenDedicatedMemoryPartition(
        HANDLE Partition,
        ULONG64 DedicatedMemoryTypeId,
        ACCESS_MASK DesiredAccess,
        BOOL InheritHandle);
__declspec(dllimport)
    BOOL
    __stdcall QueryPartitionInformation(
        HANDLE Partition,
        WIN32_MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
        PVOID PartitionInformation,
        ULONG PartitionInformationLength);
#pragma endregion
#pragma warning(pop)
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Or App Family
__declspec(dllimport)
    BOOL
    __stdcall IsEnclaveTypeSupported(
        DWORD flEnclaveType);
__declspec(dllimport)
    LPVOID
    __stdcall CreateEnclave(
        HANDLE hProcess,
        LPVOID lpAddress,
        SIZE_T dwSize,
        SIZE_T dwInitialCommitment,
        DWORD flEnclaveType,
        LPCVOID lpEnclaveInformation,
        DWORD dwInfoLength,
        LPDWORD lpEnclaveError);
__declspec(dllimport)
    BOOL
    __stdcall LoadEnclaveData(
        HANDLE hProcess,
        LPVOID lpAddress,
        LPCVOID lpBuffer,
        SIZE_T nSize,
        DWORD flProtect,
        LPCVOID lpPageInformation,
        DWORD dwInfoLength,
        PSIZE_T lpNumberOfBytesWritten,
        LPDWORD lpEnclaveError);
__declspec(dllimport)
    BOOL
    __stdcall InitializeEnclave(
        HANDLE hProcess,
        LPVOID lpAddress,
        LPCVOID lpEnclaveInformation,
        DWORD dwInfoLength,
        LPDWORD lpEnclaveError);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall LoadEnclaveImageA(
        LPVOID lpEnclaveAddress,
        LPCSTR lpImageName);
__declspec(dllimport)
    BOOL
    __stdcall LoadEnclaveImageW(
        LPVOID lpEnclaveAddress,
        LPCWSTR lpImageName);
__declspec(dllimport)
    BOOL
    __stdcall CallEnclave(
        LPENCLAVE_ROUTINE lpRoutine,
        LPVOID lpParameter,
        BOOL fWaitForThread,
        LPVOID* lpReturnValue);
__declspec(dllimport)
    BOOL
    __stdcall TerminateEnclave(
        LPVOID lpAddress,
        BOOL fWait);
__declspec(dllimport)
    BOOL
    __stdcall DeleteEnclave(
        LPVOID lpAddress);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall QueueUserWorkItem(
        LPTHREAD_START_ROUTINE Function,
        PVOID Context,
        ULONG Flags);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterWaitEx(
        HANDLE WaitHandle,
        HANDLE CompletionEvent);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateTimerQueue(
        void);
__declspec(dllimport)
    BOOL
    __stdcall CreateTimerQueueTimer(
        PHANDLE phNewTimer,
        HANDLE TimerQueue,
        WAITORTIMERCALLBACK Callback,
        PVOID Parameter,
        DWORD DueTime,
        DWORD Period,
        ULONG Flags);
__declspec(dllimport)
    BOOL
    __stdcall ChangeTimerQueueTimer(
        HANDLE TimerQueue,
        HANDLE Timer,
        ULONG DueTime,
        ULONG Period);
__declspec(dllimport)
    BOOL
    __stdcall DeleteTimerQueueTimer(
        HANDLE TimerQueue,
        HANDLE Timer,
        HANDLE CompletionEvent);
__declspec(dllimport)
    BOOL
    __stdcall DeleteTimerQueue(
        HANDLE TimerQueue);
__declspec(dllimport)
    BOOL
    __stdcall DeleteTimerQueueEx(
        HANDLE TimerQueue,
        HANDLE CompletionEvent);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
typedef void(__stdcall* PTP_WIN32_IO_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PVOID Overlapped,
    ULONG IoResult,
    ULONG_PTR NumberOfBytesTransferred,
    PTP_IO Io);
__declspec(dllimport)
    PTP_POOL
    __stdcall CreateThreadpool(
        PVOID reserved);
__declspec(dllimport) void __stdcall SetThreadpoolThreadMaximum(
    PTP_POOL ptpp,
    DWORD cthrdMost);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadpoolThreadMinimum(
        PTP_POOL ptpp,
        DWORD cthrdMic);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadpoolStackInformation(
        PTP_POOL ptpp,
        PTP_POOL_STACK_INFORMATION ptpsi);
__declspec(dllimport)
    BOOL
    __stdcall QueryThreadpoolStackInformation(
        PTP_POOL ptpp,
        PTP_POOL_STACK_INFORMATION ptpsi);
__declspec(dllimport) void __stdcall CloseThreadpool(
    PTP_POOL ptpp);
__declspec(dllimport)
    PTP_CLEANUP_GROUP
    __stdcall CreateThreadpoolCleanupGroup(
        void);
__declspec(dllimport) void __stdcall CloseThreadpoolCleanupGroupMembers(
    PTP_CLEANUP_GROUP ptpcg,
    BOOL fCancelPendingCallbacks,
    PVOID pvCleanupContext);
__declspec(dllimport) void __stdcall CloseThreadpoolCleanupGroup(
    PTP_CLEANUP_GROUP ptpcg);
__declspec(dllimport) void __stdcall SetEventWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE evt);
__declspec(dllimport) void __stdcall ReleaseSemaphoreWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE sem,
    DWORD crel);
__declspec(dllimport) void __stdcall ReleaseMutexWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE mut);
__declspec(dllimport) void __stdcall LeaveCriticalSectionWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    PCRITICAL_SECTION pcs);
__declspec(dllimport) void __stdcall FreeLibraryWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HMODULE mod);
__declspec(dllimport)
    BOOL
    __stdcall CallbackMayRunLong(
        PTP_CALLBACK_INSTANCE pci);
__declspec(dllimport) void __stdcall DisassociateCurrentThreadFromCallback(
    PTP_CALLBACK_INSTANCE pci);
__declspec(dllimport)
    BOOL
    __stdcall TrySubmitThreadpoolCallback(
        PTP_SIMPLE_CALLBACK pfns,
        PVOID pv,
        PTP_CALLBACK_ENVIRON pcbe);
__declspec(dllimport)
    PTP_WORK
    __stdcall CreateThreadpoolWork(
        PTP_WORK_CALLBACK pfnwk,
        PVOID pv,
        PTP_CALLBACK_ENVIRON pcbe);
__declspec(dllimport) void __stdcall SubmitThreadpoolWork(
    PTP_WORK pwk);
__declspec(dllimport) void __stdcall WaitForThreadpoolWorkCallbacks(
    PTP_WORK pwk,
    BOOL fCancelPendingCallbacks);
__declspec(dllimport) void __stdcall CloseThreadpoolWork(
    PTP_WORK pwk);
__declspec(dllimport)
    PTP_TIMER
    __stdcall CreateThreadpoolTimer(
        PTP_TIMER_CALLBACK pfnti,
        PVOID pv,
        PTP_CALLBACK_ENVIRON pcbe);
__declspec(dllimport) void __stdcall SetThreadpoolTimer(
    PTP_TIMER pti,
    PFILETIME pftDueTime,
    DWORD msPeriod,
    DWORD msWindowLength);
__declspec(dllimport)
    BOOL
    __stdcall IsThreadpoolTimerSet(
        PTP_TIMER pti);
__declspec(dllimport) void __stdcall WaitForThreadpoolTimerCallbacks(
    PTP_TIMER pti,
    BOOL fCancelPendingCallbacks);
__declspec(dllimport) void __stdcall CloseThreadpoolTimer(
    PTP_TIMER pti);
__declspec(dllimport)
    PTP_WAIT
    __stdcall CreateThreadpoolWait(
        PTP_WAIT_CALLBACK pfnwa,
        PVOID pv,
        PTP_CALLBACK_ENVIRON pcbe);
__declspec(dllimport) void __stdcall SetThreadpoolWait(
    PTP_WAIT pwa,
    HANDLE h,
    PFILETIME pftTimeout);
__declspec(dllimport) void __stdcall WaitForThreadpoolWaitCallbacks(
    PTP_WAIT pwa,
    BOOL fCancelPendingCallbacks);
__declspec(dllimport) void __stdcall CloseThreadpoolWait(
    PTP_WAIT pwa);
__declspec(dllimport)
    PTP_IO
    __stdcall CreateThreadpoolIo(
        HANDLE fl,
        PTP_WIN32_IO_CALLBACK pfnio,
        PVOID pv,
        PTP_CALLBACK_ENVIRON pcbe);
__declspec(dllimport) void __stdcall StartThreadpoolIo(
    PTP_IO pio);
__declspec(dllimport) void __stdcall CancelThreadpoolIo(
    PTP_IO pio);
__declspec(dllimport) void __stdcall WaitForThreadpoolIoCallbacks(
    PTP_IO pio,
    BOOL fCancelPendingCallbacks);
__declspec(dllimport) void __stdcall CloseThreadpoolIo(
    PTP_IO pio);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetThreadpoolTimerEx(
        PTP_TIMER pti,
        PFILETIME pftDueTime,
        DWORD msPeriod,
        DWORD msWindowLength);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadpoolWaitEx(
        PTP_WAIT pwa,
        HANDLE h,
        PFILETIME pftTimeout,
        PVOID Reserved);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsProcessInJob(
        HANDLE ProcessHandle,
        HANDLE JobHandle,
        PBOOL Result);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PCWSTR VolumeName;
    ULONG BaseIoSize;
    ULONG ControlFlags;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION;
__declspec(dllimport)
    HANDLE
    __stdcall CreateJobObjectW(
        LPSECURITY_ATTRIBUTES lpJobAttributes,
        LPCWSTR lpName);
__declspec(dllimport) void __stdcall FreeMemoryJobObject(
    void* Buffer);
__declspec(dllimport)
    HANDLE
    __stdcall OpenJobObjectW(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCWSTR lpName);
__declspec(dllimport)
    BOOL
    __stdcall AssignProcessToJobObject(
        HANDLE hJob,
        HANDLE hProcess);
__declspec(dllimport)
    BOOL
    __stdcall TerminateJobObject(
        HANDLE hJob,
        UINT uExitCode);
__declspec(dllimport)
    BOOL
    __stdcall SetInformationJobObject(
        HANDLE hJob,
        JOBOBJECTINFOCLASS JobObjectInformationClass,
        LPVOID lpJobObjectInformation,
        DWORD cbJobObjectInformationLength);
__declspec(dllimport)
    DWORD
    __stdcall SetIoRateControlInformationJobObject(
        HANDLE hJob,
        JOBOBJECT_IO_RATE_CONTROL_INFORMATION* IoRateControlInfo);
__declspec(dllimport)
    BOOL
    __stdcall QueryInformationJobObject(
        HANDLE hJob,
        JOBOBJECTINFOCLASS JobObjectInformationClass,
        LPVOID lpJobObjectInformation,
        DWORD cbJobObjectInformationLength,
        LPDWORD lpReturnLength);
__declspec(dllimport)
    DWORD
    __stdcall QueryIoRateControlInformationJobObject(
        HANDLE hJob,
        PCWSTR VolumeName,
        JOBOBJECT_IO_RATE_CONTROL_INFORMATION** InfoBlocks,
        ULONG* InfoBlockCount);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOLEAN
    __stdcall Wow64EnableWow64FsRedirection(
        BOOLEAN Wow64FsEnableRedirection);
__declspec(dllimport)
    BOOL
    __stdcall Wow64DisableWow64FsRedirection(
        PVOID* OldValue);
__declspec(dllimport)
    BOOL
    __stdcall Wow64RevertWow64FsRedirection(
        PVOID OlValue);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsWow64Process(
        HANDLE hProcess,
        PBOOL Wow64Process);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetSystemWow64DirectoryA(
        LPSTR lpBuffer,
        UINT uSize);
__declspec(dllimport)
    UINT
    __stdcall GetSystemWow64DirectoryW(
        LPWSTR lpBuffer,
        UINT uSize);
__declspec(dllimport)
    USHORT
    __stdcall Wow64SetThreadDefaultGuestMachine(
        USHORT Machine);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsWow64Process2(
        HANDLE hProcess,
        USHORT* pProcessMachine,
        USHORT* pNativeMachine);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetSystemWow64Directory2A(
        LPSTR lpBuffer,
        UINT uSize,
        WORD ImageFileMachineType);
__declspec(dllimport)
    UINT
    __stdcall GetSystemWow64Directory2W(
        LPWSTR lpBuffer,
        UINT uSize,
        WORD ImageFileMachineType);
__declspec(dllimport)
    HRESULT
    __stdcall IsWow64GuestMachineSupported(
        USHORT WowGuestMachine,
        BOOL* MachineIsSupported);
__declspec(dllimport)
    BOOL
    __stdcall Wow64GetThreadContext(
        HANDLE hThread,
        PWOW64_CONTEXT lpContext);
__declspec(dllimport)
    BOOL
    __stdcall Wow64SetThreadContext(
        HANDLE hThread,
        const WOW64_CONTEXT* lpContext);
__declspec(dllimport)
    DWORD
    __stdcall Wow64SuspendThread(
        HANDLE hThread);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family
typedef struct tagENUMUILANG {
    ULONG NumOfEnumUILang;
    ULONG SizeOfEnumUIBuffer;
    LANGID* pEnumUIBuffer;
} ENUMUILANG, *PENUMUILANG;
typedef BOOL(__stdcall* ENUMRESLANGPROCA)(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage,
    LONG_PTR lParam);
typedef BOOL(__stdcall* ENUMRESLANGPROCW)(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD wLanguage,
    LONG_PTR lParam);
typedef BOOL(__stdcall* ENUMRESNAMEPROCA)(
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LONG_PTR lParam);
typedef BOOL(__stdcall* ENUMRESNAMEPROCW)(
    HMODULE hModule,
    LPCWSTR lpType,
    LPWSTR lpName,
    LONG_PTR lParam);
typedef BOOL(__stdcall* ENUMRESTYPEPROCA)(
    HMODULE hModule,
    LPSTR lpType,
    LONG_PTR lParam);
typedef BOOL(__stdcall* ENUMRESTYPEPROCW)(
    HMODULE hModule,
    LPWSTR lpType,
    LONG_PTR lParam);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall DisableThreadLibraryCalls(
        HMODULE hLibModule);
__declspec(dllimport)
    HRSRC
    __stdcall FindResourceExW(
        HMODULE hModule,
        LPCWSTR lpType,
        LPCWSTR lpName,
        WORD wLanguage);
__declspec(dllimport) int __stdcall FindStringOrdinal(
    DWORD dwFindStringOrdinalFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    BOOL bIgnoreCase);
__declspec(dllimport)
    BOOL
    __stdcall FreeLibrary(
        HMODULE hLibModule);
__declspec(dllimport) __declspec(noreturn) void __stdcall FreeLibraryAndExitThread(
    HMODULE hLibModule,
    DWORD dwExitCode);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall FreeResource(
        HGLOBAL hResData);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall GetModuleFileNameA(
        HMODULE hModule,
        LPSTR lpFilename,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetModuleFileNameW(
        HMODULE hModule,
        LPWSTR lpFilename,
        DWORD nSize);
__declspec(dllimport)
    HMODULE
    __stdcall GetModuleHandleA(
        LPCSTR lpModuleName);
__declspec(dllimport)
    HMODULE
    __stdcall GetModuleHandleW(
        LPCWSTR lpModuleName);
typedef BOOL(__stdcall*
        PGET_MODULE_HANDLE_EXA)(
    DWORD dwFlags,
    LPCSTR lpModuleName,
    HMODULE* phModule);
typedef BOOL(__stdcall*
        PGET_MODULE_HANDLE_EXW)(
    DWORD dwFlags,
    LPCWSTR lpModuleName,
    HMODULE* phModule);
__declspec(dllimport)
    BOOL
    __stdcall GetModuleHandleExA(
        DWORD dwFlags,
        LPCSTR lpModuleName,
        HMODULE* phModule);
__declspec(dllimport)
    BOOL
    __stdcall GetModuleHandleExW(
        DWORD dwFlags,
        LPCWSTR lpModuleName,
        HMODULE* phModule);
__declspec(dllimport)
    FARPROC
    __stdcall GetProcAddress(
        HMODULE hModule,
        LPCSTR lpProcName);
typedef struct _REDIRECTION_FUNCTION_DESCRIPTOR {
    PCSTR DllName;
    PCSTR FunctionName;
    PVOID RedirectionTarget;
} REDIRECTION_FUNCTION_DESCRIPTOR, *PREDIRECTION_FUNCTION_DESCRIPTOR;
typedef const REDIRECTION_FUNCTION_DESCRIPTOR* PCREDIRECTION_FUNCTION_DESCRIPTOR;
typedef struct _REDIRECTION_DESCRIPTOR {
    ULONG Version;
    ULONG FunctionCount;
    PCREDIRECTION_FUNCTION_DESCRIPTOR Redirections;
} REDIRECTION_DESCRIPTOR, *PREDIRECTION_DESCRIPTOR;
typedef const REDIRECTION_DESCRIPTOR* PCREDIRECTION_DESCRIPTOR;
__declspec(dllimport)
    HMODULE
    __stdcall LoadLibraryExA(
        LPCSTR lpLibFileName,
        HANDLE hFile,
        DWORD dwFlags);
__declspec(dllimport)
    HMODULE
    __stdcall LoadLibraryExW(
        LPCWSTR lpLibFileName,
        HANDLE hFile,
        DWORD dwFlags);
__declspec(dllimport)
    HGLOBAL
    __stdcall LoadResource(
        HMODULE hModule,
        HRSRC hResInfo);
__declspec(dllimport) int __stdcall LoadStringA(
    HINSTANCE hInstance,
    UINT uID,
    LPSTR lpBuffer,
    int cchBufferMax);
__declspec(dllimport) int __stdcall LoadStringW(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int cchBufferMax);
__declspec(dllimport)
    LPVOID
    __stdcall LockResource(
        HGLOBAL hResData);
__declspec(dllimport)
    DWORD
    __stdcall SizeofResource(
        HMODULE hModule,
        HRSRC hResInfo);
#pragma endregion
#pragma region App Family or OneCore Family
typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;
__declspec(dllimport)
    DLL_DIRECTORY_COOKIE
    __stdcall AddDllDirectory(
        PCWSTR NewDirectory);
__declspec(dllimport)
    BOOL
    __stdcall RemoveDllDirectory(
        DLL_DIRECTORY_COOKIE Cookie);
__declspec(dllimport)
    BOOL
    __stdcall SetDefaultDllDirectories(
        DWORD DirectoryFlags);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceLanguagesExA(
        HMODULE hModule,
        LPCSTR lpType,
        LPCSTR lpName,
        ENUMRESLANGPROCA lpEnumFunc,
        LONG_PTR lParam,
        DWORD dwFlags,
        LANGID LangId);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceLanguagesExW(
        HMODULE hModule,
        LPCWSTR lpType,
        LPCWSTR lpName,
        ENUMRESLANGPROCW lpEnumFunc,
        LONG_PTR lParam,
        DWORD dwFlags,
        LANGID LangId);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceNamesExA(
        HMODULE hModule,
        LPCSTR lpType,
        ENUMRESNAMEPROCA lpEnumFunc,
        LONG_PTR lParam,
        DWORD dwFlags,
        LANGID LangId);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceNamesExW(
        HMODULE hModule,
        LPCWSTR lpType,
        ENUMRESNAMEPROCW lpEnumFunc,
        LONG_PTR lParam,
        DWORD dwFlags,
        LANGID LangId);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceTypesExA(
        HMODULE hModule,
        ENUMRESTYPEPROCA lpEnumFunc,
        LONG_PTR lParam,
        DWORD dwFlags,
        LANGID LangId);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceTypesExW(
        HMODULE hModule,
        ENUMRESTYPEPROCW lpEnumFunc,
        LONG_PTR lParam,
        DWORD dwFlags,
        LANGID LangId);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HRSRC
    __stdcall FindResourceW(
        HMODULE hModule,
        LPCWSTR lpName,
        LPCWSTR lpType);
__declspec(dllimport)
    HMODULE
    __stdcall LoadLibraryA(
        LPCSTR lpLibFileName);
__declspec(dllimport)
    HMODULE
    __stdcall LoadLibraryW(
        LPCWSTR lpLibFileName);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceNamesW(
        HMODULE hModule,
        LPCWSTR lpType,
        ENUMRESNAMEPROCW lpEnumFunc,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceNamesA(
        HMODULE hModule,
        LPCSTR lpType,
        ENUMRESNAMEPROCA lpEnumFunc,
        LONG_PTR lParam);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AccessCheck(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        PGENERIC_MAPPING GenericMapping,
        PPRIVILEGE_SET PrivilegeSet,
        LPDWORD PrivilegeSetLength,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckAndAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        LPWSTR ObjectTypeName,
        LPWSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        DWORD DesiredAccess,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByType(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID PrincipalSelfSid,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        PPRIVILEGE_SET PrivilegeSet,
        LPDWORD PrivilegeSetLength,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeResultList(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID PrincipalSelfSid,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        PPRIVILEGE_SET PrivilegeSet,
        LPDWORD PrivilegeSetLength,
        LPDWORD GrantedAccessList,
        LPDWORD AccessStatusList);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeAndAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        LPCWSTR ObjectTypeName,
        LPCWSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PSID PrincipalSelfSid,
        DWORD DesiredAccess,
        AUDIT_EVENT_TYPE AuditType,
        DWORD Flags,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeResultListAndAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        LPCWSTR ObjectTypeName,
        LPCWSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PSID PrincipalSelfSid,
        DWORD DesiredAccess,
        AUDIT_EVENT_TYPE AuditType,
        DWORD Flags,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccessList,
        LPDWORD AccessStatusList,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeResultListAndAuditAlarmByHandleW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        HANDLE ClientToken,
        LPCWSTR ObjectTypeName,
        LPCWSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PSID PrincipalSelfSid,
        DWORD DesiredAccess,
        AUDIT_EVENT_TYPE AuditType,
        DWORD Flags,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccessList,
        LPDWORD AccessStatusList,
        LPBOOL pfGenerateOnClose);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AddAccessAllowedAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AccessMask,
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall AddAccessAllowedAceEx(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        PSID pSid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AddAccessAllowedObjectAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        GUID* ObjectTypeGuid,
        GUID* InheritedObjectTypeGuid,
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall AddAccessDeniedAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AccessMask,
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall AddAccessDeniedAceEx(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall AddAccessDeniedObjectAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        GUID* ObjectTypeGuid,
        GUID* InheritedObjectTypeGuid,
        PSID pSid);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AddAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD dwStartingAceIndex,
        LPVOID pAceList,
        DWORD nAceListLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AddAuditAccessAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD dwAccessMask,
        PSID pSid,
        BOOL bAuditSuccess,
        BOOL bAuditFailure);
__declspec(dllimport)
    BOOL
    __stdcall AddAuditAccessAceEx(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD dwAccessMask,
        PSID pSid,
        BOOL bAuditSuccess,
        BOOL bAuditFailure);
__declspec(dllimport)
    BOOL
    __stdcall AddAuditAccessObjectAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        GUID* ObjectTypeGuid,
        GUID* InheritedObjectTypeGuid,
        PSID pSid,
        BOOL bAuditSuccess,
        BOOL bAuditFailure);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AddMandatoryAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD MandatoryPolicy,
        PSID pLabelSid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AddResourceAttributeAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        PSID pSid,
        PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo,
        PDWORD pReturnLength);
__declspec(dllimport)
    BOOL
    __stdcall AddScopedPolicyIDAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        DWORD AccessMask,
        PSID pSid);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AdjustTokenGroups(
        HANDLE TokenHandle,
        BOOL ResetToDefault,
        PTOKEN_GROUPS NewState,
        DWORD BufferLength,
        PTOKEN_GROUPS PreviousState,
        PDWORD ReturnLength);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall AdjustTokenPrivileges(
        HANDLE TokenHandle,
        BOOL DisableAllPrivileges,
        PTOKEN_PRIVILEGES NewState,
        DWORD BufferLength,
        PTOKEN_PRIVILEGES PreviousState,
        PDWORD ReturnLength);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AllocateAndInitializeSid(
        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
        BYTE nSubAuthorityCount,
        DWORD nSubAuthority0,
        DWORD nSubAuthority1,
        DWORD nSubAuthority2,
        DWORD nSubAuthority3,
        DWORD nSubAuthority4,
        DWORD nSubAuthority5,
        DWORD nSubAuthority6,
        DWORD nSubAuthority7,
        PSID* pSid);
__declspec(dllimport)
    BOOL
    __stdcall AllocateLocallyUniqueId(
        PLUID Luid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AreAllAccessesGranted(
        DWORD GrantedAccess,
        DWORD DesiredAccess);
__declspec(dllimport)
    BOOL
    __stdcall AreAnyAccessesGranted(
        DWORD GrantedAccess,
        DWORD DesiredAccess);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CheckTokenMembership(
        HANDLE TokenHandle,
        PSID SidToCheck,
        PBOOL IsMember);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CheckTokenCapability(
        HANDLE TokenHandle,
        PSID CapabilitySidToCheck,
        PBOOL HasCapability);
__declspec(dllimport)
    BOOL
    __stdcall GetAppContainerAce(
        PACL Acl,
        DWORD StartingAceIndex,
        PVOID* AppContainerAce,
        DWORD* AppContainerAceIndex);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CheckTokenMembershipEx(
        HANDLE TokenHandle,
        PSID SidToCheck,
        DWORD Flags,
        PBOOL IsMember);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall ConvertToAutoInheritPrivateObjectSecurity(
        PSECURITY_DESCRIPTOR ParentDescriptor,
        PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
        PSECURITY_DESCRIPTOR* NewSecurityDescriptor,
        GUID* ObjectType,
        BOOLEAN IsDirectoryObject,
        PGENERIC_MAPPING GenericMapping);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CopySid(
        DWORD nDestinationSidLength,
        PSID pDestinationSid,
        PSID pSourceSid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CreatePrivateObjectSecurity(
        PSECURITY_DESCRIPTOR ParentDescriptor,
        PSECURITY_DESCRIPTOR CreatorDescriptor,
        PSECURITY_DESCRIPTOR* NewDescriptor,
        BOOL IsDirectoryObject,
        HANDLE Token,
        PGENERIC_MAPPING GenericMapping);
__declspec(dllimport)
    BOOL
    __stdcall CreatePrivateObjectSecurityEx(
        PSECURITY_DESCRIPTOR ParentDescriptor,
        PSECURITY_DESCRIPTOR CreatorDescriptor,
        PSECURITY_DESCRIPTOR* NewDescriptor,
        GUID* ObjectType,
        BOOL IsContainerObject,
        ULONG AutoInheritFlags,
        HANDLE Token,
        PGENERIC_MAPPING GenericMapping);
__declspec(dllimport)
    BOOL
    __stdcall CreatePrivateObjectSecurityWithMultipleInheritance(
        PSECURITY_DESCRIPTOR ParentDescriptor,
        PSECURITY_DESCRIPTOR CreatorDescriptor,
        PSECURITY_DESCRIPTOR* NewDescriptor,
        GUID** ObjectTypes,
        ULONG GuidCount,
        BOOL IsContainerObject,
        ULONG AutoInheritFlags,
        HANDLE Token,
        PGENERIC_MAPPING GenericMapping);
__declspec(dllimport)
    BOOL
    __stdcall CreateRestrictedToken(
        HANDLE ExistingTokenHandle,
        DWORD Flags,
        DWORD DisableSidCount,
        PSID_AND_ATTRIBUTES SidsToDisable,
        DWORD DeletePrivilegeCount,
        PLUID_AND_ATTRIBUTES PrivilegesToDelete,
        DWORD RestrictedSidCount,
        PSID_AND_ATTRIBUTES SidsToRestrict,
        PHANDLE NewTokenHandle);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall CreateWellKnownSid(
        WELL_KNOWN_SID_TYPE WellKnownSidType,
        PSID DomainSid,
        PSID pSid,
        DWORD* cbSid);
__declspec(dllimport)
    BOOL
    __stdcall EqualDomainSid(
        PSID pSid1,
        PSID pSid2,
        BOOL* pfEqual);
__declspec(dllimport)
    BOOL
    __stdcall DeleteAce(
        PACL pAcl,
        DWORD dwAceIndex);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DestroyPrivateObjectSecurity(
        PSECURITY_DESCRIPTOR* ObjectDescriptor);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DuplicateToken(
        HANDLE ExistingTokenHandle,
        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
        PHANDLE DuplicateTokenHandle);
__declspec(dllimport)
    BOOL
    __stdcall DuplicateTokenEx(
        HANDLE hExistingToken,
        DWORD dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpTokenAttributes,
        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
        TOKEN_TYPE TokenType,
        PHANDLE phNewToken);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EqualPrefixSid(
        PSID pSid1,
        PSID pSid2);
__declspec(dllimport)
    BOOL
    __stdcall EqualSid(
        PSID pSid1,
        PSID pSid2);
__declspec(dllimport)
    BOOL
    __stdcall FindFirstFreeAce(
        PACL pAcl,
        LPVOID* pAce);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    PVOID
    __stdcall FreeSid(
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall GetAce(
        PACL pAcl,
        DWORD dwAceIndex,
        LPVOID* pAce);
__declspec(dllimport)
    BOOL
    __stdcall GetAclInformation(
        PACL pAcl,
        LPVOID pAclInformation,
        DWORD nAclInformationLength,
        ACL_INFORMATION_CLASS dwAclInformationClass);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetFileSecurityW(
        LPCWSTR lpFileName,
        SECURITY_INFORMATION RequestedInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD nLength,
        LPDWORD lpnLengthNeeded);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetKernelObjectSecurity(
        HANDLE Handle,
        SECURITY_INFORMATION RequestedInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD nLength,
        LPDWORD lpnLengthNeeded);
__declspec(dllimport)
    DWORD
    __stdcall GetLengthSid(
        PSID pSid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetPrivateObjectSecurity(
        PSECURITY_DESCRIPTOR ObjectDescriptor,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR ResultantDescriptor,
        DWORD DescriptorLength,
        PDWORD ReturnLength);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetSecurityDescriptorControl(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSECURITY_DESCRIPTOR_CONTROL pControl,
        LPDWORD lpdwRevision);
__declspec(dllimport)
    BOOL
    __stdcall GetSecurityDescriptorDacl(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        LPBOOL lpbDaclPresent,
        PACL* pDacl,
        LPBOOL lpbDaclDefaulted);
__declspec(dllimport)
    BOOL
    __stdcall GetSecurityDescriptorGroup(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID* pGroup,
        LPBOOL lpbGroupDefaulted);
__declspec(dllimport)
    DWORD
    __stdcall GetSecurityDescriptorLength(
        PSECURITY_DESCRIPTOR pSecurityDescriptor);
__declspec(dllimport)
    BOOL
    __stdcall GetSecurityDescriptorOwner(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID* pOwner,
        LPBOOL lpbOwnerDefaulted);
__declspec(dllimport)
    DWORD
    __stdcall GetSecurityDescriptorRMControl(
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PUCHAR RMControl);
__declspec(dllimport)
    BOOL
    __stdcall GetSecurityDescriptorSacl(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        LPBOOL lpbSaclPresent,
        PACL* pSacl,
        LPBOOL lpbSaclDefaulted);
__declspec(dllimport)
    PSID_IDENTIFIER_AUTHORITY
    __stdcall GetSidIdentifierAuthority(
        PSID pSid);
__declspec(dllimport)
    DWORD
    __stdcall GetSidLengthRequired(
        UCHAR nSubAuthorityCount);
__declspec(dllimport)
    PDWORD
    __stdcall GetSidSubAuthority(
        PSID pSid,
        DWORD nSubAuthority);
__declspec(dllimport)
    PUCHAR
    __stdcall GetSidSubAuthorityCount(
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall GetTokenInformation(
        HANDLE TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        LPVOID TokenInformation,
        DWORD TokenInformationLength,
        PDWORD ReturnLength);
__declspec(dllimport)
    BOOL
    __stdcall GetWindowsAccountDomainSid(
        PSID pSid,
        PSID pDomainSid,
        DWORD* cbDomainSid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall ImpersonateAnonymousToken(
        HANDLE ThreadHandle);
__declspec(dllimport)
    BOOL
    __stdcall ImpersonateLoggedOnUser(
        HANDLE hToken);
__declspec(dllimport)
    BOOL
    __stdcall ImpersonateSelf(
        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall InitializeAcl(
        PACL pAcl,
        DWORD nAclLength,
        DWORD dwAclRevision);
__declspec(dllimport)
    BOOL
    __stdcall InitializeSecurityDescriptor(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD dwRevision);
__declspec(dllimport)
    BOOL
    __stdcall InitializeSid(
        PSID Sid,
        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
        BYTE nSubAuthorityCount);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsTokenRestricted(
        HANDLE TokenHandle);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsValidAcl(
        PACL pAcl);
__declspec(dllimport)
    BOOL
    __stdcall IsValidSecurityDescriptor(
        PSECURITY_DESCRIPTOR pSecurityDescriptor);
__declspec(dllimport)
    BOOL
    __stdcall IsValidSid(
        PSID pSid);
__declspec(dllimport)
    BOOL
    __stdcall IsWellKnownSid(
        PSID pSid,
        WELL_KNOWN_SID_TYPE WellKnownSidType);
__declspec(dllimport)
    BOOL
    __stdcall MakeAbsoluteSD(
        PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
        PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
        LPDWORD lpdwAbsoluteSecurityDescriptorSize,
        PACL pDacl,
        LPDWORD lpdwDaclSize,
        PACL pSacl,
        LPDWORD lpdwSaclSize,
        PSID pOwner,
        LPDWORD lpdwOwnerSize,
        PSID pPrimaryGroup,
        LPDWORD lpdwPrimaryGroupSize);
__declspec(dllimport)
    BOOL
    __stdcall MakeSelfRelativeSD(
        PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
        PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
        LPDWORD lpdwBufferLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) void __stdcall MapGenericMask(
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping);
__declspec(dllimport)
    BOOL
    __stdcall ObjectCloseAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        BOOL GenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall ObjectDeleteAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        BOOL GenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall ObjectOpenAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        LPWSTR ObjectTypeName,
        LPWSTR ObjectName,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        DWORD GrantedAccess,
        PPRIVILEGE_SET Privileges,
        BOOL ObjectCreation,
        BOOL AccessGranted,
        LPBOOL GenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall ObjectPrivilegeAuditAlarmW(
        LPCWSTR SubsystemName,
        LPVOID HandleId,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        PPRIVILEGE_SET Privileges,
        BOOL AccessGranted);
__declspec(dllimport)
    BOOL
    __stdcall PrivilegeCheck(
        HANDLE ClientToken,
        PPRIVILEGE_SET RequiredPrivileges,
        LPBOOL pfResult);
__declspec(dllimport)
    BOOL
    __stdcall PrivilegedServiceAuditAlarmW(
        LPCWSTR SubsystemName,
        LPCWSTR ServiceName,
        HANDLE ClientToken,
        PPRIVILEGE_SET Privileges,
        BOOL AccessGranted);
__declspec(dllimport) void __stdcall QuerySecurityAccessMask(
    SECURITY_INFORMATION SecurityInformation,
    LPDWORD DesiredAccess);
__declspec(dllimport)
    BOOL
    __stdcall RevertToSelf(
        void);
__declspec(dllimport)
    BOOL
    __stdcall SetAclInformation(
        PACL pAcl,
        LPVOID pAclInformation,
        DWORD nAclInformationLength,
        ACL_INFORMATION_CLASS dwAclInformationClass);
__declspec(dllimport)
    BOOL
    __stdcall SetFileSecurityW(
        LPCWSTR lpFileName,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetKernelObjectSecurity(
        HANDLE Handle,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR SecurityDescriptor);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetPrivateObjectSecurity(
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR ModificationDescriptor,
        PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor,
        PGENERIC_MAPPING GenericMapping,
        HANDLE Token);
__declspec(dllimport)
    BOOL
    __stdcall SetPrivateObjectSecurityEx(
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR ModificationDescriptor,
        PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor,
        ULONG AutoInheritFlags,
        PGENERIC_MAPPING GenericMapping,
        HANDLE Token);
__declspec(dllimport) void __stdcall SetSecurityAccessMask(
    SECURITY_INFORMATION SecurityInformation,
    LPDWORD DesiredAccess);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetSecurityDescriptorControl(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
        SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet);
__declspec(dllimport)
    BOOL
    __stdcall SetSecurityDescriptorDacl(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        BOOL bDaclPresent,
        PACL pDacl,
        BOOL bDaclDefaulted);
__declspec(dllimport)
    BOOL
    __stdcall SetSecurityDescriptorGroup(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID pGroup,
        BOOL bGroupDefaulted);
__declspec(dllimport)
    BOOL
    __stdcall SetSecurityDescriptorOwner(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        PSID pOwner,
        BOOL bOwnerDefaulted);
__declspec(dllimport)
    DWORD
    __stdcall SetSecurityDescriptorRMControl(
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PUCHAR RMControl);
__declspec(dllimport)
    BOOL
    __stdcall SetSecurityDescriptorSacl(
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        BOOL bSaclPresent,
        PACL pSacl,
        BOOL bSaclDefaulted);
__declspec(dllimport)
    BOOL
    __stdcall SetTokenInformation(
        HANDLE TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        LPVOID TokenInformation,
        DWORD TokenInformationLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetCachedSigningLevel(
        PHANDLE SourceFiles,
        ULONG SourceFileCount,
        ULONG Flags,
        HANDLE TargetFile);
__declspec(dllimport)
    BOOL
    __stdcall GetCachedSigningLevel(
        HANDLE File,
        PULONG Flags,
        PULONG SigningLevel,
        PUCHAR Thumbprint,
        PULONG ThumbprintSize,
        PULONG ThumbprintAlgorithm);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LONG
    __stdcall CveEventWrite(
        PCWSTR CveId,
        PCWSTR AdditionalDetails);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DeriveCapabilitySidsFromName(
        LPCWSTR CapName,
        PSID** CapabilityGroupSids,
        DWORD* CapabilityGroupSidCount,
        PSID** CapabilitySids,
        DWORD* CapabilitySidCount);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall CreatePrivateNamespaceW(
        LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
        LPVOID lpBoundaryDescriptor,
        LPCWSTR lpAliasPrefix);
__declspec(dllimport)
    HANDLE
    __stdcall OpenPrivateNamespaceW(
        LPVOID lpBoundaryDescriptor,
        LPCWSTR lpAliasPrefix);
__declspec(dllimport)
    BOOLEAN
    __stdcall ClosePrivateNamespace(
        HANDLE Handle,
        ULONG Flags);
__declspec(dllimport)
    HANDLE
    __stdcall CreateBoundaryDescriptorW(
        LPCWSTR Name,
        ULONG Flags);
__declspec(dllimport)
    BOOL
    __stdcall AddSIDToBoundaryDescriptor(
        HANDLE* BoundaryDescriptor,
        PSID RequiredSid);
__declspec(dllimport) void __stdcall DeleteBoundaryDescriptor(
    HANDLE BoundaryDescriptor);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetNumaHighestNodeNumber(
        PULONG HighestNodeNumber);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetNumaNodeProcessorMaskEx(
        USHORT Node,
        PGROUP_AFFINITY ProcessorMask);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaNodeProcessorMask2(
        USHORT NodeNumber,
        PGROUP_AFFINITY ProcessorMasks,
        USHORT ProcessorMaskCount,
        PUSHORT RequiredMaskCount);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaProximityNodeEx(
        ULONG ProximityId,
        PUSHORT NodeNumber);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetProcessGroupAffinity(
        HANDLE hProcess,
        PUSHORT GroupCount,
        PUSHORT GroupArray);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetThreadGroupAffinity(
        HANDLE hThread,
        PGROUP_AFFINITY GroupAffinity);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadGroupAffinity(
        HANDLE hThread,
        const GROUP_AFFINITY* GroupAffinity,
        PGROUP_AFFINITY PreviousGroupAffinity);
#pragma endregion
}
#pragma once
#pragma region Desktop Family or OneCore Family
extern "C" {
BOOL __stdcall GetAppContainerNamedObjectPath(
    HANDLE Token,
    PSID AppContainerSid,
    ULONG ObjectPathLength,
    LPWSTR ObjectPath,
    PULONG ReturnLength);
}
#pragma endregion
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall QueryThreadCycleTime(
        HANDLE ThreadHandle,
        PULONG64 CycleTime);
__declspec(dllimport)
    BOOL
    __stdcall QueryProcessCycleTime(
        HANDLE ProcessHandle,
        PULONG64 CycleTime);
__declspec(dllimport)
    BOOL
    __stdcall QueryIdleProcessorCycleTime(
        PULONG BufferLength,
        PULONG64 ProcessorIdleCycleTime);
__declspec(dllimport)
    BOOL
    __stdcall QueryIdleProcessorCycleTimeEx(
        USHORT Group,
        PULONG BufferLength,
        PULONG64 ProcessorIdleCycleTime);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport) void __stdcall QueryInterruptTimePrecise(
    PULONGLONG lpInterruptTimePrecise);
__declspec(dllimport) void __stdcall QueryUnbiasedInterruptTimePrecise(
    PULONGLONG lpUnbiasedInterruptTimePrecise);
__declspec(dllimport) void __stdcall QueryInterruptTime(
    PULONGLONG lpInterruptTime);
__declspec(dllimport)
    BOOL
    __stdcall QueryUnbiasedInterruptTime(
        PULONGLONG UnbiasedTime);
__declspec(dllimport)
    HRESULT
    __stdcall QueryAuxiliaryCounterFrequency(
        PULONGLONG lpAuxiliaryCounterFrequency);
__declspec(dllimport)
    HRESULT
    __stdcall ConvertAuxiliaryCounterToPerformanceCounter(
        ULONGLONG ullAuxiliaryCounterValue,
        PULONGLONG lpPerformanceCounterValue,
        PULONGLONG lpConversionError);
__declspec(dllimport)
    HRESULT
    __stdcall ConvertPerformanceCounterToAuxiliaryCounter(
        ULONGLONG ullPerformanceCounterValue,
        PULONGLONG lpAuxiliaryCounterValue,
        PULONGLONG lpConversionError);
#pragma endregion
}
extern "C" {
#pragma region Application Family
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef void(__stdcall* PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter);
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
typedef LPVOID(__stdcall* PFIBER_CALLOUT_ROUTINE)(
    LPVOID lpParameter);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef LPVOID LPLDT_ENTRY;
typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP, *LPCOMMPROP;
typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
typedef struct _DCB {
    DWORD DCBlength;
    DWORD BaudRate;
    DWORD fBinary : 1;
    DWORD fParity : 1;
    DWORD fOutxCtsFlow : 1;
    DWORD fOutxDsrFlow : 1;
    DWORD fDtrControl : 2;
    DWORD fDsrSensitivity : 1;
    DWORD fTXContinueOnXoff : 1;
    DWORD fOutX : 1;
    DWORD fInX : 1;
    DWORD fErrorChar : 1;
    DWORD fNull : 1;
    DWORD fRtsControl : 2;
    DWORD fAbortOnError : 1;
    DWORD fDummy2 : 17;
    WORD wReserved;
    WORD XonLim;
    WORD XoffLim;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    WORD wReserved1;
} DCB, *LPDCB;
typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;
    DWORD ReadTotalTimeoutMultiplier;
    DWORD ReadTotalTimeoutConstant;
    DWORD WriteTotalTimeoutMultiplier;
    DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS, *LPCOMMTIMEOUTS;
typedef struct _COMMCONFIG {
    DWORD dwSize;
    WORD wVersion;
    WORD wReserved;
    DCB dcb;
    DWORD dwProviderSubType;
    DWORD dwProviderOffset;
    DWORD dwProviderSize;
    WCHAR wcProviderData[1];
} COMMCONFIG, *LPCOMMCONFIG;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#pragma endregion
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
#pragma endregion
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore or Games Family
#pragma endregion
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;
#pragma endregion
#pragma region Desktop Family
int __stdcall WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd);
int __stdcall wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR lpCmdLine,
    int nShowCmd);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) __declspec(allocator)
    HGLOBAL
    __stdcall GlobalAlloc(
        UINT uFlags,
        SIZE_T dwBytes);
#pragma endregion
#pragma region Application or Games Family
__declspec(dllimport) __declspec(allocator)
    HGLOBAL
    __stdcall GlobalReAlloc(
        HGLOBAL hMem,
        SIZE_T dwBytes,
        UINT uFlags);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport)
    SIZE_T
    __stdcall GlobalSize(
        HGLOBAL hMem);
__declspec(dllimport)
    BOOL
    __stdcall GlobalUnlock(
        HGLOBAL hMem);
__declspec(dllimport)
    LPVOID
    __stdcall GlobalLock(
        HGLOBAL hMem);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    UINT
    __stdcall GlobalFlags(
        HGLOBAL hMem);
__declspec(dllimport)
    HGLOBAL
    __stdcall GlobalHandle(
        LPCVOID pMem);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport)
    HGLOBAL
    __stdcall GlobalFree(
        HGLOBAL hMem);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    SIZE_T
    __stdcall GlobalCompact(
        DWORD dwMinFree);
__declspec(dllimport) void __stdcall GlobalFix(
    HGLOBAL hMem);
__declspec(dllimport) void __stdcall GlobalUnfix(
    HGLOBAL hMem);
__declspec(dllimport)
    LPVOID
    __stdcall GlobalWire(
        HGLOBAL hMem);
__declspec(dllimport)
    BOOL
    __stdcall GlobalUnWire(
        HGLOBAL hMem);
__declspec(dllimport) void __stdcall GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) __declspec(allocator)
    HLOCAL
    __stdcall LocalAlloc(
        UINT uFlags,
        SIZE_T uBytes);
__declspec(dllimport) __declspec(allocator)
    HLOCAL
    __stdcall LocalReAlloc(
        HLOCAL hMem,
        SIZE_T uBytes,
        UINT uFlags);
#pragma endregion
#pragma region Desktop Family or OneCore or Games Family
__declspec(dllimport)
    LPVOID
    __stdcall LocalLock(
        HLOCAL hMem);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HLOCAL
    __stdcall LocalHandle(
        LPCVOID pMem);
#pragma endregion
#pragma region Desktop Family or OneCore or Games Family
__declspec(dllimport)
    BOOL
    __stdcall LocalUnlock(
        HLOCAL hMem);
#pragma endregion
#pragma region Desktop or Games Family
__declspec(dllimport)
    SIZE_T
    __stdcall LocalSize(
        HLOCAL hMem);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    UINT
    __stdcall LocalFlags(
        HLOCAL hMem);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HLOCAL
    __stdcall LocalFree(
        HLOCAL hMem);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    SIZE_T
    __stdcall LocalShrink(
        HLOCAL hMem,
        UINT cbNewSize);
__declspec(dllimport)
    SIZE_T
    __stdcall LocalCompact(
        UINT uMinFree);
__declspec(dllimport)
    BOOL
    __stdcall GetBinaryTypeA(
        LPCSTR lpApplicationName,
        LPDWORD lpBinaryType);
__declspec(dllimport)
    BOOL
    __stdcall GetBinaryTypeW(
        LPCWSTR lpApplicationName,
        LPDWORD lpBinaryType);
__declspec(dllimport)
    DWORD
    __stdcall GetShortPathNameA(
        LPCSTR lpszLongPath,
        LPSTR lpszShortPath,
        DWORD cchBuffer);
__declspec(dllimport)
    DWORD
    __stdcall GetLongPathNameTransactedA(
        LPCSTR lpszShortPath,
        LPSTR lpszLongPath,
        DWORD cchBuffer,
        HANDLE hTransaction);
__declspec(dllimport)
    DWORD
    __stdcall GetLongPathNameTransactedW(
        LPCWSTR lpszShortPath,
        LPWSTR lpszLongPath,
        DWORD cchBuffer,
        HANDLE hTransaction);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetProcessAffinityMask(
        HANDLE hProcess,
        PDWORD_PTR lpProcessAffinityMask,
        PDWORD_PTR lpSystemAffinityMask);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessAffinityMask(
        HANDLE hProcess,
        DWORD_PTR dwProcessAffinityMask);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetProcessIoCounters(
        HANDLE hProcess,
        PIO_COUNTERS lpIoCounters);
__declspec(dllimport) void __stdcall FatalExit(
    int ExitCode);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetEnvironmentStringsA(
        LPCH NewEnvironment);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) void __stdcall SwitchToFiber(
    LPVOID lpFiber);
__declspec(dllimport) void __stdcall DeleteFiber(
    LPVOID lpFiber);
__declspec(dllimport)
    BOOL
    __stdcall ConvertFiberToThread(
        void);
__declspec(dllimport)
    LPVOID
    __stdcall CreateFiberEx(
        SIZE_T dwStackCommitSize,
        SIZE_T dwStackReserveSize,
        DWORD dwFlags,
        LPFIBER_START_ROUTINE lpStartAddress,
        LPVOID lpParameter);
__declspec(dllimport)
    LPVOID
    __stdcall ConvertThreadToFiberEx(
        LPVOID lpParameter,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    LPVOID
    __stdcall CreateFiber(
        SIZE_T dwStackSize,
        LPFIBER_START_ROUTINE lpStartAddress,
        LPVOID lpParameter);
__declspec(dllimport)
    LPVOID
    __stdcall ConvertThreadToFiber(
        LPVOID lpParameter);
#pragma endregion
#pragma region Desktop Family
typedef void* PUMS_CONTEXT;
typedef void* PUMS_COMPLETION_LIST;
typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;
typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;
typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;
typedef struct _UMS_SCHEDULER_STARTUP_INFO {
    ULONG UmsVersion;
    PUMS_COMPLETION_LIST CompletionList;
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
    PVOID SchedulerParam;
} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;
typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
    ULONG UmsVersion;
    union {
        struct {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
        };
        ULONG ThreadUmsFlags;
    };
} UMS_SYSTEM_THREAD_INFORMATION, *PUMS_SYSTEM_THREAD_INFORMATION;
__declspec(dllimport)
    BOOL
    __stdcall CreateUmsCompletionList(
        PUMS_COMPLETION_LIST* UmsCompletionList);
__declspec(dllimport)
    BOOL
    __stdcall DequeueUmsCompletionListItems(
        PUMS_COMPLETION_LIST UmsCompletionList,
        DWORD WaitTimeOut,
        PUMS_CONTEXT* UmsThreadList);
__declspec(dllimport)
    BOOL
    __stdcall GetUmsCompletionListEvent(
        PUMS_COMPLETION_LIST UmsCompletionList,
        PHANDLE UmsCompletionEvent);
__declspec(dllimport)
    BOOL
    __stdcall ExecuteUmsThread(
        PUMS_CONTEXT UmsThread);
__declspec(dllimport)
    BOOL
    __stdcall UmsThreadYield(
        PVOID SchedulerParam);
__declspec(dllimport)
    BOOL
    __stdcall DeleteUmsCompletionList(
        PUMS_COMPLETION_LIST UmsCompletionList);
__declspec(dllimport)
    PUMS_CONTEXT
    __stdcall GetCurrentUmsThread(
        void);
__declspec(dllimport)
    PUMS_CONTEXT
    __stdcall GetNextUmsListItem(
        PUMS_CONTEXT UmsContext);
__declspec(dllimport)
    BOOL
    __stdcall QueryUmsThreadInformation(
        PUMS_CONTEXT UmsThread,
        UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
        PVOID UmsThreadInformation,
        ULONG UmsThreadInformationLength,
        PULONG ReturnLength);
__declspec(dllimport)
    BOOL
    __stdcall SetUmsThreadInformation(
        PUMS_CONTEXT UmsThread,
        UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
        PVOID UmsThreadInformation,
        ULONG UmsThreadInformationLength);
__declspec(dllimport)
    BOOL
    __stdcall DeleteUmsThreadContext(
        PUMS_CONTEXT UmsThread);
__declspec(dllimport)
    BOOL
    __stdcall CreateUmsThreadContext(
        PUMS_CONTEXT* lpUmsThread);
__declspec(dllimport)
    BOOL
    __stdcall EnterUmsSchedulingMode(
        PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetUmsSystemThreadInformation(
        HANDLE ThreadHandle,
        PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD_PTR
    __stdcall SetThreadAffinityMask(
        HANDLE hThread,
        DWORD_PTR dwThreadAffinityMask);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetProcessDEPPolicy(
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessDEPPolicy(
        HANDLE hProcess,
        LPDWORD lpFlags,
        PBOOL lpPermanent);
__declspec(dllimport)
    BOOL
    __stdcall RequestWakeupLatency(
        LATENCY_TIME latency);
__declspec(dllimport)
    BOOL
    __stdcall IsSystemResumeAutomatic(
        void);
__declspec(dllimport)
    BOOL
    __stdcall GetThreadSelectorEntry(
        HANDLE hThread,
        DWORD dwSelector,
        LPLDT_ENTRY lpSelectorEntry);
__declspec(dllimport)
    EXECUTION_STATE
    __stdcall SetThreadExecutionState(
        EXECUTION_STATE esFlags);
typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;
__declspec(dllimport)
    HANDLE
    __stdcall PowerCreateRequest(
        PREASON_CONTEXT Context);
__declspec(dllimport)
    BOOL
    __stdcall PowerSetRequest(
        HANDLE PowerRequest,
        POWER_REQUEST_TYPE RequestType);
__declspec(dllimport)
    BOOL
    __stdcall PowerClearRequest(
        HANDLE PowerRequest,
        POWER_REQUEST_TYPE RequestType);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Desktop or Games Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetFileCompletionNotificationModes(
        HANDLE FileHandle,
        UCHAR Flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall Wow64GetThreadSelectorEntry(
        HANDLE hThread,
        DWORD dwSelector,
        PWOW64_LDT_ENTRY lpSelectorEntry);
__declspec(dllimport)
    BOOL
    __stdcall DebugSetProcessKillOnExit(
        BOOL KillOnExit);
__declspec(dllimport)
    BOOL
    __stdcall DebugBreakProcess(
        HANDLE Process);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall PulseEvent(
        HANDLE hEvent);
__declspec(dllimport)
    ATOM
    __stdcall GlobalDeleteAtom(
        ATOM nAtom);
__declspec(dllimport)
    BOOL
    __stdcall InitAtomTable(
        DWORD nSize);
__declspec(dllimport)
    ATOM
    __stdcall DeleteAtom(
        ATOM nAtom);
__declspec(dllimport)
    UINT
    __stdcall SetHandleCount(
        UINT uNumber);
__declspec(dllimport)
    BOOL
    __stdcall RequestDeviceWakeup(
        HANDLE hDevice);
__declspec(dllimport)
    BOOL
    __stdcall CancelDeviceWakeupRequest(
        HANDLE hDevice);
__declspec(dllimport)
    BOOL
    __stdcall GetDevicePowerState(
        HANDLE hDevice,
        BOOL* pfOn);
__declspec(dllimport)
    BOOL
    __stdcall SetMessageWaitingIndicator(
        HANDLE hMsgIndicator,
        ULONG ulMsgCount);
__declspec(dllimport)
    BOOL
    __stdcall SetFileShortNameA(
        HANDLE hFile,
        LPCSTR lpShortName);
__declspec(dllimport)
    BOOL
    __stdcall SetFileShortNameW(
        HANDLE hFile,
        LPCWSTR lpShortName);
#pragma endregion
#pragma region Desktop Family or Games Family
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall LoadModule(
        LPCSTR lpModuleName,
        LPVOID lpParameterBlock);
__declspec(dllimport)
    UINT
    __stdcall WinExec(
        LPCSTR lpCmdLine,
        UINT uCmdShow);
#pragma endregion
#pragma region Desktop Family or OneCore or App Family
__declspec(dllimport)
    BOOL
    __stdcall ClearCommBreak(
        HANDLE hFile);
__declspec(dllimport)
    BOOL
    __stdcall ClearCommError(
        HANDLE hFile,
        LPDWORD lpErrors,
        LPCOMSTAT lpStat);
__declspec(dllimport)
    BOOL
    __stdcall SetupComm(
        HANDLE hFile,
        DWORD dwInQueue,
        DWORD dwOutQueue);
__declspec(dllimport)
    BOOL
    __stdcall EscapeCommFunction(
        HANDLE hFile,
        DWORD dwFunc);
__declspec(dllimport)
    BOOL
    __stdcall GetCommConfig(
        HANDLE hCommDev,
        LPCOMMCONFIG lpCC,
        LPDWORD lpdwSize);
__declspec(dllimport)
    BOOL
    __stdcall GetCommMask(
        HANDLE hFile,
        LPDWORD lpEvtMask);
__declspec(dllimport)
    BOOL
    __stdcall GetCommProperties(
        HANDLE hFile,
        LPCOMMPROP lpCommProp);
__declspec(dllimport)
    BOOL
    __stdcall GetCommModemStatus(
        HANDLE hFile,
        LPDWORD lpModemStat);
__declspec(dllimport)
    BOOL
    __stdcall GetCommState(
        HANDLE hFile,
        LPDCB lpDCB);
__declspec(dllimport)
    BOOL
    __stdcall GetCommTimeouts(
        HANDLE hFile,
        LPCOMMTIMEOUTS lpCommTimeouts);
__declspec(dllimport)
    BOOL
    __stdcall PurgeComm(
        HANDLE hFile,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall SetCommBreak(
        HANDLE hFile);
__declspec(dllimport)
    BOOL
    __stdcall SetCommConfig(
        HANDLE hCommDev,
        LPCOMMCONFIG lpCC,
        DWORD dwSize);
__declspec(dllimport)
    BOOL
    __stdcall SetCommMask(
        HANDLE hFile,
        DWORD dwEvtMask);
__declspec(dllimport)
    BOOL
    __stdcall SetCommState(
        HANDLE hFile,
        LPDCB lpDCB);
__declspec(dllimport)
    BOOL
    __stdcall SetCommTimeouts(
        HANDLE hFile,
        LPCOMMTIMEOUTS lpCommTimeouts);
__declspec(dllimport)
    BOOL
    __stdcall TransmitCommChar(
        HANDLE hFile,
        char cChar);
__declspec(dllimport)
    BOOL
    __stdcall WaitCommEvent(
        HANDLE hFile,
        LPDWORD lpEvtMask,
        LPOVERLAPPED lpOverlapped);
__declspec(dllimport)
    HANDLE
    __stdcall OpenCommPort(
        ULONG uPortNumber,
        DWORD dwDesiredAccess,
        DWORD dwFlagsAndAttributes);
__declspec(dllimport)
    ULONG
    __stdcall GetCommPorts(
        PULONG lpPortNumbers,
        ULONG uPortNumbersCount,
        PULONG puPortNumbersFound);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall SetTapePosition(
        HANDLE hDevice,
        DWORD dwPositionMethod,
        DWORD dwPartition,
        DWORD dwOffsetLow,
        DWORD dwOffsetHigh,
        BOOL bImmediate);
__declspec(dllimport)
    DWORD
    __stdcall GetTapePosition(
        HANDLE hDevice,
        DWORD dwPositionType,
        LPDWORD lpdwPartition,
        LPDWORD lpdwOffsetLow,
        LPDWORD lpdwOffsetHigh);
__declspec(dllimport)
    DWORD
    __stdcall PrepareTape(
        HANDLE hDevice,
        DWORD dwOperation,
        BOOL bImmediate);
__declspec(dllimport)
    DWORD
    __stdcall EraseTape(
        HANDLE hDevice,
        DWORD dwEraseType,
        BOOL bImmediate);
__declspec(dllimport)
    DWORD
    __stdcall CreateTapePartition(
        HANDLE hDevice,
        DWORD dwPartitionMethod,
        DWORD dwCount,
        DWORD dwSize);
__declspec(dllimport)
    DWORD
    __stdcall WriteTapemark(
        HANDLE hDevice,
        DWORD dwTapemarkType,
        DWORD dwTapemarkCount,
        BOOL bImmediate);
__declspec(dllimport)
    DWORD
    __stdcall GetTapeStatus(
        HANDLE hDevice);
__declspec(dllimport)
    DWORD
    __stdcall GetTapeParameters(
        HANDLE hDevice,
        DWORD dwOperation,
        LPDWORD lpdwSize,
        LPVOID lpTapeInformation);
__declspec(dllimport)
    DWORD
    __stdcall SetTapeParameters(
        HANDLE hDevice,
        DWORD dwOperation,
        LPVOID lpTapeInformation);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) int __stdcall MulDiv(
    int nNumber,
    int nNumerator,
    int nDenominator);
#pragma endregion
#pragma region Desktop Family
typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;
__declspec(dllimport)
    DEP_SYSTEM_POLICY_TYPE
    __stdcall GetSystemDEPPolicy(
        void);
__declspec(dllimport)
    BOOL
    __stdcall GetSystemRegistryQuota(
        PDWORD pdwQuotaAllowed,
        PDWORD pdwQuotaUsed);
__declspec(dllimport)
    BOOL
    __stdcall FileTimeToDosDateTime(
        const FILETIME* lpFileTime,
        LPWORD lpFatDate,
        LPWORD lpFatTime);
__declspec(dllimport)
    BOOL
    __stdcall DosDateTimeToFileTime(
        WORD wFatDate,
        WORD wFatTime,
        LPFILETIME lpFileTime);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall FormatMessageA(
        DWORD dwFlags,
        LPCVOID lpSource,
        DWORD dwMessageId,
        DWORD dwLanguageId,
        LPSTR lpBuffer,
        DWORD nSize,
        va_list* Arguments);
__declspec(dllimport)
    DWORD
    __stdcall FormatMessageW(
        DWORD dwFlags,
        LPCVOID lpSource,
        DWORD dwMessageId,
        DWORD dwLanguageId,
        LPWSTR lpBuffer,
        DWORD nSize,
        va_list* Arguments);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateMailslotA(
        LPCSTR lpName,
        DWORD nMaxMessageSize,
        DWORD lReadTimeout,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    HANDLE
    __stdcall CreateMailslotW(
        LPCWSTR lpName,
        DWORD nMaxMessageSize,
        DWORD lReadTimeout,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    BOOL
    __stdcall GetMailslotInfo(
        HANDLE hMailslot,
        LPDWORD lpMaxMessageSize,
        LPDWORD lpNextSize,
        LPDWORD lpMessageCount,
        LPDWORD lpReadTimeout);
__declspec(dllimport)
    BOOL
    __stdcall SetMailslotInfo(
        HANDLE hMailslot,
        DWORD lReadTimeout);
__declspec(dllimport)
    BOOL
    __stdcall EncryptFileA(
        LPCSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall EncryptFileW(
        LPCWSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall DecryptFileA(
        LPCSTR lpFileName,
        DWORD dwReserved);
__declspec(dllimport)
    BOOL
    __stdcall DecryptFileW(
        LPCWSTR lpFileName,
        DWORD dwReserved);
__declspec(dllimport)
    BOOL
    __stdcall FileEncryptionStatusA(
        LPCSTR lpFileName,
        LPDWORD lpStatus);
__declspec(dllimport)
    BOOL
    __stdcall FileEncryptionStatusW(
        LPCWSTR lpFileName,
        LPDWORD lpStatus);
typedef DWORD(__stdcall* PFE_EXPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    ULONG ulLength);
typedef DWORD(__stdcall* PFE_IMPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    PULONG ulLength);
__declspec(dllimport)
    DWORD
    __stdcall OpenEncryptedFileRawA(
        LPCSTR lpFileName,
        ULONG ulFlags,
        PVOID* pvContext);
__declspec(dllimport)
    DWORD
    __stdcall OpenEncryptedFileRawW(
        LPCWSTR lpFileName,
        ULONG ulFlags,
        PVOID* pvContext);
__declspec(dllimport)
    DWORD
    __stdcall ReadEncryptedFileRaw(
        PFE_EXPORT_FUNC pfExportCallback,
        PVOID pvCallbackContext,
        PVOID pvContext);
__declspec(dllimport)
    DWORD
    __stdcall WriteEncryptedFileRaw(
        PFE_IMPORT_FUNC pfImportCallback,
        PVOID pvCallbackContext,
        PVOID pvContext);
__declspec(dllimport) void __stdcall CloseEncryptedFileRaw(
    PVOID pvContext);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport) int __stdcall lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2);
__declspec(dllimport) int __stdcall lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2);
__declspec(dllimport) int __stdcall lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2);
__declspec(dllimport) int __stdcall lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2);
#pragma endregion
#pragma region Desktop Family or OneCore Family
#pragma warning(push)
#pragma warning(disable : 4995)
__declspec(dllimport)
    LPSTR
    __stdcall lstrcpynA(
        LPSTR lpString1,
        LPCSTR lpString2,
        int iMaxLength);
__declspec(dllimport)
    LPWSTR
    __stdcall lstrcpynW(
        LPWSTR lpString1,
        LPCWSTR lpString2,
        int iMaxLength);
__declspec(dllimport)
    LPSTR
    __stdcall lstrcpyA(
        LPSTR lpString1,
        LPCSTR lpString2);
__declspec(dllimport)
    LPWSTR
    __stdcall lstrcpyW(
        LPWSTR lpString1,
        LPCWSTR lpString2);
__declspec(dllimport)
    LPSTR
    __stdcall lstrcatA(
        LPSTR lpString1,
        LPCSTR lpString2);
__declspec(dllimport)
    LPWSTR
    __stdcall lstrcatW(
        LPWSTR lpString1,
        LPCWSTR lpString2);
#pragma warning(pop)
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport) int __stdcall lstrlenA(
    LPCSTR lpString);
__declspec(dllimport) int __stdcall lstrlenW(
    LPCWSTR lpString);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HFILE
    __stdcall OpenFile(
        LPCSTR lpFileName,
        LPOFSTRUCT lpReOpenBuff,
        UINT uStyle);
__declspec(dllimport)
    HFILE
    __stdcall _lopen(
        LPCSTR lpPathName,
        int iReadWrite);
__declspec(dllimport)
    HFILE
    __stdcall _lcreat(
        LPCSTR lpPathName,
        int iAttribute);
__declspec(dllimport)
    UINT
    __stdcall _lread(
        HFILE hFile,
        LPVOID lpBuffer,
        UINT uBytes);
__declspec(dllimport)
    UINT
    __stdcall _lwrite(
        HFILE hFile,
        LPCCH lpBuffer,
        UINT uBytes);
__declspec(dllimport) long __stdcall _hread(
    HFILE hFile,
    LPVOID lpBuffer,
    long lBytes);
__declspec(dllimport) long __stdcall _hwrite(
    HFILE hFile,
    LPCCH lpBuffer,
    long lBytes);
__declspec(dllimport)
    HFILE
    __stdcall _lclose(
        HFILE hFile);
__declspec(dllimport)
    LONG
    __stdcall _llseek(
        HFILE hFile,
        LONG lOffset,
        int iOrigin);
__declspec(dllimport)
    BOOL
    __stdcall IsTextUnicode(
        const void* lpv,
        int iSize,
        LPINT lpiResult);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD
    __stdcall SignalObjectAndWait(
        HANDLE hObjectToSignal,
        HANDLE hObjectToWaitOn,
        DWORD dwMilliseconds,
        BOOL bAlertable);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall BackupRead(
        HANDLE hFile,
        LPBYTE lpBuffer,
        DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
        BOOL bAbort,
        BOOL bProcessSecurity,
        LPVOID* lpContext);
__declspec(dllimport)
    BOOL
    __stdcall BackupSeek(
        HANDLE hFile,
        DWORD dwLowBytesToSeek,
        DWORD dwHighBytesToSeek,
        LPDWORD lpdwLowByteSeeked,
        LPDWORD lpdwHighByteSeeked,
        LPVOID* lpContext);
__declspec(dllimport)
    BOOL
    __stdcall BackupWrite(
        HANDLE hFile,
        LPBYTE lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPDWORD lpNumberOfBytesWritten,
        BOOL bAbort,
        BOOL bProcessSecurity,
        LPVOID* lpContext);
typedef struct _WIN32_STREAM_ID {
    DWORD dwStreamId;
    DWORD dwStreamAttributes;
    LARGE_INTEGER Size;
    DWORD dwStreamNameSize;
    WCHAR cStreamName[1];
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID;
#pragma endregion
#pragma region Desktop Family or Games Family
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;
typedef STARTUPINFOEXW STARTUPINFOEX;
typedef LPSTARTUPINFOEXW LPSTARTUPINFOEX;
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall OpenMutexA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall CreateSemaphoreA(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
        LONG lInitialCount,
        LONG lMaximumCount,
        LPCSTR lpName);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall OpenSemaphoreA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateWaitableTimerA(
        LPSECURITY_ATTRIBUTES lpTimerAttributes,
        BOOL bManualReset,
        LPCSTR lpTimerName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenWaitableTimerA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpTimerName);
__declspec(dllimport)
    HANDLE
    __stdcall CreateSemaphoreExA(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
        LONG lInitialCount,
        LONG lMaximumCount,
        LPCSTR lpName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    HANDLE
    __stdcall CreateWaitableTimerExA(
        LPSECURITY_ATTRIBUTES lpTimerAttributes,
        LPCSTR lpTimerName,
        DWORD dwFlags,
        DWORD dwDesiredAccess);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileMappingA(
        HANDLE hFile,
        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
        DWORD flProtect,
        DWORD dwMaximumSizeHigh,
        DWORD dwMaximumSizeLow,
        LPCSTR lpName);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileMappingNumaA(
        HANDLE hFile,
        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
        DWORD flProtect,
        DWORD dwMaximumSizeHigh,
        DWORD dwMaximumSizeLow,
        LPCSTR lpName,
        DWORD nndPreferred);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall OpenFileMappingA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall GetLogicalDriveStringsA(
        DWORD nBufferLength,
        LPSTR lpBuffer);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HMODULE
    __stdcall LoadPackagedLibrary(
        LPCWSTR lpwLibFileName,
        DWORD Reserved);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall QueryFullProcessImageNameA(
        HANDLE hProcess,
        DWORD dwFlags,
        LPSTR lpExeName,
        PDWORD lpdwSize);
__declspec(dllimport)
    BOOL
    __stdcall QueryFullProcessImageNameW(
        HANDLE hProcess,
        DWORD dwFlags,
        LPWSTR lpExeName,
        PDWORD lpdwSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,
    ProcThreadAttributeSecurityCapabilities = 9,
    ProcThreadAttributeProtectionLevel = 11,
    ProcThreadAttributeJobList = 13,
    ProcThreadAttributeChildProcessPolicy = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter = 16,
    ProcThreadAttributeSafeOpenPromptOriginClaim = 17,
    ProcThreadAttributeDesktopAppPolicy = 18,
    ProcThreadAttributePseudoConsole = 22,
    ProcThreadAttributeMitigationAuditPolicy = 24,
    ProcThreadAttributeMachineType = 25,
    ProcThreadAttributeComponentFilter = 26,
    ProcThreadAttributeEnableOptionalXStateFeatures = 27,
} PROC_THREAD_ATTRIBUTE_NUM;
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport) void __stdcall GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region OneCore Family or App Family
__declspec(dllimport)
    DWORD
    __stdcall GetFirmwareEnvironmentVariableA(
        LPCSTR lpName,
        LPCSTR lpGuid,
        PVOID pBuffer,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetFirmwareEnvironmentVariableW(
        LPCWSTR lpName,
        LPCWSTR lpGuid,
        PVOID pBuffer,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetFirmwareEnvironmentVariableExA(
        LPCSTR lpName,
        LPCSTR lpGuid,
        PVOID pBuffer,
        DWORD nSize,
        PDWORD pdwAttribubutes);
__declspec(dllimport)
    DWORD
    __stdcall GetFirmwareEnvironmentVariableExW(
        LPCWSTR lpName,
        LPCWSTR lpGuid,
        PVOID pBuffer,
        DWORD nSize,
        PDWORD pdwAttribubutes);
__declspec(dllimport)
    BOOL
    __stdcall SetFirmwareEnvironmentVariableA(
        LPCSTR lpName,
        LPCSTR lpGuid,
        PVOID pValue,
        DWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall SetFirmwareEnvironmentVariableW(
        LPCWSTR lpName,
        LPCWSTR lpGuid,
        PVOID pValue,
        DWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall SetFirmwareEnvironmentVariableExA(
        LPCSTR lpName,
        LPCSTR lpGuid,
        PVOID pValue,
        DWORD nSize,
        DWORD dwAttributes);
__declspec(dllimport)
    BOOL
    __stdcall SetFirmwareEnvironmentVariableExW(
        LPCWSTR lpName,
        LPCWSTR lpGuid,
        PVOID pValue,
        DWORD nSize,
        DWORD dwAttributes);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetFirmwareType(
        PFIRMWARE_TYPE FirmwareType);
__declspec(dllimport)
    BOOL
    __stdcall IsNativeVhdBoot(
        PBOOL NativeVhdBoot);
__declspec(dllimport)
    HRSRC
    __stdcall FindResourceA(
        HMODULE hModule,
        LPCSTR lpName,
        LPCSTR lpType);
__declspec(dllimport)
    HRSRC
    __stdcall FindResourceExA(
        HMODULE hModule,
        LPCSTR lpType,
        LPCSTR lpName,
        WORD wLanguage);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceTypesA(
        HMODULE hModule,
        ENUMRESTYPEPROCA lpEnumFunc,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceTypesW(
        HMODULE hModule,
        ENUMRESTYPEPROCW lpEnumFunc,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceLanguagesA(
        HMODULE hModule,
        LPCSTR lpType,
        LPCSTR lpName,
        ENUMRESLANGPROCA lpEnumFunc,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumResourceLanguagesW(
        HMODULE hModule,
        LPCWSTR lpType,
        LPCWSTR lpName,
        ENUMRESLANGPROCW lpEnumFunc,
        LONG_PTR lParam);
__declspec(dllimport)
    HANDLE
    __stdcall BeginUpdateResourceA(
        LPCSTR pFileName,
        BOOL bDeleteExistingResources);
__declspec(dllimport)
    HANDLE
    __stdcall BeginUpdateResourceW(
        LPCWSTR pFileName,
        BOOL bDeleteExistingResources);
__declspec(dllimport)
    BOOL
    __stdcall UpdateResourceA(
        HANDLE hUpdate,
        LPCSTR lpType,
        LPCSTR lpName,
        WORD wLanguage,
        LPVOID lpData,
        DWORD cb);
__declspec(dllimport)
    BOOL
    __stdcall UpdateResourceW(
        HANDLE hUpdate,
        LPCWSTR lpType,
        LPCWSTR lpName,
        WORD wLanguage,
        LPVOID lpData,
        DWORD cb);
__declspec(dllimport)
    BOOL
    __stdcall EndUpdateResourceA(
        HANDLE hUpdate,
        BOOL fDiscard);
__declspec(dllimport)
    BOOL
    __stdcall EndUpdateResourceW(
        HANDLE hUpdate,
        BOOL fDiscard);
__declspec(dllimport)
    ATOM
    __stdcall GlobalAddAtomA(
        LPCSTR lpString);
__declspec(dllimport)
    ATOM
    __stdcall GlobalAddAtomW(
        LPCWSTR lpString);
__declspec(dllimport)
    ATOM
    __stdcall GlobalAddAtomExA(
        LPCSTR lpString,
        DWORD Flags);
__declspec(dllimport)
    ATOM
    __stdcall GlobalAddAtomExW(
        LPCWSTR lpString,
        DWORD Flags);
__declspec(dllimport)
    ATOM
    __stdcall GlobalFindAtomA(
        LPCSTR lpString);
__declspec(dllimport)
    ATOM
    __stdcall GlobalFindAtomW(
        LPCWSTR lpString);
__declspec(dllimport)
    UINT
    __stdcall GlobalGetAtomNameA(
        ATOM nAtom,
        LPSTR lpBuffer,
        int nSize);
__declspec(dllimport)
    UINT
    __stdcall GlobalGetAtomNameW(
        ATOM nAtom,
        LPWSTR lpBuffer,
        int nSize);
__declspec(dllimport)
    ATOM
    __stdcall AddAtomA(
        LPCSTR lpString);
__declspec(dllimport)
    ATOM
    __stdcall AddAtomW(
        LPCWSTR lpString);
__declspec(dllimport)
    ATOM
    __stdcall FindAtomA(
        LPCSTR lpString);
__declspec(dllimport)
    ATOM
    __stdcall FindAtomW(
        LPCWSTR lpString);
__declspec(dllimport)
    UINT
    __stdcall GetAtomNameA(
        ATOM nAtom,
        LPSTR lpBuffer,
        int nSize);
__declspec(dllimport)
    UINT
    __stdcall GetAtomNameW(
        ATOM nAtom,
        LPWSTR lpBuffer,
        int nSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetProfileIntA(
        LPCSTR lpAppName,
        LPCSTR lpKeyName,
        INT nDefault);
__declspec(dllimport)
    UINT
    __stdcall GetProfileIntW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT nDefault);
__declspec(dllimport)
    DWORD
    __stdcall GetProfileStringA(
        LPCSTR lpAppName,
        LPCSTR lpKeyName,
        LPCSTR lpDefault,
        LPSTR lpReturnedString,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetProfileStringW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpDefault,
        LPWSTR lpReturnedString,
        DWORD nSize);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall WriteProfileStringA(
        LPCSTR lpAppName,
        LPCSTR lpKeyName,
        LPCSTR lpString);
__declspec(dllimport)
    BOOL
    __stdcall WriteProfileStringW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpString);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall GetProfileSectionA(
        LPCSTR lpAppName,
        LPSTR lpReturnedString,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetProfileSectionW(
        LPCWSTR lpAppName,
        LPWSTR lpReturnedString,
        DWORD nSize);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall WriteProfileSectionA(
        LPCSTR lpAppName,
        LPCSTR lpString);
__declspec(dllimport)
    BOOL
    __stdcall WriteProfileSectionW(
        LPCWSTR lpAppName,
        LPCWSTR lpString);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetPrivateProfileIntA(
        LPCSTR lpAppName,
        LPCSTR lpKeyName,
        INT nDefault,
        LPCSTR lpFileName);
__declspec(dllimport)
    UINT
    __stdcall GetPrivateProfileIntW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT nDefault,
        LPCWSTR lpFileName);
__declspec(dllimport)
    DWORD
    __stdcall GetPrivateProfileStringA(
        LPCSTR lpAppName,
        LPCSTR lpKeyName,
        LPCSTR lpDefault,
        LPSTR lpReturnedString,
        DWORD nSize,
        LPCSTR lpFileName);
__declspec(dllimport)
    DWORD
    __stdcall GetPrivateProfileStringW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpDefault,
        LPWSTR lpReturnedString,
        DWORD nSize,
        LPCWSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall WritePrivateProfileStringA(
        LPCSTR lpAppName,
        LPCSTR lpKeyName,
        LPCSTR lpString,
        LPCSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall WritePrivateProfileStringW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpString,
        LPCWSTR lpFileName);
__declspec(dllimport)
    DWORD
    __stdcall GetPrivateProfileSectionA(
        LPCSTR lpAppName,
        LPSTR lpReturnedString,
        DWORD nSize,
        LPCSTR lpFileName);
__declspec(dllimport)
    DWORD
    __stdcall GetPrivateProfileSectionW(
        LPCWSTR lpAppName,
        LPWSTR lpReturnedString,
        DWORD nSize,
        LPCWSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall WritePrivateProfileSectionA(
        LPCSTR lpAppName,
        LPCSTR lpString,
        LPCSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall WritePrivateProfileSectionW(
        LPCWSTR lpAppName,
        LPCWSTR lpString,
        LPCWSTR lpFileName);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall GetPrivateProfileSectionNamesA(
        LPSTR lpszReturnBuffer,
        DWORD nSize,
        LPCSTR lpFileName);
__declspec(dllimport)
    DWORD
    __stdcall GetPrivateProfileSectionNamesW(
        LPWSTR lpszReturnBuffer,
        DWORD nSize,
        LPCWSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall GetPrivateProfileStructA(
        LPCSTR lpszSection,
        LPCSTR lpszKey,
        LPVOID lpStruct,
        UINT uSizeStruct,
        LPCSTR szFile);
__declspec(dllimport)
    BOOL
    __stdcall GetPrivateProfileStructW(
        LPCWSTR lpszSection,
        LPCWSTR lpszKey,
        LPVOID lpStruct,
        UINT uSizeStruct,
        LPCWSTR szFile);
__declspec(dllimport)
    BOOL
    __stdcall WritePrivateProfileStructA(
        LPCSTR lpszSection,
        LPCSTR lpszKey,
        LPVOID lpStruct,
        UINT uSizeStruct,
        LPCSTR szFile);
__declspec(dllimport)
    BOOL
    __stdcall WritePrivateProfileStructW(
        LPCWSTR lpszSection,
        LPCWSTR lpszKey,
        LPVOID lpStruct,
        UINT uSizeStruct,
        LPCWSTR szFile);
typedef UINT(__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_A)(LPSTR lpBuffer, UINT uSize);
typedef UINT(__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_W)(LPWSTR lpBuffer, UINT uSize);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall SetDllDirectoryA(
        LPCSTR lpPathName);
__declspec(dllimport)
    BOOL
    __stdcall SetDllDirectoryW(
        LPCWSTR lpPathName);
__declspec(dllimport)
    DWORD
    __stdcall GetDllDirectoryA(
        DWORD nBufferLength,
        LPSTR lpBuffer);
__declspec(dllimport)
    DWORD
    __stdcall GetDllDirectoryW(
        DWORD nBufferLength,
        LPWSTR lpBuffer);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetSearchPathMode(
        DWORD Flags);
#pragma endregion
#pragma region Application Family or Games Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryExA(
        LPCSTR lpTemplateDirectory,
        LPCSTR lpNewDirectory,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryExW(
        LPCWSTR lpTemplateDirectory,
        LPCWSTR lpNewDirectory,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryTransactedA(
        LPCSTR lpTemplateDirectory,
        LPCSTR lpNewDirectory,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall CreateDirectoryTransactedW(
        LPCWSTR lpTemplateDirectory,
        LPCWSTR lpNewDirectory,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall RemoveDirectoryTransactedA(
        LPCSTR lpPathName,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall RemoveDirectoryTransactedW(
        LPCWSTR lpPathName,
        HANDLE hTransaction);
__declspec(dllimport)
    DWORD
    __stdcall GetFullPathNameTransactedA(
        LPCSTR lpFileName,
        DWORD nBufferLength,
        LPSTR lpBuffer,
        LPSTR* lpFilePart,
        HANDLE hTransaction);
__declspec(dllimport)
    DWORD
    __stdcall GetFullPathNameTransactedW(
        LPCWSTR lpFileName,
        DWORD nBufferLength,
        LPWSTR lpBuffer,
        LPWSTR* lpFilePart,
        HANDLE hTransaction);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DefineDosDeviceA(
        DWORD dwFlags,
        LPCSTR lpDeviceName,
        LPCSTR lpTargetPath);
__declspec(dllimport)
    DWORD
    __stdcall QueryDosDeviceA(
        LPCSTR lpDeviceName,
        LPSTR lpTargetPath,
        DWORD ucchMax);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileTransactedA(
        LPCSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile,
        HANDLE hTransaction,
        PUSHORT pusMiniVersion,
        PVOID lpExtendedParameter);
__declspec(dllimport)
    HANDLE
    __stdcall CreateFileTransactedW(
        LPCWSTR lpFileName,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile,
        HANDLE hTransaction,
        PUSHORT pusMiniVersion,
        PVOID lpExtendedParameter);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall ReOpenFile(
        HANDLE hOriginalFile,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        DWORD dwFlagsAndAttributes);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetFileAttributesTransactedA(
        LPCSTR lpFileName,
        DWORD dwFileAttributes,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall SetFileAttributesTransactedW(
        LPCWSTR lpFileName,
        DWORD dwFileAttributes,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall GetFileAttributesTransactedA(
        LPCSTR lpFileName,
        GET_FILEEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFileInformation,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall GetFileAttributesTransactedW(
        LPCWSTR lpFileName,
        GET_FILEEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFileInformation,
        HANDLE hTransaction);
__declspec(dllimport)
    DWORD
    __stdcall GetCompressedFileSizeTransactedA(
        LPCSTR lpFileName,
        LPDWORD lpFileSizeHigh,
        HANDLE hTransaction);
__declspec(dllimport)
    DWORD
    __stdcall GetCompressedFileSizeTransactedW(
        LPCWSTR lpFileName,
        LPDWORD lpFileSizeHigh,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall DeleteFileTransactedA(
        LPCSTR lpFileName,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall DeleteFileTransactedW(
        LPCWSTR lpFileName,
        HANDLE hTransaction);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CheckNameLegalDOS8Dot3A(
        LPCSTR lpName,
        LPSTR lpOemName,
        DWORD OemNameSize,
        PBOOL pbNameContainsSpaces,
        PBOOL pbNameLegal);
__declspec(dllimport)
    BOOL
    __stdcall CheckNameLegalDOS8Dot3W(
        LPCWSTR lpName,
        LPSTR lpOemName,
        DWORD OemNameSize,
        PBOOL pbNameContainsSpaces,
        PBOOL pbNameLegal);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileTransactedA(
        LPCSTR lpFileName,
        FINDEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFindFileData,
        FINDEX_SEARCH_OPS fSearchOp,
        LPVOID lpSearchFilter,
        DWORD dwAdditionalFlags,
        HANDLE hTransaction);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileTransactedW(
        LPCWSTR lpFileName,
        FINDEX_INFO_LEVELS fInfoLevelId,
        LPVOID lpFindFileData,
        FINDEX_SEARCH_OPS fSearchOp,
        LPVOID lpSearchFilter,
        DWORD dwAdditionalFlags,
        HANDLE hTransaction);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall CopyFileA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName,
        BOOL bFailIfExists);
__declspec(dllimport)
    BOOL
    __stdcall CopyFileW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        BOOL bFailIfExists);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
typedef DWORD(__stdcall* LPPROGRESS_ROUTINE)(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData);
__declspec(dllimport)
    BOOL
    __stdcall CopyFileExA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        LPBOOL pbCancel,
        DWORD dwCopyFlags);
__declspec(dllimport)
    BOOL
    __stdcall CopyFileExW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        LPBOOL pbCancel,
        DWORD dwCopyFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CopyFileTransactedA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        LPBOOL pbCancel,
        DWORD dwCopyFlags,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall CopyFileTransactedW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        LPBOOL pbCancel,
        DWORD dwCopyFlags,
        HANDLE hTransaction);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef enum _COPYFILE2_MESSAGE_TYPE {
    COPYFILE2_CALLBACK_NONE = 0,
    COPYFILE2_CALLBACK_CHUNK_STARTED,
    COPYFILE2_CALLBACK_CHUNK_FINISHED,
    COPYFILE2_CALLBACK_STREAM_STARTED,
    COPYFILE2_CALLBACK_STREAM_FINISHED,
    COPYFILE2_CALLBACK_POLL_CONTINUE,
    COPYFILE2_CALLBACK_ERROR,
    COPYFILE2_CALLBACK_MAX,
} COPYFILE2_MESSAGE_TYPE;
typedef enum _COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE,
} COPYFILE2_MESSAGE_ACTION;
typedef enum _COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,
    COPYFILE2_PHASE_MAX,
} COPYFILE2_COPY_PHASE;
typedef struct COPYFILE2_MESSAGE {
    COPYFILE2_MESSAGE_TYPE Type;
    DWORD dwPadding;
    union {
        struct {
            DWORD dwStreamNumber;
            DWORD dwReserved;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliChunkSize;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliTotalFileSize;
        } ChunkStarted;
        struct {
            DWORD dwStreamNumber;
            DWORD dwFlags;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliChunkSize;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        } ChunkFinished;
        struct {
            DWORD dwStreamNumber;
            DWORD dwReserved;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliTotalFileSize;
        } StreamStarted;
        struct {
            DWORD dwStreamNumber;
            DWORD dwReserved;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        } StreamFinished;
        struct {
            DWORD dwReserved;
        } PollContinue;
        struct {
            COPYFILE2_COPY_PHASE CopyPhase;
            DWORD dwStreamNumber;
            HRESULT hrFailure;
            DWORD dwReserved;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        } Error;
    } Info;
} COPYFILE2_MESSAGE;
typedef COPYFILE2_MESSAGE_ACTION(__stdcall* PCOPYFILE2_PROGRESS_ROUTINE)(
    const COPYFILE2_MESSAGE* pMessage,
    PVOID pvCallbackContext);
typedef struct COPYFILE2_EXTENDED_PARAMETERS {
    DWORD dwSize;
    DWORD dwCopyFlags;
    BOOL* pfCancel;
    PCOPYFILE2_PROGRESS_ROUTINE pProgressRoutine;
    PVOID pvCallbackContext;
} COPYFILE2_EXTENDED_PARAMETERS;
typedef struct COPYFILE2_EXTENDED_PARAMETERS_V2 {
    DWORD dwSize;
    DWORD dwCopyFlags;
    BOOL* pfCancel;
    PCOPYFILE2_PROGRESS_ROUTINE pProgressRoutine;
    PVOID pvCallbackContext;
    DWORD dwCopyFlagsV2;
    ULONG ioDesiredSize;
    ULONG ioDesiredRate;
    PVOID reserved[8];
} COPYFILE2_EXTENDED_PARAMETERS_V2;
__declspec(dllimport)
    HRESULT
    __stdcall CopyFile2(
        PCWSTR pwszExistingFileName,
        PCWSTR pwszNewFileName,
        COPYFILE2_EXTENDED_PARAMETERS* pExtendedParameters);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall MoveFileA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName);
__declspec(dllimport)
    BOOL
    __stdcall MoveFileW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall MoveFileExA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall MoveFileExW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        DWORD dwFlags);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall MoveFileWithProgressA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall MoveFileWithProgressW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall MoveFileTransactedA(
        LPCSTR lpExistingFileName,
        LPCSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        DWORD dwFlags,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall MoveFileTransactedW(
        LPCWSTR lpExistingFileName,
        LPCWSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
        DWORD dwFlags,
        HANDLE hTransaction);
#pragma endregion
#pragma region Application Family or Games Family
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall ReplaceFileA(
        LPCSTR lpReplacedFileName,
        LPCSTR lpReplacementFileName,
        LPCSTR lpBackupFileName,
        DWORD dwReplaceFlags,
        LPVOID lpExclude,
        LPVOID lpReserved);
__declspec(dllimport)
    BOOL
    __stdcall ReplaceFileW(
        LPCWSTR lpReplacedFileName,
        LPCWSTR lpReplacementFileName,
        LPCWSTR lpBackupFileName,
        DWORD dwReplaceFlags,
        LPVOID lpExclude,
        LPVOID lpReserved);
__declspec(dllimport)
    BOOL
    __stdcall CreateHardLinkA(
        LPCSTR lpFileName,
        LPCSTR lpExistingFileName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    BOOL
    __stdcall CreateHardLinkW(
        LPCWSTR lpFileName,
        LPCWSTR lpExistingFileName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CreateHardLinkTransactedA(
        LPCSTR lpFileName,
        LPCSTR lpExistingFileName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall CreateHardLinkTransactedW(
        LPCWSTR lpFileName,
        LPCWSTR lpExistingFileName,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        HANDLE hTransaction);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstStreamTransactedW(
        LPCWSTR lpFileName,
        STREAM_INFO_LEVELS InfoLevel,
        LPVOID lpFindStreamData,
        DWORD dwFlags,
        HANDLE hTransaction);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstFileNameTransactedW(
        LPCWSTR lpFileName,
        DWORD dwFlags,
        LPDWORD StringLength,
        PWSTR LinkName,
        HANDLE hTransaction);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateNamedPipeA(
        LPCSTR lpName,
        DWORD dwOpenMode,
        DWORD dwPipeMode,
        DWORD nMaxInstances,
        DWORD nOutBufferSize,
        DWORD nInBufferSize,
        DWORD nDefaultTimeOut,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeHandleStateA(
        HANDLE hNamedPipe,
        LPDWORD lpState,
        LPDWORD lpCurInstances,
        LPDWORD lpMaxCollectionCount,
        LPDWORD lpCollectDataTimeout,
        LPSTR lpUserName,
        DWORD nMaxUserNameSize);
__declspec(dllimport)
    BOOL
    __stdcall CallNamedPipeA(
        LPCSTR lpNamedPipeName,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesRead,
        DWORD nTimeOut);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall WaitNamedPipeA(
        LPCSTR lpNamedPipeName,
        DWORD nTimeOut);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeClientComputerNameA(
        HANDLE Pipe,
        LPSTR ClientComputerName,
        ULONG ClientComputerNameLength);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeClientProcessId(
        HANDLE Pipe,
        PULONG ClientProcessId);
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeClientSessionId(
        HANDLE Pipe,
        PULONG ClientSessionId);
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeServerProcessId(
        HANDLE Pipe,
        PULONG ServerProcessId);
__declspec(dllimport)
    BOOL
    __stdcall GetNamedPipeServerSessionId(
        HANDLE Pipe,
        PULONG ServerSessionId);
#pragma endregion
#pragma region Application Family or Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetVolumeLabelA(
        LPCSTR lpRootPathName,
        LPCSTR lpVolumeName);
__declspec(dllimport)
    BOOL
    __stdcall SetVolumeLabelW(
        LPCWSTR lpRootPathName,
        LPCWSTR lpVolumeName);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetFileBandwidthReservation(
        HANDLE hFile,
        DWORD nPeriodMilliseconds,
        DWORD nBytesPerPeriod,
        BOOL bDiscardable,
        LPDWORD lpTransferSize,
        LPDWORD lpNumOutstandingRequests);
__declspec(dllimport)
    BOOL
    __stdcall GetFileBandwidthReservation(
        HANDLE hFile,
        LPDWORD lpPeriodMilliseconds,
        LPDWORD lpBytesPerPeriod,
        LPBOOL pDiscardable,
        LPDWORD lpTransferSize,
        LPDWORD lpNumOutstandingRequests);
__declspec(dllimport)
    BOOL
    __stdcall ClearEventLogA(
        HANDLE hEventLog,
        LPCSTR lpBackupFileName);
__declspec(dllimport)
    BOOL
    __stdcall ClearEventLogW(
        HANDLE hEventLog,
        LPCWSTR lpBackupFileName);
__declspec(dllimport)
    BOOL
    __stdcall BackupEventLogA(
        HANDLE hEventLog,
        LPCSTR lpBackupFileName);
__declspec(dllimport)
    BOOL
    __stdcall BackupEventLogW(
        HANDLE hEventLog,
        LPCWSTR lpBackupFileName);
__declspec(dllimport)
    BOOL
    __stdcall CloseEventLog(
        HANDLE hEventLog);
#pragma endregion
#pragma region Application Family
__declspec(dllimport)
    BOOL
    __stdcall DeregisterEventSource(
        HANDLE hEventLog);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall NotifyChangeEventLog(
        HANDLE hEventLog,
        HANDLE hEvent);
__declspec(dllimport)
    BOOL
    __stdcall GetNumberOfEventLogRecords(
        HANDLE hEventLog,
        PDWORD NumberOfRecords);
__declspec(dllimport)
    BOOL
    __stdcall GetOldestEventLogRecord(
        HANDLE hEventLog,
        PDWORD OldestRecord);
__declspec(dllimport)
    HANDLE
    __stdcall OpenEventLogA(
        LPCSTR lpUNCServerName,
        LPCSTR lpSourceName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenEventLogW(
        LPCWSTR lpUNCServerName,
        LPCWSTR lpSourceName);
#pragma endregion
#pragma region Application Family
__declspec(dllimport)
    HANDLE
    __stdcall RegisterEventSourceA(
        LPCSTR lpUNCServerName,
        LPCSTR lpSourceName);
__declspec(dllimport)
    HANDLE
    __stdcall RegisterEventSourceW(
        LPCWSTR lpUNCServerName,
        LPCWSTR lpSourceName);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall OpenBackupEventLogA(
        LPCSTR lpUNCServerName,
        LPCSTR lpFileName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenBackupEventLogW(
        LPCWSTR lpUNCServerName,
        LPCWSTR lpFileName);
__declspec(dllimport)
    BOOL
    __stdcall ReadEventLogA(
        HANDLE hEventLog,
        DWORD dwReadFlags,
        DWORD dwRecordOffset,
        LPVOID lpBuffer,
        DWORD nNumberOfBytesToRead,
        DWORD* pnBytesRead,
        DWORD* pnMinNumberOfBytesNeeded);
__declspec(dllimport)
    BOOL
    __stdcall ReadEventLogW(
        HANDLE hEventLog,
        DWORD dwReadFlags,
        DWORD dwRecordOffset,
        LPVOID lpBuffer,
        DWORD nNumberOfBytesToRead,
        DWORD* pnBytesRead,
        DWORD* pnMinNumberOfBytesNeeded);
#pragma endregion
#pragma region Application Family
__declspec(dllimport)
    BOOL
    __stdcall ReportEventA(
        HANDLE hEventLog,
        WORD wType,
        WORD wCategory,
        DWORD dwEventID,
        PSID lpUserSid,
        WORD wNumStrings,
        DWORD dwDataSize,
        LPCSTR* lpStrings,
        LPVOID lpRawData);
__declspec(dllimport)
    BOOL
    __stdcall ReportEventW(
        HANDLE hEventLog,
        WORD wType,
        WORD wCategory,
        DWORD dwEventID,
        PSID lpUserSid,
        WORD wNumStrings,
        DWORD dwDataSize,
        LPCWSTR* lpStrings,
        LPVOID lpRawData);
#pragma endregion
#pragma region Desktop Family
typedef struct _EVENTLOG_FULL_INFORMATION {
    DWORD dwFull;
} EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;
__declspec(dllimport)
    BOOL
    __stdcall GetEventLogInformation(
        HANDLE hEventLog,
        DWORD dwInfoLevel,
        LPVOID lpBuffer,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
typedef ULONG OPERATION_ID;
typedef struct _OPERATION_START_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_START_PARAMETERS, *POPERATION_START_PARAMETERS;
typedef struct _OPERATION_END_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_END_PARAMETERS, *POPERATION_END_PARAMETERS;
__declspec(dllimport)
    BOOL
    __stdcall OperationStart(
        OPERATION_START_PARAMETERS* OperationStartParams);
__declspec(dllimport)
    BOOL
    __stdcall OperationEnd(
        OPERATION_END_PARAMETERS* OperationEndParams);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckAndAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        LPSTR ObjectTypeName,
        LPSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        DWORD DesiredAccess,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeAndAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        LPCSTR ObjectTypeName,
        LPCSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PSID PrincipalSelfSid,
        DWORD DesiredAccess,
        AUDIT_EVENT_TYPE AuditType,
        DWORD Flags,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeResultListAndAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        LPCSTR ObjectTypeName,
        LPCSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PSID PrincipalSelfSid,
        DWORD DesiredAccess,
        AUDIT_EVENT_TYPE AuditType,
        DWORD Flags,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPDWORD AccessStatusList,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall AccessCheckByTypeResultListAndAuditAlarmByHandleA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        HANDLE ClientToken,
        LPCSTR ObjectTypeName,
        LPCSTR ObjectName,
        PSECURITY_DESCRIPTOR SecurityDescriptor,
        PSID PrincipalSelfSid,
        DWORD DesiredAccess,
        AUDIT_EVENT_TYPE AuditType,
        DWORD Flags,
        POBJECT_TYPE_LIST ObjectTypeList,
        DWORD ObjectTypeListLength,
        PGENERIC_MAPPING GenericMapping,
        BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPDWORD AccessStatusList,
        LPBOOL pfGenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall ObjectOpenAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        LPSTR ObjectTypeName,
        LPSTR ObjectName,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        DWORD GrantedAccess,
        PPRIVILEGE_SET Privileges,
        BOOL ObjectCreation,
        BOOL AccessGranted,
        LPBOOL GenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall ObjectPrivilegeAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        HANDLE ClientToken,
        DWORD DesiredAccess,
        PPRIVILEGE_SET Privileges,
        BOOL AccessGranted);
__declspec(dllimport)
    BOOL
    __stdcall ObjectCloseAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        BOOL GenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall ObjectDeleteAuditAlarmA(
        LPCSTR SubsystemName,
        LPVOID HandleId,
        BOOL GenerateOnClose);
__declspec(dllimport)
    BOOL
    __stdcall PrivilegedServiceAuditAlarmA(
        LPCSTR SubsystemName,
        LPCSTR ServiceName,
        HANDLE ClientToken,
        PPRIVILEGE_SET Privileges,
        BOOL AccessGranted);
__declspec(dllimport)
    BOOL
    __stdcall AddConditionalAce(
        PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        UCHAR AceType,
        DWORD AccessMask,
        PSID pSid,
        PWCHAR ConditionStr,
        DWORD* ReturnLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetFileSecurityA(
        LPCSTR lpFileName,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor);
__declspec(dllimport)
    BOOL
    __stdcall GetFileSecurityA(
        LPCSTR lpFileName,
        SECURITY_INFORMATION RequestedInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        DWORD nLength,
        LPDWORD lpnLengthNeeded);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall ReadDirectoryChangesW(
        HANDLE hDirectory,
        LPVOID lpBuffer,
        DWORD nBufferLength,
        BOOL bWatchSubtree,
        DWORD dwNotifyFilter,
        LPDWORD lpBytesReturned,
        LPOVERLAPPED lpOverlapped,
        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
__declspec(dllimport)
    BOOL
    __stdcall ReadDirectoryChangesExW(
        HANDLE hDirectory,
        LPVOID lpBuffer,
        DWORD nBufferLength,
        BOOL bWatchSubtree,
        DWORD dwNotifyFilter,
        LPDWORD lpBytesReturned,
        LPOVERLAPPED lpOverlapped,
        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    LPVOID
    __stdcall MapViewOfFileExNuma(
        HANDLE hFileMappingObject,
        DWORD dwDesiredAccess,
        DWORD dwFileOffsetHigh,
        DWORD dwFileOffsetLow,
        SIZE_T dwNumberOfBytesToMap,
        LPVOID lpBaseAddress,
        DWORD nndPreferred);
__declspec(dllimport)
    BOOL
    __stdcall IsBadReadPtr(
        const void* lp,
        UINT_PTR ucb);
__declspec(dllimport)
    BOOL
    __stdcall IsBadWritePtr(
        LPVOID lp,
        UINT_PTR ucb);
__declspec(dllimport)
    BOOL
    __stdcall IsBadHugeReadPtr(
        const void* lp,
        UINT_PTR ucb);
__declspec(dllimport)
    BOOL
    __stdcall IsBadHugeWritePtr(
        LPVOID lp,
        UINT_PTR ucb);
__declspec(dllimport)
    BOOL
    __stdcall IsBadCodePtr(
        FARPROC lpfn);
__declspec(dllimport)
    BOOL
    __stdcall IsBadStringPtrA(
        LPCSTR lpsz,
        UINT_PTR ucchMax);
__declspec(dllimport)
    BOOL
    __stdcall IsBadStringPtrW(
        LPCWSTR lpsz,
        UINT_PTR ucchMax);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountSidA(
        LPCSTR lpSystemName,
        PSID Sid,
        LPSTR Name,
        LPDWORD cchName,
        LPSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountSidW(
        LPCWSTR lpSystemName,
        PSID Sid,
        LPWSTR Name,
        LPDWORD cchName,
        LPWSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountNameA(
        LPCSTR lpSystemName,
        LPCSTR lpAccountName,
        PSID Sid,
        LPDWORD cbSid,
        LPSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountNameW(
        LPCWSTR lpSystemName,
        LPCWSTR lpAccountName,
        PSID Sid,
        LPDWORD cbSid,
        LPWSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountNameLocalA(
        LPCSTR lpAccountName,
        PSID Sid,
        LPDWORD cbSid,
        LPSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountNameLocalW(
        LPCWSTR lpAccountName,
        PSID Sid,
        LPDWORD cbSid,
        LPWSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountSidLocalA(
        PSID Sid,
        LPSTR Name,
        LPDWORD cchName,
        LPSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
__declspec(dllimport)
    BOOL
    __stdcall LookupAccountSidLocalW(
        PSID Sid,
        LPWSTR Name,
        LPDWORD cchName,
        LPWSTR ReferencedDomainName,
        LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall LookupPrivilegeValueA(
        LPCSTR lpSystemName,
        LPCSTR lpName,
        PLUID lpLuid);
__declspec(dllimport)
    BOOL
    __stdcall LookupPrivilegeValueW(
        LPCWSTR lpSystemName,
        LPCWSTR lpName,
        PLUID lpLuid);
__declspec(dllimport)
    BOOL
    __stdcall LookupPrivilegeNameA(
        LPCSTR lpSystemName,
        PLUID lpLuid,
        LPSTR lpName,
        LPDWORD cchName);
__declspec(dllimport)
    BOOL
    __stdcall LookupPrivilegeNameW(
        LPCWSTR lpSystemName,
        PLUID lpLuid,
        LPWSTR lpName,
        LPDWORD cchName);
__declspec(dllimport)
    BOOL
    __stdcall LookupPrivilegeDisplayNameA(
        LPCSTR lpSystemName,
        LPCSTR lpName,
        LPSTR lpDisplayName,
        LPDWORD cchDisplayName,
        LPDWORD lpLanguageId);
__declspec(dllimport)
    BOOL
    __stdcall LookupPrivilegeDisplayNameW(
        LPCWSTR lpSystemName,
        LPCWSTR lpName,
        LPWSTR lpDisplayName,
        LPDWORD cchDisplayName,
        LPDWORD lpLanguageId);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall BuildCommDCBA(
        LPCSTR lpDef,
        LPDCB lpDCB);
__declspec(dllimport)
    BOOL
    __stdcall BuildCommDCBW(
        LPCWSTR lpDef,
        LPDCB lpDCB);
__declspec(dllimport)
    BOOL
    __stdcall BuildCommDCBAndTimeoutsA(
        LPCSTR lpDef,
        LPDCB lpDCB,
        LPCOMMTIMEOUTS lpCommTimeouts);
__declspec(dllimport)
    BOOL
    __stdcall BuildCommDCBAndTimeoutsW(
        LPCWSTR lpDef,
        LPDCB lpDCB,
        LPCOMMTIMEOUTS lpCommTimeouts);
__declspec(dllimport)
    BOOL
    __stdcall CommConfigDialogA(
        LPCSTR lpszName,
        HWND hWnd,
        LPCOMMCONFIG lpCC);
__declspec(dllimport)
    BOOL
    __stdcall CommConfigDialogW(
        LPCWSTR lpszName,
        HWND hWnd,
        LPCOMMCONFIG lpCC);
__declspec(dllimport)
    BOOL
    __stdcall GetDefaultCommConfigA(
        LPCSTR lpszName,
        LPCOMMCONFIG lpCC,
        LPDWORD lpdwSize);
__declspec(dllimport)
    BOOL
    __stdcall GetDefaultCommConfigW(
        LPCWSTR lpszName,
        LPCOMMCONFIG lpCC,
        LPDWORD lpdwSize);
__declspec(dllimport)
    BOOL
    __stdcall SetDefaultCommConfigA(
        LPCSTR lpszName,
        LPCOMMCONFIG lpCC,
        DWORD dwSize);
__declspec(dllimport)
    BOOL
    __stdcall SetDefaultCommConfigW(
        LPCWSTR lpszName,
        LPCOMMCONFIG lpCC,
        DWORD dwSize);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetComputerNameA(
        LPSTR lpBuffer,
        LPDWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall GetComputerNameW(
        LPWSTR lpBuffer,
        LPDWORD nSize);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DnsHostnameToComputerNameA(
        LPCSTR Hostname,
        LPSTR ComputerName,
        LPDWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall DnsHostnameToComputerNameW(
        LPCWSTR Hostname,
        LPWSTR ComputerName,
        LPDWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall GetUserNameA(
        LPSTR lpBuffer,
        LPDWORD pcbBuffer);
__declspec(dllimport)
    BOOL
    __stdcall GetUserNameW(
        LPWSTR lpBuffer,
        LPDWORD pcbBuffer);
__declspec(dllimport)
    BOOL
    __stdcall LogonUserA(
        LPCSTR lpszUsername,
        LPCSTR lpszDomain,
        LPCSTR lpszPassword,
        DWORD dwLogonType,
        DWORD dwLogonProvider,
        PHANDLE phToken);
__declspec(dllimport)
    BOOL
    __stdcall LogonUserW(
        LPCWSTR lpszUsername,
        LPCWSTR lpszDomain,
        LPCWSTR lpszPassword,
        DWORD dwLogonType,
        DWORD dwLogonProvider,
        PHANDLE phToken);
__declspec(dllimport)
    BOOL
    __stdcall LogonUserExA(
        LPCSTR lpszUsername,
        LPCSTR lpszDomain,
        LPCSTR lpszPassword,
        DWORD dwLogonType,
        DWORD dwLogonProvider,
        PHANDLE phToken,
        PSID* ppLogonSid,
        PVOID* ppProfileBuffer,
        LPDWORD pdwProfileLength,
        PQUOTA_LIMITS pQuotaLimits);
__declspec(dllimport)
    BOOL
    __stdcall LogonUserExW(
        LPCWSTR lpszUsername,
        LPCWSTR lpszDomain,
        LPCWSTR lpszPassword,
        DWORD dwLogonType,
        DWORD dwLogonProvider,
        PHANDLE phToken,
        PSID* ppLogonSid,
        PVOID* ppProfileBuffer,
        LPDWORD pdwProfileLength,
        PQUOTA_LIMITS pQuotaLimits);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CreateProcessWithLogonW(
        LPCWSTR lpUsername,
        LPCWSTR lpDomain,
        LPCWSTR lpPassword,
        DWORD dwLogonFlags,
        LPCWSTR lpApplicationName,
        LPWSTR lpCommandLine,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
        LPSTARTUPINFOW lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation);
__declspec(dllimport)
    BOOL
    __stdcall CreateProcessWithTokenW(
        HANDLE hToken,
        DWORD dwLogonFlags,
        LPCWSTR lpApplicationName,
        LPWSTR lpCommandLine,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
        LPSTARTUPINFOW lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation);
__declspec(dllimport)
    BOOL
    __stdcall IsTokenUntrusted(
        HANDLE TokenHandle);
#pragma region Desktop or Games Family
__declspec(dllimport)
    BOOL
    __stdcall RegisterWaitForSingleObject(
        PHANDLE phNewWaitObject,
        HANDLE hObject,
        WAITORTIMERCALLBACK Callback,
        PVOID Context,
        ULONG dwMilliseconds,
        ULONG dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterWait(
        HANDLE WaitHandle);
__declspec(dllimport)
    BOOL
    __stdcall BindIoCompletionCallback(
        HANDLE FileHandle,
        LPOVERLAPPED_COMPLETION_ROUTINE Function,
        ULONG Flags);
__declspec(dllimport)
    HANDLE
    __stdcall SetTimerQueueTimer(
        HANDLE TimerQueue,
        WAITORTIMERCALLBACK Callback,
        PVOID Parameter,
        DWORD DueTime,
        DWORD Period,
        BOOL PreferIo);
__declspec(dllimport)
    BOOL
    __stdcall CancelTimerQueueTimer(
        HANDLE TimerQueue,
        HANDLE Timer);
__forceinline void
InitializeThreadpoolEnvironment(
    PTP_CALLBACK_ENVIRON pcbe)
{
    TpInitializeCallbackEnviron(pcbe);
}
__forceinline void
SetThreadpoolCallbackPool(
    PTP_CALLBACK_ENVIRON pcbe,
    PTP_POOL ptpp)
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}
__forceinline void
SetThreadpoolCallbackCleanupGroup(
    PTP_CALLBACK_ENVIRON pcbe,
    PTP_CLEANUP_GROUP ptpcg,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng)
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}
__forceinline void
SetThreadpoolCallbackRunsLong(
    PTP_CALLBACK_ENVIRON pcbe)
{
    TpSetCallbackLongFunction(pcbe);
}
__forceinline void
SetThreadpoolCallbackLibrary(
    PTP_CALLBACK_ENVIRON pcbe,
    PVOID mod)
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}
__forceinline void
SetThreadpoolCallbackPriority(
    PTP_CALLBACK_ENVIRON pcbe,
    TP_CALLBACK_PRIORITY Priority)
{
    TpSetCallbackPriority(pcbe, Priority);
}
__forceinline void
DestroyThreadpoolEnvironment(
    PTP_CALLBACK_ENVIRON pcbe)
{
    TpDestroyCallbackEnviron(pcbe);
}
#pragma region Desktop Family
__forceinline void
SetThreadpoolCallbackPersistent(
    PTP_CALLBACK_ENVIRON pcbe)
{
    TpSetCallbackPersistent(pcbe);
}
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall CreatePrivateNamespaceA(
        LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
        LPVOID lpBoundaryDescriptor,
        LPCSTR lpAliasPrefix);
__declspec(dllimport)
    HANDLE
    __stdcall OpenPrivateNamespaceA(
        LPVOID lpBoundaryDescriptor,
        LPCSTR lpAliasPrefix);
__declspec(dllimport)
    HANDLE
    __stdcall CreateBoundaryDescriptorA(
        LPCSTR Name,
        ULONG Flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall AddIntegrityLabelToBoundaryDescriptor(
        HANDLE* BoundaryDescriptor,
        PSID IntegrityLabel);
#pragma endregion
#pragma region Desktop Family
typedef struct tagHW_PROFILE_INFOA {
    DWORD dwDockInfo;
    CHAR szHwProfileGuid[39];
    CHAR szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD dwDockInfo;
    WCHAR szHwProfileGuid[39];
    WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;
typedef HW_PROFILE_INFOW HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetCurrentHwProfileA(
        LPHW_PROFILE_INFOA lpHwProfileInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetCurrentHwProfileW(
        LPHW_PROFILE_INFOW lpHwProfileInfo);
#pragma endregion
#pragma region Desktop Family or Gaming Family
__declspec(dllimport)
    BOOL
    __stdcall VerifyVersionInfoA(
        LPOSVERSIONINFOEXA lpVersionInformation,
        DWORD dwTypeMask,
        DWORDLONG dwlConditionMask);
__declspec(dllimport)
    BOOL
    __stdcall VerifyVersionInfoW(
        LPOSVERSIONINFOEXW lpVersionInformation,
        DWORD dwTypeMask,
        DWORDLONG dwlConditionMask);
#pragma endregion
#pragma once
constexpr __forceinline HRESULT HRESULT_FROM_WIN32(unsigned long x)
{
    return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT)(((x)&0x0000FFFF) | (7 << 16) | 0x80000000);
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[32];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[32];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;
typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[32];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[32];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[128];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;
__declspec(dllimport)
    BOOL
    __stdcall SystemTimeToTzSpecificLocalTime(
        const TIME_ZONE_INFORMATION* lpTimeZoneInformation,
        const SYSTEMTIME* lpUniversalTime,
        LPSYSTEMTIME lpLocalTime);
__declspec(dllimport)
    BOOL
    __stdcall TzSpecificLocalTimeToSystemTime(
        const TIME_ZONE_INFORMATION* lpTimeZoneInformation,
        const SYSTEMTIME* lpLocalTime,
        LPSYSTEMTIME lpUniversalTime);
__declspec(dllimport)
    BOOL
    __stdcall FileTimeToSystemTime(
        const FILETIME* lpFileTime,
        LPSYSTEMTIME lpSystemTime);
__declspec(dllimport)
    BOOL
    __stdcall SystemTimeToFileTime(
        const SYSTEMTIME* lpSystemTime,
        LPFILETIME lpFileTime);
__declspec(dllimport)
    DWORD
    __stdcall GetTimeZoneInformation(
        LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
__declspec(dllimport)
    BOOL
    __stdcall SetTimeZoneInformation(
        const TIME_ZONE_INFORMATION* lpTimeZoneInformation);
__declspec(dllimport)
    BOOL
    __stdcall SetDynamicTimeZoneInformation(
        const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation);
__declspec(dllimport)
    DWORD
    __stdcall GetDynamicTimeZoneInformation(
        PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
BOOL __stdcall GetTimeZoneInformationForYear(
    USHORT wYear,
    PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
    LPTIME_ZONE_INFORMATION ptzi);
__declspec(dllimport)
    DWORD
    __stdcall EnumDynamicTimeZoneInformation(
        const DWORD dwIndex,
        PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation);
__declspec(dllimport)
    DWORD
    __stdcall GetDynamicTimeZoneInformationEffectiveYears(
        const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation,
        LPDWORD FirstYear,
        LPDWORD LastYear);
__declspec(dllimport)
    BOOL
    __stdcall SystemTimeToTzSpecificLocalTimeEx(
        const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation,
        const SYSTEMTIME* lpUniversalTime,
        LPSYSTEMTIME lpLocalTime);
__declspec(dllimport)
    BOOL
    __stdcall TzSpecificLocalTimeToSystemTimeEx(
        const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation,
        const SYSTEMTIME* lpLocalTime,
        LPSYSTEMTIME lpUniversalTime);
__declspec(dllimport)
    BOOL
    __stdcall LocalFileTimeToLocalSystemTime(
        const TIME_ZONE_INFORMATION* timeZoneInformation,
        const FILETIME* localFileTime,
        SYSTEMTIME* localSystemTime);
__declspec(dllimport)
    BOOL
    __stdcall LocalSystemTimeToLocalFileTime(
        const TIME_ZONE_INFORMATION* timeZoneInformation,
        const SYSTEMTIME* localSystemTime,
        FILETIME* localFileTime);
#pragma endregion
}
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetSystemPowerState(
        BOOL fSuspend,
        BOOL fForce);
#pragma endregion
#pragma region Desktop or PC Family
typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE SystemStatusFlag;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;
__declspec(dllimport)
    BOOL
    __stdcall GetSystemPowerStatus(
        LPSYSTEM_POWER_STATUS lpSystemPowerStatus);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall MapUserPhysicalPagesScatter(
        PVOID* VirtualAddresses,
        ULONG_PTR NumberOfPages,
        PULONG_PTR PageArray);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall CreateJobObjectA(
        LPSECURITY_ATTRIBUTES lpJobAttributes,
        LPCSTR lpName);
__declspec(dllimport)
    HANDLE
    __stdcall OpenJobObjectA(
        DWORD dwDesiredAccess,
        BOOL bInheritHandle,
        LPCSTR lpName);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CreateJobSet(
        ULONG NumJob,
        PJOB_SET_ARRAY UserJobSet,
        ULONG Flags);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstVolumeA(
        LPSTR lpszVolumeName,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall FindNextVolumeA(
        HANDLE hFindVolume,
        LPSTR lpszVolumeName,
        DWORD cchBufferLength);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstVolumeMountPointA(
        LPCSTR lpszRootPathName,
        LPSTR lpszVolumeMountPoint,
        DWORD cchBufferLength);
__declspec(dllimport)
    HANDLE
    __stdcall FindFirstVolumeMountPointW(
        LPCWSTR lpszRootPathName,
        LPWSTR lpszVolumeMountPoint,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall FindNextVolumeMountPointA(
        HANDLE hFindVolumeMountPoint,
        LPSTR lpszVolumeMountPoint,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall FindNextVolumeMountPointW(
        HANDLE hFindVolumeMountPoint,
        LPWSTR lpszVolumeMountPoint,
        DWORD cchBufferLength);
__declspec(dllimport)
    BOOL
    __stdcall FindVolumeMountPointClose(
        HANDLE hFindVolumeMountPoint);
__declspec(dllimport)
    BOOL
    __stdcall SetVolumeMountPointA(
        LPCSTR lpszVolumeMountPoint,
        LPCSTR lpszVolumeName);
__declspec(dllimport)
    BOOL
    __stdcall SetVolumeMountPointW(
        LPCWSTR lpszVolumeMountPoint,
        LPCWSTR lpszVolumeName);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall DeleteVolumeMountPointA(
        LPCSTR lpszVolumeMountPoint);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumeNameForVolumeMountPointA(
        LPCSTR lpszVolumeMountPoint,
        LPSTR lpszVolumeName,
        DWORD cchBufferLength);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumePathNameA(
        LPCSTR lpszFileName,
        LPSTR lpszVolumePathName,
        DWORD cchBufferLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetVolumePathNamesForVolumeNameA(
        LPCSTR lpszVolumeName,
        LPCH lpszVolumePathNames,
        DWORD cchBufferLength,
        PDWORD lpcchReturnLength);
typedef struct tagACTCTXA {
    ULONG cbSize;
    DWORD dwFlags;
    LPCSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCSTR lpAssemblyDirectory;
    LPCSTR lpResourceName;
    LPCSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG cbSize;
    DWORD dwFlags;
    LPCWSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCWSTR lpAssemblyDirectory;
    LPCWSTR lpResourceName;
    LPCWSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXW, *PACTCTXW;
typedef ACTCTXW ACTCTX;
typedef PACTCTXW PACTCTX;
typedef const ACTCTXA* PCACTCTXA;
typedef const ACTCTXW* PCACTCTXW;
typedef PCACTCTXW PCACTCTX;
__declspec(dllimport)
    HANDLE
    __stdcall CreateActCtxA(
        PCACTCTXA pActCtx);
__declspec(dllimport)
    HANDLE
    __stdcall CreateActCtxW(
        PCACTCTXW pActCtx);
__declspec(dllimport) void __stdcall AddRefActCtx(
    HANDLE hActCtx);
__declspec(dllimport) void __stdcall ReleaseActCtx(
    HANDLE hActCtx);
__declspec(dllimport)
    BOOL
    __stdcall ZombifyActCtx(
        HANDLE hActCtx);
__declspec(dllimport)
    BOOL
    __stdcall ActivateActCtx(
        HANDLE hActCtx,
        ULONG_PTR* lpCookie);
__declspec(dllimport)
    BOOL
    __stdcall DeactivateActCtx(
        DWORD dwFlags,
        ULONG_PTR ulCookie);
__declspec(dllimport)
    BOOL
    __stdcall GetCurrentActCtx(
        HANDLE* lphActCtx);
typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600* PCACTCTX_SECTION_KEYED_DATA_2600;
typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA* PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA* PCACTCTX_SECTION_KEYED_DATA;
__declspec(dllimport)
    BOOL
    __stdcall FindActCtxSectionStringA(
        DWORD dwFlags,
        const GUID* lpExtensionGuid,
        ULONG ulSectionId,
        LPCSTR lpStringToFind,
        PACTCTX_SECTION_KEYED_DATA ReturnedData);
__declspec(dllimport)
    BOOL
    __stdcall FindActCtxSectionStringW(
        DWORD dwFlags,
        const GUID* lpExtensionGuid,
        ULONG ulSectionId,
        LPCWSTR lpStringToFind,
        PACTCTX_SECTION_KEYED_DATA ReturnedData);
__declspec(dllimport)
    BOOL
    __stdcall FindActCtxSectionGuid(
        DWORD dwFlags,
        const GUID* lpExtensionGuid,
        ULONG ulSectionId,
        const GUID* lpGuidToFind,
        PACTCTX_SECTION_KEYED_DATA ReturnedData);
typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE hActCtx;
    DWORD dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION* PCACTIVATION_CONTEXT_BASIC_INFORMATION;
__declspec(dllimport)
    BOOL
    __stdcall QueryActCtxW(
        DWORD dwFlags,
        HANDLE hActCtx,
        PVOID pvSubInstance,
        ULONG ulInfoClass,
        PVOID pvBuffer,
        SIZE_T cbBuffer,
        SIZE_T* pcbWrittenOrRequired);
typedef BOOL(__stdcall* PQUERYACTCTXW_FUNC)(
    DWORD dwFlags,
    HANDLE hActCtx,
    PVOID pvSubInstance,
    ULONG ulInfoClass,
    PVOID pvBuffer,
    SIZE_T cbBuffer,
    SIZE_T* pcbWrittenOrRequired);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall WTSGetActiveConsoleSessionId(
        void);
__declspec(dllimport)
    DWORD
    __stdcall WTSGetServiceSessionId(
        void);
__declspec(dllimport)
    BOOLEAN
    __stdcall WTSIsServerContainer(
        void);
__declspec(dllimport)
    WORD
    __stdcall GetActiveProcessorGroupCount(
        void);
__declspec(dllimport)
    WORD
    __stdcall GetMaximumProcessorGroupCount(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetActiveProcessorCount(
        WORD GroupNumber);
__declspec(dllimport)
    DWORD
    __stdcall GetMaximumProcessorCount(
        WORD GroupNumber);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaProcessorNode(
        UCHAR Processor,
        PUCHAR NodeNumber);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaNodeNumberFromHandle(
        HANDLE hFile,
        PUSHORT NodeNumber);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaProcessorNodeEx(
        PPROCESSOR_NUMBER Processor,
        PUSHORT NodeNumber);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaNodeProcessorMask(
        UCHAR Node,
        PULONGLONG ProcessorMask);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaAvailableMemoryNode(
        UCHAR Node,
        PULONGLONG AvailableBytes);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaAvailableMemoryNodeEx(
        USHORT Node,
        PULONGLONG AvailableBytes);
__declspec(dllimport)
    BOOL
    __stdcall GetNumaProximityNode(
        ULONG ProximityId,
        PUCHAR NodeNumber);
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef DWORD(__stdcall* APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HRESULT
    __stdcall RegisterApplicationRecoveryCallback(
        APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
        PVOID pvParameter,
        DWORD dwPingInterval,
        DWORD dwFlags);
__declspec(dllimport)
    HRESULT
    __stdcall UnregisterApplicationRecoveryCallback(void);
__declspec(dllimport)
    HRESULT
    __stdcall RegisterApplicationRestart(
        PCWSTR pwzCommandline,
        DWORD dwFlags);
__declspec(dllimport)
    HRESULT
    __stdcall UnregisterApplicationRestart(void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HRESULT
    __stdcall GetApplicationRecoveryCallback(
        HANDLE hProcess,
        APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
        PVOID* ppvParameter,
        PDWORD pdwPingInterval,
        PDWORD pdwFlags);
__declspec(dllimport)
    HRESULT
    __stdcall GetApplicationRestartSettings(
        HANDLE hProcess,
        PWSTR pwzCommandline,
        PDWORD pcchSize,
        PDWORD pdwFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HRESULT
    __stdcall ApplicationRecoveryInProgress(
        PBOOL pbCancelled);
__declspec(dllimport) void __stdcall ApplicationRecoveryFinished(
    BOOL bSuccess);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;
typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;
typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;
typedef struct _FILE_CASE_SENSITIVE_INFO {
    ULONG Flags;
} FILE_CASE_SENSITIVE_INFO, *PFILE_CASE_SENSITIVE_INFO;
typedef struct _FILE_RENAME_INFO {
    union {
        BOOLEAN ReplaceIfExists;
        DWORD Flags;
    };
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;
typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;
typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;
typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;
typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;
typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;
typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileW;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;
typedef struct _FILE_DISPOSITION_INFO_EX {
    DWORD Flags;
} FILE_DISPOSITION_INFO_EX, *PFILE_DISPOSITION_INFO_EX;
typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;
typedef struct _FILE_FULL_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;
typedef enum _PRIORITY_HINT {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow,
    IoPriorityHintNormal,
    MaximumIoPriorityHintType
} PRIORITY_HINT;
typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;
typedef struct _FILE_ALIGNMENT_INFO {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFO, *PFILE_ALIGNMENT_INFO;
typedef struct _FILE_STORAGE_INFO {
    ULONG LogicalBytesPerSector;
    ULONG PhysicalBytesPerSectorForAtomicity;
    ULONG PhysicalBytesPerSectorForPerformance;
    ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    ULONG Flags;
    ULONG ByteOffsetForSectorAlignment;
    ULONG ByteOffsetForPartitionAlignment;
} FILE_STORAGE_INFO, *PFILE_STORAGE_INFO;
typedef struct _FILE_ID_INFO {
    ULONGLONG VolumeSerialNumber;
    FILE_ID_128 FileId;
} FILE_ID_INFO, *PFILE_ID_INFO;
typedef struct _FILE_ID_EXTD_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    WCHAR FileName[1];
} FILE_ID_EXTD_DIR_INFO, *PFILE_ID_EXTD_DIR_INFO;
typedef struct _FILE_REMOTE_PROTOCOL_INFO {
    USHORT StructureVersion;
    USHORT StructureSize;
    ULONG Protocol;
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;
    USHORT Reserved;
    ULONG Flags;
    struct {
        ULONG Reserved[8];
    } GenericReserved;
    union {
        struct {
            struct {
                ULONG Capabilities;
            } Server;
            struct {
                ULONG Capabilities;
                ULONG CachingFlags;
            } Share;
        } Smb2;
        ULONG Reserved[16];
    } ProtocolSpecific;
} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetFileInformationByHandleEx(
        HANDLE hFile,
        FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
        LPVOID lpFileInformation,
        DWORD dwBufferSize);
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef enum _FILE_ID_TYPE {
    FileIdType,
    ObjectIdType,
    ExtendedFileIdType,
    MaximumFileIdType
} FILE_ID_TYPE,
    *PFILE_ID_TYPE;
typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize;
    FILE_ID_TYPE Type;
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;
        FILE_ID_128 ExtendedFileId;
    };
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;
__declspec(dllimport)
    HANDLE
    __stdcall OpenFileById(
        HANDLE hVolumeHint,
        LPFILE_ID_DESCRIPTOR lpFileId,
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD dwFlagsAndAttributes);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOLEAN
    __stdcall CreateSymbolicLinkA(
        LPCSTR lpSymlinkFileName,
        LPCSTR lpTargetFileName,
        DWORD dwFlags);
__declspec(dllimport)
    BOOLEAN
    __stdcall CreateSymbolicLinkW(
        LPCWSTR lpSymlinkFileName,
        LPCWSTR lpTargetFileName,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall QueryActCtxSettingsW(
        DWORD dwFlags,
        HANDLE hActCtx,
        PCWSTR settingsNameSpace,
        PCWSTR settingName,
        PWSTR pvBuffer,
        SIZE_T dwBuffer,
        SIZE_T* pdwWrittenOrRequired);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOLEAN
    __stdcall CreateSymbolicLinkTransactedA(
        LPCSTR lpSymlinkFileName,
        LPCSTR lpTargetFileName,
        DWORD dwFlags,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOLEAN
    __stdcall CreateSymbolicLinkTransactedW(
        LPCWSTR lpSymlinkFileName,
        LPCWSTR lpTargetFileName,
        DWORD dwFlags,
        HANDLE hTransaction);
__declspec(dllimport)
    BOOL
    __stdcall ReplacePartitionUnit(
        PWSTR TargetPartition,
        PWSTR SparePartition,
        ULONG Flags);
__declspec(dllimport)
    BOOL
    __stdcall AddSecureMemoryCacheCallback(
        PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
__declspec(dllimport)
    BOOL
    __stdcall RemoveSecureMemoryCacheCallback(
        PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall CopyContext(
        PCONTEXT Destination,
        DWORD ContextFlags,
        PCONTEXT Source);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall InitializeContext(
        PVOID Buffer,
        DWORD ContextFlags,
        PCONTEXT* Context,
        PDWORD ContextLength);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall InitializeContext2(
        PVOID Buffer,
        DWORD ContextFlags,
        PCONTEXT* Context,
        PDWORD ContextLength,
        ULONG64 XStateCompactionMask);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    DWORD64
    __stdcall GetEnabledXStateFeatures(
        void);
__declspec(dllimport)
    BOOL
    __stdcall GetXStateFeaturesMask(
        PCONTEXT Context,
        PDWORD64 FeatureMask);
__declspec(dllimport)
    PVOID
    __stdcall LocateXStateFeature(
        PCONTEXT Context,
        DWORD FeatureId,
        PDWORD Length);
__declspec(dllimport)
    BOOL
    __stdcall SetXStateFeaturesMask(
        PCONTEXT Context,
        DWORD64 FeatureMask);
__declspec(dllimport)
    DWORD64
    __stdcall GetThreadEnabledXStateFeatures(
        void);
__declspec(dllimport)
    BOOL
    __stdcall EnableProcessOptionalXStateFeatures(
        DWORD64 Features);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall EnableThreadProfiling(
        HANDLE ThreadHandle,
        DWORD Flags,
        DWORD64 HardwareCounters,
        HANDLE* PerformanceDataHandle);
__declspec(dllimport)
    DWORD
    __stdcall DisableThreadProfiling(
        HANDLE PerformanceDataHandle);
__declspec(dllimport)
    DWORD
    __stdcall QueryThreadProfiling(
        HANDLE ThreadHandle,
        PBOOLEAN Enabled);
__declspec(dllimport)
    DWORD
    __stdcall ReadThreadProfilingData(
        HANDLE PerformanceDataHandle,
        DWORD Flags,
        PPERFORMANCE_DATA PerformanceData);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall RaiseCustomSystemEventTrigger(
        PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
#pragma endregion
}
#pragma warning(pop)
#pragma once
extern "C++" {
__forceinline unsigned
_InterlockedIncrement(
    unsigned volatile* Addend)
{
    return (unsigned)_InterlockedIncrement((volatile long*)Addend);
}
__forceinline unsigned long
_InterlockedIncrement(
    unsigned long volatile* Addend)
{
    return (unsigned long)_InterlockedIncrement((volatile long*)Addend);
}
__forceinline unsigned __int64
_InterlockedIncrement(
    unsigned __int64 volatile* Addend)
{
    return (unsigned __int64)(_InterlockedIncrement64)((volatile __int64*)Addend);
}
__forceinline unsigned
_InterlockedDecrement(
    unsigned volatile* Addend)
{
    return (unsigned long)_InterlockedDecrement((volatile long*)Addend);
}
__forceinline unsigned long
_InterlockedDecrement(
    unsigned long volatile* Addend)
{
    return (unsigned long)_InterlockedDecrement((volatile long*)Addend);
}
__forceinline unsigned __int64
_InterlockedDecrement(
    unsigned __int64 volatile* Addend)
{
    return (unsigned __int64)(_InterlockedDecrement64)((volatile __int64*)Addend);
}
__forceinline unsigned
_InterlockedExchange(
    unsigned volatile* Target,
    unsigned Value)
{
    return (unsigned)_InterlockedExchange((volatile long*)Target, (long)Value);
}
__forceinline unsigned long
_InterlockedExchange(
    unsigned long volatile* Target,
    unsigned long Value)
{
    return (unsigned long)_InterlockedExchange((volatile long*)Target, (long)Value);
}
__forceinline unsigned __int64
_InterlockedExchange(
    unsigned __int64 volatile* Target,
    unsigned __int64 Value)
{
    return (unsigned __int64)_InterlockedExchange64((volatile __int64*)Target, (__int64)Value);
}
__forceinline unsigned
_InterlockedExchangeAdd(
    unsigned volatile* Addend,
    unsigned Value)
{
    return (unsigned)_InterlockedExchangeAdd((volatile long*)Addend, (long)Value);
}
__forceinline unsigned
InterlockedExchangeSubtract(
    unsigned volatile* Addend,
    unsigned Value)
{
    return (unsigned)_InterlockedExchangeAdd((volatile long*)Addend, -(long)Value);
}
__forceinline unsigned long
_InterlockedExchangeAdd(
    unsigned long volatile* Addend,
    unsigned long Value)
{
    return (unsigned long)_InterlockedExchangeAdd((volatile long*)Addend, (long)Value);
}
__forceinline unsigned long
InterlockedExchangeSubtract(
    unsigned long volatile* Addend,
    unsigned long Value)
{
    return (unsigned long)_InterlockedExchangeAdd((volatile long*)Addend, -(long)Value);
}
__forceinline unsigned __int64
_InterlockedExchangeAdd(
    unsigned __int64 volatile* Addend,
    unsigned __int64 Value)
{
    return (unsigned __int64)_InterlockedExchangeAdd64((volatile __int64*)Addend, (__int64)Value);
}
__forceinline unsigned __int64
InterlockedExchangeSubtract(
    unsigned __int64 volatile* Addend,
    unsigned __int64 Value)
{
    return (unsigned __int64)_InterlockedExchangeAdd64((volatile __int64*)Addend, -(__int64)Value);
}
__forceinline unsigned
_InterlockedCompareExchange(
    unsigned volatile* Destination,
    unsigned Exchange,
    unsigned Comperand)
{
    return (unsigned)_InterlockedCompareExchange((volatile long*)Destination, (long)Exchange, (long)Comperand);
}
__forceinline unsigned long
_InterlockedCompareExchange(
    unsigned long volatile* Destination,
    unsigned long Exchange,
    unsigned long Comperand)
{
    return (unsigned long)_InterlockedCompareExchange((volatile long*)Destination, (long)Exchange, (long)Comperand);
}
__forceinline unsigned __int64
_InterlockedCompareExchange(
    unsigned __int64 volatile* Destination,
    unsigned __int64 Exchange,
    unsigned __int64 Comperand)
{
    return (unsigned __int64)_InterlockedCompareExchange64((volatile __int64*)Destination, (__int64)Exchange, (__int64)Comperand);
}
__forceinline unsigned __int64
_InterlockedAnd(
    unsigned __int64 volatile* Destination,
    unsigned __int64 Value)
{
    return (unsigned __int64)_InterlockedAnd64((volatile __int64*)Destination, (__int64)Value);
}
__forceinline unsigned __int64
_InterlockedOr(
    unsigned __int64 volatile* Destination,
    unsigned __int64 Value)
{
    return (unsigned __int64)_InterlockedOr64((volatile __int64*)Destination, (__int64)Value);
}
__forceinline unsigned __int64
_InterlockedXor(
    unsigned __int64 volatile* Destination,
    unsigned __int64 Value)
{
    return (unsigned __int64)_InterlockedXor64((volatile __int64*)Destination, (__int64)Value);
}
}
#pragma once
#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4820)
extern "C" {
#pragma region Desktop Family
typedef struct _DRAWPATRECT {
    POINT ptPosition;
    POINT ptSize;
    WORD wStyle;
    WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
#pragma endregion
#pragma region Desktop Family
typedef struct _PSINJECTDATA {
    DWORD DataBytes;
    WORD InjectionPoint;
    WORD PageNumber;
} PSINJECTDATA, *PPSINJECTDATA;
#pragma endregion
#pragma region Desktop Family
typedef struct _PSFEATURE_OUTPUT {
    BOOL bPageIndependent;
    BOOL bSetPageDevice;
} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;
typedef struct _PSFEATURE_CUSTPAPER {
    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;
} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;
#pragma endregion
#pragma region Application Family
typedef struct tagXFORM {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
} XFORM, *PXFORM, *LPXFORM;
typedef struct tagBITMAP {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    LPVOID bmBits;
} BITMAP, *PBITMAP, *NPBITMAP, *LPBITMAP;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(push, 1)
#pragma region Application Family
typedef struct tagRGBTRIPLE {
    BYTE rgbtBlue;
    BYTE rgbtGreen;
    BYTE rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE, *NPRGBTRIPLE, *LPRGBTRIPLE;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma region Application Family
typedef struct tagRGBQUAD {
    BYTE rgbBlue;
    BYTE rgbGreen;
    BYTE rgbRed;
    BYTE rgbReserved;
} RGBQUAD;
#pragma endregion
#pragma region Desktop Family
typedef RGBQUAD* LPRGBQUAD;
#pragma endregion
#pragma region Application Family
typedef LONG LCSCSTYPE;
typedef LONG LCSGAMUTMATCH;
typedef long FXPT16DOT16, *LPFXPT16DOT16;
typedef long FXPT2DOT30, *LPFXPT2DOT30;
typedef struct tagCIEXYZ {
    FXPT2DOT30 ciexyzX;
    FXPT2DOT30 ciexyzY;
    FXPT2DOT30 ciexyzZ;
} CIEXYZ;
#pragma endregion
#pragma region Desktop Family
typedef CIEXYZ* LPCIEXYZ;
#pragma endregion
#pragma region Application Family
typedef struct tagICEXYZTRIPLE {
    CIEXYZ ciexyzRed;
    CIEXYZ ciexyzGreen;
    CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE;
#pragma endregion
#pragma region Desktop Family
typedef CIEXYZTRIPLE* LPCIEXYZTRIPLE;
#pragma endregion
#pragma region Application Family
typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;
typedef LOGCOLORSPACEW LOGCOLORSPACE;
typedef LPLOGCOLORSPACEW LPLOGCOLORSPACE;
#pragma endregion
#pragma region Desktop Family
typedef struct tagBITMAPCOREHEADER {
    DWORD bcSize;
    WORD bcWidth;
    WORD bcHeight;
    WORD bcPlanes;
    WORD bcBitCount;
} BITMAPCOREHEADER, *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct tagBITMAPINFOHEADER {
    DWORD biSize;
    LONG biWidth;
    LONG biHeight;
    WORD biPlanes;
    WORD biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;
#pragma endregion
#pragma region Desktop Family
typedef struct {
    DWORD bV4Size;
    LONG bV4Width;
    LONG bV4Height;
    WORD bV4Planes;
    WORD bV4BitCount;
    DWORD bV4V4Compression;
    DWORD bV4SizeImage;
    LONG bV4XPelsPerMeter;
    LONG bV4YPelsPerMeter;
    DWORD bV4ClrUsed;
    DWORD bV4ClrImportant;
    DWORD bV4RedMask;
    DWORD bV4GreenMask;
    DWORD bV4BlueMask;
    DWORD bV4AlphaMask;
    DWORD bV4CSType;
    CIEXYZTRIPLE bV4Endpoints;
    DWORD bV4GammaRed;
    DWORD bV4GammaGreen;
    DWORD bV4GammaBlue;
} BITMAPV4HEADER, *LPBITMAPV4HEADER, *PBITMAPV4HEADER;
#pragma endregion
#pragma region Desktop Family
typedef struct {
    DWORD bV5Size;
    LONG bV5Width;
    LONG bV5Height;
    WORD bV5Planes;
    WORD bV5BitCount;
    DWORD bV5Compression;
    DWORD bV5SizeImage;
    LONG bV5XPelsPerMeter;
    LONG bV5YPelsPerMeter;
    DWORD bV5ClrUsed;
    DWORD bV5ClrImportant;
    DWORD bV5RedMask;
    DWORD bV5GreenMask;
    DWORD bV5BlueMask;
    DWORD bV5AlphaMask;
    DWORD bV5CSType;
    CIEXYZTRIPLE bV5Endpoints;
    DWORD bV5GammaRed;
    DWORD bV5GammaGreen;
    DWORD bV5GammaBlue;
    DWORD bV5Intent;
    DWORD bV5ProfileData;
    DWORD bV5ProfileSize;
    DWORD bV5Reserved;
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;
#pragma endregion
#pragma region Application Family
typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1];
} BITMAPINFO, *LPBITMAPINFO, *PBITMAPINFO;
#pragma endregion
#pragma region Desktop Family
typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO, *LPBITMAPCOREINFO, *PBITMAPCOREINFO;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(push, 2)
#pragma region Desktop Family
typedef struct tagBITMAPFILEHEADER {
    WORD bfType;
    DWORD bfSize;
    WORD bfReserved1;
    WORD bfReserved2;
    DWORD bfOffBits;
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma region Application Family
typedef struct tagFONTSIGNATURE {
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;
#pragma endregion
#pragma region Desktop Family
typedef struct tagCHARSETINFO {
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, *NPCHARSETINFO, *LPCHARSETINFO;
#pragma endregion
#pragma region Application Family
typedef struct tagLOCALESIGNATURE {
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;
#pragma endregion
#pragma region Application Family
typedef struct tagHANDLETABLE {
    HGDIOBJ objectHandle[1];
} HANDLETABLE, *PHANDLETABLE, *LPHANDLETABLE;
typedef struct tagMETARECORD {
    DWORD rdSize;
    WORD rdFunction;
    WORD rdParm[1];
} METARECORD;
#pragma endregion
#pragma region Desktop Family
typedef struct tagMETARECORD __unaligned* PMETARECORD;
#pragma endregion
#pragma region Application Family
typedef struct tagMETARECORD __unaligned* LPMETARECORD;
typedef struct tagMETAFILEPICT {
    LONG mm;
    LONG xExt;
    LONG yExt;
    HMETAFILE hMF;
} METAFILEPICT, *LPMETAFILEPICT;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(push, 2)
#pragma region Desktop Family
typedef struct tagMETAHEADER {
    WORD mtType;
    WORD mtHeaderSize;
    WORD mtVersion;
    DWORD mtSize;
    WORD mtNoObjects;
    DWORD mtMaxRecord;
    WORD mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER __unaligned* PMETAHEADER;
typedef struct tagMETAHEADER __unaligned* LPMETAHEADER;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma region Application Family
typedef struct tagENHMETARECORD {
    DWORD iType;
    DWORD nSize;
    DWORD dParm[1];
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;
typedef struct tagENHMETAHEADER {
    DWORD iType;
    DWORD nSize;
    RECTL rclBounds;
    RECTL rclFrame;
    DWORD dSignature;
    DWORD nVersion;
    DWORD nBytes;
    DWORD nRecords;
    WORD nHandles;
    WORD sReserved;
    DWORD nDescription;
    DWORD offDescription;
    DWORD nPalEntries;
    SIZEL szlDevice;
    SIZEL szlMillimeters;
    DWORD cbPixelFormat;
    DWORD offPixelFormat;
    DWORD bOpenGL;
    SIZEL szlMicrometers;
} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;
#pragma endregion
#pragma region Desktop Family
typedef WCHAR BCHAR;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(push, 4)
#pragma region Application Family
typedef struct tagTEXTMETRICA {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA, *NPTEXTMETRICA, *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW, *NPTEXTMETRICW, *LPTEXTMETRICW;
typedef TEXTMETRICW TEXTMETRIC;
typedef PTEXTMETRICW PTEXTMETRIC;
typedef NPTEXTMETRICW NPTEXTMETRIC;
typedef LPTEXTMETRICW LPTEXTMETRIC;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma warning(disable : 4103)
#pragma pack(push, 4)
#pragma region Desktop Family
typedef struct tagNEWTEXTMETRICA {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, *NPNEWTEXTMETRICA, *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW, *NPNEWTEXTMETRICW, *LPNEWTEXTMETRICW;
typedef NEWTEXTMETRICW NEWTEXTMETRIC;
typedef PNEWTEXTMETRICW PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICW NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICW LPNEWTEXTMETRIC;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma region Desktop Family
typedef struct tagNEWTEXTMETRICEXA {
    NEWTEXTMETRICA ntmTm;
    FONTSIGNATURE ntmFontSig;
} NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW {
    NEWTEXTMETRICW ntmTm;
    FONTSIGNATURE ntmFontSig;
} NEWTEXTMETRICEXW;
typedef NEWTEXTMETRICEXW NEWTEXTMETRICEX;
#pragma endregion
#pragma region Desktop Family
typedef struct tagPELARRAY {
    LONG paXCount;
    LONG paYCount;
    LONG paXExt;
    LONG paYExt;
    BYTE paRGBs;
} PELARRAY, *PPELARRAY, *NPPELARRAY, *LPPELARRAY;
#pragma endregion
#pragma region Application Family
typedef struct tagLOGBRUSH {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG_PTR lbHatch;
} LOGBRUSH, *PLOGBRUSH, *NPLOGBRUSH, *LPLOGBRUSH;
typedef struct tagLOGBRUSH32 {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG lbHatch;
} LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;
#pragma endregion
#pragma region Desktop Family
typedef LOGBRUSH PATTERN;
typedef PATTERN* PPATTERN;
typedef PATTERN* NPPATTERN;
typedef PATTERN* LPPATTERN;
#pragma endregion
#pragma region Application Family
typedef struct tagLOGPEN {
    UINT lopnStyle;
    POINT lopnWidth;
    COLORREF lopnColor;
} LOGPEN, *PLOGPEN, *NPLOGPEN, *LPLOGPEN;
#pragma endregion
#pragma region Desktop Family
typedef struct tagEXTLOGPEN {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG_PTR elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN, *NPEXTLOGPEN, *LPEXTLOGPEN;
#pragma endregion
#pragma region Application Family
typedef struct tagEXTLOGPEN32 {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32, *NPEXTLOGPEN32, *LPEXTLOGPEN32;
typedef struct tagPALETTEENTRY {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
} PALETTEENTRY, *PPALETTEENTRY, *LPPALETTEENTRY;
typedef struct tagLOGPALETTE {
    WORD palVersion;
    WORD palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, *NPLOGPALETTE, *LPLOGPALETTE;
typedef struct tagLOGFONTA {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[32];
} LOGFONTA, *PLOGFONTA, *NPLOGFONTA, *LPLOGFONTA;
typedef struct tagLOGFONTW {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[32];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;
typedef LOGFONTW LOGFONT;
typedef PLOGFONTW PLOGFONT;
typedef NPLOGFONTW NPLOGFONT;
typedef LPLOGFONTW LPLOGFONT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagENUMLOGFONTA {
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
} ENUMLOGFONTA, *LPENUMLOGFONTA;
typedef struct tagENUMLOGFONTW {
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
} ENUMLOGFONTW, *LPENUMLOGFONTW;
typedef ENUMLOGFONTW ENUMLOGFONT;
typedef LPENUMLOGFONTW LPENUMLOGFONT;
typedef struct tagENUMLOGFONTEXA {
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    BYTE elfScript[32];
} ENUMLOGFONTEXA, *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW {
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    WCHAR elfScript[32];
} ENUMLOGFONTEXW, *LPENUMLOGFONTEXW;
typedef ENUMLOGFONTEXW ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXW LPENUMLOGFONTEX;
#pragma endregion
#pragma region Application Family
typedef struct tagPANOSE {
    BYTE bFamilyType;
    BYTE bSerifStyle;
    BYTE bWeight;
    BYTE bProportion;
    BYTE bContrast;
    BYTE bStrokeVariation;
    BYTE bArmStyle;
    BYTE bLetterform;
    BYTE bMidline;
    BYTE bXHeight;
} PANOSE, *LPPANOSE;
typedef struct tagEXTLOGFONTA {
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    DWORD elfVersion;
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture;
    PANOSE elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA, *NPEXTLOGFONTA, *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    DWORD elfVersion;
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture;
    PANOSE elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW, *NPEXTLOGFONTW, *LPEXTLOGFONTW;
typedef EXTLOGFONTW EXTLOGFONT;
typedef PEXTLOGFONTW PEXTLOGFONT;
typedef NPEXTLOGFONTW NPEXTLOGFONT;
typedef LPEXTLOGFONTW LPEXTLOGFONT;
#pragma endregion
#pragma region Application Family
typedef struct _devicemodeA {
    BYTE dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
        struct {
            short dmOrientation;
            short dmPaperSize;
            short dmPaperLength;
            short dmPaperWidth;
            short dmScale;
            short dmCopies;
            short dmDefaultSource;
            short dmPrintQuality;
        };
        struct {
            POINTL dmPosition;
            DWORD dmDisplayOrientation;
            DWORD dmDisplayFixedOutput;
        };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    };
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
        struct {
            short dmOrientation;
            short dmPaperSize;
            short dmPaperLength;
            short dmPaperWidth;
            short dmScale;
            short dmCopies;
            short dmDefaultSource;
            short dmPrintQuality;
        };
        struct {
            POINTL dmPosition;
            DWORD dmDisplayOrientation;
            DWORD dmDisplayFixedOutput;
        };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    };
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;
typedef DEVMODEW DEVMODE;
typedef PDEVMODEW PDEVMODE;
typedef NPDEVMODEW NPDEVMODE;
typedef LPDEVMODEW LPDEVMODE;
#pragma endregion
#pragma region Application Family
typedef struct _DISPLAY_DEVICEA {
    DWORD cb;
    CHAR DeviceName[32];
    CHAR DeviceString[128];
    DWORD StateFlags;
    CHAR DeviceID[128];
    CHAR DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD cb;
    WCHAR DeviceName[32];
    WCHAR DeviceString[128];
    DWORD StateFlags;
    WCHAR DeviceID[128];
    WCHAR DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;
typedef DISPLAY_DEVICEW DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEW PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEW LPDISPLAY_DEVICE;
#pragma endregion
#pragma region Application Family
typedef struct DISPLAYCONFIG_RATIONAL {
    UINT32 Numerator;
    UINT32 Denominator;
} DISPLAYCONFIG_RATIONAL;
typedef enum {
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL = 18,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;
typedef enum {
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_SCANLINE_ORDERING;
typedef struct DISPLAYCONFIG_2DREGION {
    UINT32 cx;
    UINT32 cy;
} DISPLAYCONFIG_2DREGION;
typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
    UINT64 pixelRate;
    DISPLAYCONFIG_RATIONAL hSyncFreq;
    DISPLAYCONFIG_RATIONAL vSyncFreq;
    DISPLAYCONFIG_2DREGION activeSize;
    DISPLAYCONFIG_2DREGION totalSize;
    union {
        struct
        {
            UINT32 videoStandard : 16;
            UINT32 vSyncFreqDivider : 6;
            UINT32 reserved : 10;
        } AdditionalSignalInfo;
        UINT32 videoStandard;
    };
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
} DISPLAYCONFIG_VIDEO_SIGNAL_INFO;
typedef enum {
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_SCALING;
typedef enum {
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_ROTATION;
typedef enum {
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_MODE_INFO_TYPE;
typedef enum {
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = 0xffffffff
} DISPLAYCONFIG_PIXELFORMAT;
typedef struct DISPLAYCONFIG_SOURCE_MODE {
    UINT32 width;
    UINT32 height;
    DISPLAYCONFIG_PIXELFORMAT pixelFormat;
    POINTL position;
} DISPLAYCONFIG_SOURCE_MODE;
typedef struct DISPLAYCONFIG_TARGET_MODE {
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
} DISPLAYCONFIG_TARGET_MODE;
typedef struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO {
    POINTL PathSourceSize;
    RECTL DesktopImageRegion;
    RECTL DesktopImageClip;
} DISPLAYCONFIG_DESKTOP_IMAGE_INFO;
typedef struct DISPLAYCONFIG_MODE_INFO {
    DISPLAYCONFIG_MODE_INFO_TYPE infoType;
    UINT32 id;
    LUID adapterId;
    union {
        DISPLAYCONFIG_TARGET_MODE targetMode;
        DISPLAYCONFIG_SOURCE_MODE sourceMode;
        DISPLAYCONFIG_DESKTOP_IMAGE_INFO desktopImageInfo;
    };
} DISPLAYCONFIG_MODE_INFO;
typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO {
    LUID adapterId;
    UINT32 id;
    union {
        UINT32 modeInfoIdx;
        struct
        {
            UINT32 cloneGroupId : 16;
            UINT32 sourceModeInfoIdx : 16;
        };
    };
    UINT32 statusFlags;
} DISPLAYCONFIG_PATH_SOURCE_INFO;
typedef struct DISPLAYCONFIG_PATH_TARGET_INFO {
    LUID adapterId;
    UINT32 id;
    union {
        UINT32 modeInfoIdx;
        struct
        {
            UINT32 desktopModeInfoIdx : 16;
            UINT32 targetModeInfoIdx : 16;
        };
    };
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    DISPLAYCONFIG_ROTATION rotation;
    DISPLAYCONFIG_SCALING scaling;
    DISPLAYCONFIG_RATIONAL refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    BOOL targetAvailable;
    UINT32 statusFlags;
} DISPLAYCONFIG_PATH_TARGET_INFO;
typedef struct DISPLAYCONFIG_PATH_INFO {
    DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
    UINT32 flags;
} DISPLAYCONFIG_PATH_INFO;
typedef enum DISPLAYCONFIG_TOPOLOGY_ID {
    DISPLAYCONFIG_TOPOLOGY_INTERNAL = 0x00000001,
    DISPLAYCONFIG_TOPOLOGY_CLONE = 0x00000002,
    DISPLAYCONFIG_TOPOLOGY_EXTEND = 0x00000004,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 0x00000008,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_TOPOLOGY_ID;
typedef enum {
    DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
    DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6,
    DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7,
    DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9,
    DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10,
    DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11,
    DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION = 12,
    DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION = 13,
    DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_DEVICE_INFO_TYPE;
#pragma endregion
#pragma region Application Family
typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER {
    DISPLAYCONFIG_DEVICE_INFO_TYPE type;
    UINT32 size;
    LUID adapterId;
    UINT32 id;
} DISPLAYCONFIG_DEVICE_INFO_HEADER;
#pragma endregion
#pragma region Desktop Family
typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    WCHAR viewGdiDeviceName[32];
} DISPLAYCONFIG_SOURCE_DEVICE_NAME;
typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
    union {
        struct
        {
            UINT32 friendlyNameFromEdid : 1;
            UINT32 friendlyNameForced : 1;
            UINT32 edidIdsValid : 1;
            UINT32 reserved : 29;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;
typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    UINT16 edidManufactureId;
    UINT16 edidProductCodeId;
    UINT32 connectorInstance;
    WCHAR monitorFriendlyDeviceName[64];
    WCHAR monitorDevicePath[128];
} DISPLAYCONFIG_TARGET_DEVICE_NAME;
typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    UINT32 width;
    UINT32 height;
    DISPLAYCONFIG_TARGET_MODE targetMode;
} DISPLAYCONFIG_TARGET_PREFERRED_MODE;
typedef struct DISPLAYCONFIG_ADAPTER_NAME {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    WCHAR adapterDevicePath[128];
} DISPLAYCONFIG_ADAPTER_NAME;
typedef struct DISPLAYCONFIG_TARGET_BASE_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
} DISPLAYCONFIG_TARGET_BASE_TYPE;
typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union {
        struct
        {
            UINT32 bootPersistenceOn : 1;
            UINT32 reserved : 31;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_SET_TARGET_PERSISTENCE;
typedef struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union {
        struct
        {
            UINT32 disableMonitorVirtualResolution : 1;
            UINT32 reserved : 31;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION;
typedef enum _DISPLAYCONFIG_COLOR_ENCODING {
    DISPLAYCONFIG_COLOR_ENCODING_RGB = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_COLOR_ENCODING;
typedef struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union {
        struct
        {
            UINT32 advancedColorSupported : 1;
            UINT32 advancedColorEnabled : 1;
            UINT32 wideColorEnforced : 1;
            UINT32 advancedColorForceDisabled : 1;
            UINT32 reserved : 28;
        };
        UINT32 value;
    };
    DISPLAYCONFIG_COLOR_ENCODING colorEncoding;
    UINT32 bitsPerColorChannel;
} DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;
typedef struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union {
        struct
        {
            UINT32 enableAdvancedColor : 1;
            UINT32 reserved : 31;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;
typedef struct _DISPLAYCONFIG_SDR_WHITE_LEVEL {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    ULONG SDRWhiteLevel;
} DISPLAYCONFIG_SDR_WHITE_LEVEL;
typedef struct _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union {
        struct
        {
            UINT32 isSpecializationEnabled : 1;
            UINT32 isSpecializationAvailableForMonitor : 1;
            UINT32 isSpecializationAvailableForSystem : 1;
            UINT32 reserved : 29;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION;
typedef struct _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION {
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union {
        struct
        {
            UINT32 isSpecializationEnabled : 1;
            UINT32 reserved : 31;
        };
        UINT32 value;
    };
    GUID specializationType;
    GUID specializationSubType;
    WCHAR specializationApplicationName[128];
} DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION;
#pragma endregion
#pragma region Application Family
typedef struct _RGNDATAHEADER {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;
typedef struct _RGNDATA {
    RGNDATAHEADER rdh;
    char Buffer[1];
} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;
#pragma endregion
#pragma region Desktop Family
typedef struct _ABC {
    int abcA;
    UINT abcB;
    int abcC;
} ABC, *PABC, *NPABC, *LPABC;
typedef struct _ABCFLOAT {
    FLOAT abcfA;
    FLOAT abcfB;
    FLOAT abcfC;
} ABCFLOAT, *PABCFLOAT, *NPABCFLOAT, *LPABCFLOAT;
#pragma endregion
#pragma region Desktop Family
typedef struct _OUTLINETEXTMETRICA {
    UINT otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
    int otmsCharSlopeRise;
    int otmsCharSlopeRun;
    int otmItalicAngle;
    UINT otmEMSquare;
    int otmAscent;
    int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
    int otmMacAscent;
    int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
    int otmsStrikeoutPosition;
    int otmsUnderscoreSize;
    int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, *NPOUTLINETEXTMETRICA, *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
    int otmsCharSlopeRise;
    int otmsCharSlopeRun;
    int otmItalicAngle;
    UINT otmEMSquare;
    int otmAscent;
    int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
    int otmMacAscent;
    int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
    int otmsStrikeoutPosition;
    int otmsUnderscoreSize;
    int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, *NPOUTLINETEXTMETRICW, *LPOUTLINETEXTMETRICW;
typedef OUTLINETEXTMETRICW OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICW POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICW NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICW LPOUTLINETEXTMETRIC;
#pragma endregion
#pragma region Application Family
typedef struct tagPOLYTEXTA {
    int x;
    int y;
    UINT n;
    LPCSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int* pdx;
} POLYTEXTA, *PPOLYTEXTA, *NPPOLYTEXTA, *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW {
    int x;
    int y;
    UINT n;
    LPCWSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int* pdx;
} POLYTEXTW, *PPOLYTEXTW, *NPPOLYTEXTW, *LPPOLYTEXTW;
typedef POLYTEXTW POLYTEXT;
typedef PPOLYTEXTW PPOLYTEXT;
typedef NPPOLYTEXTW NPPOLYTEXT;
typedef LPPOLYTEXTW LPPOLYTEXT;
#pragma endregion
#pragma region Desktop Family
typedef struct _FIXED {
    WORD fract;
    short value;
} FIXED;
typedef struct _MAT2 {
    FIXED eM11;
    FIXED eM12;
    FIXED eM21;
    FIXED eM22;
} MAT2, *LPMAT2;
typedef struct _GLYPHMETRICS {
    UINT gmBlackBoxX;
    UINT gmBlackBoxY;
    POINT gmptGlyphOrigin;
    short gmCellIncX;
    short gmCellIncY;
} GLYPHMETRICS, *LPGLYPHMETRICS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagPOINTFX {
    FIXED x;
    FIXED y;
} POINTFX, *LPPOINTFX;
typedef struct tagTTPOLYCURVE {
    WORD wType;
    WORD cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, *LPTTPOLYCURVE;
typedef struct tagTTPOLYGONHEADER {
    DWORD cb;
    DWORD dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, *LPTTPOLYGONHEADER;
#pragma endregion
#pragma region Desktop Family
typedef struct tagGCP_RESULTSA {
    DWORD lStructSize;
    LPSTR lpOutString;
    UINT* lpOrder;
    int* lpDx;
    int* lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
} GCP_RESULTSA, *LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW {
    DWORD lStructSize;
    LPWSTR lpOutString;
    UINT* lpOrder;
    int* lpDx;
    int* lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
} GCP_RESULTSW, *LPGCP_RESULTSW;
typedef GCP_RESULTSW GCP_RESULTS;
typedef LPGCP_RESULTSW LPGCP_RESULTS;
#pragma endregion
#pragma region Desktop Family
typedef struct _RASTERIZER_STATUS {
    short nSize;
    short wFlags;
    short nLanguageID;
} RASTERIZER_STATUS, *LPRASTERIZER_STATUS;
#pragma endregion
#pragma region Application Family
typedef struct tagPIXELFORMATDESCRIPTOR {
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerType;
    BYTE bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, *LPPIXELFORMATDESCRIPTOR;
#pragma endregion
#pragma region Desktop Family
typedef int(__stdcall* OLDFONTENUMPROCA)(const LOGFONTA*, const TEXTMETRICA*, DWORD, LPARAM);
typedef int(__stdcall* OLDFONTENUMPROCW)(const LOGFONTW*, const TEXTMETRICW*, DWORD, LPARAM);
typedef OLDFONTENUMPROCA FONTENUMPROCA;
typedef OLDFONTENUMPROCW FONTENUMPROCW;
typedef FONTENUMPROCW FONTENUMPROC;
typedef int(__stdcall* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void(__stdcall* LINEDDAPROC)(int, int, LPARAM);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall AddFontResourceA(LPCSTR);
__declspec(dllimport) int __stdcall AddFontResourceW(LPCWSTR);
__declspec(dllimport) BOOL __stdcall AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY* ppe);
__declspec(dllimport) BOOL __stdcall Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
__declspec(dllimport) BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
__declspec(dllimport) BOOL __stdcall CancelDC(HDC hdc);
__declspec(dllimport) BOOL __stdcall Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
__declspec(dllimport) int __stdcall ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR* ppfd);
__declspec(dllimport) HMETAFILE __stdcall CloseMetaFile(HDC hdc);
__declspec(dllimport) int __stdcall CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA(HMETAFILE, LPCSTR);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW(HMETAFILE, LPCWSTR);
__declspec(dllimport) HBITMAP __stdcall CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void* lpBits);
__declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect(const BITMAP* pbm);
__declspec(dllimport) HBRUSH __stdcall CreateBrushIndirect(const LOGBRUSH* plbrush);
__declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
__declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap(HDC hdc, int cx, int cy);
__declspec(dllimport) HDC __stdcall CreateCompatibleDC(HDC hdc);
__declspec(dllimport) HDC __stdcall CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA* pdm);
__declspec(dllimport) HDC __stdcall CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW* pdm);
__declspec(dllimport) HBITMAP __stdcall CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER* pbmih, DWORD flInit, const void* pjBits, const BITMAPINFO* pbmi, UINT iUsage);
__declspec(dllimport) HBRUSH __stdcall CreateDIBPatternBrush(HGLOBAL h, UINT iUsage);
__declspec(dllimport) HBRUSH __stdcall CreateDIBPatternBrushPt(const void* lpPackedDIB, UINT iUsage);
__declspec(dllimport) HRGN __stdcall CreateEllipticRgn(int x1, int y1, int x2, int y2);
__declspec(dllimport) HRGN __stdcall CreateEllipticRgnIndirect(const RECT* lprect);
__declspec(dllimport) HFONT __stdcall CreateFontIndirectA(const LOGFONTA* lplf);
__declspec(dllimport) HFONT __stdcall CreateFontIndirectW(const LOGFONTW* lplf);
__declspec(dllimport) HFONT __stdcall CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
    DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
    DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
__declspec(dllimport) HFONT __stdcall CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
    DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
    DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
__declspec(dllimport) HBRUSH __stdcall CreateHatchBrush(int iHatch, COLORREF color);
__declspec(dllimport) HDC __stdcall CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA* pdm);
__declspec(dllimport) HDC __stdcall CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW* pdm);
__declspec(dllimport) HDC __stdcall CreateMetaFileA(LPCSTR pszFile);
__declspec(dllimport) HDC __stdcall CreateMetaFileW(LPCWSTR pszFile);
__declspec(dllimport) HPALETTE __stdcall CreatePalette(const LOGPALETTE* plpal);
__declspec(dllimport) HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
__declspec(dllimport) HPEN __stdcall CreatePenIndirect(const LOGPEN* plpen);
__declspec(dllimport) HRGN __stdcall CreatePolyPolygonRgn(const POINT* pptl,
    const INT* pc,
    int cPoly,
    int iMode);
__declspec(dllimport) HBRUSH __stdcall CreatePatternBrush(HBITMAP hbm);
__declspec(dllimport) HRGN __stdcall CreateRectRgn(int x1, int y1, int x2, int y2);
__declspec(dllimport) HRGN __stdcall CreateRectRgnIndirect(const RECT* lprect);
__declspec(dllimport) HRGN __stdcall CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h);
__declspec(dllimport) BOOL __stdcall CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath);
__declspec(dllimport) BOOL __stdcall CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath);
__declspec(dllimport) HBRUSH __stdcall CreateSolidBrush(COLORREF color);
__declspec(dllimport) BOOL __stdcall DeleteDC(HDC hdc);
__declspec(dllimport) BOOL __stdcall DeleteMetaFile(HMETAFILE hmf);
__declspec(dllimport) BOOL __stdcall DeleteObject(HGDIOBJ ho);
__declspec(dllimport) int __stdcall DescribePixelFormat(HDC hdc,
    int iPixelFormat,
    UINT nBytes,
    LPPIXELFORMATDESCRIPTOR ppfd);
typedef UINT(__stdcall* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);
typedef DWORD(__stdcall* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall DeviceCapabilitiesA(
    LPCSTR pDevice,
    LPCSTR pPort,
    WORD fwCapability,
    LPSTR pOutput,
    const DEVMODEA* pDevMode);
__declspec(dllimport) int __stdcall DeviceCapabilitiesW(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD fwCapability,
    LPWSTR pOutput,
    const DEVMODEW* pDevMode);
__declspec(dllimport) int __stdcall DrawEscape(HDC hdc,
    int iEscape,
    int cjIn,
    LPCSTR lpIn);
__declspec(dllimport) BOOL __stdcall Ellipse(HDC hdc, int left, int top, int right, int bottom);
__declspec(dllimport) int __stdcall EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags);
__declspec(dllimport) int __stdcall EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);
__declspec(dllimport) int __stdcall EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
__declspec(dllimport) int __stdcall EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);
__declspec(dllimport) int __stdcall EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
__declspec(dllimport) int __stdcall EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);
__declspec(dllimport) int __stdcall EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam);
__declspec(dllimport) BOOL __stdcall EqualRgn(HRGN hrgn1, HRGN hrgn2);
__declspec(dllimport) int __stdcall Escape(HDC hdc,
    int iEscape,
    int cjIn,
    LPCSTR pvIn,
    LPVOID pvOut);
__declspec(dllimport) int __stdcall ExtEscape(HDC hdc,
    int iEscape,
    int cjInput,
    LPCSTR lpInData,
    int cjOutput,
    LPSTR lpOutData);
__declspec(dllimport) int __stdcall ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom);
__declspec(dllimport) HRGN __stdcall ExtCreateRegion(const XFORM* lpx, DWORD nCount, const RGNDATA* lpData);
__declspec(dllimport) BOOL __stdcall ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type);
__declspec(dllimport) BOOL __stdcall FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
__declspec(dllimport) BOOL __stdcall FloodFill(HDC hdc, int x, int y, COLORREF color);
__declspec(dllimport) BOOL __stdcall FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
__declspec(dllimport) int __stdcall GetROP2(HDC hdc);
__declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize);
__declspec(dllimport) COLORREF __stdcall GetBkColor(HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCBrushColor(HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCPenColor(HDC hdc);
__declspec(dllimport) int __stdcall GetBkMode(
    HDC hdc);
__declspec(dllimport)
    LONG
    __stdcall GetBitmapBits(
        HBITMAP hbit,
        LONG cb,
        LPVOID lpvBits);
__declspec(dllimport) BOOL __stdcall GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize);
__declspec(dllimport) UINT __stdcall GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags);
__declspec(dllimport) BOOL __stdcall GetBrushOrgEx(HDC hdc, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsA(HDC hdc,
    UINT wFirst,
    UINT wLast,
    LPABC lpABC);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsW(HDC hdc,
    UINT wFirst,
    UINT wLast,
    LPABC lpABC);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
__declspec(dllimport) int __stdcall GetClipBox(HDC hdc, LPRECT lprect);
__declspec(dllimport) int __stdcall GetClipRgn(HDC hdc, HRGN hrgn);
__declspec(dllimport) int __stdcall GetMetaRgn(HDC hdc, HRGN hrgn);
__declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject(HDC hdc, UINT type);
__declspec(dllimport) BOOL __stdcall GetCurrentPositionEx(HDC hdc, LPPOINT lppt);
__declspec(dllimport) int __stdcall GetDeviceCaps(HDC hdc, int index);
__declspec(dllimport) int __stdcall GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,
    LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
__declspec(dllimport) DWORD __stdcall GetFontData(HDC hdc,
    DWORD dwTable,
    DWORD dwOffset,
    PVOID pvBuffer,
    DWORD cjBuffer);
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineA(HDC hdc,
    UINT uChar,
    UINT fuFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cjBuffer,
    LPVOID pvBuffer,
    const MAT2* lpmat2);
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineW(HDC hdc,
    UINT uChar,
    UINT fuFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cjBuffer,
    LPVOID pvBuffer,
    const MAT2* lpmat2);
__declspec(dllimport) int __stdcall GetGraphicsMode(HDC hdc);
__declspec(dllimport) int __stdcall GetMapMode(HDC hdc);
__declspec(dllimport) UINT __stdcall GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData);
__declspec(dllimport) HMETAFILE __stdcall GetMetaFileA(LPCSTR lpName);
__declspec(dllimport) HMETAFILE __stdcall GetMetaFileW(LPCWSTR lpName);
__declspec(dllimport) COLORREF __stdcall GetNearestColor(HDC hdc, COLORREF color);
__declspec(dllimport) UINT __stdcall GetNearestPaletteIndex(HPALETTE h, COLORREF color);
__declspec(dllimport) DWORD __stdcall GetObjectType(HGDIOBJ h);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA(HDC hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICA potm);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW(HDC hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICW potm);
__declspec(dllimport) UINT __stdcall GetPaletteEntries(HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries);
__declspec(dllimport) COLORREF __stdcall GetPixel(HDC hdc, int x, int y);
__declspec(dllimport) int __stdcall GetPixelFormat(HDC hdc);
__declspec(dllimport) int __stdcall GetPolyFillMode(HDC hdc);
__declspec(dllimport) BOOL __stdcall GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat,
    UINT cjBytes);
__declspec(dllimport) int __stdcall GetRandomRgn(HDC hdc, HRGN hrgn, INT i);
__declspec(dllimport) DWORD __stdcall GetRegionData(HRGN hrgn,
    DWORD nCount,
    LPRGNDATA lpRgnData);
__declspec(dllimport) int __stdcall GetRgnBox(HRGN hrgn, LPRECT lprc);
__declspec(dllimport) HGDIOBJ __stdcall GetStockObject(int i);
__declspec(dllimport) int __stdcall GetStretchBltMode(HDC hdc);
__declspec(dllimport)
    UINT
    __stdcall GetSystemPaletteEntries(
        HDC hdc,
        UINT iStart,
        UINT cEntries,
        LPPALETTEENTRY pPalEntries);
__declspec(dllimport) UINT __stdcall GetSystemPaletteUse(HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharacterExtra(HDC hdc);
__declspec(dllimport) UINT __stdcall GetTextAlign(HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetTextColor(HDC hdc);
__declspec(dllimport)
    BOOL
    __stdcall GetTextExtentPointA(
        HDC hdc,
        LPCSTR lpString,
        int c,
        LPSIZE lpsz);
__declspec(dllimport)
    BOOL
    __stdcall GetTextExtentPointW(
        HDC hdc,
        LPCWSTR lpString,
        int c,
        LPSIZE lpsz);
__declspec(dllimport)
    BOOL
    __stdcall GetTextExtentPoint32A(
        HDC hdc,
        LPCSTR lpString,
        int c,
        LPSIZE psizl);
__declspec(dllimport)
    BOOL
    __stdcall GetTextExtentPoint32W(
        HDC hdc,
        LPCWSTR lpString,
        int c,
        LPSIZE psizl);
__declspec(dllimport)
    BOOL
    __stdcall GetTextExtentExPointA(
        HDC hdc,
        LPCSTR lpszString,
        int cchString,
        int nMaxExtent,
        LPINT lpnFit,
        LPINT lpnDx,
        LPSIZE lpSize);
__declspec(dllimport)
    BOOL
    __stdcall GetTextExtentExPointW(
        HDC hdc,
        LPCWSTR lpszString,
        int cchString,
        int nMaxExtent,
        LPINT lpnFit,
        LPINT lpnDx,
        LPSIZE lpSize);
__declspec(dllimport) int __stdcall GetTextCharset(HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
__declspec(dllimport) BOOL __stdcall TranslateCharsetInfo(DWORD* lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetFontLanguageInfo(HDC hdc);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family
typedef struct tagWCRANGE {
    WCHAR wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;
typedef struct tagGLYPHSET {
    DWORD cbThis;
    DWORD flAccel;
    DWORD cGlyphsSupported;
    DWORD cRanges;
    WCRANGE ranges[1];
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;
__declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl);
__declspec(dllimport) BOOL __stdcall GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize);
__declspec(dllimport) BOOL __stdcall GetTextExtentExPointI(HDC hdc,
    LPWORD lpwszString,
    int cwchString,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT lpnDx,
    LPSIZE lpSize);
__declspec(dllimport) BOOL __stdcall GetCharWidthI(HDC hdc,
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT piWidths);
__declspec(dllimport) BOOL __stdcall GetCharABCWidthsI(HDC hdc,
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC pabc);
typedef struct tagDESIGNVECTOR {
    DWORD dvReserved;
    DWORD dvNumAxes;
    LONG dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;
__declspec(dllimport) int __stdcall AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res);
__declspec(dllimport) int __stdcall AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv);
__declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx(PVOID pFileView,
    DWORD cjSize,
    PVOID pvResrved,
    DWORD* pNumFonts);
__declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx(HANDLE h);
typedef struct tagAXISINFOA {
    LONG axMinValue;
    LONG axMaxValue;
    BYTE axAxisName[16];
} AXISINFOA, *PAXISINFOA, *LPAXISINFOA;
typedef struct tagAXISINFOW {
    LONG axMinValue;
    LONG axMaxValue;
    WCHAR axAxisName[16];
} AXISINFOW, *PAXISINFOW, *LPAXISINFOW;
typedef AXISINFOW AXISINFO;
typedef PAXISINFOW PAXISINFO;
typedef LPAXISINFOW LPAXISINFO;
typedef struct tagAXESLISTA {
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA, *LPAXESLISTA;
typedef struct tagAXESLISTW {
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW, *LPAXESLISTW;
typedef AXESLISTW AXESLIST;
typedef PAXESLISTW PAXESLIST;
typedef LPAXESLISTW LPAXESLIST;
typedef struct tagENUMLOGFONTEXDVA {
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW {
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, *LPENUMLOGFONTEXDVW;
typedef ENUMLOGFONTEXDVW ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVW PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVW LPENUMLOGFONTEXDV;
__declspec(dllimport) HFONT __stdcall CreateFontIndirectExA(const ENUMLOGFONTEXDVA*);
__declspec(dllimport) HFONT __stdcall CreateFontIndirectExW(const ENUMLOGFONTEXDVW*);
typedef struct tagENUMTEXTMETRICA {
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA, *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW {
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW, *LPENUMTEXTMETRICW;
typedef ENUMTEXTMETRICW ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICW PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICW LPENUMTEXTMETRIC;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) BOOL __stdcall GetViewportExtEx(HDC hdc, LPSIZE lpsize);
__declspec(dllimport) BOOL __stdcall GetViewportOrgEx(HDC hdc, LPPOINT lppoint);
__declspec(dllimport) BOOL __stdcall GetWindowExtEx(HDC hdc, LPSIZE lpsize);
__declspec(dllimport) BOOL __stdcall GetWindowOrgEx(HDC hdc, LPPOINT lppoint);
__declspec(dllimport) int __stdcall IntersectClipRect(HDC hdc, int left, int top, int right, int bottom);
__declspec(dllimport) BOOL __stdcall InvertRgn(HDC hdc, HRGN hrgn);
__declspec(dllimport) BOOL __stdcall LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data);
__declspec(dllimport) BOOL __stdcall LineTo(HDC hdc, int x, int y);
__declspec(dllimport) BOOL __stdcall MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height,
    HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop);
__declspec(dllimport) BOOL __stdcall PlgBlt(HDC hdcDest, const POINT* lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width,
    int height, HBITMAP hbmMask, int xMask, int yMask);
__declspec(dllimport) int __stdcall OffsetClipRgn(HDC hdc, int x, int y);
__declspec(dllimport) int __stdcall OffsetRgn(HRGN hrgn, int x, int y);
__declspec(dllimport) BOOL __stdcall PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop);
__declspec(dllimport) BOOL __stdcall Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
__declspec(dllimport) BOOL __stdcall PlayMetaFile(HDC hdc, HMETAFILE hmf);
__declspec(dllimport) BOOL __stdcall PaintRgn(HDC hdc, HRGN hrgn);
__declspec(dllimport) BOOL __stdcall PolyPolygon(HDC hdc, const POINT* apt, const INT* asz, int csz);
__declspec(dllimport) BOOL __stdcall PtInRegion(HRGN hrgn, int x, int y);
__declspec(dllimport) BOOL __stdcall PtVisible(HDC hdc, int x, int y);
__declspec(dllimport) BOOL __stdcall RectInRegion(HRGN hrgn, const RECT* lprect);
__declspec(dllimport) BOOL __stdcall RectVisible(HDC hdc, const RECT* lprect);
__declspec(dllimport) BOOL __stdcall Rectangle(HDC hdc, int left, int top, int right, int bottom);
__declspec(dllimport) BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC);
__declspec(dllimport) HDC __stdcall ResetDCA(HDC hdc, const DEVMODEA* lpdm);
__declspec(dllimport) HDC __stdcall ResetDCW(HDC hdc, const DEVMODEW* lpdm);
__declspec(dllimport) UINT __stdcall RealizePalette(HDC hdc);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceA(LPCSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceW(LPCWSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height);
__declspec(dllimport) BOOL __stdcall ResizePalette(HPALETTE hpal, UINT n);
__declspec(dllimport) int __stdcall SaveDC(HDC hdc);
__declspec(dllimport) int __stdcall SelectClipRgn(HDC hdc, HRGN hrgn);
__declspec(dllimport) int __stdcall ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode);
__declspec(dllimport) int __stdcall SetMetaRgn(HDC hdc);
__declspec(dllimport) HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
__declspec(dllimport) HPALETTE __stdcall SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
__declspec(dllimport) COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCBrushColor(HDC hdc, COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCPenColor(HDC hdc, COLORREF color);
__declspec(dllimport) int __stdcall SetBkMode(HDC hdc, int mode);
__declspec(dllimport)
    LONG __stdcall SetBitmapBits(
        HBITMAP hbm,
        DWORD cb,
        const void* pvBits);
__declspec(dllimport) UINT __stdcall SetBoundsRect(HDC hdc, const RECT* lprect, UINT flags);
__declspec(dllimport) int __stdcall SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void* lpBits, const BITMAPINFO* lpbmi, UINT ColorUse);
__declspec(dllimport) int __stdcall SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc,
    int ySrc, UINT StartScan, UINT cLines, const void* lpvBits, const BITMAPINFO* lpbmi, UINT ColorUse);
__declspec(dllimport) DWORD __stdcall SetMapperFlags(HDC hdc, DWORD flags);
__declspec(dllimport) int __stdcall SetGraphicsMode(HDC hdc, int iMode);
__declspec(dllimport) int __stdcall SetMapMode(HDC hdc, int iMode);
__declspec(dllimport) DWORD __stdcall SetLayout(HDC hdc, DWORD l);
__declspec(dllimport) DWORD __stdcall GetLayout(HDC hdc);
__declspec(dllimport) HMETAFILE __stdcall SetMetaFileBitsEx(UINT cbBuffer, const BYTE* lpData);
__declspec(dllimport) UINT __stdcall SetPaletteEntries(HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    const PALETTEENTRY* pPalEntries);
__declspec(dllimport) COLORREF __stdcall SetPixel(HDC hdc, int x, int y, COLORREF color);
__declspec(dllimport) BOOL __stdcall SetPixelV(HDC hdc, int x, int y, COLORREF color);
__declspec(dllimport) BOOL __stdcall SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR* ppfd);
__declspec(dllimport) int __stdcall SetPolyFillMode(HDC hdc, int mode);
__declspec(dllimport) BOOL __stdcall StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
__declspec(dllimport) BOOL __stdcall SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom);
__declspec(dllimport) int __stdcall StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight,
    const void* lpBits, const BITMAPINFO* lpbmi, UINT iUsage, DWORD rop);
__declspec(dllimport) int __stdcall SetROP2(HDC hdc, int rop2);
__declspec(dllimport) int __stdcall SetStretchBltMode(HDC hdc, int mode);
__declspec(dllimport) UINT __stdcall SetSystemPaletteUse(HDC hdc, UINT use);
__declspec(dllimport) int __stdcall SetTextCharacterExtra(HDC hdc, int extra);
__declspec(dllimport) COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
__declspec(dllimport) UINT __stdcall SetTextAlign(HDC hdc, UINT align);
__declspec(dllimport) BOOL __stdcall SetTextJustification(HDC hdc, int extra, int count);
__declspec(dllimport) BOOL __stdcall UpdateColors(HDC hdc);
#pragma endregion
#pragma region Application Family
typedef USHORT COLOR16;
typedef struct _TRIVERTEX {
    LONG x;
    LONG y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
} TRIVERTEX, *PTRIVERTEX, *LPTRIVERTEX;
#pragma endregion
#pragma region Desktop Family
typedef struct _GRADIENT_TRIANGLE {
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE, *PGRADIENT_TRIANGLE, *LPGRADIENT_TRIANGLE;
typedef struct _GRADIENT_RECT {
    ULONG UpperLeft;
    ULONG LowerRight;
} GRADIENT_RECT, *PGRADIENT_RECT, *LPGRADIENT_RECT;
#pragma endregion
#pragma region Application Family
typedef struct _BLENDFUNCTION {
    BYTE BlendOp;
    BYTE BlendFlags;
    BYTE SourceConstantAlpha;
    BYTE AlphaFormat;
} BLENDFUNCTION, *PBLENDFUNCTION;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) BOOL __stdcall AlphaBlend(
    HDC hdcDest,
    int xoriginDest,
    int yoriginDest,
    int wDest,
    int hDest,
    HDC hdcSrc,
    int xoriginSrc,
    int yoriginSrc,
    int wSrc,
    int hSrc,
    BLENDFUNCTION ftn);
__declspec(dllimport) BOOL __stdcall TransparentBlt(
    HDC hdcDest,
    int xoriginDest,
    int yoriginDest,
    int wDest,
    int hDest,
    HDC hdcSrc,
    int xoriginSrc,
    int yoriginSrc,
    int wSrc,
    int hSrc,
    UINT crTransparent);
__declspec(dllimport)
    BOOL
    __stdcall GradientFill(
        HDC hdc,
        PTRIVERTEX pVertex,
        ULONG nVertex,
        PVOID pMesh,
        ULONG nMesh,
        ULONG ulMode);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) BOOL __stdcall GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);
__declspec(dllimport) BOOL __stdcall GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc,
    int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);
__declspec(dllimport) BOOL __stdcall GdiGradientFill(HDC hdc,
    PTRIVERTEX pVertex,
    ULONG nVertex,
    PVOID pMesh,
    ULONG nCount,
    ULONG ulMode);
__declspec(dllimport) BOOL __stdcall PlayMetaFileRecord(HDC hdc,
    LPHANDLETABLE lpHandleTable,
    LPMETARECORD lpMR,
    UINT noObjs);
typedef int(__stdcall* MFENUMPROC)(HDC hdc, HANDLETABLE* lpht, METARECORD* lpMR, int nObj, LPARAM param);
__declspec(dllimport) BOOL __stdcall EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param);
typedef int(__stdcall* ENHMFENUMPROC)(HDC hdc, HANDLETABLE* lpht, const ENHMETARECORD* lpmr, int nHandles, LPARAM data);
__declspec(dllimport) HENHMETAFILE __stdcall CloseEnhMetaFile(HDC hdc);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName);
__declspec(dllimport) HDC __stdcall CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT* lprc, LPCSTR lpDesc);
__declspec(dllimport) HDC __stdcall CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT* lprc, LPCWSTR lpDesc);
__declspec(dllimport) BOOL __stdcall DeleteEnhMetaFile(HENHMETAFILE hmf);
__declspec(dllimport) BOOL __stdcall EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc,
    LPVOID param, const RECT* lpRect);
__declspec(dllimport) HENHMETAFILE __stdcall GetEnhMetaFileA(LPCSTR lpName);
__declspec(dllimport) HENHMETAFILE __stdcall GetEnhMetaFileW(LPCWSTR lpName);
__declspec(dllimport) UINT __stdcall GetEnhMetaFileBits(HENHMETAFILE hEMF,
    UINT nSize,
    LPBYTE lpData);
__declspec(dllimport) UINT __stdcall GetEnhMetaFileDescriptionA(HENHMETAFILE hemf,
    UINT cchBuffer,
    LPSTR lpDescription);
__declspec(dllimport) UINT __stdcall GetEnhMetaFileDescriptionW(HENHMETAFILE hemf,
    UINT cchBuffer,
    LPWSTR lpDescription);
__declspec(dllimport) UINT __stdcall GetEnhMetaFileHeader(HENHMETAFILE hemf,
    UINT nSize,
    LPENHMETAHEADER lpEnhMetaHeader);
__declspec(dllimport) UINT __stdcall GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf,
    UINT nNumEntries,
    LPPALETTEENTRY lpPaletteEntries);
__declspec(dllimport) UINT __stdcall GetEnhMetaFilePixelFormat(HENHMETAFILE hemf,
    UINT cbBuffer,
    PIXELFORMATDESCRIPTOR* ppfd);
__declspec(dllimport) UINT __stdcall GetWinMetaFileBits(HENHMETAFILE hemf,
    UINT cbData16,
    LPBYTE pData16,
    INT iMapMode,
    HDC hdcRef);
__declspec(dllimport) BOOL __stdcall PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT* lprect);
__declspec(dllimport) BOOL __stdcall PlayEnhMetaFileRecord(HDC hdc,
    LPHANDLETABLE pht,
    const ENHMETARECORD* pmr,
    UINT cht);
__declspec(dllimport) HENHMETAFILE __stdcall SetEnhMetaFileBits(UINT nSize,
    const BYTE* pb);
__declspec(dllimport) HENHMETAFILE __stdcall SetWinMetaFileBits(UINT nSize,
    const BYTE* lpMeta16Data,
    HDC hdcRef,
    const METAFILEPICT* lpMFP);
__declspec(dllimport) BOOL __stdcall GdiComment(HDC hdc, UINT nSize, const BYTE* lpData);
__declspec(dllimport) BOOL __stdcall GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm);
__declspec(dllimport) BOOL __stdcall GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
typedef struct tagDIBSECTION {
    BITMAP dsBm;
    BITMAPINFOHEADER dsBmih;
    DWORD dsBitfields[3];
    HANDLE dshSection;
    DWORD dsOffset;
} DIBSECTION, *LPDIBSECTION, *PDIBSECTION;
__declspec(dllimport) BOOL __stdcall AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle);
__declspec(dllimport) BOOL __stdcall PolyPolyline(HDC hdc, const POINT* apt, const DWORD* asz, DWORD csz);
__declspec(dllimport) BOOL __stdcall GetWorldTransform(HDC hdc, LPXFORM lpxf);
__declspec(dllimport) BOOL __stdcall SetWorldTransform(HDC hdc, const XFORM* lpxf);
__declspec(dllimport) BOOL __stdcall ModifyWorldTransform(HDC hdc, const XFORM* lpxf, DWORD mode);
__declspec(dllimport) BOOL __stdcall CombineTransform(LPXFORM lpxfOut, const XFORM* lpxf1, const XFORM* lpxf2);
__declspec(dllimport) HBITMAP __stdcall CreateDIBSection(
    HDC hdc,
    const BITMAPINFO* pbmi,
    UINT usage,
    void** ppvBits,
    HANDLE hSection,
    DWORD offset);
__declspec(dllimport) UINT __stdcall GetDIBColorTable(HDC hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD* prgbq);
__declspec(dllimport) UINT __stdcall SetDIBColorTable(HDC hdc,
    UINT iStart,
    UINT cEntries,
    const RGBQUAD* prgbq);
typedef struct tagCOLORADJUSTMENT {
    WORD caSize;
    WORD caFlags;
    WORD caIlluminantIndex;
    WORD caRedGamma;
    WORD caGreenGamma;
    WORD caBlueGamma;
    WORD caReferenceBlack;
    WORD caReferenceWhite;
    SHORT caContrast;
    SHORT caBrightness;
    SHORT caColorfulness;
    SHORT caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, *LPCOLORADJUSTMENT;
__declspec(dllimport) BOOL __stdcall SetColorAdjustment(HDC hdc, const COLORADJUSTMENT* lpca);
__declspec(dllimport) BOOL __stdcall GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca);
__declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette(HDC hdc);
typedef BOOL(__stdcall* ABORTPROC)(HDC, int);
typedef struct _DOCINFOA {
    int cbSize;
    LPCSTR lpszDocName;
    LPCSTR lpszOutput;
    LPCSTR lpszDatatype;
    DWORD fwType;
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int cbSize;
    LPCWSTR lpszDocName;
    LPCWSTR lpszOutput;
    LPCWSTR lpszDatatype;
    DWORD fwType;
} DOCINFOW, *LPDOCINFOW;
typedef DOCINFOW DOCINFO;
typedef LPDOCINFOW LPDOCINFO;
__declspec(dllimport) int __stdcall StartDocA(HDC hdc, const DOCINFOA* lpdi);
__declspec(dllimport) int __stdcall StartDocW(HDC hdc, const DOCINFOW* lpdi);
__declspec(dllimport) int __stdcall EndDoc(HDC hdc);
__declspec(dllimport) int __stdcall StartPage(HDC hdc);
__declspec(dllimport) int __stdcall EndPage(HDC hdc);
__declspec(dllimport) int __stdcall AbortDoc(HDC hdc);
__declspec(dllimport) int __stdcall SetAbortProc(HDC hdc, ABORTPROC proc);
__declspec(dllimport) BOOL __stdcall AbortPath(HDC hdc);
__declspec(dllimport) BOOL __stdcall ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
__declspec(dllimport) BOOL __stdcall BeginPath(HDC hdc);
__declspec(dllimport) BOOL __stdcall CloseFigure(HDC hdc);
__declspec(dllimport) BOOL __stdcall EndPath(HDC hdc);
__declspec(dllimport) BOOL __stdcall FillPath(HDC hdc);
__declspec(dllimport) BOOL __stdcall FlattenPath(HDC hdc);
__declspec(dllimport) int __stdcall GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
__declspec(dllimport) HRGN __stdcall PathToRegion(HDC hdc);
__declspec(dllimport) BOOL __stdcall PolyDraw(HDC hdc, const POINT* apt, const BYTE* aj, int cpt);
__declspec(dllimport) BOOL __stdcall SelectClipPath(HDC hdc, int mode);
__declspec(dllimport) int __stdcall SetArcDirection(HDC hdc, int dir);
__declspec(dllimport) BOOL __stdcall SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old);
__declspec(dllimport) BOOL __stdcall StrokeAndFillPath(HDC hdc);
__declspec(dllimport) BOOL __stdcall StrokePath(HDC hdc);
__declspec(dllimport) BOOL __stdcall WidenPath(HDC hdc);
__declspec(dllimport) HPEN __stdcall ExtCreatePen(DWORD iPenStyle,
    DWORD cWidth,
    const LOGBRUSH* plbrush,
    DWORD cStyle,
    const DWORD* pstyle);
__declspec(dllimport) BOOL __stdcall GetMiterLimit(HDC hdc, PFLOAT plimit);
__declspec(dllimport) int __stdcall GetArcDirection(HDC hdc);
__declspec(dllimport) int __stdcall GetObjectA(HANDLE h, int c, LPVOID pv);
__declspec(dllimport) int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv);
__declspec(dllimport) BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
__declspec(dllimport) BOOL __stdcall TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c);
__declspec(dllimport) BOOL __stdcall ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT* lprect, LPCSTR lpString, UINT c, const INT* lpDx);
__declspec(dllimport) BOOL __stdcall ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT* lprect, LPCWSTR lpString, UINT c, const INT* lpDx);
__declspec(dllimport) BOOL __stdcall PolyTextOutA(HDC hdc, const POLYTEXTA* ppt, int nstrings);
__declspec(dllimport) BOOL __stdcall PolyTextOutW(HDC hdc, const POLYTEXTW* ppt, int nstrings);
__declspec(dllimport) HRGN __stdcall CreatePolygonRgn(const POINT* pptl,
    int cPoint,
    int iMode);
__declspec(dllimport) BOOL __stdcall DPtoLP(HDC hdc, LPPOINT lppt, int c);
__declspec(dllimport) BOOL __stdcall LPtoDP(HDC hdc, LPPOINT lppt, int c);
__declspec(dllimport) BOOL __stdcall Polygon(HDC hdc, const POINT* apt, int cpt);
__declspec(dllimport) BOOL __stdcall Polyline(HDC hdc, const POINT* apt, int cpt);
__declspec(dllimport) BOOL __stdcall PolyBezier(HDC hdc, const POINT* apt, DWORD cpt);
__declspec(dllimport) BOOL __stdcall PolyBezierTo(HDC hdc, const POINT* apt, DWORD cpt);
__declspec(dllimport) BOOL __stdcall PolylineTo(HDC hdc, const POINT* apt, DWORD cpt);
__declspec(dllimport) BOOL __stdcall SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz);
__declspec(dllimport) BOOL __stdcall SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
__declspec(dllimport) int __stdcall GetTextFaceA(HDC hdc, int c, LPSTR lpName);
__declspec(dllimport) int __stdcall GetTextFaceW(HDC hdc, int c, LPWSTR lpName);
typedef struct tagKERNINGPAIR {
    WORD wFirst;
    WORD wSecond;
    int iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;
__declspec(dllimport) DWORD __stdcall GetKerningPairsA(HDC hdc,
    DWORD nPairs,
    LPKERNINGPAIR lpKernPair);
__declspec(dllimport) DWORD __stdcall GetKerningPairsW(HDC hdc,
    DWORD nPairs,
    LPKERNINGPAIR lpKernPair);
__declspec(dllimport) BOOL __stdcall GetDCOrgEx(HDC hdc, LPPOINT lppt);
__declspec(dllimport) BOOL __stdcall FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl);
__declspec(dllimport) BOOL __stdcall UnrealizeObject(HGDIOBJ h);
__declspec(dllimport) BOOL __stdcall GdiFlush(void);
__declspec(dllimport) DWORD __stdcall GdiSetBatchLimit(DWORD dw);
__declspec(dllimport) DWORD __stdcall GdiGetBatchLimit(void);
typedef int(__stdcall* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int(__stdcall* ICMENUMPROCW)(LPWSTR, LPARAM);
__declspec(dllimport) int __stdcall SetICMMode(HDC hdc, int mode);
__declspec(dllimport) BOOL __stdcall CheckColorsInGamut(HDC hdc,
    LPRGBTRIPLE lpRGBTriple,
    LPVOID dlpBuffer,
    DWORD nCount);
__declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace(HDC hdc);
__declspec(dllimport) BOOL __stdcall GetLogColorSpaceA(HCOLORSPACE hColorSpace,
    LPLOGCOLORSPACEA lpBuffer,
    DWORD nSize);
__declspec(dllimport) BOOL __stdcall GetLogColorSpaceW(HCOLORSPACE hColorSpace,
    LPLOGCOLORSPACEW lpBuffer,
    DWORD nSize);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA(LPLOGCOLORSPACEA lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW(LPLOGCOLORSPACEW lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace(HDC hdc, HCOLORSPACE hcs);
__declspec(dllimport) BOOL __stdcall DeleteColorSpace(HCOLORSPACE hcs);
__declspec(dllimport) BOOL __stdcall GetICMProfileA(HDC hdc,
    LPDWORD pBufSize,
    LPSTR pszFilename);
__declspec(dllimport) BOOL __stdcall GetICMProfileW(HDC hdc,
    LPDWORD pBufSize,
    LPWSTR pszFilename);
__declspec(dllimport) BOOL __stdcall SetICMProfileA(HDC hdc, LPSTR lpFileName);
__declspec(dllimport) BOOL __stdcall SetICMProfileW(HDC hdc, LPWSTR lpFileName);
__declspec(dllimport) BOOL __stdcall GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp);
__declspec(dllimport) BOOL __stdcall SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp);
__declspec(dllimport) BOOL __stdcall ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action);
__declspec(dllimport) int __stdcall EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param);
__declspec(dllimport) int __stdcall EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param);
__declspec(dllimport) BOOL __stdcall UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command);
__declspec(dllimport) BOOL __stdcall UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command);
#pragma deprecated(UpdateICMRegKeyW)
#pragma deprecated(UpdateICMRegKeyA)
__declspec(dllimport) BOOL __stdcall ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num);
typedef struct tagEMR {
    DWORD iType;
    DWORD nSize;
} EMR, *PEMR;
typedef struct tagEMRTEXT {
    POINTL ptlReference;
    DWORD nChars;
    DWORD offString;
    DWORD fOptions;
    RECTL rcl;
    DWORD offDx;
} EMRTEXT, *PEMRTEXT;
typedef struct tagABORTPATH {
    EMR emr;
} EMRABORTPATH, *PEMRABORTPATH,
    EMRBEGINPATH, *PEMRBEGINPATH,
    EMRENDPATH, *PEMRENDPATH,
    EMRCLOSEFIGURE, *PEMRCLOSEFIGURE,
    EMRFLATTENPATH, *PEMRFLATTENPATH,
    EMRWIDENPATH, *PEMRWIDENPATH,
    EMRSETMETARGN, *PEMRSETMETARGN,
    EMRSAVEDC, *PEMRSAVEDC,
    EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;
typedef struct tagEMRSELECTCLIPPATH {
    EMR emr;
    DWORD iMode;
} EMRSELECTCLIPPATH, *PEMRSELECTCLIPPATH,
    EMRSETBKMODE, *PEMRSETBKMODE,
    EMRSETMAPMODE, *PEMRSETMAPMODE,
    EMRSETLAYOUT, *PEMRSETLAYOUT,
    EMRSETPOLYFILLMODE, *PEMRSETPOLYFILLMODE,
    EMRSETROP2, *PEMRSETROP2,
    EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
    EMRSETICMMODE, *PEMRSETICMMODE,
    EMRSETTEXTALIGN, *PEMRSETTEXTALIGN;
typedef struct tagEMRSETMITERLIMIT {
    EMR emr;
    FLOAT eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;
typedef struct tagEMRRESTOREDC {
    EMR emr;
    LONG iRelative;
} EMRRESTOREDC, *PEMRRESTOREDC;
typedef struct tagEMRSETARCDIRECTION {
    EMR emr;
    DWORD iArcDirection;
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;
typedef struct tagEMRSETMAPPERFLAGS {
    EMR emr;
    DWORD dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;
typedef struct tagEMRSETTEXTCOLOR {
    EMR emr;
    COLORREF crColor;
} EMRSETBKCOLOR, *PEMRSETBKCOLOR,
    EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;
typedef struct tagEMRSELECTOBJECT {
    EMR emr;
    DWORD ihObject;
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
    EMRDELETEOBJECT, *PEMRDELETEOBJECT;
typedef struct tagEMRSELECTPALETTE {
    EMR emr;
    DWORD ihPal;
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;
typedef struct tagEMRRESIZEPALETTE {
    EMR emr;
    DWORD ihPal;
    DWORD cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;
typedef struct tagEMRSETPALETTEENTRIES {
    EMR emr;
    DWORD ihPal;
    DWORD iStart;
    DWORD cEntries;
    PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;
typedef struct tagEMRSETCOLORADJUSTMENT {
    EMR emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;
typedef struct tagEMRGDICOMMENT {
    EMR emr;
    DWORD cbData;
    BYTE Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;
typedef struct tagEMREOF {
    EMR emr;
    DWORD nPalEntries;
    DWORD offPalEntries;
    DWORD nSizeLast;
} EMREOF, *PEMREOF;
typedef struct tagEMRLINETO {
    EMR emr;
    POINTL ptl;
} EMRLINETO, *PEMRLINETO,
    EMRMOVETOEX, *PEMRMOVETOEX;
typedef struct tagEMROFFSETCLIPRGN {
    EMR emr;
    POINTL ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;
typedef struct tagEMRFILLPATH {
    EMR emr;
    RECTL rclBounds;
} EMRFILLPATH, *PEMRFILLPATH,
    EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
    EMRSTROKEPATH, *PEMRSTROKEPATH;
typedef struct tagEMREXCLUDECLIPRECT {
    EMR emr;
    RECTL rclClip;
} EMREXCLUDECLIPRECT, *PEMREXCLUDECLIPRECT,
    EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;
typedef struct tagEMRSETVIEWPORTORGEX {
    EMR emr;
    POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
    EMRSETWINDOWORGEX, *PEMRSETWINDOWORGEX,
    EMRSETBRUSHORGEX, *PEMRSETBRUSHORGEX;
typedef struct tagEMRSETVIEWPORTEXTEX {
    EMR emr;
    SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
    EMRSETWINDOWEXTEX, *PEMRSETWINDOWEXTEX;
typedef struct tagEMRSCALEVIEWPORTEXTEX {
    EMR emr;
    LONG xNum;
    LONG xDenom;
    LONG yNum;
    LONG yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
    EMRSCALEWINDOWEXTEX, *PEMRSCALEWINDOWEXTEX;
typedef struct tagEMRSETWORLDTRANSFORM {
    EMR emr;
    XFORM xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;
typedef struct tagEMRMODIFYWORLDTRANSFORM {
    EMR emr;
    XFORM xform;
    DWORD iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;
typedef struct tagEMRSETPIXELV {
    EMR emr;
    POINTL ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;
typedef struct tagEMREXTFLOODFILL {
    EMR emr;
    POINTL ptlStart;
    COLORREF crColor;
    DWORD iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;
typedef struct tagEMRELLIPSE {
    EMR emr;
    RECTL rclBox;
} EMRELLIPSE, *PEMRELLIPSE,
    EMRRECTANGLE, *PEMRRECTANGLE;
typedef struct tagEMRROUNDRECT {
    EMR emr;
    RECTL rclBox;
    SIZEL szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;
typedef struct tagEMRARC {
    EMR emr;
    RECTL rclBox;
    POINTL ptlStart;
    POINTL ptlEnd;
} EMRARC, *PEMRARC,
    EMRARCTO, *PEMRARCTO,
    EMRCHORD, *PEMRCHORD,
    EMRPIE, *PEMRPIE;
typedef struct tagEMRANGLEARC {
    EMR emr;
    POINTL ptlCenter;
    DWORD nRadius;
    FLOAT eStartAngle;
    FLOAT eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;
typedef struct tagEMRPOLYLINE {
    EMR emr;
    RECTL rclBounds;
    DWORD cptl;
    POINTL aptl[1];
} EMRPOLYLINE, *PEMRPOLYLINE,
    EMRPOLYBEZIER, *PEMRPOLYBEZIER,
    EMRPOLYGON, *PEMRPOLYGON,
    EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
    EMRPOLYLINETO, *PEMRPOLYLINETO;
typedef struct tagEMRPOLYLINE16 {
    EMR emr;
    RECTL rclBounds;
    DWORD cpts;
    POINTS apts[1];
} EMRPOLYLINE16, *PEMRPOLYLINE16,
    EMRPOLYBEZIER16, *PEMRPOLYBEZIER16,
    EMRPOLYGON16, *PEMRPOLYGON16,
    EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
    EMRPOLYLINETO16, *PEMRPOLYLINETO16;
typedef struct tagEMRPOLYDRAW {
    EMR emr;
    RECTL rclBounds;
    DWORD cptl;
    POINTL aptl[1];
    BYTE abTypes[1];
} EMRPOLYDRAW, *PEMRPOLYDRAW;
typedef struct tagEMRPOLYDRAW16 {
    EMR emr;
    RECTL rclBounds;
    DWORD cpts;
    POINTS apts[1];
    BYTE abTypes[1];
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;
typedef struct tagEMRPOLYPOLYLINE {
    EMR emr;
    RECTL rclBounds;
    DWORD nPolys;
    DWORD cptl;
    DWORD aPolyCounts[1];
    POINTL aptl[1];
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
    EMRPOLYPOLYGON, *PEMRPOLYPOLYGON;
typedef struct tagEMRPOLYPOLYLINE16 {
    EMR emr;
    RECTL rclBounds;
    DWORD nPolys;
    DWORD cpts;
    DWORD aPolyCounts[1];
    POINTS apts[1];
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
    EMRPOLYPOLYGON16, *PEMRPOLYPOLYGON16;
typedef struct tagEMRINVERTRGN {
    EMR emr;
    RECTL rclBounds;
    DWORD cbRgnData;
    BYTE RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
    EMRPAINTRGN, *PEMRPAINTRGN;
typedef struct tagEMRFILLRGN {
    EMR emr;
    RECTL rclBounds;
    DWORD cbRgnData;
    DWORD ihBrush;
    BYTE RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;
typedef struct tagEMRFRAMERGN {
    EMR emr;
    RECTL rclBounds;
    DWORD cbRgnData;
    DWORD ihBrush;
    SIZEL szlStroke;
    BYTE RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;
typedef struct tagEMREXTSELECTCLIPRGN {
    EMR emr;
    DWORD cbRgnData;
    DWORD iMode;
    BYTE RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;
typedef struct tagEMREXTTEXTOUTA {
    EMR emr;
    RECTL rclBounds;
    DWORD iGraphicsMode;
    FLOAT exScale;
    FLOAT eyScale;
    EMRTEXT emrtext;
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
    EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;
typedef struct tagEMRPOLYTEXTOUTA {
    EMR emr;
    RECTL rclBounds;
    DWORD iGraphicsMode;
    FLOAT exScale;
    FLOAT eyScale;
    LONG cStrings;
    EMRTEXT aemrtext[1];
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
    EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;
typedef struct tagEMRBITBLT {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc;
    COLORREF crBkColorSrc;
    DWORD iUsageSrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
} EMRBITBLT, *PEMRBITBLT;
typedef struct tagEMRSTRETCHBLT {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc;
    COLORREF crBkColorSrc;
    DWORD iUsageSrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    LONG cxSrc;
    LONG cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;
typedef struct tagEMRMASKBLT {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc;
    COLORREF crBkColorSrc;
    DWORD iUsageSrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    LONG xMask;
    LONG yMask;
    DWORD iUsageMask;
    DWORD offBmiMask;
    DWORD cbBmiMask;
    DWORD offBitsMask;
    DWORD cbBitsMask;
} EMRMASKBLT, *PEMRMASKBLT;
typedef struct tagEMRPLGBLT {
    EMR emr;
    RECTL rclBounds;
    POINTL aptlDest[3];
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    XFORM xformSrc;
    COLORREF crBkColorSrc;
    DWORD iUsageSrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    LONG xMask;
    LONG yMask;
    DWORD iUsageMask;
    DWORD offBmiMask;
    DWORD cbBmiMask;
    DWORD offBitsMask;
    DWORD cbBitsMask;
} EMRPLGBLT, *PEMRPLGBLT;
typedef struct tagEMRSETDIBITSTODEVICE {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    DWORD iUsageSrc;
    DWORD iStartScan;
    DWORD cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;
typedef struct tagEMRSTRETCHDIBITS {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    DWORD iUsageSrc;
    DWORD dwRop;
    LONG cxDest;
    LONG cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;
typedef struct tagEMREXTCREATEFONTINDIRECTW {
    EMR emr;
    DWORD ihFont;
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;
typedef struct tagEMRCREATEPALETTE {
    EMR emr;
    DWORD ihPal;
    LOGPALETTE lgpl;
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;
typedef struct tagEMRCREATEPEN {
    EMR emr;
    DWORD ihPen;
    LOGPEN lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;
typedef struct tagEMREXTCREATEPEN {
    EMR emr;
    DWORD ihPen;
    DWORD offBmi;
    DWORD cbBmi;
    DWORD offBits;
    DWORD cbBits;
    EXTLOGPEN32 elp;
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;
typedef struct tagEMRCREATEBRUSHINDIRECT {
    EMR emr;
    DWORD ihBrush;
    LOGBRUSH32 lb;
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;
typedef struct tagEMRCREATEMONOBRUSH {
    EMR emr;
    DWORD ihBrush;
    DWORD iUsage;
    DWORD offBmi;
    DWORD cbBmi;
    DWORD offBits;
    DWORD cbBits;
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;
typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
    EMR emr;
    DWORD ihBrush;
    DWORD iUsage;
    DWORD offBmi;
    DWORD cbBmi;
    DWORD offBits;
    DWORD cbBits;
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;
typedef struct tagEMRFORMAT {
    DWORD dSignature;
    DWORD nVersion;
    DWORD cbData;
    DWORD offData;
} EMRFORMAT, *PEMRFORMAT;
typedef struct tagEMRGLSRECORD {
    EMR emr;
    DWORD cbData;
    BYTE Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;
typedef struct tagEMRGLSBOUNDEDRECORD {
    EMR emr;
    RECTL rclBounds;
    DWORD cbData;
    BYTE Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;
typedef struct tagEMRPIXELFORMAT {
    EMR emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;
typedef struct tagEMRCREATECOLORSPACE {
    EMR emr;
    DWORD ihCS;
    LOGCOLORSPACEA lcs;
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;
typedef struct tagEMRSETCOLORSPACE {
    EMR emr;
    DWORD ihCS;
} EMRSETCOLORSPACE, *PEMRSETCOLORSPACE,
    EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
    EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;
typedef struct tagEMREXTESCAPE {
    EMR emr;
    INT iEscape;
    INT cbEscData;
    BYTE EscData[1];
} EMREXTESCAPE, *PEMREXTESCAPE,
    EMRDRAWESCAPE, *PEMRDRAWESCAPE;
typedef struct tagEMRNAMEDESCAPE {
    EMR emr;
    INT iEscape;
    INT cbDriver;
    INT cbEscData;
    BYTE EscData[1];
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;
typedef struct tagEMRSETICMPROFILE {
    EMR emr;
    DWORD dwFlags;
    DWORD cbName;
    DWORD cbData;
    BYTE Data[1];
} EMRSETICMPROFILE, *PEMRSETICMPROFILE,
    EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
    EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;
typedef struct tagEMRCREATECOLORSPACEW {
    EMR emr;
    DWORD ihCS;
    LOGCOLORSPACEW lcs;
    DWORD dwFlags;
    DWORD cbData;
    BYTE Data[1];
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;
typedef struct tagCOLORMATCHTOTARGET {
    EMR emr;
    DWORD dwAction;
    DWORD dwFlags;
    DWORD cbName;
    DWORD cbData;
    BYTE Data[1];
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;
typedef struct tagCOLORCORRECTPALETTE {
    EMR emr;
    DWORD ihPalette;
    DWORD nFirstEntry;
    DWORD nPalEntries;
    DWORD nReserved;
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;
typedef struct tagEMRALPHABLEND {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc;
    COLORREF crBkColorSrc;
    DWORD iUsageSrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    LONG cxSrc;
    LONG cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;
typedef struct tagEMRGRADIENTFILL {
    EMR emr;
    RECTL rclBounds;
    DWORD nVer;
    DWORD nTri;
    ULONG ulMode;
    TRIVERTEX Ver[1];
} EMRGRADIENTFILL, *PEMRGRADIENTFILL;
typedef struct tagEMRTRANSPARENTBLT {
    EMR emr;
    RECTL rclBounds;
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc;
    COLORREF crBkColorSrc;
    DWORD iUsageSrc;
    DWORD offBmiSrc;
    DWORD cbBmiSrc;
    DWORD offBitsSrc;
    DWORD cbBitsSrc;
    LONG cxSrc;
    LONG cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;
__declspec(dllimport) BOOL __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
__declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
__declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
__declspec(dllimport) BOOL __stdcall wglDeleteContext(HGLRC);
__declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void);
__declspec(dllimport) HDC __stdcall wglGetCurrentDC(void);
__declspec(dllimport) PROC __stdcall wglGetProcAddress(LPCSTR);
__declspec(dllimport) BOOL __stdcall wglMakeCurrent(HDC, HGLRC);
__declspec(dllimport) BOOL __stdcall wglShareLists(HGLRC, HGLRC);
__declspec(dllimport) BOOL __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL __stdcall SwapBuffers(HDC);
typedef struct _POINTFLOAT {
    FLOAT x;
    FLOAT y;
} POINTFLOAT, *PPOINTFLOAT;
typedef struct _GLYPHMETRICSFLOAT {
    FLOAT gmfBlackBoxX;
    FLOAT gmfBlackBoxY;
    POINTFLOAT gmfptGlyphOrigin;
    FLOAT gmfCellIncX;
    FLOAT gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, *LPGLYPHMETRICSFLOAT;
__declspec(dllimport) BOOL __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
    FLOAT, int, LPGLYPHMETRICSFLOAT);
__declspec(dllimport) BOOL __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
    FLOAT, int, LPGLYPHMETRICSFLOAT);
typedef struct tagLAYERPLANEDESCRIPTOR {
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerPlane;
    BYTE bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR, *LPLAYERPLANEDESCRIPTOR;
__declspec(dllimport) BOOL __stdcall wglDescribeLayerPlane(HDC, int, int, UINT,
    LPLAYERPLANEDESCRIPTOR);
__declspec(dllimport) int __stdcall wglSetLayerPaletteEntries(HDC, int, int, int,
    const COLORREF*);
__declspec(dllimport) int __stdcall wglGetLayerPaletteEntries(HDC, int, int, int,
    COLORREF*);
__declspec(dllimport) BOOL __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
__declspec(dllimport) BOOL __stdcall wglSwapLayerBuffers(HDC, UINT);
typedef struct _WGLSWAP {
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;
__declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP*);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
}
#pragma warning(pop)
#pragma once
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family
typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;
typedef MENUTEMPLATEW MENUTEMPLATE;
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;
typedef LPMENUTEMPLATEW LPMENUTEMPLATE;
#pragma endregion
#pragma region Desktop Family
typedef LRESULT(__stdcall* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef INT_PTR(__stdcall* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#pragma endregion
#pragma region Desktop Family or Games Family
typedef void(__stdcall* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
#pragma endregion
#pragma region Desktop Family
typedef BOOL(__stdcall* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL(__stdcall* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT(__stdcall* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void(__stdcall* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);
typedef BOOL(__stdcall* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL(__stdcall* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);
typedef BOOL(__stdcall* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL(__stdcall* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);
typedef int(__stdcall* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int(__stdcall* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);
typedef BOOL(__stdcall* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#pragma endregion
#pragma region Desktop Family
typedef PROPENUMPROCW PROPENUMPROC;
typedef PROPENUMPROCEXW PROPENUMPROCEX;
typedef EDITWORDBREAKPROCW EDITWORDBREAKPROC;
typedef BOOL(__stdcall* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL(__stdcall* NAMEENUMPROCW)(LPWSTR, LPARAM);
typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;
typedef WINSTAENUMPROCW WINSTAENUMPROC;
typedef DESKTOPENUMPROCW DESKTOPENUMPROC;
#pragma endregion
#pragma region Desktop Family
#pragma warning(push)
#pragma warning(disable : 4995)
__declspec(dllimport) int __stdcall wvsprintfA(
    LPSTR,
    LPCSTR,
    va_list arglist);
__declspec(dllimport) int __stdcall wvsprintfW(
    LPWSTR,
    LPCWSTR,
    va_list arglist);
__declspec(dllimport) int __cdecl wsprintfA(
    LPSTR,
    LPCSTR,
    ...);
__declspec(dllimport) int __cdecl wsprintfW(
    LPWSTR,
    LPCWSTR,
    ...);
#pragma warning(pop)
#pragma endregion
#pragma region Desktop Family
typedef struct tagCBT_CREATEWNDA {
    struct tagCREATESTRUCTA* lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
typedef struct tagCBT_CREATEWNDW {
    struct tagCREATESTRUCTW* lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
typedef CBT_CREATEWNDW CBT_CREATEWND;
typedef LPCBT_CREATEWNDW LPCBT_CREATEWND;
typedef struct tagCBTACTIVATESTRUCT {
    BOOL fMouse;
    HWND hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagWTSSESSION_NOTIFICATION {
    DWORD cbSize;
    DWORD dwSessionId;
} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;
#pragma endregion
#pragma region Desktop Family
typedef struct
{
    HWND hwnd;
    RECT rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;
typedef struct tagEVENTMSG {
    UINT message;
    UINT paramL;
    UINT paramH;
    DWORD time;
    HWND hwnd;
} EVENTMSG, *PEVENTMSGMSG, *NPEVENTMSGMSG, *LPEVENTMSGMSG;
typedef struct tagEVENTMSG *PEVENTMSG, *NPEVENTMSG, *LPEVENTMSG;
typedef struct tagCWPSTRUCT {
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT;
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, *NPCWPRETSTRUCT, *LPCWPRETSTRUCT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD vkCode;
    DWORD scanCode;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;
typedef struct tagMSLLHOOKSTRUCT {
    POINT pt;
    DWORD mouseData;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagDEBUGHOOKINFO {
    DWORD idThread;
    DWORD idThreadInstaller;
    LPARAM lParam;
    WPARAM wParam;
    int code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, *NPDEBUGHOOKINFO, *LPDEBUGHOOKINFO;
typedef struct tagMOUSEHOOKSTRUCT {
    POINT pt;
    HWND hwnd;
    UINT wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT {
    DWORD mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HKL
    __stdcall LoadKeyboardLayoutA(
        LPCSTR pwszKLID,
        UINT Flags);
__declspec(dllimport)
    HKL
    __stdcall LoadKeyboardLayoutW(
        LPCWSTR pwszKLID,
        UINT Flags);
__declspec(dllimport)
    HKL
    __stdcall ActivateKeyboardLayout(
        HKL hkl,
        UINT Flags);
__declspec(dllimport) int __stdcall ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    const BYTE* lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL dwhkl);
__declspec(dllimport)
    BOOL
    __stdcall UnloadKeyboardLayout(
        HKL hkl);
__declspec(dllimport)
    BOOL
    __stdcall GetKeyboardLayoutNameA(
        LPSTR pwszKLID);
__declspec(dllimport)
    BOOL
    __stdcall GetKeyboardLayoutNameW(
        LPWSTR pwszKLID);
__declspec(dllimport) int __stdcall GetKeyboardLayoutList(
    int nBuff,
    HKL* lpList);
__declspec(dllimport)
    HKL
    __stdcall GetKeyboardLayout(
        DWORD idThread);
#pragma endregion
#pragma region Desktop Family
typedef struct tagMOUSEMOVEPOINT {
    int x;
    int y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, *LPMOUSEMOVEPOINT;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall GetMouseMovePointsEx(
    UINT cbSize,
    LPMOUSEMOVEPOINT lppt,
    LPMOUSEMOVEPOINT lpptBuf,
    int nBufPoints,
    DWORD resolution);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HDESK
    __stdcall CreateDesktopA(
        LPCSTR lpszDesktop,
        LPCSTR lpszDevice,
        DEVMODEA* pDevmode,
        DWORD dwFlags,
        ACCESS_MASK dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
    HDESK
    __stdcall CreateDesktopW(
        LPCWSTR lpszDesktop,
        LPCWSTR lpszDevice,
        DEVMODEW* pDevmode,
        DWORD dwFlags,
        ACCESS_MASK dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
    HDESK
    __stdcall CreateDesktopExA(
        LPCSTR lpszDesktop,
        LPCSTR lpszDevice,
        DEVMODEA* pDevmode,
        DWORD dwFlags,
        ACCESS_MASK dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpsa,
        ULONG ulHeapSize,
        PVOID pvoid);
__declspec(dllimport)
    HDESK
    __stdcall CreateDesktopExW(
        LPCWSTR lpszDesktop,
        LPCWSTR lpszDevice,
        DEVMODEW* pDevmode,
        DWORD dwFlags,
        ACCESS_MASK dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpsa,
        ULONG ulHeapSize,
        PVOID pvoid);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HDESK
    __stdcall OpenDesktopA(
        LPCSTR lpszDesktop,
        DWORD dwFlags,
        BOOL fInherit,
        ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
    HDESK
    __stdcall OpenDesktopW(
        LPCWSTR lpszDesktop,
        DWORD dwFlags,
        BOOL fInherit,
        ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
    HDESK
    __stdcall OpenInputDesktop(
        DWORD dwFlags,
        BOOL fInherit,
        ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
    BOOL
    __stdcall EnumDesktopsA(
        HWINSTA hwinsta,
        DESKTOPENUMPROCA lpEnumFunc,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumDesktopsW(
        HWINSTA hwinsta,
        DESKTOPENUMPROCW lpEnumFunc,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumDesktopWindows(
        HDESK hDesktop,
        WNDENUMPROC lpfn,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall SwitchDesktop(
        HDESK hDesktop);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadDesktop(
        HDESK hDesktop);
__declspec(dllimport)
    BOOL
    __stdcall CloseDesktop(
        HDESK hDesktop);
__declspec(dllimport)
    HDESK
    __stdcall GetThreadDesktop(
        DWORD dwThreadId);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HWINSTA
    __stdcall CreateWindowStationA(
        LPCSTR lpwinsta,
        DWORD dwFlags,
        ACCESS_MASK dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
    HWINSTA
    __stdcall CreateWindowStationW(
        LPCWSTR lpwinsta,
        DWORD dwFlags,
        ACCESS_MASK dwDesiredAccess,
        LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
    HWINSTA
    __stdcall OpenWindowStationA(
        LPCSTR lpszWinSta,
        BOOL fInherit,
        ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
    HWINSTA
    __stdcall OpenWindowStationW(
        LPCWSTR lpszWinSta,
        BOOL fInherit,
        ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
    BOOL
    __stdcall EnumWindowStationsA(
        WINSTAENUMPROCA lpEnumFunc,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumWindowStationsW(
        WINSTAENUMPROCW lpEnumFunc,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall CloseWindowStation(
        HWINSTA hWinSta);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessWindowStation(
        HWINSTA hWinSta);
__declspec(dllimport)
    HWINSTA
    __stdcall GetProcessWindowStation(
        void);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetUserObjectSecurity(
        HANDLE hObj,
        PSECURITY_INFORMATION pSIRequested,
        PSECURITY_DESCRIPTOR pSID);
__declspec(dllimport)
    BOOL
    __stdcall GetUserObjectSecurity(
        HANDLE hObj,
        PSECURITY_INFORMATION pSIRequested,
        PSECURITY_DESCRIPTOR pSID,
        DWORD nLength,
        LPDWORD lpnLengthNeeded);
#pragma endregion
#pragma region Desktop Family
typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;
__declspec(dllimport)
    BOOL
    __stdcall GetUserObjectInformationA(
        HANDLE hObj,
        int nIndex,
        PVOID pvInfo,
        DWORD nLength,
        LPDWORD lpnLengthNeeded);
__declspec(dllimport)
    BOOL
    __stdcall GetUserObjectInformationW(
        HANDLE hObj,
        int nIndex,
        PVOID pvInfo,
        DWORD nLength,
        LPDWORD lpnLengthNeeded);
__declspec(dllimport)
    BOOL
    __stdcall SetUserObjectInformationA(
        HANDLE hObj,
        int nIndex,
        PVOID pvInfo,
        DWORD nLength);
__declspec(dllimport)
    BOOL
    __stdcall SetUserObjectInformationW(
        HANDLE hObj,
        int nIndex,
        PVOID pvInfo,
        DWORD nLength);
#pragma endregion
#pragma region Desktop or Games Family
typedef struct tagWNDCLASSEXA {
    UINT cbSize;
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
    HICON hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, *NPWNDCLASSEXA, *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT cbSize;
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
    HICON hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW;
typedef WNDCLASSEXW WNDCLASSEX;
typedef PWNDCLASSEXW PWNDCLASSEX;
typedef NPWNDCLASSEXW NPWNDCLASSEX;
typedef LPWNDCLASSEXW LPWNDCLASSEX;
typedef struct tagWNDCLASSA {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;
typedef WNDCLASSW WNDCLASS;
typedef PWNDCLASSW PWNDCLASS;
typedef NPWNDCLASSW NPWNDCLASS;
typedef LPWNDCLASSW LPWNDCLASS;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsHungAppWindow(
        HWND hwnd);
__declspec(dllimport) void __stdcall DisableProcessWindowsGhosting(
    void);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct tagMSG {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
} MSG, *PMSG, *NPMSG, *LPMSG;
#pragma endregion
#pragma region Desktop Family
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;
#pragma endregion
#pragma region Desktop Family
typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;
typedef struct tagMDINEXTMENU {
    HMENU hmenuIn;
    HMENU hmenuNext;
    HWND hwndNext;
} MDINEXTMENU, *PMDINEXTMENU, *LPMDINEXTMENU;
#pragma endregion
#pragma region Desktop Family
typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    UINT
    __stdcall RegisterWindowMessageA(
        LPCSTR lpString);
__declspec(dllimport)
    UINT
    __stdcall RegisterWindowMessageW(
        LPCWSTR lpString);
#pragma endregion
#pragma region Desktop Family
typedef struct tagWINDOWPOS {
    HWND hwnd;
    HWND hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    UINT flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;
typedef struct tagNCCALCSIZE_PARAMS {
    RECT rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;
__declspec(dllimport)
    BOOL
    __stdcall TrackMouseEvent(
        LPTRACKMOUSEEVENT lpEventTrack);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawEdge(
        HDC hdc,
        LPRECT qrc,
        UINT edge,
        UINT grfFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawFrameControl(
        HDC,
        LPRECT,
        UINT,
        UINT);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawCaption(
        HWND hwnd,
        HDC hdc,
        const RECT* lprect,
        UINT flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawAnimatedRects(
        HWND hwnd,
        int idAni,
        const RECT* lprcFrom,
        const RECT* lprcTo);
#pragma endregion
#pragma region Desktop Family
typedef struct tagACCEL {
    BYTE fVirt;
    WORD key;
    WORD cmd;
} ACCEL, *LPACCEL;
typedef struct tagPAINTSTRUCT {
    HDC hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;
#pragma endregion
#pragma region Desktop Family or Games Family
typedef struct tagCREATESTRUCTA {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCSTR lpszName;
    LPCSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCWSTR lpszName;
    LPCWSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;
typedef CREATESTRUCTW CREATESTRUCT;
typedef LPCREATESTRUCTW LPCREATESTRUCT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagWINDOWPLACEMENT {
    UINT length;
    UINT flags;
    UINT showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct tagNMHDR {
    HWND hwndFrom;
    UINT_PTR idFrom;
    UINT code;
} NMHDR;
#pragma endregion
#pragma region Desktop Family
typedef NMHDR* LPNMHDR;
typedef struct tagSTYLESTRUCT {
    DWORD styleOld;
    DWORD styleNew;
} STYLESTRUCT, *LPSTYLESTRUCT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagMEASUREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemWidth;
    UINT itemHeight;
    ULONG_PTR itemData;
} MEASUREITEMSTRUCT, *PMEASUREITEMSTRUCT, *LPMEASUREITEMSTRUCT;
typedef struct tagDRAWITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemAction;
    UINT itemState;
    HWND hwndItem;
    HDC hDC;
    RECT rcItem;
    ULONG_PTR itemData;
} DRAWITEMSTRUCT, *PDRAWITEMSTRUCT, *LPDRAWITEMSTRUCT;
typedef struct tagDELETEITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    HWND hwndItem;
    ULONG_PTR itemData;
} DELETEITEMSTRUCT, *PDELETEITEMSTRUCT, *LPDELETEITEMSTRUCT;
typedef struct tagCOMPAREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    HWND hwndItem;
    UINT itemID1;
    ULONG_PTR itemData1;
    UINT itemID2;
    ULONG_PTR itemData2;
    DWORD dwLocaleId;
} COMPAREITEMSTRUCT, *PCOMPAREITEMSTRUCT, *LPCOMPAREITEMSTRUCT;
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetMessageA(
        LPMSG lpMsg,
        HWND hWnd,
        UINT wMsgFilterMin,
        UINT wMsgFilterMax);
__declspec(dllimport)
    BOOL
    __stdcall GetMessageW(
        LPMSG lpMsg,
        HWND hWnd,
        UINT wMsgFilterMin,
        UINT wMsgFilterMax);
__declspec(dllimport)
    BOOL
    __stdcall TranslateMessage(
        const MSG* lpMsg);
__declspec(dllimport)
    LRESULT
    __stdcall DispatchMessageA(
        const MSG* lpMsg);
__declspec(dllimport)
    LRESULT
    __stdcall DispatchMessageW(
        const MSG* lpMsg);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetMessageQueue(
        int cMessagesMax);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall PeekMessageA(
        LPMSG lpMsg,
        HWND hWnd,
        UINT wMsgFilterMin,
        UINT wMsgFilterMax,
        UINT wRemoveMsg);
__declspec(dllimport)
    BOOL
    __stdcall PeekMessageW(
        LPMSG lpMsg,
        HWND hWnd,
        UINT wMsgFilterMin,
        UINT wMsgFilterMax,
        UINT wRemoveMsg);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall RegisterHotKey(
        HWND hWnd,
        int id,
        UINT fsModifiers,
        UINT vk);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterHotKey(
        HWND hWnd,
        int id);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall ExitWindowsEx(
        UINT uFlags,
        DWORD dwReason);
__declspec(dllimport)
    BOOL
    __stdcall SwapMouseButton(
        BOOL fSwap);
__declspec(dllimport)
    DWORD
    __stdcall GetMessagePos(
        void);
__declspec(dllimport)
    LONG
    __stdcall GetMessageTime(
        void);
__declspec(dllimport)
    LPARAM
    __stdcall GetMessageExtraInfo(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetUnpredictedMessagePos(
        void);
__declspec(dllimport)
    BOOL
    __stdcall IsWow64Message(
        void);
__declspec(dllimport)
    LPARAM
    __stdcall SetMessageExtraInfo(
        LPARAM lParam);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    LRESULT
    __stdcall SendMessageA(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall SendMessageW(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    LRESULT
    __stdcall SendMessageTimeoutA(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam,
        UINT fuFlags,
        UINT uTimeout,
        PDWORD_PTR lpdwResult);
__declspec(dllimport)
    LRESULT
    __stdcall SendMessageTimeoutW(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam,
        UINT fuFlags,
        UINT uTimeout,
        PDWORD_PTR lpdwResult);
__declspec(dllimport)
    BOOL
    __stdcall SendNotifyMessageA(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall SendNotifyMessageW(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall SendMessageCallbackA(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam,
        SENDASYNCPROC lpResultCallBack,
        ULONG_PTR dwData);
__declspec(dllimport)
    BOOL
    __stdcall SendMessageCallbackW(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam,
        SENDASYNCPROC lpResultCallBack,
        ULONG_PTR dwData);
typedef struct {
    UINT cbSize;
    HDESK hdesk;
    HWND hwnd;
    LUID luid;
} BSMINFO, *PBSMINFO;
__declspec(dllimport) long __stdcall BroadcastSystemMessageExA(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pbsmInfo);
__declspec(dllimport) long __stdcall BroadcastSystemMessageExW(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pbsmInfo);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) long __stdcall BroadcastSystemMessageA(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
__declspec(dllimport) long __stdcall BroadcastSystemMessageW(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
#pragma endregion
#pragma region Desktop Family
typedef PVOID HDEVNOTIFY;
typedef HDEVNOTIFY* PHDEVNOTIFY;
__declspec(dllimport)
    HDEVNOTIFY
    __stdcall RegisterDeviceNotificationA(
        HANDLE hRecipient,
        LPVOID NotificationFilter,
        DWORD Flags);
__declspec(dllimport)
    HDEVNOTIFY
    __stdcall RegisterDeviceNotificationW(
        HANDLE hRecipient,
        LPVOID NotificationFilter,
        DWORD Flags);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterDeviceNotification(
        HDEVNOTIFY Handle);
typedef PVOID HPOWERNOTIFY;
typedef HPOWERNOTIFY* PHPOWERNOTIFY;
__declspec(dllimport)
    HPOWERNOTIFY
    __stdcall RegisterPowerSettingNotification(
        HANDLE hRecipient,
        LPCGUID PowerSettingGuid,
        DWORD Flags);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterPowerSettingNotification(
        HPOWERNOTIFY Handle);
__declspec(dllimport)
    HPOWERNOTIFY
    __stdcall RegisterSuspendResumeNotification(
        HANDLE hRecipient,
        DWORD Flags);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterSuspendResumeNotification(
        HPOWERNOTIFY Handle);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall PostMessageA(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall PostMessageW(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall PostThreadMessageA(
        DWORD idThread,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall PostThreadMessageW(
        DWORD idThread,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall AttachThreadInput(
        DWORD idAttach,
        DWORD idAttachTo,
        BOOL fAttach);
__declspec(dllimport)
    BOOL
    __stdcall ReplyMessage(
        LRESULT lResult);
__declspec(dllimport)
    BOOL
    __stdcall WaitMessage(
        void);
__declspec(dllimport)
    DWORD
    __stdcall WaitForInputIdle(
        HANDLE hProcess,
        DWORD dwMilliseconds);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    LRESULT
    __stdcall DefWindowProcA(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall DefWindowProcW(
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport) void __stdcall PostQuitMessage(
    int nExitCode);
__declspec(dllimport)
    LRESULT
    __stdcall CallWindowProcA(
        WNDPROC lpPrevWndFunc,
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall CallWindowProcW(
        WNDPROC lpPrevWndFunc,
        HWND hWnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall InSendMessage(
        void);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall InSendMessageEx(
        LPVOID lpReserved);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    UINT
    __stdcall GetDoubleClickTime(
        void);
__declspec(dllimport)
    BOOL
    __stdcall SetDoubleClickTime(
        UINT);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    ATOM
    __stdcall RegisterClassA(
        const WNDCLASSA* lpWndClass);
__declspec(dllimport)
    ATOM
    __stdcall RegisterClassW(
        const WNDCLASSW* lpWndClass);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterClassA(
        LPCSTR lpClassName,
        HINSTANCE hInstance);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterClassW(
        LPCWSTR lpClassName,
        HINSTANCE hInstance);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetClassInfoA(
        HINSTANCE hInstance,
        LPCSTR lpClassName,
        LPWNDCLASSA lpWndClass);
__declspec(dllimport)
    BOOL
    __stdcall GetClassInfoW(
        HINSTANCE hInstance,
        LPCWSTR lpClassName,
        LPWNDCLASSW lpWndClass);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    ATOM
    __stdcall RegisterClassExA(
        const WNDCLASSEXA*);
__declspec(dllimport)
    ATOM
    __stdcall RegisterClassExW(
        const WNDCLASSEXW*);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetClassInfoExA(
        HINSTANCE hInstance,
        LPCSTR lpszClass,
        LPWNDCLASSEXA lpwcx);
__declspec(dllimport)
    BOOL
    __stdcall GetClassInfoExW(
        HINSTANCE hInstance,
        LPCWSTR lpszClass,
        LPWNDCLASSEXW lpwcx);
#pragma endregion
#pragma region Desktop Family or Games Family
typedef BOOLEAN(__stdcall* PREGISTERCLASSNAMEW)(LPCWSTR);
__declspec(dllimport)
    HWND
    __stdcall CreateWindowExA(
        DWORD dwExStyle,
        LPCSTR lpClassName,
        LPCSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent,
        HMENU hMenu,
        HINSTANCE hInstance,
        LPVOID lpParam);
__declspec(dllimport)
    HWND
    __stdcall CreateWindowExW(
        DWORD dwExStyle,
        LPCWSTR lpClassName,
        LPCWSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent,
        HMENU hMenu,
        HINSTANCE hInstance,
        LPVOID lpParam);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsWindow(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall IsMenu(
        HMENU hMenu);
__declspec(dllimport)
    BOOL
    __stdcall IsChild(
        HWND hWndParent,
        HWND hWnd);
#pragma endregion
#pragma region Desktop or Games Family
__declspec(dllimport)
    BOOL
    __stdcall DestroyWindow(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall ShowWindow(
        HWND hWnd,
        int nCmdShow);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall AnimateWindow(
        HWND hWnd,
        DWORD dwTime,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall UpdateLayeredWindow(
        HWND hWnd,
        HDC hdcDst,
        POINT* pptDst,
        SIZE* psize,
        HDC hdcSrc,
        POINT* pptSrc,
        COLORREF crKey,
        BLENDFUNCTION* pblend,
        DWORD dwFlags);
typedef struct tagUPDATELAYEREDWINDOWINFO {
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;
__declspec(dllimport)
    BOOL
    __stdcall UpdateLayeredWindowIndirect(
        HWND hWnd,
        const UPDATELAYEREDWINDOWINFO* pULWInfo);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetLayeredWindowAttributes(
        HWND hwnd,
        COLORREF* pcrKey,
        BYTE* pbAlpha,
        DWORD* pdwFlags);
__declspec(dllimport)
    BOOL
    __stdcall PrintWindow(
        HWND hwnd,
        HDC hdcBlt,
        UINT nFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetLayeredWindowAttributes(
        HWND hwnd,
        COLORREF crKey,
        BYTE bAlpha,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall ShowWindowAsync(
        HWND hWnd,
        int nCmdShow);
__declspec(dllimport)
    BOOL
    __stdcall FlashWindow(
        HWND hWnd,
        BOOL bInvert);
typedef struct {
    UINT cbSize;
    HWND hwnd;
    DWORD dwFlags;
    UINT uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;
__declspec(dllimport)
    BOOL
    __stdcall FlashWindowEx(
        PFLASHWINFO pfwi);
__declspec(dllimport)
    BOOL
    __stdcall ShowOwnedPopups(
        HWND hWnd,
        BOOL fShow);
__declspec(dllimport)
    BOOL
    __stdcall OpenIcon(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall CloseWindow(
        HWND hWnd);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall MoveWindow(
        HWND hWnd,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        BOOL bRepaint);
__declspec(dllimport)
    BOOL
    __stdcall SetWindowPos(
        HWND hWnd,
        HWND hWndInsertAfter,
        int X,
        int Y,
        int cx,
        int cy,
        UINT uFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetWindowPlacement(
        HWND hWnd,
        WINDOWPLACEMENT* lpwndpl);
__declspec(dllimport)
    BOOL
    __stdcall SetWindowPlacement(
        HWND hWnd,
        const WINDOWPLACEMENT* lpwndpl);
__declspec(dllimport)
    BOOL
    __stdcall GetWindowDisplayAffinity(
        HWND hWnd,
        DWORD* pdwAffinity);
__declspec(dllimport)
    BOOL
    __stdcall SetWindowDisplayAffinity(
        HWND hWnd,
        DWORD dwAffinity);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HDWP
    __stdcall BeginDeferWindowPos(
        int nNumWindows);
__declspec(dllimport)
    HDWP
    __stdcall DeferWindowPos(
        HDWP hWinPosInfo,
        HWND hWnd,
        HWND hWndInsertAfter,
        int x,
        int y,
        int cx,
        int cy,
        UINT uFlags);
__declspec(dllimport)
    BOOL
    __stdcall EndDeferWindowPos(
        HDWP hWinPosInfo);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsWindowVisible(
        HWND hWnd);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsIconic(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall AnyPopup(
        void);
__declspec(dllimport)
    BOOL
    __stdcall BringWindowToTop(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall IsZoomed(
        HWND hWnd);
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(push, 2)
#pragma region Application Family or OneCore Family
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
#pragma endregion
#pragma region Desktop Family
typedef DLGTEMPLATE* LPDLGTEMPLATEA;
typedef DLGTEMPLATE* LPDLGTEMPLATEW;
typedef LPDLGTEMPLATEW LPDLGTEMPLATE;
#pragma endregion
#pragma region Application Family or OneCore Family
typedef const DLGTEMPLATE* LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE* LPCDLGTEMPLATEW;
typedef LPCDLGTEMPLATEW LPCDLGTEMPLATE;
#pragma endregion
#pragma region Desktop Family
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE* PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE* PDLGITEMTEMPLATEW;
typedef PDLGITEMTEMPLATEW PDLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE* LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE* LPDLGITEMTEMPLATEW;
typedef LPDLGITEMTEMPLATEW LPDLGITEMTEMPLATE;
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma region Desktop Family
__declspec(dllimport)
    HWND
    __stdcall CreateDialogParamA(
        HINSTANCE hInstance,
        LPCSTR lpTemplateName,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    HWND
    __stdcall CreateDialogParamW(
        HINSTANCE hInstance,
        LPCWSTR lpTemplateName,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    HWND
    __stdcall CreateDialogIndirectParamA(
        HINSTANCE hInstance,
        LPCDLGTEMPLATEA lpTemplate,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    HWND
    __stdcall CreateDialogIndirectParamW(
        HINSTANCE hInstance,
        LPCDLGTEMPLATEW lpTemplate,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    INT_PTR
    __stdcall DialogBoxParamA(
        HINSTANCE hInstance,
        LPCSTR lpTemplateName,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    INT_PTR
    __stdcall DialogBoxParamW(
        HINSTANCE hInstance,
        LPCWSTR lpTemplateName,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    INT_PTR
    __stdcall DialogBoxIndirectParamA(
        HINSTANCE hInstance,
        LPCDLGTEMPLATEA hDialogTemplate,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    INT_PTR
    __stdcall DialogBoxIndirectParamW(
        HINSTANCE hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND hWndParent,
        DLGPROC lpDialogFunc,
        LPARAM dwInitParam);
__declspec(dllimport)
    BOOL
    __stdcall EndDialog(
        HWND hDlg,
        INT_PTR nResult);
__declspec(dllimport)
    HWND
    __stdcall GetDlgItem(
        HWND hDlg,
        int nIDDlgItem);
__declspec(dllimport)
    BOOL
    __stdcall SetDlgItemInt(
        HWND hDlg,
        int nIDDlgItem,
        UINT uValue,
        BOOL bSigned);
__declspec(dllimport)
    UINT
    __stdcall GetDlgItemInt(
        HWND hDlg,
        int nIDDlgItem,
        BOOL* lpTranslated,
        BOOL bSigned);
__declspec(dllimport)
    BOOL
    __stdcall SetDlgItemTextA(
        HWND hDlg,
        int nIDDlgItem,
        LPCSTR lpString);
__declspec(dllimport)
    BOOL
    __stdcall SetDlgItemTextW(
        HWND hDlg,
        int nIDDlgItem,
        LPCWSTR lpString);
__declspec(dllimport)
    UINT
    __stdcall GetDlgItemTextA(
        HWND hDlg,
        int nIDDlgItem,
        LPSTR lpString,
        int cchMax);
__declspec(dllimport)
    UINT
    __stdcall GetDlgItemTextW(
        HWND hDlg,
        int nIDDlgItem,
        LPWSTR lpString,
        int cchMax);
__declspec(dllimport)
    BOOL
    __stdcall CheckDlgButton(
        HWND hDlg,
        int nIDButton,
        UINT uCheck);
__declspec(dllimport)
    BOOL
    __stdcall CheckRadioButton(
        HWND hDlg,
        int nIDFirstButton,
        int nIDLastButton,
        int nIDCheckButton);
__declspec(dllimport)
    UINT
    __stdcall IsDlgButtonChecked(
        HWND hDlg,
        int nIDButton);
__declspec(dllimport)
    LRESULT
    __stdcall SendDlgItemMessageA(
        HWND hDlg,
        int nIDDlgItem,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall SendDlgItemMessageW(
        HWND hDlg,
        int nIDDlgItem,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    HWND
    __stdcall GetNextDlgGroupItem(
        HWND hDlg,
        HWND hCtl,
        BOOL bPrevious);
__declspec(dllimport)
    HWND
    __stdcall GetNextDlgTabItem(
        HWND hDlg,
        HWND hCtl,
        BOOL bPrevious);
__declspec(dllimport) int __stdcall GetDlgCtrlID(
    HWND hWnd);
__declspec(dllimport) long __stdcall GetDialogBaseUnits(void);
__declspec(dllimport)
    LRESULT
    __stdcall DefDlgProcA(
        HWND hDlg,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall DefDlgProcW(
        HWND hDlg,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
typedef enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
    DCDC_DEFAULT = 0x0000,
    DCDC_DISABLE_FONT_UPDATE = 0x0001,
    DCDC_DISABLE_RELAYOUT = 0x0002,
} DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;
extern "C++" {
inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator|(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) noexcept { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& operator|=(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) noexcept { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator&(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) noexcept { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& operator&=(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) noexcept { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator~(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a) noexcept { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)); }
inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator^(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) noexcept { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& operator^=(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) noexcept { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); }
};
BOOL __stdcall SetDialogControlDpiChangeBehavior(
    HWND hWnd,
    DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask,
    DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);
DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
__stdcall GetDialogControlDpiChangeBehavior(
    HWND hWnd);
typedef enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT = 0x0000,
    DDC_DISABLE_ALL = 0x0001,
    DDC_DISABLE_RESIZE = 0x0002,
    DDC_DISABLE_CONTROL_RELAYOUT = 0x0004,
} DIALOG_DPI_CHANGE_BEHAVIORS;
extern "C++" {
inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator|(DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) noexcept { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline DIALOG_DPI_CHANGE_BEHAVIORS& operator|=(DIALOG_DPI_CHANGE_BEHAVIORS& a, DIALOG_DPI_CHANGE_BEHAVIORS b) noexcept { return (DIALOG_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator&(DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) noexcept { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline DIALOG_DPI_CHANGE_BEHAVIORS& operator&=(DIALOG_DPI_CHANGE_BEHAVIORS& a, DIALOG_DPI_CHANGE_BEHAVIORS b) noexcept { return (DIALOG_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator~(DIALOG_DPI_CHANGE_BEHAVIORS a) noexcept { return DIALOG_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)); }
inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator^(DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) noexcept { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); }
inline DIALOG_DPI_CHANGE_BEHAVIORS& operator^=(DIALOG_DPI_CHANGE_BEHAVIORS& a, DIALOG_DPI_CHANGE_BEHAVIORS b) noexcept { return (DIALOG_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); }
};
BOOL __stdcall SetDialogDpiChangeBehavior(
    HWND hDlg,
    DIALOG_DPI_CHANGE_BEHAVIORS mask,
    DIALOG_DPI_CHANGE_BEHAVIORS values);
DIALOG_DPI_CHANGE_BEHAVIORS
__stdcall GetDialogDpiChangeBehavior(
    HWND hDlg);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CallMsgFilterA(
        LPMSG lpMsg,
        int nCode);
__declspec(dllimport)
    BOOL
    __stdcall CallMsgFilterW(
        LPMSG lpMsg,
        int nCode);
__declspec(dllimport)
    BOOL
    __stdcall OpenClipboard(
        HWND hWndNewOwner);
__declspec(dllimport)
    BOOL
    __stdcall CloseClipboard(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetClipboardSequenceNumber(
        void);
__declspec(dllimport)
    HWND
    __stdcall GetClipboardOwner(
        void);
__declspec(dllimport)
    HWND
    __stdcall SetClipboardViewer(
        HWND hWndNewViewer);
__declspec(dllimport)
    HWND
    __stdcall GetClipboardViewer(
        void);
__declspec(dllimport)
    BOOL
    __stdcall ChangeClipboardChain(
        HWND hWndRemove,
        HWND hWndNewNext);
__declspec(dllimport)
    HANDLE
    __stdcall SetClipboardData(
        UINT uFormat,
        HANDLE hMem);
__declspec(dllimport)
    HANDLE
    __stdcall GetClipboardData(
        UINT uFormat);
__declspec(dllimport)
    UINT
    __stdcall RegisterClipboardFormatA(
        LPCSTR lpszFormat);
__declspec(dllimport)
    UINT
    __stdcall RegisterClipboardFormatW(
        LPCWSTR lpszFormat);
__declspec(dllimport) int __stdcall CountClipboardFormats(
    void);
__declspec(dllimport)
    UINT
    __stdcall EnumClipboardFormats(
        UINT format);
__declspec(dllimport) int __stdcall GetClipboardFormatNameA(
    UINT format,
    LPSTR lpszFormatName,
    int cchMaxCount);
__declspec(dllimport) int __stdcall GetClipboardFormatNameW(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);
__declspec(dllimport)
    BOOL
    __stdcall EmptyClipboard(
        void);
__declspec(dllimport)
    BOOL
    __stdcall IsClipboardFormatAvailable(
        UINT format);
__declspec(dllimport) int __stdcall GetPriorityClipboardFormat(
    UINT* paFormatPriorityList,
    int cFormats);
__declspec(dllimport)
    HWND
    __stdcall GetOpenClipboardWindow(
        void);
__declspec(dllimport)
    BOOL
    __stdcall AddClipboardFormatListener(
        HWND hwnd);
__declspec(dllimport)
    BOOL
    __stdcall RemoveClipboardFormatListener(
        HWND hwnd);
__declspec(dllimport)
    BOOL
    __stdcall GetUpdatedClipboardFormats(
        PUINT lpuiFormats,
        UINT cFormats,
        PUINT pcFormatsOut);
__declspec(dllimport)
    BOOL
    __stdcall CharToOemA(
        LPCSTR pSrc,
        LPSTR pDst);
__declspec(dllimport)
    BOOL
    __stdcall CharToOemW(
        LPCWSTR pSrc,
        LPSTR pDst);
__declspec(dllimport)
    BOOL
    __stdcall OemToCharA(
        LPCSTR pSrc,
        LPSTR pDst);
__declspec(dllimport)
    BOOL
    __stdcall OemToCharW(
        LPCSTR pSrc,
        LPWSTR pDst);
__declspec(dllimport)
    BOOL
    __stdcall CharToOemBuffA(
        LPCSTR lpszSrc,
        LPSTR lpszDst,
        DWORD cchDstLength);
__declspec(dllimport)
    BOOL
    __stdcall CharToOemBuffW(
        LPCWSTR lpszSrc,
        LPSTR lpszDst,
        DWORD cchDstLength);
__declspec(dllimport)
    BOOL
    __stdcall OemToCharBuffA(
        LPCSTR lpszSrc,
        LPSTR lpszDst,
        DWORD cchDstLength);
__declspec(dllimport)
    BOOL
    __stdcall OemToCharBuffW(
        LPCSTR lpszSrc,
        LPWSTR lpszDst,
        DWORD cchDstLength);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    LPSTR
    __stdcall CharUpperA(
        LPSTR lpsz);
__declspec(dllimport)
    LPWSTR
    __stdcall CharUpperW(
        LPWSTR lpsz);
__declspec(dllimport)
    DWORD
    __stdcall CharUpperBuffA(
        LPSTR lpsz,
        DWORD cchLength);
__declspec(dllimport)
    DWORD
    __stdcall CharUpperBuffW(
        LPWSTR lpsz,
        DWORD cchLength);
__declspec(dllimport)
    LPSTR
    __stdcall CharLowerA(
        LPSTR lpsz);
__declspec(dllimport)
    LPWSTR
    __stdcall CharLowerW(
        LPWSTR lpsz);
__declspec(dllimport)
    DWORD
    __stdcall CharLowerBuffA(
        LPSTR lpsz,
        DWORD cchLength);
__declspec(dllimport)
    DWORD
    __stdcall CharLowerBuffW(
        LPWSTR lpsz,
        DWORD cchLength);
__declspec(dllimport)
    LPSTR
    __stdcall CharNextA(
        LPCSTR lpsz);
__declspec(dllimport)
    LPWSTR
    __stdcall CharNextW(
        LPCWSTR lpsz);
__declspec(dllimport)
    LPSTR
    __stdcall CharPrevA(
        LPCSTR lpszStart,
        LPCSTR lpszCurrent);
__declspec(dllimport)
    LPWSTR
    __stdcall CharPrevW(
        LPCWSTR lpszStart,
        LPCWSTR lpszCurrent);
__declspec(dllimport)
    LPSTR
    __stdcall CharNextExA(
        WORD CodePage,
        LPCSTR lpCurrentChar,
        DWORD dwFlags);
__declspec(dllimport)
    LPSTR
    __stdcall CharPrevExA(
        WORD CodePage,
        LPCSTR lpStart,
        LPCSTR lpCurrentChar,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsCharAlphaA(
        CHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharAlphaW(
        WCHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharAlphaNumericA(
        CHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharAlphaNumericW(
        WCHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharUpperA(
        CHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharUpperW(
        WCHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharLowerA(
        CHAR ch);
__declspec(dllimport)
    BOOL
    __stdcall IsCharLowerW(
        WCHAR ch);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HWND
    __stdcall SetFocus(
        HWND hWnd);
__declspec(dllimport)
    HWND
    __stdcall GetActiveWindow(
        void);
__declspec(dllimport)
    HWND
    __stdcall GetFocus(
        void);
__declspec(dllimport)
    UINT
    __stdcall GetKBCodePage(
        void);
__declspec(dllimport)
    SHORT
    __stdcall GetKeyState(
        int nVirtKey);
__declspec(dllimport)
    SHORT
    __stdcall GetAsyncKeyState(
        int vKey);
__declspec(dllimport)
    BOOL
    __stdcall GetKeyboardState(
        PBYTE lpKeyState);
__declspec(dllimport)
    BOOL
    __stdcall SetKeyboardState(
        LPBYTE lpKeyState);
#pragma endregion
#pragma region Desktop or PC Family
__declspec(dllimport) int __stdcall GetKeyNameTextA(
    LONG lParam,
    LPSTR lpString,
    int cchSize);
__declspec(dllimport) int __stdcall GetKeyNameTextW(
    LONG lParam,
    LPWSTR lpString,
    int cchSize);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall GetKeyboardType(
    int nTypeFlag);
__declspec(dllimport) int __stdcall ToAscii(
    UINT uVirtKey,
    UINT uScanCode,
    const BYTE* lpKeyState,
    LPWORD lpChar,
    UINT uFlags);
__declspec(dllimport) int __stdcall ToAsciiEx(
    UINT uVirtKey,
    UINT uScanCode,
    const BYTE* lpKeyState,
    LPWORD lpChar,
    UINT uFlags,
    HKL dwhkl);
__declspec(dllimport) int __stdcall ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    const BYTE* lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags);
__declspec(dllimport)
    DWORD
    __stdcall OemKeyScan(
        WORD wOemChar);
__declspec(dllimport)
    SHORT
    __stdcall VkKeyScanA(
        CHAR ch);
__declspec(dllimport)
    SHORT
    __stdcall VkKeyScanW(
        WCHAR ch);
__declspec(dllimport)
    SHORT
    __stdcall VkKeyScanExA(
        CHAR ch,
        HKL dwhkl);
__declspec(dllimport)
    SHORT
    __stdcall VkKeyScanExW(
        WCHAR ch,
        HKL dwhkl);
__declspec(dllimport) void __stdcall keybd_event(
    BYTE bVk,
    BYTE bScan,
    DWORD dwFlags,
    ULONG_PTR dwExtraInfo);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) void __stdcall mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD dwData,
    ULONG_PTR dwExtraInfo);
#pragma endregion
typedef struct tagMOUSEINPUT {
    LONG dx;
    LONG dy;
    DWORD mouseData;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, *LPMOUSEINPUT;
typedef struct tagKEYBDINPUT {
    WORD wVk;
    WORD wScan;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, *LPKEYBDINPUT;
#pragma region Desktop Family
typedef struct tagHARDWAREINPUT {
    DWORD uMsg;
    WORD wParamL;
    WORD wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, *LPHARDWAREINPUT;
typedef struct tagINPUT {
    DWORD type;
    union {
        MOUSEINPUT mi;
        KEYBDINPUT ki;
        HARDWAREINPUT hi;
    };
} INPUT, *PINPUT, *LPINPUT;
__declspec(dllimport)
    UINT
    __stdcall SendInput(
        UINT cInputs,
        LPINPUT pInputs,
        int cbSize);
#pragma endregion
#pragma region Desktop Family
struct HTOUCHINPUT__ {
    int unused;
};
typedef struct HTOUCHINPUT__* HTOUCHINPUT;
typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const* PCTOUCHINPUT;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetTouchInputInfo(
        HTOUCHINPUT hTouchInput,
        UINT cInputs,
        PTOUCHINPUT pInputs,
        int cbSize);
__declspec(dllimport)
    BOOL
    __stdcall CloseTouchInputHandle(
        HTOUCHINPUT hTouchInput);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall RegisterTouchWindow(
        HWND hwnd,
        ULONG ulFlags);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterTouchWindow(
        HWND hwnd);
__declspec(dllimport)
    BOOL
    __stdcall IsTouchWindow(
        HWND hwnd,
        PULONG pulFlags);
#pragma endregion
#pragma region Desktop Family
enum tagPOINTER_INPUT_TYPE {
    PT_POINTER = 1,
    PT_TOUCH = 2,
    PT_PEN = 3,
    PT_MOUSE = 4,
    PT_TOUCHPAD = 5,
};
typedef DWORD POINTER_INPUT_TYPE;
typedef UINT32 POINTER_FLAGS;
#pragma endregion
#pragma region Desktop Family
typedef enum tagPOINTER_BUTTON_CHANGE_TYPE {
    POINTER_CHANGE_NONE,
    POINTER_CHANGE_FIRSTBUTTON_DOWN,
    POINTER_CHANGE_FIRSTBUTTON_UP,
    POINTER_CHANGE_SECONDBUTTON_DOWN,
    POINTER_CHANGE_SECONDBUTTON_UP,
    POINTER_CHANGE_THIRDBUTTON_DOWN,
    POINTER_CHANGE_THIRDBUTTON_UP,
    POINTER_CHANGE_FOURTHBUTTON_DOWN,
    POINTER_CHANGE_FOURTHBUTTON_UP,
    POINTER_CHANGE_FIFTHBUTTON_DOWN,
    POINTER_CHANGE_FIFTHBUTTON_UP,
} POINTER_BUTTON_CHANGE_TYPE;
typedef struct tagPOINTER_INFO {
    POINTER_INPUT_TYPE pointerType;
    UINT32 pointerId;
    UINT32 frameId;
    POINTER_FLAGS pointerFlags;
    HANDLE sourceDevice;
    HWND hwndTarget;
    POINT ptPixelLocation;
    POINT ptHimetricLocation;
    POINT ptPixelLocationRaw;
    POINT ptHimetricLocationRaw;
    DWORD dwTime;
    UINT32 historyCount;
    INT32 InputData;
    DWORD dwKeyStates;
    UINT64 PerformanceCount;
    POINTER_BUTTON_CHANGE_TYPE ButtonChangeType;
} POINTER_INFO;
typedef UINT32 TOUCH_FLAGS;
typedef UINT32 TOUCH_MASK;
typedef struct tagPOINTER_TOUCH_INFO {
    POINTER_INFO pointerInfo;
    TOUCH_FLAGS touchFlags;
    TOUCH_MASK touchMask;
    RECT rcContact;
    RECT rcContactRaw;
    UINT32 orientation;
    UINT32 pressure;
} POINTER_TOUCH_INFO;
typedef UINT32 PEN_FLAGS;
typedef UINT32 PEN_MASK;
typedef struct tagPOINTER_PEN_INFO {
    POINTER_INFO pointerInfo;
    PEN_FLAGS penFlags;
    PEN_MASK penMask;
    UINT32 pressure;
    UINT32 rotation;
    INT32 tiltX;
    INT32 tiltY;
} POINTER_PEN_INFO;
#pragma endregion
typedef enum {
    POINTER_FEEDBACK_DEFAULT = 1,
    POINTER_FEEDBACK_INDIRECT = 2,
    POINTER_FEEDBACK_NONE = 3,
} POINTER_FEEDBACK_MODE;
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall InitializeTouchInjection(
        UINT32 maxCount,
        DWORD dwMode);
__declspec(dllimport)
    BOOL
    __stdcall InjectTouchInput(
        UINT32 count,
        const POINTER_TOUCH_INFO* contacts);
typedef struct tagUSAGE_PROPERTIES {
    USHORT level;
    USHORT page;
    USHORT usage;
    INT32 logicalMinimum;
    INT32 logicalMaximum;
    USHORT unit;
    USHORT exponent;
    BYTE count;
    INT32 physicalMinimum;
    INT32 physicalMaximum;
} USAGE_PROPERTIES, *PUSAGE_PROPERTIES;
typedef struct tagPOINTER_TYPE_INFO {
    POINTER_INPUT_TYPE type;
    union {
        POINTER_TOUCH_INFO touchInfo;
        POINTER_PEN_INFO penInfo;
    };
} POINTER_TYPE_INFO, *PPOINTER_TYPE_INFO;
typedef struct tagINPUT_INJECTION_VALUE {
    USHORT page;
    USHORT usage;
    INT32 value;
    USHORT index;
} INPUT_INJECTION_VALUE, *PINPUT_INJECTION_VALUE;
__declspec(dllimport)
    BOOL
    __stdcall GetPointerType(
        UINT32 pointerId,
        POINTER_INPUT_TYPE* pointerType);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerCursorId(
        UINT32 pointerId,
        UINT32* cursorId);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerInfo(
        UINT32 pointerId,
        POINTER_INFO* pointerInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerInfoHistory(
        UINT32 pointerId,
        UINT32* entriesCount,
        POINTER_INFO* pointerInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerFrameInfo(
        UINT32 pointerId,
        UINT32* pointerCount,
        POINTER_INFO* pointerInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerFrameInfoHistory(
        UINT32 pointerId,
        UINT32* entriesCount,
        UINT32* pointerCount,
        POINTER_INFO* pointerInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerTouchInfo(
        UINT32 pointerId,
        POINTER_TOUCH_INFO* touchInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerTouchInfoHistory(
        UINT32 pointerId,
        UINT32* entriesCount,
        POINTER_TOUCH_INFO* touchInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerFrameTouchInfo(
        UINT32 pointerId,
        UINT32* pointerCount,
        POINTER_TOUCH_INFO* touchInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerFrameTouchInfoHistory(
        UINT32 pointerId,
        UINT32* entriesCount,
        UINT32* pointerCount,
        POINTER_TOUCH_INFO* touchInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerPenInfo(
        UINT32 pointerId,
        POINTER_PEN_INFO* penInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerPenInfoHistory(
        UINT32 pointerId,
        UINT32* entriesCount,
        POINTER_PEN_INFO* penInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerFramePenInfo(
        UINT32 pointerId,
        UINT32* pointerCount,
        POINTER_PEN_INFO* penInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerFramePenInfoHistory(
        UINT32 pointerId,
        UINT32* entriesCount,
        UINT32* pointerCount,
        POINTER_PEN_INFO* penInfo);
__declspec(dllimport)
    BOOL
    __stdcall SkipPointerFrameMessages(
        UINT32 pointerId);
__declspec(dllimport)
    BOOL
    __stdcall RegisterPointerInputTarget(
        HWND hwnd,
        POINTER_INPUT_TYPE pointerType);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterPointerInputTarget(
        HWND hwnd,
        POINTER_INPUT_TYPE pointerType);
__declspec(dllimport)
    BOOL
    __stdcall RegisterPointerInputTargetEx(
        HWND hwnd,
        POINTER_INPUT_TYPE pointerType,
        BOOL fObserve);
__declspec(dllimport)
    BOOL
    __stdcall UnregisterPointerInputTargetEx(
        HWND hwnd,
        POINTER_INPUT_TYPE pointerType);
struct HSYNTHETICPOINTERDEVICE__ {
    int unused;
};
typedef struct HSYNTHETICPOINTERDEVICE__* HSYNTHETICPOINTERDEVICE;
__declspec(dllimport)
    HSYNTHETICPOINTERDEVICE
    __stdcall CreateSyntheticPointerDevice(
        POINTER_INPUT_TYPE pointerType,
        ULONG maxCount,
        POINTER_FEEDBACK_MODE mode);
__declspec(dllimport)
    BOOL
    __stdcall InjectSyntheticPointerInput(
        HSYNTHETICPOINTERDEVICE device,
        const POINTER_TYPE_INFO* pointerInfo,
        UINT32 count);
__declspec(dllimport) void __stdcall DestroySyntheticPointerDevice(
    HSYNTHETICPOINTERDEVICE device);
__declspec(dllimport)
    BOOL
    __stdcall EnableMouseInPointer(
        BOOL fEnable);
__declspec(dllimport)
    BOOL
    __stdcall IsMouseInPointerEnabled(
        void);
__declspec(dllimport)
    BOOL
    __stdcall EnableMouseInPointerForThread(void);
__declspec(dllimport)
    BOOL
    __stdcall RegisterTouchHitTestingWindow(
        HWND hwnd,
        ULONG value);
typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
    UINT16 score;
    POINT adjustedPoint;
} TOUCH_HIT_TESTING_PROXIMITY_EVALUATION, *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
typedef struct tagTOUCH_HIT_TESTING_INPUT {
    UINT32 pointerId;
    POINT point;
    RECT boundingBox;
    RECT nonOccludedBoundingBox;
    UINT32 orientation;
} TOUCH_HIT_TESTING_INPUT, *PTOUCH_HIT_TESTING_INPUT;
__declspec(dllimport)
    BOOL
    __stdcall EvaluateProximityToRect(
        const RECT* controlBoundingBox,
        const TOUCH_HIT_TESTING_INPUT* pHitTestingInput,
        TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);
__declspec(dllimport)
    BOOL
    __stdcall EvaluateProximityToPolygon(
        UINT32 numVertices,
        const POINT* controlPolygon,
        const TOUCH_HIT_TESTING_INPUT* pHitTestingInput,
        TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);
__declspec(dllimport)
    LRESULT
    __stdcall PackTouchHitTestingProximityEvaluation(
        const TOUCH_HIT_TESTING_INPUT* pHitTestingInput,
        const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);
typedef enum tagFEEDBACK_TYPE {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION = 2,
    FEEDBACK_PEN_TAP = 3,
    FEEDBACK_PEN_DOUBLETAP = 4,
    FEEDBACK_PEN_PRESSANDHOLD = 5,
    FEEDBACK_PEN_RIGHTTAP = 6,
    FEEDBACK_TOUCH_TAP = 7,
    FEEDBACK_TOUCH_DOUBLETAP = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD = 9,
    FEEDBACK_TOUCH_RIGHTTAP = 10,
    FEEDBACK_GESTURE_PRESSANDTAP = 11,
    FEEDBACK_MAX = 0xFFFFFFFF
} FEEDBACK_TYPE;
__declspec(dllimport)
    BOOL
    __stdcall GetWindowFeedbackSetting(
        HWND hwnd,
        FEEDBACK_TYPE feedback,
        DWORD dwFlags,
        UINT32* pSize,
        void* config);
__declspec(dllimport)
    BOOL
    __stdcall SetWindowFeedbackSetting(
        HWND hwnd,
        FEEDBACK_TYPE feedback,
        DWORD dwFlags,
        UINT32 size,
        const void* configuration);
#pragma endregion
#pragma region Desktop Family
#pragma warning(push)
#pragma warning(disable : 4201)
typedef struct tagINPUT_TRANSFORM {
    union {
        struct {
            float _11, _12, _13, _14;
            float _21, _22, _23, _24;
            float _31, _32, _33, _34;
            float _41, _42, _43, _44;
        };
        float m[4][4];
    };
} INPUT_TRANSFORM;
#pragma warning(pop)
__declspec(dllimport)
    BOOL
    __stdcall GetPointerInputTransform(
        UINT32 pointerId,
        UINT32 historyCount,
        INPUT_TRANSFORM* inputTransform);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family
typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, *PLASTINPUTINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetLastInputInfo(
        PLASTINPUTINFO plii);
#pragma endregion
#pragma region Desktop or PC Family
__declspec(dllimport)
    UINT
    __stdcall MapVirtualKeyA(
        UINT uCode,
        UINT uMapType);
__declspec(dllimport)
    UINT
    __stdcall MapVirtualKeyW(
        UINT uCode,
        UINT uMapType);
__declspec(dllimport)
    UINT
    __stdcall MapVirtualKeyExA(
        UINT uCode,
        UINT uMapType,
        HKL dwhkl);
__declspec(dllimport)
    UINT
    __stdcall MapVirtualKeyExW(
        UINT uCode,
        UINT uMapType,
        HKL dwhkl);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetInputState(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetQueueStatus(
        UINT flags);
__declspec(dllimport)
    HWND
    __stdcall GetCapture(
        void);
__declspec(dllimport)
    HWND
    __stdcall SetCapture(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall ReleaseCapture(
        void);
__declspec(dllimport)
    DWORD
    __stdcall MsgWaitForMultipleObjects(
        DWORD nCount,
        const HANDLE* pHandles,
        BOOL fWaitAll,
        DWORD dwMilliseconds,
        DWORD dwWakeMask);
__declspec(dllimport)
    DWORD
    __stdcall MsgWaitForMultipleObjectsEx(
        DWORD nCount,
        const HANDLE* pHandles,
        DWORD dwMilliseconds,
        DWORD dwWakeMask,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    UINT_PTR
    __stdcall SetTimer(
        HWND hWnd,
        UINT_PTR nIDEvent,
        UINT uElapse,
        TIMERPROC lpTimerFunc);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    UINT_PTR
    __stdcall SetCoalescableTimer(
        HWND hWnd,
        UINT_PTR nIDEvent,
        UINT uElapse,
        TIMERPROC lpTimerFunc,
        ULONG uToleranceDelay);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall KillTimer(
        HWND hWnd,
        UINT_PTR uIDEvent);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsWindowUnicode(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall EnableWindow(
        HWND hWnd,
        BOOL bEnable);
__declspec(dllimport)
    BOOL
    __stdcall IsWindowEnabled(
        HWND hWnd);
__declspec(dllimport)
    HACCEL
    __stdcall LoadAcceleratorsA(
        HINSTANCE hInstance,
        LPCSTR lpTableName);
__declspec(dllimport)
    HACCEL
    __stdcall LoadAcceleratorsW(
        HINSTANCE hInstance,
        LPCWSTR lpTableName);
__declspec(dllimport)
    HACCEL
    __stdcall CreateAcceleratorTableA(
        LPACCEL paccel,
        int cAccel);
__declspec(dllimport)
    HACCEL
    __stdcall CreateAcceleratorTableW(
        LPACCEL paccel,
        int cAccel);
__declspec(dllimport)
    BOOL
    __stdcall DestroyAcceleratorTable(
        HACCEL hAccel);
__declspec(dllimport) int __stdcall CopyAcceleratorTableA(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
__declspec(dllimport) int __stdcall CopyAcceleratorTableW(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
__declspec(dllimport) int __stdcall TranslateAcceleratorA(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
__declspec(dllimport) int __stdcall TranslateAcceleratorW(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall GetSystemMetrics(
    int nIndex);
__declspec(dllimport) int __stdcall GetSystemMetricsForDpi(
    int nIndex,
    UINT dpi);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HMENU
    __stdcall LoadMenuA(
        HINSTANCE hInstance,
        LPCSTR lpMenuName);
__declspec(dllimport)
    HMENU
    __stdcall LoadMenuW(
        HINSTANCE hInstance,
        LPCWSTR lpMenuName);
__declspec(dllimport)
    HMENU
    __stdcall LoadMenuIndirectA(
        const MENUTEMPLATEA* lpMenuTemplate);
__declspec(dllimport)
    HMENU
    __stdcall LoadMenuIndirectW(
        const MENUTEMPLATEW* lpMenuTemplate);
__declspec(dllimport)
    HMENU
    __stdcall GetMenu(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall SetMenu(
        HWND hWnd,
        HMENU hMenu);
__declspec(dllimport)
    BOOL
    __stdcall ChangeMenuA(
        HMENU hMenu,
        UINT cmd,
        LPCSTR lpszNewItem,
        UINT cmdInsert,
        UINT flags);
__declspec(dllimport)
    BOOL
    __stdcall ChangeMenuW(
        HMENU hMenu,
        UINT cmd,
        LPCWSTR lpszNewItem,
        UINT cmdInsert,
        UINT flags);
__declspec(dllimport)
    BOOL
    __stdcall HiliteMenuItem(
        HWND hWnd,
        HMENU hMenu,
        UINT uIDHiliteItem,
        UINT uHilite);
__declspec(dllimport) int __stdcall GetMenuStringA(
    HMENU hMenu,
    UINT uIDItem,
    LPSTR lpString,
    int cchMax,
    UINT flags);
__declspec(dllimport) int __stdcall GetMenuStringW(
    HMENU hMenu,
    UINT uIDItem,
    LPWSTR lpString,
    int cchMax,
    UINT flags);
__declspec(dllimport)
    UINT
    __stdcall GetMenuState(
        HMENU hMenu,
        UINT uId,
        UINT uFlags);
__declspec(dllimport)
    BOOL
    __stdcall DrawMenuBar(
        HWND hWnd);
__declspec(dllimport)
    HMENU
    __stdcall GetSystemMenu(
        HWND hWnd,
        BOOL bRevert);
__declspec(dllimport)
    HMENU
    __stdcall CreateMenu(
        void);
__declspec(dllimport)
    HMENU
    __stdcall CreatePopupMenu(
        void);
__declspec(dllimport)
    BOOL
    __stdcall DestroyMenu(
        HMENU hMenu);
__declspec(dllimport)
    DWORD
    __stdcall CheckMenuItem(
        HMENU hMenu,
        UINT uIDCheckItem,
        UINT uCheck);
__declspec(dllimport)
    BOOL
    __stdcall EnableMenuItem(
        HMENU hMenu,
        UINT uIDEnableItem,
        UINT uEnable);
__declspec(dllimport)
    HMENU
    __stdcall GetSubMenu(
        HMENU hMenu,
        int nPos);
__declspec(dllimport)
    UINT
    __stdcall GetMenuItemID(
        HMENU hMenu,
        int nPos);
__declspec(dllimport) int __stdcall GetMenuItemCount(
    HMENU hMenu);
__declspec(dllimport)
    BOOL
    __stdcall InsertMenuA(
        HMENU hMenu,
        UINT uPosition,
        UINT uFlags,
        UINT_PTR uIDNewItem,
        LPCSTR lpNewItem);
__declspec(dllimport)
    BOOL
    __stdcall InsertMenuW(
        HMENU hMenu,
        UINT uPosition,
        UINT uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem);
__declspec(dllimport)
    BOOL
    __stdcall AppendMenuA(
        HMENU hMenu,
        UINT uFlags,
        UINT_PTR uIDNewItem,
        LPCSTR lpNewItem);
__declspec(dllimport)
    BOOL
    __stdcall AppendMenuW(
        HMENU hMenu,
        UINT uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem);
__declspec(dllimport)
    BOOL
    __stdcall ModifyMenuA(
        HMENU hMnu,
        UINT uPosition,
        UINT uFlags,
        UINT_PTR uIDNewItem,
        LPCSTR lpNewItem);
__declspec(dllimport)
    BOOL
    __stdcall ModifyMenuW(
        HMENU hMnu,
        UINT uPosition,
        UINT uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem);
__declspec(dllimport)
    BOOL
    __stdcall RemoveMenu(
        HMENU hMenu,
        UINT uPosition,
        UINT uFlags);
__declspec(dllimport)
    BOOL
    __stdcall DeleteMenu(
        HMENU hMenu,
        UINT uPosition,
        UINT uFlags);
__declspec(dllimport)
    BOOL
    __stdcall SetMenuItemBitmaps(
        HMENU hMenu,
        UINT uPosition,
        UINT uFlags,
        HBITMAP hBitmapUnchecked,
        HBITMAP hBitmapChecked);
__declspec(dllimport)
    LONG
    __stdcall GetMenuCheckMarkDimensions(
        void);
__declspec(dllimport)
    BOOL
    __stdcall TrackPopupMenu(
        HMENU hMenu,
        UINT uFlags,
        int x,
        int y,
        int nReserved,
        HWND hWnd,
        const RECT* prcRect);
typedef struct tagTPMPARAMS {
    UINT cbSize;
    RECT rcExclude;
} TPMPARAMS;
typedef TPMPARAMS* LPTPMPARAMS;
__declspec(dllimport)
    BOOL
    __stdcall TrackPopupMenuEx(
        HMENU hMenu,
        UINT uFlags,
        int x,
        int y,
        HWND hwnd,
        LPTPMPARAMS lptpm);
__declspec(dllimport)
    BOOL
    __stdcall CalculatePopupWindowPosition(
        const POINT* anchorPoint,
        const SIZE* windowSize,
        UINT flags,
        RECT* excludeRect,
        RECT* popupWindowPosition);
typedef struct tagMENUINFO {
    DWORD cbSize;
    DWORD fMask;
    DWORD dwStyle;
    UINT cyMax;
    HBRUSH hbrBack;
    DWORD dwContextHelpID;
    ULONG_PTR dwMenuData;
} MENUINFO, *LPMENUINFO;
typedef MENUINFO const* LPCMENUINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetMenuInfo(
        HMENU,
        LPMENUINFO);
__declspec(dllimport)
    BOOL
    __stdcall SetMenuInfo(
        HMENU,
        LPCMENUINFO);
__declspec(dllimport)
    BOOL
    __stdcall EndMenu(
        void);
typedef struct tagMENUGETOBJECTINFO {
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;
typedef struct tagMENUITEMINFOA {
    UINT cbSize;
    UINT fMask;
    UINT fType;
    UINT fState;
    UINT wID;
    HMENU hSubMenu;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    ULONG_PTR dwItemData;
    LPSTR dwTypeData;
    UINT cch;
    HBITMAP hbmpItem;
} MENUITEMINFOA, *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW {
    UINT cbSize;
    UINT fMask;
    UINT fType;
    UINT fState;
    UINT wID;
    HMENU hSubMenu;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    ULONG_PTR dwItemData;
    LPWSTR dwTypeData;
    UINT cch;
    HBITMAP hbmpItem;
} MENUITEMINFOW, *LPMENUITEMINFOW;
typedef MENUITEMINFOW MENUITEMINFO;
typedef LPMENUITEMINFOW LPMENUITEMINFO;
typedef MENUITEMINFOA const* LPCMENUITEMINFOA;
typedef MENUITEMINFOW const* LPCMENUITEMINFOW;
typedef LPCMENUITEMINFOW LPCMENUITEMINFO;
__declspec(dllimport)
    BOOL
    __stdcall InsertMenuItemA(
        HMENU hmenu,
        UINT item,
        BOOL fByPosition,
        LPCMENUITEMINFOA lpmi);
__declspec(dllimport)
    BOOL
    __stdcall InsertMenuItemW(
        HMENU hmenu,
        UINT item,
        BOOL fByPosition,
        LPCMENUITEMINFOW lpmi);
__declspec(dllimport)
    BOOL
    __stdcall GetMenuItemInfoA(
        HMENU hmenu,
        UINT item,
        BOOL fByPosition,
        LPMENUITEMINFOA lpmii);
__declspec(dllimport)
    BOOL
    __stdcall GetMenuItemInfoW(
        HMENU hmenu,
        UINT item,
        BOOL fByPosition,
        LPMENUITEMINFOW lpmii);
__declspec(dllimport)
    BOOL
    __stdcall SetMenuItemInfoA(
        HMENU hmenu,
        UINT item,
        BOOL fByPositon,
        LPCMENUITEMINFOA lpmii);
__declspec(dllimport)
    BOOL
    __stdcall SetMenuItemInfoW(
        HMENU hmenu,
        UINT item,
        BOOL fByPositon,
        LPCMENUITEMINFOW lpmii);
__declspec(dllimport)
    UINT
    __stdcall GetMenuDefaultItem(
        HMENU hMenu,
        UINT fByPos,
        UINT gmdiFlags);
__declspec(dllimport)
    BOOL
    __stdcall SetMenuDefaultItem(
        HMENU hMenu,
        UINT uItem,
        UINT fByPos);
__declspec(dllimport)
    BOOL
    __stdcall GetMenuItemRect(
        HWND hWnd,
        HMENU hMenu,
        UINT uItem,
        LPRECT lprcItem);
__declspec(dllimport) int __stdcall MenuItemFromPoint(
    HWND hWnd,
    HMENU hMenu,
    POINT ptScreen);
#pragma endregion
#pragma region Desktop Family
typedef struct tagDROPSTRUCT {
    HWND hwndSource;
    HWND hwndSink;
    DWORD wFmt;
    ULONG_PTR dwData;
    POINT ptDrop;
    DWORD dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall DragObject(
        HWND hwndParent,
        HWND hwndFrom,
        UINT fmt,
        ULONG_PTR data,
        HCURSOR hcur);
__declspec(dllimport)
    BOOL
    __stdcall DragDetect(
        HWND hwnd,
        POINT pt);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawIcon(
        HDC hDC,
        int X,
        int Y,
        HICON hIcon);
#pragma endregion
#pragma region Desktop Family
typedef struct tagDRAWTEXTPARAMS {
    UINT cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    UINT uiLengthDrawn;
} DRAWTEXTPARAMS, *LPDRAWTEXTPARAMS;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall DrawTextA(
    HDC hdc,
    LPCSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format);
__declspec(dllimport) int __stdcall DrawTextW(
    HDC hdc,
    LPCWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format);
__declspec(dllimport) int __stdcall DrawTextExA(
    HDC hdc,
    LPSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp);
__declspec(dllimport) int __stdcall DrawTextExW(
    HDC hdc,
    LPWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GrayStringA(
        HDC hDC,
        HBRUSH hBrush,
        GRAYSTRINGPROC lpOutputFunc,
        LPARAM lpData,
        int nCount,
        int X,
        int Y,
        int nWidth,
        int nHeight);
__declspec(dllimport)
    BOOL
    __stdcall GrayStringW(
        HDC hDC,
        HBRUSH hBrush,
        GRAYSTRINGPROC lpOutputFunc,
        LPARAM lpData,
        int nCount,
        int X,
        int Y,
        int nWidth,
        int nHeight);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawStateA(
        HDC hdc,
        HBRUSH hbrFore,
        DRAWSTATEPROC qfnCallBack,
        LPARAM lData,
        WPARAM wData,
        int x,
        int y,
        int cx,
        int cy,
        UINT uFlags);
__declspec(dllimport)
    BOOL
    __stdcall DrawStateW(
        HDC hdc,
        HBRUSH hbrFore,
        DRAWSTATEPROC qfnCallBack,
        LPARAM lData,
        WPARAM wData,
        int x,
        int y,
        int cx,
        int cy,
        UINT uFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    LONG
    __stdcall TabbedTextOutA(
        HDC hdc,
        int x,
        int y,
        LPCSTR lpString,
        int chCount,
        int nTabPositions,
        const INT* lpnTabStopPositions,
        int nTabOrigin);
__declspec(dllimport)
    LONG
    __stdcall TabbedTextOutW(
        HDC hdc,
        int x,
        int y,
        LPCWSTR lpString,
        int chCount,
        int nTabPositions,
        const INT* lpnTabStopPositions,
        int nTabOrigin);
__declspec(dllimport)
    DWORD
    __stdcall GetTabbedTextExtentA(
        HDC hdc,
        LPCSTR lpString,
        int chCount,
        int nTabPositions,
        const INT* lpnTabStopPositions);
__declspec(dllimport)
    DWORD
    __stdcall GetTabbedTextExtentW(
        HDC hdc,
        LPCWSTR lpString,
        int chCount,
        int nTabPositions,
        const INT* lpnTabStopPositions);
__declspec(dllimport)
    BOOL
    __stdcall UpdateWindow(
        HWND hWnd);
__declspec(dllimport)
    HWND
    __stdcall SetActiveWindow(
        HWND hWnd);
__declspec(dllimport)
    HWND
    __stdcall GetForegroundWindow(
        void);
__declspec(dllimport)
    BOOL
    __stdcall PaintDesktop(
        HDC hdc);
__declspec(dllimport) void __stdcall SwitchToThisWindow(
    HWND hwnd,
    BOOL fUnknown);
__declspec(dllimport)
    BOOL
    __stdcall SetForegroundWindow(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall AllowSetForegroundWindow(
        DWORD dwProcessId);
__declspec(dllimport)
    BOOL
    __stdcall LockSetForegroundWindow(
        UINT uLockCode);
__declspec(dllimport)
    HWND
    __stdcall WindowFromDC(
        HDC hDC);
__declspec(dllimport)
    HDC
    __stdcall GetDC(
        HWND hWnd);
__declspec(dllimport)
    HDC
    __stdcall GetDCEx(
        HWND hWnd,
        HRGN hrgnClip,
        DWORD flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HDC
    __stdcall GetWindowDC(
        HWND hWnd);
__declspec(dllimport) int __stdcall ReleaseDC(
    HWND hWnd,
    HDC hDC);
__declspec(dllimport)
    HDC
    __stdcall BeginPaint(
        HWND hWnd,
        LPPAINTSTRUCT lpPaint);
__declspec(dllimport)
    BOOL
    __stdcall EndPaint(
        HWND hWnd,
        const PAINTSTRUCT* lpPaint);
__declspec(dllimport)
    BOOL
    __stdcall GetUpdateRect(
        HWND hWnd,
        LPRECT lpRect,
        BOOL bErase);
__declspec(dllimport) int __stdcall GetUpdateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);
__declspec(dllimport) int __stdcall SetWindowRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bRedraw);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall GetWindowRgn(
    HWND hWnd,
    HRGN hRgn);
__declspec(dllimport) int __stdcall GetWindowRgnBox(
    HWND hWnd,
    LPRECT lprc);
__declspec(dllimport) int __stdcall ExcludeUpdateRgn(
    HDC hDC,
    HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall InvalidateRect(
        HWND hWnd,
        const RECT* lpRect,
        BOOL bErase);
__declspec(dllimport)
    BOOL
    __stdcall ValidateRect(
        HWND hWnd,
        const RECT* lpRect);
__declspec(dllimport)
    BOOL
    __stdcall InvalidateRgn(
        HWND hWnd,
        HRGN hRgn,
        BOOL bErase);
__declspec(dllimport)
    BOOL
    __stdcall ValidateRgn(
        HWND hWnd,
        HRGN hRgn);
__declspec(dllimport)
    BOOL
    __stdcall RedrawWindow(
        HWND hWnd,
        const RECT* lprcUpdate,
        HRGN hrgnUpdate,
        UINT flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall LockWindowUpdate(
        HWND hWndLock);
__declspec(dllimport)
    BOOL
    __stdcall ScrollWindow(
        HWND hWnd,
        int XAmount,
        int YAmount,
        const RECT* lpRect,
        const RECT* lpClipRect);
__declspec(dllimport)
    BOOL
    __stdcall ScrollDC(
        HDC hDC,
        int dx,
        int dy,
        const RECT* lprcScroll,
        const RECT* lprcClip,
        HRGN hrgnUpdate,
        LPRECT lprcUpdate);
__declspec(dllimport) int __stdcall ScrollWindowEx(
    HWND hWnd,
    int dx,
    int dy,
    const RECT* prcScroll,
    const RECT* prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall SetScrollPos(
    HWND hWnd,
    int nBar,
    int nPos,
    BOOL bRedraw);
__declspec(dllimport) int __stdcall GetScrollPos(
    HWND hWnd,
    int nBar);
__declspec(dllimport)
    BOOL
    __stdcall SetScrollRange(
        HWND hWnd,
        int nBar,
        int nMinPos,
        int nMaxPos,
        BOOL bRedraw);
__declspec(dllimport)
    BOOL
    __stdcall GetScrollRange(
        HWND hWnd,
        int nBar,
        LPINT lpMinPos,
        LPINT lpMaxPos);
__declspec(dllimport)
    BOOL
    __stdcall ShowScrollBar(
        HWND hWnd,
        int wBar,
        BOOL bShow);
__declspec(dllimport)
    BOOL
    __stdcall EnableScrollBar(
        HWND hWnd,
        UINT wSBflags,
        UINT wArrows);
__declspec(dllimport)
    BOOL
    __stdcall SetPropA(
        HWND hWnd,
        LPCSTR lpString,
        HANDLE hData);
__declspec(dllimport)
    BOOL
    __stdcall SetPropW(
        HWND hWnd,
        LPCWSTR lpString,
        HANDLE hData);
__declspec(dllimport)
    HANDLE
    __stdcall GetPropA(
        HWND hWnd,
        LPCSTR lpString);
__declspec(dllimport)
    HANDLE
    __stdcall GetPropW(
        HWND hWnd,
        LPCWSTR lpString);
__declspec(dllimport)
    HANDLE
    __stdcall RemovePropA(
        HWND hWnd,
        LPCSTR lpString);
__declspec(dllimport)
    HANDLE
    __stdcall RemovePropW(
        HWND hWnd,
        LPCWSTR lpString);
__declspec(dllimport) int __stdcall EnumPropsExA(
    HWND hWnd,
    PROPENUMPROCEXA lpEnumFunc,
    LPARAM lParam);
__declspec(dllimport) int __stdcall EnumPropsExW(
    HWND hWnd,
    PROPENUMPROCEXW lpEnumFunc,
    LPARAM lParam);
__declspec(dllimport) int __stdcall EnumPropsA(
    HWND hWnd,
    PROPENUMPROCA lpEnumFunc);
__declspec(dllimport) int __stdcall EnumPropsW(
    HWND hWnd,
    PROPENUMPROCW lpEnumFunc);
__declspec(dllimport)
    BOOL
    __stdcall SetWindowTextA(
        HWND hWnd,
        LPCSTR lpString);
__declspec(dllimport)
    BOOL
    __stdcall SetWindowTextW(
        HWND hWnd,
        LPCWSTR lpString);
__declspec(dllimport) int __stdcall GetWindowTextA(
    HWND hWnd,
    LPSTR lpString,
    int nMaxCount);
__declspec(dllimport) int __stdcall GetWindowTextW(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount);
__declspec(dllimport) int __stdcall GetWindowTextLengthA(
    HWND hWnd);
__declspec(dllimport) int __stdcall GetWindowTextLengthW(
    HWND hWnd);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetClientRect(
        HWND hWnd,
        LPRECT lpRect);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetWindowRect(
        HWND hWnd,
        LPRECT lpRect);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall AdjustWindowRect(
        LPRECT lpRect,
        DWORD dwStyle,
        BOOL bMenu);
__declspec(dllimport)
    BOOL
    __stdcall AdjustWindowRectEx(
        LPRECT lpRect,
        DWORD dwStyle,
        BOOL bMenu,
        DWORD dwExStyle);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall AdjustWindowRectExForDpi(
        LPRECT lpRect,
        DWORD dwStyle,
        BOOL bMenu,
        DWORD dwExStyle,
        UINT dpi);
#pragma endregion
#pragma region Desktop Family
typedef struct tagHELPINFO {
    UINT cbSize;
    int iContextType;
    int iCtrlId;
    HANDLE hItemHandle;
    DWORD_PTR dwContextId;
    POINT MousePos;
} HELPINFO, *LPHELPINFO;
__declspec(dllimport)
    BOOL
    __stdcall SetWindowContextHelpId(
        HWND,
        DWORD);
__declspec(dllimport)
    DWORD
    __stdcall GetWindowContextHelpId(
        HWND);
__declspec(dllimport)
    BOOL
    __stdcall SetMenuContextHelpId(
        HMENU,
        DWORD);
__declspec(dllimport)
    DWORD
    __stdcall GetMenuContextHelpId(
        HMENU);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall MessageBoxA(
    HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType);
__declspec(dllimport) int __stdcall MessageBoxW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);
__declspec(dllimport) int __stdcall MessageBoxExA(
    HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
__declspec(dllimport) int __stdcall MessageBoxExW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
typedef void(__stdcall* MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);
typedef struct tagMSGBOXPARAMSA {
    UINT cbSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCSTR lpszText;
    LPCSTR lpszCaption;
    DWORD dwStyle;
    LPCSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW {
    UINT cbSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCWSTR lpszText;
    LPCWSTR lpszCaption;
    DWORD dwStyle;
    LPCWSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;
typedef MSGBOXPARAMSW MSGBOXPARAMS;
typedef PMSGBOXPARAMSW PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSW LPMSGBOXPARAMS;
__declspec(dllimport) int __stdcall MessageBoxIndirectA(
    const MSGBOXPARAMSA* lpmbp);
__declspec(dllimport) int __stdcall MessageBoxIndirectW(
    const MSGBOXPARAMSW* lpmbp);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall MessageBeep(
        UINT uType);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport) int __stdcall ShowCursor(
    BOOL bShow);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetCursorPos(
        int X,
        int Y);
__declspec(dllimport)
    BOOL
    __stdcall SetPhysicalCursorPos(
        int X,
        int Y);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    HCURSOR
    __stdcall SetCursor(
        HCURSOR hCursor);
__declspec(dllimport)
    BOOL
    __stdcall GetCursorPos(
        LPPOINT lpPoint);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetPhysicalCursorPos(
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall GetClipCursor(
        LPRECT lpRect);
__declspec(dllimport)
    HCURSOR
    __stdcall GetCursor(
        void);
__declspec(dllimport)
    BOOL
    __stdcall CreateCaret(
        HWND hWnd,
        HBITMAP hBitmap,
        int nWidth,
        int nHeight);
__declspec(dllimport)
    UINT
    __stdcall GetCaretBlinkTime(
        void);
__declspec(dllimport)
    BOOL
    __stdcall SetCaretBlinkTime(
        UINT uMSeconds);
__declspec(dllimport)
    BOOL
    __stdcall DestroyCaret(
        void);
__declspec(dllimport)
    BOOL
    __stdcall HideCaret(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall ShowCaret(
        HWND hWnd);
__declspec(dllimport)
    BOOL
    __stdcall SetCaretPos(
        int X,
        int Y);
__declspec(dllimport)
    BOOL
    __stdcall GetCaretPos(
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall ClientToScreen(
        HWND hWnd,
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall ScreenToClient(
        HWND hWnd,
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall LogicalToPhysicalPoint(
        HWND hWnd,
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall PhysicalToLogicalPoint(
        HWND hWnd,
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall LogicalToPhysicalPointForPerMonitorDPI(
        HWND hWnd,
        LPPOINT lpPoint);
__declspec(dllimport)
    BOOL
    __stdcall PhysicalToLogicalPointForPerMonitorDPI(
        HWND hWnd,
        LPPOINT lpPoint);
__declspec(dllimport) int __stdcall MapWindowPoints(
    HWND hWndFrom,
    HWND hWndTo,
    LPPOINT lpPoints,
    UINT cPoints);
__declspec(dllimport)
    HWND
    __stdcall WindowFromPoint(
        POINT Point);
__declspec(dllimport)
    HWND
    __stdcall WindowFromPhysicalPoint(
        POINT Point);
__declspec(dllimport)
    HWND
    __stdcall ChildWindowFromPoint(
        HWND hWndParent,
        POINT Point);
#pragma endregion
#pragma region Desktop or PC Family
__declspec(dllimport)
    BOOL
    __stdcall ClipCursor(
        const RECT* lpRect);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HWND
    __stdcall ChildWindowFromPointEx(
        HWND hwnd,
        POINT pt,
        UINT flags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall GetSysColor(
        int nIndex);
__declspec(dllimport)
    HBRUSH
    __stdcall GetSysColorBrush(
        int nIndex);
__declspec(dllimport)
    BOOL
    __stdcall SetSysColors(
        int cElements,
        const INT* lpaElements,
        const COLORREF* lpaRgbValues);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DrawFocusRect(
        HDC hDC,
        const RECT* lprc);
__declspec(dllimport) int __stdcall FillRect(
    HDC hDC,
    const RECT* lprc,
    HBRUSH hbr);
__declspec(dllimport) int __stdcall FrameRect(
    HDC hDC,
    const RECT* lprc,
    HBRUSH hbr);
__declspec(dllimport)
    BOOL
    __stdcall InvertRect(
        HDC hDC,
        const RECT* lprc);
__declspec(dllimport)
    BOOL
    __stdcall SetRect(
        LPRECT lprc,
        int xLeft,
        int yTop,
        int xRight,
        int yBottom);
__declspec(dllimport)
    BOOL
    __stdcall SetRectEmpty(
        LPRECT lprc);
__declspec(dllimport)
    BOOL
    __stdcall CopyRect(
        LPRECT lprcDst,
        const RECT* lprcSrc);
__declspec(dllimport)
    BOOL
    __stdcall InflateRect(
        LPRECT lprc,
        int dx,
        int dy);
__declspec(dllimport)
    BOOL
    __stdcall IntersectRect(
        LPRECT lprcDst,
        const RECT* lprcSrc1,
        const RECT* lprcSrc2);
__declspec(dllimport)
    BOOL
    __stdcall UnionRect(
        LPRECT lprcDst,
        const RECT* lprcSrc1,
        const RECT* lprcSrc2);
__declspec(dllimport)
    BOOL
    __stdcall SubtractRect(
        LPRECT lprcDst,
        const RECT* lprcSrc1,
        const RECT* lprcSrc2);
__declspec(dllimport)
    BOOL
    __stdcall OffsetRect(
        LPRECT lprc,
        int dx,
        int dy);
__declspec(dllimport)
    BOOL
    __stdcall IsRectEmpty(
        const RECT* lprc);
__declspec(dllimport)
    BOOL
    __stdcall EqualRect(
        const RECT* lprc1,
        const RECT* lprc2);
__declspec(dllimport)
    BOOL
    __stdcall PtInRect(
        const RECT* lprc,
        POINT pt);
__declspec(dllimport)
    WORD
    __stdcall GetWindowWord(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    WORD
    __stdcall SetWindowWord(
        HWND hWnd,
        int nIndex,
        WORD wNewWord);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport)
    LONG
    __stdcall GetWindowLongA(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    LONG
    __stdcall GetWindowLongW(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    LONG
    __stdcall SetWindowLongA(
        HWND hWnd,
        int nIndex,
        LONG dwNewLong);
__declspec(dllimport)
    LONG
    __stdcall SetWindowLongW(
        HWND hWnd,
        int nIndex,
        LONG dwNewLong);
__declspec(dllimport)
    LONG_PTR
    __stdcall GetWindowLongPtrA(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    LONG_PTR
    __stdcall GetWindowLongPtrW(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    LONG_PTR
    __stdcall SetWindowLongPtrA(
        HWND hWnd,
        int nIndex,
        LONG_PTR dwNewLong);
__declspec(dllimport)
    LONG_PTR
    __stdcall SetWindowLongPtrW(
        HWND hWnd,
        int nIndex,
        LONG_PTR dwNewLong);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    WORD
    __stdcall GetClassWord(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    WORD
    __stdcall SetClassWord(
        HWND hWnd,
        int nIndex,
        WORD wNewWord);
__declspec(dllimport)
    DWORD
    __stdcall GetClassLongA(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    DWORD
    __stdcall GetClassLongW(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    DWORD
    __stdcall SetClassLongA(
        HWND hWnd,
        int nIndex,
        LONG dwNewLong);
__declspec(dllimport)
    DWORD
    __stdcall SetClassLongW(
        HWND hWnd,
        int nIndex,
        LONG dwNewLong);
__declspec(dllimport)
    ULONG_PTR
    __stdcall GetClassLongPtrA(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    ULONG_PTR
    __stdcall GetClassLongPtrW(
        HWND hWnd,
        int nIndex);
__declspec(dllimport)
    ULONG_PTR
    __stdcall SetClassLongPtrA(
        HWND hWnd,
        int nIndex,
        LONG_PTR dwNewLong);
__declspec(dllimport)
    ULONG_PTR
    __stdcall SetClassLongPtrW(
        HWND hWnd,
        int nIndex,
        LONG_PTR dwNewLong);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessDefaultLayout(
        DWORD* pdwDefaultLayout);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessDefaultLayout(
        DWORD dwDefaultLayout);
__declspec(dllimport)
    HWND
    __stdcall GetDesktopWindow(
        void);
__declspec(dllimport)
    HWND
    __stdcall GetParent(
        HWND hWnd);
__declspec(dllimport)
    HWND
    __stdcall SetParent(
        HWND hWndChild,
        HWND hWndNewParent);
__declspec(dllimport)
    BOOL
    __stdcall EnumChildWindows(
        HWND hWndParent,
        WNDENUMPROC lpEnumFunc,
        LPARAM lParam);
__declspec(dllimport)
    HWND
    __stdcall FindWindowA(
        LPCSTR lpClassName,
        LPCSTR lpWindowName);
__declspec(dllimport)
    HWND
    __stdcall FindWindowW(
        LPCWSTR lpClassName,
        LPCWSTR lpWindowName);
__declspec(dllimport)
    HWND
    __stdcall FindWindowExA(
        HWND hWndParent,
        HWND hWndChildAfter,
        LPCSTR lpszClass,
        LPCSTR lpszWindow);
__declspec(dllimport)
    HWND
    __stdcall FindWindowExW(
        HWND hWndParent,
        HWND hWndChildAfter,
        LPCWSTR lpszClass,
        LPCWSTR lpszWindow);
__declspec(dllimport)
    HWND
    __stdcall GetShellWindow(
        void);
__declspec(dllimport)
    BOOL
    __stdcall RegisterShellHookWindow(
        HWND hwnd);
__declspec(dllimport)
    BOOL
    __stdcall DeregisterShellHookWindow(
        HWND hwnd);
__declspec(dllimport)
    BOOL
    __stdcall EnumWindows(
        WNDENUMPROC lpEnumFunc,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumThreadWindows(
        DWORD dwThreadId,
        WNDENUMPROC lpfn,
        LPARAM lParam);
#pragma endregion
#pragma region Desktop Family or Games Family
__declspec(dllimport) int __stdcall GetClassNameA(
    HWND hWnd,
    LPSTR lpClassName,
    int nMaxCount);
__declspec(dllimport) int __stdcall GetClassNameW(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HWND
    __stdcall GetTopWindow(
        HWND hWnd);
__declspec(dllimport)
    DWORD
    __stdcall GetWindowThreadProcessId(
        HWND hWnd,
        LPDWORD lpdwProcessId);
__declspec(dllimport)
    BOOL
    __stdcall IsGUIThread(
        BOOL bConvert);
__declspec(dllimport)
    HWND
    __stdcall GetLastActivePopup(
        HWND hWnd);
__declspec(dllimport)
    HWND
    __stdcall GetWindow(
        HWND hWnd,
        UINT uCmd);
__declspec(dllimport)
    HHOOK
    __stdcall SetWindowsHookA(
        int nFilterType,
        HOOKPROC pfnFilterProc);
__declspec(dllimport)
    HHOOK
    __stdcall SetWindowsHookW(
        int nFilterType,
        HOOKPROC pfnFilterProc);
__declspec(dllimport)
    BOOL
    __stdcall UnhookWindowsHook(
        int nCode,
        HOOKPROC pfnFilterProc);
__declspec(dllimport)
    HHOOK
    __stdcall SetWindowsHookExA(
        int idHook,
        HOOKPROC lpfn,
        HINSTANCE hmod,
        DWORD dwThreadId);
__declspec(dllimport)
    HHOOK
    __stdcall SetWindowsHookExW(
        int idHook,
        HOOKPROC lpfn,
        HINSTANCE hmod,
        DWORD dwThreadId);
__declspec(dllimport)
    BOOL
    __stdcall UnhookWindowsHookEx(
        HHOOK hhk);
__declspec(dllimport)
    LRESULT
    __stdcall CallNextHookEx(
        HHOOK hhk,
        int nCode,
        WPARAM wParam,
        LPARAM lParam);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall CheckMenuRadioItem(
        HMENU hmenu,
        UINT first,
        UINT last,
        UINT check,
        UINT flags);
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;
typedef struct {
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HBITMAP
    __stdcall LoadBitmapA(
        HINSTANCE hInstance,
        LPCSTR lpBitmapName);
__declspec(dllimport)
    HBITMAP
    __stdcall LoadBitmapW(
        HINSTANCE hInstance,
        LPCWSTR lpBitmapName);
#pragma endregion
#pragma region Desktop or Games Family
__declspec(dllimport)
    HCURSOR
    __stdcall LoadCursorA(
        HINSTANCE hInstance,
        LPCSTR lpCursorName);
__declspec(dllimport)
    HCURSOR
    __stdcall LoadCursorW(
        HINSTANCE hInstance,
        LPCWSTR lpCursorName);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HCURSOR
    __stdcall LoadCursorFromFileA(
        LPCSTR lpFileName);
__declspec(dllimport)
    HCURSOR
    __stdcall LoadCursorFromFileW(
        LPCWSTR lpFileName);
#pragma endregion
#pragma region Desktop or Games Family
__declspec(dllimport)
    HCURSOR
    __stdcall CreateCursor(
        HINSTANCE hInst,
        int xHotSpot,
        int yHotSpot,
        int nWidth,
        int nHeight,
        const void* pvANDPlane,
        const void* pvXORPlane);
__declspec(dllimport)
    BOOL
    __stdcall DestroyCursor(
        HCURSOR hCursor);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetSystemCursor(
        HCURSOR hcur,
        DWORD id);
typedef struct _ICONINFO {
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO* PICONINFO;
__declspec(dllimport)
    HICON
    __stdcall LoadIconA(
        HINSTANCE hInstance,
        LPCSTR lpIconName);
__declspec(dllimport)
    HICON
    __stdcall LoadIconW(
        HINSTANCE hInstance,
        LPCWSTR lpIconName);
__declspec(dllimport)
    UINT
    __stdcall PrivateExtractIconsA(
        LPCSTR szFileName,
        int nIconIndex,
        int cxIcon,
        int cyIcon,
        HICON* phicon,
        UINT* piconid,
        UINT nIcons,
        UINT flags);
__declspec(dllimport)
    UINT
    __stdcall PrivateExtractIconsW(
        LPCWSTR szFileName,
        int nIconIndex,
        int cxIcon,
        int cyIcon,
        HICON* phicon,
        UINT* piconid,
        UINT nIcons,
        UINT flags);
__declspec(dllimport)
    HICON
    __stdcall CreateIcon(
        HINSTANCE hInstance,
        int nWidth,
        int nHeight,
        BYTE cPlanes,
        BYTE cBitsPixel,
        const BYTE* lpbANDbits,
        const BYTE* lpbXORbits);
__declspec(dllimport)
    BOOL
    __stdcall DestroyIcon(
        HICON hIcon);
__declspec(dllimport) int __stdcall LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL fIcon);
__declspec(dllimport) int __stdcall LookupIconIdFromDirectoryEx(
    PBYTE presbits,
    BOOL fIcon,
    int cxDesired,
    int cyDesired,
    UINT Flags);
__declspec(dllimport)
    HICON
    __stdcall CreateIconFromResource(
        PBYTE presbits,
        DWORD dwResSize,
        BOOL fIcon,
        DWORD dwVer);
__declspec(dllimport)
    HICON
    __stdcall CreateIconFromResourceEx(
        PBYTE presbits,
        DWORD dwResSize,
        BOOL fIcon,
        DWORD dwVer,
        int cxDesired,
        int cyDesired,
        UINT Flags);
typedef struct tagCURSORSHAPE {
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE, *LPCURSORSHAPE;
#pragma endregion
#pragma region Desktop or Games Family
__declspec(dllimport)
    UINT
    __stdcall SetThreadCursorCreationScaling(
        UINT cursorDpi);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HANDLE
    __stdcall LoadImageA(
        HINSTANCE hInst,
        LPCSTR name,
        UINT type,
        int cx,
        int cy,
        UINT fuLoad);
__declspec(dllimport)
    HANDLE
    __stdcall LoadImageW(
        HINSTANCE hInst,
        LPCWSTR name,
        UINT type,
        int cx,
        int cy,
        UINT fuLoad);
__declspec(dllimport)
    HANDLE
    __stdcall CopyImage(
        HANDLE h,
        UINT type,
        int cx,
        int cy,
        UINT flags);
__declspec(dllimport) BOOL __stdcall DrawIconEx(
    HDC hdc,
    int xLeft,
    int yTop,
    HICON hIcon,
    int cxWidth,
    int cyWidth,
    UINT istepIfAniCur,
    HBRUSH hbrFlickerFreeDraw,
    UINT diFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HICON
    __stdcall CreateIconIndirect(
        PICONINFO piconinfo);
__declspec(dllimport)
    HICON
    __stdcall CopyIcon(
        HICON hIcon);
__declspec(dllimport)
    BOOL
    __stdcall GetIconInfo(
        HICON hIcon,
        PICONINFO piconinfo);
typedef struct _ICONINFOEXA {
    DWORD cbSize;
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD wResID;
    CHAR szModName[260];
    CHAR szResName[260];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD cbSize;
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD wResID;
    WCHAR szModName[260];
    WCHAR szResName[260];
} ICONINFOEXW, *PICONINFOEXW;
typedef ICONINFOEXW ICONINFOEX;
typedef PICONINFOEXW PICONINFOEX;
__declspec(dllimport)
    BOOL
    __stdcall GetIconInfoExA(
        HICON hicon,
        PICONINFOEXA piconinfo);
__declspec(dllimport)
    BOOL
    __stdcall GetIconInfoExW(
        HICON hicon,
        PICONINFOEXW piconinfo);
#pragma endregion
typedef enum {
    EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0,
    EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1,
} EDIT_CONTROL_FEATURE;
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsDialogMessageA(
        HWND hDlg,
        LPMSG lpMsg);
__declspec(dllimport)
    BOOL
    __stdcall IsDialogMessageW(
        HWND hDlg,
        LPMSG lpMsg);
__declspec(dllimport)
    BOOL
    __stdcall MapDialogRect(
        HWND hDlg,
        LPRECT lpRect);
__declspec(dllimport) int __stdcall DlgDirListA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
__declspec(dllimport) int __stdcall DlgDirListW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall DlgDirSelectExA(
        HWND hwndDlg,
        LPSTR lpString,
        int chCount,
        int idListBox);
__declspec(dllimport)
    BOOL
    __stdcall DlgDirSelectExW(
        HWND hwndDlg,
        LPWSTR lpString,
        int chCount,
        int idListBox);
__declspec(dllimport) int __stdcall DlgDirListComboBoxA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
__declspec(dllimport) int __stdcall DlgDirListComboBoxW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
__declspec(dllimport)
    BOOL
    __stdcall DlgDirSelectComboBoxExA(
        HWND hwndDlg,
        LPSTR lpString,
        int cchOut,
        int idComboBox);
__declspec(dllimport)
    BOOL
    __stdcall DlgDirSelectComboBoxExW(
        HWND hwndDlg,
        LPWSTR lpString,
        int cchOut,
        int idComboBox);
#pragma endregion
#pragma region Desktop Family
typedef struct tagSCROLLINFO {
    UINT cbSize;
    UINT fMask;
    int nMin;
    int nMax;
    UINT nPage;
    int nPos;
    int nTrackPos;
} SCROLLINFO, *LPSCROLLINFO;
typedef SCROLLINFO const* LPCSCROLLINFO;
__declspec(dllimport) int __stdcall SetScrollInfo(
    HWND hwnd,
    int nBar,
    LPCSCROLLINFO lpsi,
    BOOL redraw);
__declspec(dllimport)
    BOOL
    __stdcall GetScrollInfo(
        HWND hwnd,
        int nBar,
        LPSCROLLINFO lpsi);
#pragma endregion
#pragma region Desktop Family
typedef struct tagMDICREATESTRUCTA {
    LPCSTR szClass;
    LPCSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR szClass;
    LPCWSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;
typedef MDICREATESTRUCTW MDICREATESTRUCT;
typedef LPMDICREATESTRUCTW LPMDICREATESTRUCT;
typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;
__declspec(dllimport)
    LRESULT
    __stdcall DefFrameProcA(
        HWND hWnd,
        HWND hWndMDIClient,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall DefFrameProcW(
        HWND hWnd,
        HWND hWndMDIClient,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall DefMDIChildProcA(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    LRESULT
    __stdcall DefMDIChildProcW(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
    BOOL
    __stdcall TranslateMDISysAccel(
        HWND hWndClient,
        LPMSG lpMsg);
__declspec(dllimport)
    UINT
    __stdcall ArrangeIconicWindows(
        HWND hWnd);
__declspec(dllimport)
    HWND
    __stdcall CreateMDIWindowA(
        LPCSTR lpClassName,
        LPCSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent,
        HINSTANCE hInstance,
        LPARAM lParam);
__declspec(dllimport)
    HWND
    __stdcall CreateMDIWindowW(
        LPCWSTR lpClassName,
        LPCWSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent,
        HINSTANCE hInstance,
        LPARAM lParam);
__declspec(dllimport)
    WORD
    __stdcall TileWindows(
        HWND hwndParent,
        UINT wHow,
        const RECT* lpRect,
        UINT cKids,
        const HWND* lpKids);
__declspec(dllimport)
    WORD
    __stdcall CascadeWindows(
        HWND hwndParent,
        UINT wHow,
        const RECT* lpRect,
        UINT cKids,
        const HWND* lpKids);
#pragma endregion
#pragma region Desktop Family
typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
    DWORD mkSize;
    CHAR mkKeylist;
    CHAR szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
    DWORD mkSize;
    WCHAR mkKeylist;
    WCHAR szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;
typedef MULTIKEYHELPW MULTIKEYHELP;
typedef PMULTIKEYHELPW PMULTIKEYHELP;
typedef LPMULTIKEYHELPW LPMULTIKEYHELP;
typedef struct tagHELPWININFOA {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    CHAR rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    WCHAR rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;
typedef HELPWININFOW HELPWININFO;
typedef PHELPWININFOW PHELPWININFO;
typedef LPHELPWININFOW LPHELPWININFO;
__declspec(dllimport)
    BOOL
    __stdcall WinHelpA(
        HWND hWndMain,
        LPCSTR lpszHelp,
        UINT uCommand,
        ULONG_PTR dwData);
__declspec(dllimport)
    BOOL
    __stdcall WinHelpW(
        HWND hWndMain,
        LPCWSTR lpszHelp,
        UINT uCommand,
        ULONG_PTR dwData);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    DWORD
    __stdcall GetGuiResources(
        HANDLE hProcess,
        DWORD uiFlags);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family
typedef struct tagTouchPredictionParameters {
    UINT cbSize;
    UINT dwLatency;
    UINT dwSampleTime;
    UINT bUseHWTimeStamp;
} TOUCHPREDICTIONPARAMETERS, *PTOUCHPREDICTIONPARAMETERS;
#pragma endregion
typedef enum tagHANDEDNESS {
    HANDEDNESS_LEFT = 0,
    HANDEDNESS_RIGHT
} HANDEDNESS,
    *PHANDEDNESS;
#pragma region Desktop Family
typedef struct tagNONCLIENTMETRICSA {
    UINT cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
    int iPaddedBorderWidth;
} NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, *LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW {
    UINT cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
    int iPaddedBorderWidth;
} NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, *LPNONCLIENTMETRICSW;
typedef NONCLIENTMETRICSW NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSW PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSW LPNONCLIENTMETRICS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagMINIMIZEDMETRICS {
    UINT cbSize;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
} MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;
typedef struct tagICONMETRICSA {
    UINT cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTA lfFont;
} ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW {
    UINT cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTW lfFont;
} ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;
typedef ICONMETRICSW ICONMETRICS;
typedef PICONMETRICSW PICONMETRICS;
typedef LPICONMETRICSW LPICONMETRICS;
typedef struct tagANIMATIONINFO {
    UINT cbSize;
    int iMinAnimate;
} ANIMATIONINFO, *LPANIMATIONINFO;
typedef struct tagSERIALKEYSA {
    UINT cbSize;
    DWORD dwFlags;
    LPSTR lpszActivePort;
    LPSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
} SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW {
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR lpszActivePort;
    LPWSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
} SERIALKEYSW, *LPSERIALKEYSW;
typedef SERIALKEYSW SERIALKEYS;
typedef LPSERIALKEYSW LPSERIALKEYS;
typedef struct tagHIGHCONTRASTA {
    UINT cbSize;
    DWORD dwFlags;
    LPSTR lpszDefaultScheme;
} HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW {
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR lpszDefaultScheme;
} HIGHCONTRASTW, *LPHIGHCONTRASTW;
typedef HIGHCONTRASTW HIGHCONTRAST;
typedef LPHIGHCONTRASTW LPHIGHCONTRAST;
#pragma endregion
#pragma once
#pragma region Desktop Family
typedef struct _VIDEOPARAMETERS {
    GUID Guid;
    ULONG dwOffset;
    ULONG dwCommand;
    ULONG dwFlags;
    ULONG dwMode;
    ULONG dwTVStandard;
    ULONG dwAvailableModes;
    ULONG dwAvailableTVStandard;
    ULONG dwFlickerFilter;
    ULONG dwOverScanX;
    ULONG dwOverScanY;
    ULONG dwMaxUnscaledX;
    ULONG dwMaxUnscaledY;
    ULONG dwPositionX;
    ULONG dwPositionY;
    ULONG dwBrightness;
    ULONG dwContrast;
    ULONG dwCPType;
    ULONG dwCPCommand;
    ULONG dwCPStandard;
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;
    UCHAR bOEMCopyProtection[256];
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    LONG
    __stdcall ChangeDisplaySettingsA(
        DEVMODEA* lpDevMode,
        DWORD dwFlags);
__declspec(dllimport)
    LONG
    __stdcall ChangeDisplaySettingsW(
        DEVMODEW* lpDevMode,
        DWORD dwFlags);
__declspec(dllimport)
    LONG
    __stdcall ChangeDisplaySettingsExA(
        LPCSTR lpszDeviceName,
        DEVMODEA* lpDevMode,
        HWND hwnd,
        DWORD dwflags,
        LPVOID lParam);
__declspec(dllimport)
    LONG
    __stdcall ChangeDisplaySettingsExW(
        LPCWSTR lpszDeviceName,
        DEVMODEW* lpDevMode,
        HWND hwnd,
        DWORD dwflags,
        LPVOID lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplaySettingsA(
        LPCSTR lpszDeviceName,
        DWORD iModeNum,
        DEVMODEA* lpDevMode);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplaySettingsW(
        LPCWSTR lpszDeviceName,
        DWORD iModeNum,
        DEVMODEW* lpDevMode);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplaySettingsExA(
        LPCSTR lpszDeviceName,
        DWORD iModeNum,
        DEVMODEA* lpDevMode,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplaySettingsExW(
        LPCWSTR lpszDeviceName,
        DWORD iModeNum,
        DEVMODEW* lpDevMode,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplayDevicesA(
        LPCSTR lpDevice,
        DWORD iDevNum,
        PDISPLAY_DEVICEA lpDisplayDevice,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplayDevicesW(
        LPCWSTR lpDevice,
        DWORD iDevNum,
        PDISPLAY_DEVICEW lpDisplayDevice,
        DWORD dwFlags);
__declspec(dllimport)
    LONG
    __stdcall GetDisplayConfigBufferSizes(
        UINT32 flags,
        UINT32* numPathArrayElements,
        UINT32* numModeInfoArrayElements);
__declspec(dllimport)
    LONG
    __stdcall SetDisplayConfig(
        UINT32 numPathArrayElements,
        DISPLAYCONFIG_PATH_INFO* pathArray,
        UINT32 numModeInfoArrayElements,
        DISPLAYCONFIG_MODE_INFO* modeInfoArray,
        UINT32 flags);
__declspec(dllimport)
    LONG
    __stdcall QueryDisplayConfig(
        UINT32 flags,
        UINT32* numPathArrayElements,
        DISPLAYCONFIG_PATH_INFO* pathArray,
        UINT32* numModeInfoArrayElements,
        DISPLAYCONFIG_MODE_INFO* modeInfoArray,
        DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);
__declspec(dllimport)
    LONG
    __stdcall DisplayConfigGetDeviceInfo(
        DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);
__declspec(dllimport)
    LONG
    __stdcall DisplayConfigSetDeviceInfo(
        DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);
__declspec(dllimport)
    BOOL
    __stdcall SystemParametersInfoA(
        UINT uiAction,
        UINT uiParam,
        PVOID pvParam,
        UINT fWinIni);
__declspec(dllimport)
    BOOL
    __stdcall SystemParametersInfoW(
        UINT uiAction,
        UINT uiParam,
        PVOID pvParam,
        UINT fWinIni);
__declspec(dllimport)
    BOOL
    __stdcall SystemParametersInfoForDpi(
        UINT uiAction,
        UINT uiParam,
        PVOID pvParam,
        UINT fWinIni,
        UINT dpi);
#pragma endregion
#pragma region Desktop Family
typedef struct tagFILTERKEYS {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;
    DWORD iDelayMSec;
    DWORD iRepeatMSec;
    DWORD iBounceMSec;
} FILTERKEYS, *LPFILTERKEYS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagSTICKYKEYS {
    UINT cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagMOUSEKEYS {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagACCESSTIMEOUT {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagSOUNDSENTRYA {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;
typedef SOUNDSENTRYW SOUNDSENTRY;
typedef LPSOUNDSENTRYW LPSOUNDSENTRY;
#pragma endregion
#pragma region Desktop or PC Family
__declspec(dllimport)
    BOOL
    __stdcall SoundSentry(void);
#pragma endregion
#pragma region Desktop Family
typedef struct tagTOGGLEKEYS {
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;
#pragma endregion
#pragma region Desktop Family
typedef struct tagAUDIODESCRIPTION {
    UINT cbSize;
    BOOL Enabled;
    LCID Locale;
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;
__declspec(dllimport) void __stdcall SetDebugErrorLevel(
    DWORD dwLevel);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) void __stdcall SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType);
__declspec(dllimport) int __stdcall InternalGetWindowText(
    HWND hWnd,
    LPWSTR pString,
    int cchMaxCount);
__declspec(dllimport)
    BOOL
    __stdcall CancelShutdown(
        void);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HMONITOR
    __stdcall MonitorFromPoint(
        POINT pt,
        DWORD dwFlags);
__declspec(dllimport)
    HMONITOR
    __stdcall MonitorFromRect(
        LPCRECT lprc,
        DWORD dwFlags);
__declspec(dllimport)
    HMONITOR
    __stdcall MonitorFromWindow(
        HWND hwnd,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family
typedef struct tagMONITORINFO {
    DWORD cbSize;
    RECT rcMonitor;
    RECT rcWork;
    DWORD dwFlags;
} MONITORINFO, *LPMONITORINFO;
typedef struct tagMONITORINFOEXA : public tagMONITORINFO {
    CHAR szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO {
    WCHAR szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
__declspec(dllimport)
    BOOL
    __stdcall GetMonitorInfoA(
        HMONITOR hMonitor,
        LPMONITORINFO lpmi);
__declspec(dllimport)
    BOOL
    __stdcall GetMonitorInfoW(
        HMONITOR hMonitor,
        LPMONITORINFO lpmi);
typedef BOOL(__stdcall* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);
__declspec(dllimport)
    BOOL
    __stdcall EnumDisplayMonitors(
        HDC hdc,
        LPCRECT lprcClip,
        MONITORENUMPROC lpfnEnum,
        LPARAM dwData);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) void __stdcall NotifyWinEvent(
    DWORD event,
    HWND hwnd,
    LONG idObject,
    LONG idChild);
typedef void(__stdcall* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD event,
    HWND hwnd,
    LONG idObject,
    LONG idChild,
    DWORD idEventThread,
    DWORD dwmsEventTime);
__declspec(dllimport)
    HWINEVENTHOOK
    __stdcall SetWinEventHook(
        DWORD eventMin,
        DWORD eventMax,
        HMODULE hmodWinEventProc,
        WINEVENTPROC pfnWinEventProc,
        DWORD idProcess,
        DWORD idThread,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall IsWinEventHookInstalled(
        DWORD event);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall UnhookWinEvent(
        HWINEVENTHOOK hWinEventHook);
#pragma endregion
#pragma region Desktop Family
typedef struct tagGUITHREADINFO {
    DWORD cbSize;
    DWORD flags;
    HWND hwndActive;
    HWND hwndFocus;
    HWND hwndCapture;
    HWND hwndMenuOwner;
    HWND hwndMoveSize;
    HWND hwndCaret;
    RECT rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall GetGUIThreadInfo(
        DWORD idThread,
        PGUITHREADINFO pgui);
__declspec(dllimport)
    BOOL
    __stdcall BlockInput(
        BOOL fBlockIt);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessDPIAware(
        void);
__declspec(dllimport)
    BOOL
    __stdcall IsProcessDPIAware(
        void);
__declspec(dllimport)
    DPI_AWARENESS_CONTEXT
    __stdcall SetThreadDpiAwarenessContext(
        DPI_AWARENESS_CONTEXT dpiContext);
__declspec(dllimport)
    DPI_AWARENESS_CONTEXT
    __stdcall GetThreadDpiAwarenessContext(
        void);
__declspec(dllimport)
    DPI_AWARENESS_CONTEXT
    __stdcall GetWindowDpiAwarenessContext(
        HWND hwnd);
__declspec(dllimport)
    DPI_AWARENESS
    __stdcall GetAwarenessFromDpiAwarenessContext(
        DPI_AWARENESS_CONTEXT value);
__declspec(dllimport)
    UINT
    __stdcall GetDpiFromDpiAwarenessContext(
        DPI_AWARENESS_CONTEXT value);
__declspec(dllimport)
    BOOL
    __stdcall AreDpiAwarenessContextsEqual(
        DPI_AWARENESS_CONTEXT dpiContextA,
        DPI_AWARENESS_CONTEXT dpiContextB);
__declspec(dllimport)
    BOOL
    __stdcall IsValidDpiAwarenessContext(
        DPI_AWARENESS_CONTEXT value);
__declspec(dllimport)
    UINT
    __stdcall GetDpiForWindow(
        HWND hwnd);
__declspec(dllimport)
    UINT
    __stdcall GetDpiForSystem(
        void);
__declspec(dllimport)
    UINT
    __stdcall GetSystemDpiForProcess(
        HANDLE hProcess);
__declspec(dllimport)
    BOOL
    __stdcall EnableNonClientDpiScaling(
        HWND hwnd);
__declspec(dllimport)
    BOOL
    __stdcall InheritWindowMonitor(
        HWND hwnd,
        HWND hwndInherit);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessDpiAwarenessContext(
        DPI_AWARENESS_CONTEXT value);
__declspec(dllimport)
    DPI_AWARENESS_CONTEXT
    __stdcall GetDpiAwarenessContextForProcess(
        HANDLE hProcess);
__declspec(dllimport)
    DPI_HOSTING_BEHAVIOR
    __stdcall SetThreadDpiHostingBehavior(
        DPI_HOSTING_BEHAVIOR value);
__declspec(dllimport)
    DPI_HOSTING_BEHAVIOR
    __stdcall GetThreadDpiHostingBehavior(void);
__declspec(dllimport)
    DPI_HOSTING_BEHAVIOR
    __stdcall GetWindowDpiHostingBehavior(
        HWND hwnd);
__declspec(dllimport)
    UINT
    __stdcall GetWindowModuleFileNameA(
        HWND hwnd,
        LPSTR pszFileName,
        UINT cchFileNameMax);
__declspec(dllimport)
    UINT
    __stdcall GetWindowModuleFileNameW(
        HWND hwnd,
        LPWSTR pszFileName,
        UINT cchFileNameMax);
#pragma endregion
#pragma region Desktop Family or Games Family
typedef struct tagCURSORINFO {
    DWORD cbSize;
    DWORD flags;
    HCURSOR hCursor;
    POINT ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetCursorInfo(
        PCURSORINFO pci);
#pragma endregion
#pragma region Desktop Family
typedef struct tagWINDOWINFO {
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetWindowInfo(
        HWND hwnd,
        PWINDOWINFO pwi);
typedef struct tagTITLEBARINFO {
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetTitleBarInfo(
        HWND hwnd,
        PTITLEBARINFO pti);
typedef struct tagTITLEBARINFOEX {
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
    RECT rgrect[5 + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;
typedef struct tagMENUBARINFO {
    DWORD cbSize;
    RECT rcBar;
    HMENU hMenu;
    HWND hwndMenu;
    BOOL fBarFocused : 1;
    BOOL fFocused : 1;
    BOOL fUnused : 30;
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetMenuBarInfo(
        HWND hwnd,
        LONG idObject,
        LONG idItem,
        PMENUBARINFO pmbi);
typedef struct tagSCROLLBARINFO {
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetScrollBarInfo(
        HWND hwnd,
        LONG idObject,
        PSCROLLBARINFO psbi);
typedef struct tagCOMBOBOXINFO {
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetComboBoxInfo(
        HWND hwndCombo,
        PCOMBOBOXINFO pcbi);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    HWND
    __stdcall GetAncestor(
        HWND hwnd,
        UINT gaFlags);
__declspec(dllimport)
    HWND
    __stdcall RealChildWindowFromPoint(
        HWND hwndParent,
        POINT ptParentClientCoords);
__declspec(dllimport)
    UINT
    __stdcall RealGetWindowClassA(
        HWND hwnd,
        LPSTR ptszClassName,
        UINT cchClassNameMax);
__declspec(dllimport)
    UINT
    __stdcall RealGetWindowClassW(
        HWND hwnd,
        LPWSTR ptszClassName,
        UINT cchClassNameMax);
typedef struct tagALTTABINFO {
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;
__declspec(dllimport)
    BOOL
    __stdcall GetAltTabInfoA(
        HWND hwnd,
        int iItem,
        PALTTABINFO pati,
        LPSTR pszItemText,
        UINT cchItemText);
__declspec(dllimport)
    BOOL
    __stdcall GetAltTabInfoW(
        HWND hwnd,
        int iItem,
        PALTTABINFO pati,
        LPWSTR pszItemText,
        UINT cchItemText);
__declspec(dllimport)
    DWORD
    __stdcall GetListBoxInfo(
        HWND hwnd);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall LockWorkStation(
        void);
__declspec(dllimport)
    BOOL
    __stdcall UserHandleGrantAccess(
        HANDLE hUserHandle,
        HANDLE hJob,
        BOOL bGrant);
#pragma endregion
#pragma region Desktop Family
struct HRAWINPUT__ {
    int unused;
};
typedef struct HRAWINPUT__* HRAWINPUT;
#pragma endregion
#pragma region Desktop Family
typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;
#pragma endregion
#pragma region Desktop Family
#pragma warning(push)
#pragma warning(disable : 4201)
typedef struct tagRAWMOUSE {
    USHORT usFlags;
    union {
        ULONG ulButtons;
        struct {
            USHORT usButtonFlags;
            USHORT usButtonData;
        };
    };
    ULONG ulRawButtons;
    LONG lLastX;
    LONG lLastY;
    ULONG ulExtraInformation;
} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;
#pragma warning(pop)
#pragma endregion
#pragma region Desktop Family
typedef struct tagRAWKEYBOARD {
    USHORT MakeCode;
    USHORT Flags;
    USHORT Reserved;
    USHORT VKey;
    UINT Message;
    ULONG ExtraInformation;
} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;
#pragma endregion
#pragma region Desktop Family
typedef struct tagRAWHID {
    DWORD dwSizeHid;
    DWORD dwCount;
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;
#pragma endregion
#pragma region Desktop Family
typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE mouse;
        RAWKEYBOARD keyboard;
        RAWHID hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    UINT
    __stdcall GetRawInputData(
        HRAWINPUT hRawInput,
        UINT uiCommand,
        LPVOID pData,
        PUINT pcbSize,
        UINT cbSizeHeader);
#pragma endregion
#pragma region Desktop Family
typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;
typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;
typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;
    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;
typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    };
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;
__declspec(dllimport)
    UINT
    __stdcall GetRawInputDeviceInfoA(
        HANDLE hDevice,
        UINT uiCommand,
        LPVOID pData,
        PUINT pcbSize);
__declspec(dllimport)
    UINT
    __stdcall GetRawInputDeviceInfoW(
        HANDLE hDevice,
        UINT uiCommand,
        LPVOID pData,
        PUINT pcbSize);
__declspec(dllimport)
    UINT
    __stdcall GetRawInputBuffer(
        PRAWINPUT pData,
        PUINT pcbSize,
        UINT cbSizeHeader);
typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage;
    USHORT usUsage;
    DWORD dwFlags;
    HWND hwndTarget;
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;
typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall RegisterRawInputDevices(
        PCRAWINPUTDEVICE pRawInputDevices,
        UINT uiNumDevices,
        UINT cbSize);
__declspec(dllimport)
    UINT
    __stdcall GetRegisteredRawInputDevices(
        PRAWINPUTDEVICE pRawInputDevices,
        PUINT puiNumDevices,
        UINT cbSize);
typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;
__declspec(dllimport)
    UINT
    __stdcall GetRawInputDeviceList(
        PRAWINPUTDEVICELIST pRawInputDeviceList,
        PUINT puiNumDevices,
        UINT cbSize);
__declspec(dllimport)
    LRESULT
    __stdcall DefRawInputProc(
        PRAWINPUT* paRawInput,
        INT nInput,
        UINT cbSizeHeader);
#pragma endregion
#pragma region Desktop Family
typedef enum tagPOINTER_DEVICE_TYPE {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN = 0x00000002,
    POINTER_DEVICE_TYPE_TOUCH = 0x00000003,
    POINTER_DEVICE_TYPE_TOUCH_PAD = 0x00000004,
    POINTER_DEVICE_TYPE_MAX = 0xFFFFFFFF
} POINTER_DEVICE_TYPE;
typedef struct tagPOINTER_DEVICE_INFO {
    DWORD displayOrientation;
    HANDLE device;
    POINTER_DEVICE_TYPE pointerDeviceType;
    HMONITOR monitor;
    ULONG startingCursorId;
    USHORT maxActiveContacts;
    WCHAR productString[520];
} POINTER_DEVICE_INFO;
typedef struct tagPOINTER_DEVICE_PROPERTY {
    INT32 logicalMin;
    INT32 logicalMax;
    INT32 physicalMin;
    INT32 physicalMax;
    UINT32 unit;
    UINT32 unitExponent;
    USHORT usagePageId;
    USHORT usageId;
} POINTER_DEVICE_PROPERTY;
typedef enum tagPOINTER_DEVICE_CURSOR_TYPE {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0x00000000,
    POINTER_DEVICE_CURSOR_TYPE_TIP = 0x00000001,
    POINTER_DEVICE_CURSOR_TYPE_ERASER = 0x00000002,
    POINTER_DEVICE_CURSOR_TYPE_MAX = 0xFFFFFFFF
} POINTER_DEVICE_CURSOR_TYPE;
typedef struct tagPOINTER_DEVICE_CURSOR_INFO {
    UINT32 cursorId;
    POINTER_DEVICE_CURSOR_TYPE cursor;
} POINTER_DEVICE_CURSOR_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetPointerDevices(
        UINT32* deviceCount,
        POINTER_DEVICE_INFO* pointerDevices);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerDevice(
        HANDLE device,
        POINTER_DEVICE_INFO* pointerDevice);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerDeviceProperties(
        HANDLE device,
        UINT32* propertyCount,
        POINTER_DEVICE_PROPERTY* pointerProperties);
__declspec(dllimport)
    BOOL
    __stdcall RegisterPointerDeviceNotifications(
        HWND window,
        BOOL notifyRange);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerDeviceRects(
        HANDLE device,
        RECT* pointerDeviceRect,
        RECT* displayRect);
__declspec(dllimport)
    BOOL
    __stdcall GetPointerDeviceCursors(
        HANDLE device,
        UINT32* cursorCount,
        POINTER_DEVICE_CURSOR_INFO* deviceCursors);
__declspec(dllimport)
    BOOL
    __stdcall GetRawPointerDeviceData(
        UINT32 pointerId,
        UINT32 historyCount,
        UINT32 propertiesCount,
        POINTER_DEVICE_PROPERTY* pProperties,
        LONG* pValues);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall ChangeWindowMessageFilter(
        UINT message,
        DWORD dwFlag);
#pragma endregion
#pragma region Desktop Family
typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall ChangeWindowMessageFilterEx(
        HWND hwnd,
        UINT message,
        DWORD action,
        PCHANGEFILTERSTRUCT pChangeFilterStruct);
#pragma endregion
#pragma region Desktop Family
struct HGESTUREINFO__ {
    int unused;
};
typedef struct HGESTUREINFO__* HGESTUREINFO;
#pragma endregion
#pragma region Desktop Family
typedef struct tagGESTUREINFO {
    UINT cbSize;
    DWORD dwFlags;
    DWORD dwID;
    HWND hwndTarget;
    POINTS ptsLocation;
    DWORD dwInstanceID;
    DWORD dwSequenceID;
    ULONGLONG ullArguments;
    UINT cbExtraArgs;
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const* PCGESTUREINFO;
typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize;
    DWORD dwFlags;
    HWND hwndTarget;
    POINTS ptsLocation;
    DWORD dwInstanceID;
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;
__declspec(dllimport)
    BOOL
    __stdcall GetGestureInfo(
        HGESTUREINFO hGestureInfo,
        PGESTUREINFO pGestureInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetGestureExtraArgs(
        HGESTUREINFO hGestureInfo,
        UINT cbExtraArgs,
        PBYTE pExtraArgs);
__declspec(dllimport)
    BOOL
    __stdcall CloseGestureInfoHandle(
        HGESTUREINFO hGestureInfo);
typedef struct tagGESTURECONFIG {
    DWORD dwID;
    DWORD dwWant;
    DWORD dwBlock;
} GESTURECONFIG, *PGESTURECONFIG;
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall SetGestureConfig(
        HWND hwnd,
        DWORD dwReserved,
        UINT cIDs,
        PGESTURECONFIG pGestureConfig,
        UINT cbSize);
__declspec(dllimport)
    BOOL
    __stdcall GetGestureConfig(
        HWND hwnd,
        DWORD dwReserved,
        DWORD dwFlags,
        PUINT pcIDs,
        PGESTURECONFIG pGestureConfig,
        UINT cbSize);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall ShutdownBlockReasonCreate(
        HWND hWnd,
        LPCWSTR pwszReason);
__declspec(dllimport)
    BOOL
    __stdcall ShutdownBlockReasonQuery(
        HWND hWnd,
        LPWSTR pwszBuff,
        DWORD* pcchBuff);
__declspec(dllimport)
    BOOL
    __stdcall ShutdownBlockReasonDestroy(
        HWND hWnd);
#pragma endregion
#pragma region Desktop Family
typedef enum tagINPUT_MESSAGE_DEVICE_TYPE {
    IMDT_UNAVAILABLE = 0x00000000,
    IMDT_KEYBOARD = 0x00000001,
    IMDT_MOUSE = 0x00000002,
    IMDT_TOUCH = 0x00000004,
    IMDT_PEN = 0x00000008,
    IMDT_TOUCHPAD = 0x00000010,
} INPUT_MESSAGE_DEVICE_TYPE;
typedef enum tagINPUT_MESSAGE_ORIGIN_ID {
    IMO_UNAVAILABLE = 0x00000000,
    IMO_HARDWARE = 0x00000001,
    IMO_INJECTED = 0x00000002,
    IMO_SYSTEM = 0x00000004,
} INPUT_MESSAGE_ORIGIN_ID;
typedef struct tagINPUT_MESSAGE_SOURCE {
    INPUT_MESSAGE_DEVICE_TYPE deviceType;
    INPUT_MESSAGE_ORIGIN_ID originId;
} INPUT_MESSAGE_SOURCE;
__declspec(dllimport)
    BOOL
    __stdcall GetCurrentInputMessageSource(
        INPUT_MESSAGE_SOURCE* inputMessageSource);
__declspec(dllimport)
    BOOL
    __stdcall GetCIMSSM(
        INPUT_MESSAGE_SOURCE* inputMessageSource);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef enum tagAR_STATE {
    AR_ENABLED = 0x0,
    AR_DISABLED = 0x1,
    AR_SUPPRESSED = 0x2,
    AR_REMOTESESSION = 0x4,
    AR_MULTIMON = 0x8,
    AR_NOSENSOR = 0x10,
    AR_NOT_SUPPORTED = 0x20,
    AR_DOCKED = 0x40,
    AR_LAPTOP = 0x80
} AR_STATE,
    *PAR_STATE;
#pragma endregion
extern "C++" {
inline constexpr AR_STATE operator|(AR_STATE a, AR_STATE b) noexcept { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); }
inline AR_STATE& operator|=(AR_STATE& a, AR_STATE b) noexcept { return (AR_STATE&)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); }
inline constexpr AR_STATE operator&(AR_STATE a, AR_STATE b) noexcept { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); }
inline AR_STATE& operator&=(AR_STATE& a, AR_STATE b) noexcept { return (AR_STATE&)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); }
inline constexpr AR_STATE operator~(AR_STATE a) noexcept { return AR_STATE(~((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a)); }
inline constexpr AR_STATE operator^(AR_STATE a, AR_STATE b) noexcept { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); }
inline AR_STATE& operator^=(AR_STATE& a, AR_STATE b) noexcept { return (AR_STATE&)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); }
}
#pragma region Desktop Family
typedef enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE = 0x0,
    ORIENTATION_PREFERENCE_LANDSCAPE = 0x1,
    ORIENTATION_PREFERENCE_PORTRAIT = 0x2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 0x8
} ORIENTATION_PREFERENCE;
extern "C++" {
inline constexpr ORIENTATION_PREFERENCE operator|(ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) noexcept { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); }
inline ORIENTATION_PREFERENCE& operator|=(ORIENTATION_PREFERENCE& a, ORIENTATION_PREFERENCE b) noexcept { return (ORIENTATION_PREFERENCE&)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); }
inline constexpr ORIENTATION_PREFERENCE operator&(ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) noexcept { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); }
inline ORIENTATION_PREFERENCE& operator&=(ORIENTATION_PREFERENCE& a, ORIENTATION_PREFERENCE b) noexcept { return (ORIENTATION_PREFERENCE&)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); }
inline constexpr ORIENTATION_PREFERENCE operator~(ORIENTATION_PREFERENCE a) noexcept { return ORIENTATION_PREFERENCE(~((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)); }
inline constexpr ORIENTATION_PREFERENCE operator^(ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) noexcept { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); }
inline ORIENTATION_PREFERENCE& operator^=(ORIENTATION_PREFERENCE& a, ORIENTATION_PREFERENCE b) noexcept { return (ORIENTATION_PREFERENCE&)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); }
}
__declspec(dllimport)
    BOOL
    __stdcall GetAutoRotationState(
        PAR_STATE pState);
__declspec(dllimport)
    BOOL
    __stdcall GetDisplayAutoRotationPreferences(
        ORIENTATION_PREFERENCE* pOrientation);
__declspec(dllimport)
    BOOL
    __stdcall GetDisplayAutoRotationPreferencesByProcessId(
        DWORD dwProcessId,
        ORIENTATION_PREFERENCE* pOrientation,
        BOOL* fRotateScreen);
__declspec(dllimport)
    BOOL
    __stdcall SetDisplayAutoRotationPreferences(
        ORIENTATION_PREFERENCE orientation);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall IsImmersiveProcess(
        HANDLE hProcess);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessRestrictionExemption(
        BOOL fEnableExemption);
#pragma endregion
#pragma region Desktop Family
#pragma warning(pop)
}
extern "C" {
#pragma once
extern "C" {
#pragma region Desktop Family or OneCore or Games Family
__declspec(dllimport) int __stdcall GetDateFormatA(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME* lpDate,
    LPCSTR lpFormat,
    LPSTR lpDateStr,
    int cchDate);
__declspec(dllimport) int __stdcall GetDateFormatW(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME* lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate);
__declspec(dllimport) int __stdcall GetTimeFormatA(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME* lpTime,
    LPCSTR lpFormat,
    LPSTR lpTimeStr,
    int cchTime);
__declspec(dllimport) int __stdcall GetTimeFormatW(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME* lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) int __stdcall GetTimeFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME* lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime);
__declspec(dllimport) int __stdcall GetDateFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME* lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate,
    LPCWSTR lpCalendar);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) int __stdcall GetDurationFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME* lpDuration,
    ULONGLONG ullDuration,
    LPCWSTR lpFormat,
    LPWSTR lpDurationStr,
    int cchDuration);
#pragma endregion
}
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Application Family or OneCore or Games Family
typedef DWORD LGRPID;
typedef DWORD LCTYPE;
typedef DWORD CALTYPE;
typedef DWORD CALID;
typedef struct _cpinfo {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
} CPINFO, *LPCPINFO;
typedef DWORD GEOTYPE;
typedef DWORD GEOCLASS;
typedef LONG GEOID;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
typedef struct _cpinfoexA {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
    WCHAR UnicodeDefaultChar;
    UINT CodePage;
    CHAR CodePageName[260];
} CPINFOEXA, *LPCPINFOEXA;
typedef struct _cpinfoexW {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
    WCHAR UnicodeDefaultChar;
    UINT CodePage;
    WCHAR CodePageName[260];
} CPINFOEXW, *LPCPINFOEXW;
typedef CPINFOEXW CPINFOEX;
typedef LPCPINFOEXW LPCPINFOEX;
#pragma endregion
#pragma region Application Family or OneCore or Games Family
typedef struct _numberfmtA {
    UINT NumDigits;
    UINT LeadingZero;
    UINT Grouping;
    LPSTR lpDecimalSep;
    LPSTR lpThousandSep;
    UINT NegativeOrder;
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT NumDigits;
    UINT LeadingZero;
    UINT Grouping;
    LPWSTR lpDecimalSep;
    LPWSTR lpThousandSep;
    UINT NegativeOrder;
} NUMBERFMTW, *LPNUMBERFMTW;
typedef NUMBERFMTW NUMBERFMT;
typedef LPNUMBERFMTW LPNUMBERFMT;
typedef struct _currencyfmtA {
    UINT NumDigits;
    UINT LeadingZero;
    UINT Grouping;
    LPSTR lpDecimalSep;
    LPSTR lpThousandSep;
    UINT NegativeOrder;
    UINT PositiveOrder;
    LPSTR lpCurrencySymbol;
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT NumDigits;
    UINT LeadingZero;
    UINT Grouping;
    LPWSTR lpDecimalSep;
    LPWSTR lpThousandSep;
    UINT NegativeOrder;
    UINT PositiveOrder;
    LPWSTR lpCurrencySymbol;
} CURRENCYFMTW, *LPCURRENCYFMTW;
typedef CURRENCYFMTW CURRENCYFMT;
typedef LPCURRENCYFMTW LPCURRENCYFMT;
#pragma endregion
#pragma region Application Family or OneCore Family
enum SYSNLS_FUNCTION {
    COMPARE_STRING = 0x0001,
};
typedef DWORD NLS_FUNCTION;
#pragma endregion
#pragma region Application Family or OneCore or Games Family
typedef struct _nlsversioninfo {
    DWORD dwNLSVersionInfoSize;
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
    DWORD dwEffectiveId;
    GUID guidCustomVersion;
} NLSVERSIONINFO, *LPNLSVERSIONINFO;
#pragma endregion
#pragma region Application Family or OneCore or Games Family
typedef struct _nlsversioninfoex {
    DWORD dwNLSVersionInfoSize;
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
    DWORD dwEffectiveId;
    GUID guidCustomVersion;
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;
enum SYSGEOTYPE {
    GEO_NATION = 0x0001,
    GEO_LATITUDE = 0x0002,
    GEO_LONGITUDE = 0x0003,
    GEO_ISO2 = 0x0004,
    GEO_ISO3 = 0x0005,
    GEO_RFC1766 = 0x0006,
    GEO_LCID = 0x0007,
    GEO_FRIENDLYNAME = 0x0008,
    GEO_OFFICIALNAME = 0x0009,
    GEO_TIMEZONES = 0x000A,
    GEO_OFFICIALLANGUAGES = 0x000B,
    GEO_ISO_UN_NUMBER = 0x000C,
    GEO_PARENT = 0x000D,
    GEO_DIALINGCODE = 0x000E,
    GEO_CURRENCYCODE = 0x000F,
    GEO_CURRENCYSYMBOL = 0x0010,
    GEO_NAME = 0x0011,
    GEO_ID = 0x0012
};
enum SYSGEOCLASS {
    GEOCLASS_NATION = 16,
    GEOCLASS_REGION = 14,
    GEOCLASS_ALL = 0
};
typedef BOOL(__stdcall* LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL(__stdcall* LOCALE_ENUMPROCW)(LPWSTR);
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef enum _NORM_FORM {
    NormalizationOther = 0,
    NormalizationC = 0x1,
    NormalizationD = 0x2,
    NormalizationKC = 0x5,
    NormalizationKD = 0x6
} NORM_FORM;
typedef BOOL(__stdcall* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL(__stdcall* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL(__stdcall* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL(__stdcall* CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL(__stdcall* DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL(__stdcall* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL(__stdcall* TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL(__stdcall* CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL(__stdcall* CALINFO_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL(__stdcall* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL(__stdcall* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL(__stdcall* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL(__stdcall* CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL(__stdcall* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL(__stdcall* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL(__stdcall* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL(__stdcall* CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL(__stdcall* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL(__stdcall* GEO_ENUMPROC)(GEOID);
typedef BOOL(__stdcall* GEO_ENUMNAMEPROC)(PWSTR, LPARAM);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef struct _FILEMUIINFO {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwFileType;
    BYTE pChecksum[16];
    BYTE pServiceChecksum[16];
    DWORD dwLanguageNameOffset;
    DWORD dwTypeIDMainSize;
    DWORD dwTypeIDMainOffset;
    DWORD dwTypeNameMainOffset;
    DWORD dwTypeIDMUISize;
    DWORD dwTypeIDMUIOffset;
    DWORD dwTypeNameMUIOffset;
    BYTE abBuffer[8];
} FILEMUIINFO, *PFILEMUIINFO;
#pragma endregion
#pragma region Application Family or OneCore or Games Family
#pragma once
extern "C" {
#pragma region Desktop or OneCore or Application or Games Family
__declspec(dllimport) int __stdcall CompareStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwCmpFlags,
    LPCWCH lpString1,
    int cchCount1,
    LPCWCH lpString2,
    int cchCount2,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam);
__declspec(dllimport) int __stdcall CompareStringOrdinal(
    LPCWCH lpString1,
    int cchCount1,
    LPCWCH lpString2,
    int cchCount2,
    BOOL bIgnoreCase);
__declspec(dllimport) int __stdcall CompareStringW(
    LCID Locale,
    DWORD dwCmpFlags,
    PCNZWCH lpString1,
    int cchCount1,
    PCNZWCH lpString2,
    int cchCount2);
__declspec(dllimport) int __stdcall FoldStringW(
    DWORD dwMapFlags,
    LPCWCH lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);
__declspec(dllimport)
    BOOL
    __stdcall GetStringTypeExW(
        LCID Locale,
        DWORD dwInfoType,
        LPCWCH lpSrcStr,
        int cchSrc,
        LPWORD lpCharType);
__declspec(dllimport)
    BOOL
    __stdcall GetStringTypeW(
        DWORD dwInfoType,
        LPCWCH lpSrcStr,
        int cchSrc,
        LPWORD lpCharType);
__declspec(dllimport) int __stdcall MultiByteToWideChar(
    UINT CodePage,
    DWORD dwFlags,
    LPCCH lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);
__declspec(dllimport) int __stdcall WideCharToMultiByte(
    UINT CodePage,
    DWORD dwFlags,
    LPCWCH lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCCH lpDefaultChar,
    LPBOOL lpUsedDefaultChar);
#pragma endregion
}
#pragma endregion
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport)
    BOOL
    __stdcall IsValidCodePage(
        UINT CodePage);
__declspec(dllimport)
    UINT
    __stdcall GetACP(void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    UINT
    __stdcall GetOEMCP(void);
#pragma endregion
#pragma region Desktop or Pc Family or OneCore or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetCPInfo(
        UINT CodePage,
        LPCPINFO lpCPInfo);
#pragma endregion
#pragma region Desktop or Pc Family or OneCore Family or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetCPInfoExA(
        UINT CodePage,
        DWORD dwFlags,
        LPCPINFOEXA lpCPInfoEx);
__declspec(dllimport)
    BOOL
    __stdcall GetCPInfoExW(
        UINT CodePage,
        DWORD dwFlags,
        LPCPINFOEXW lpCPInfoEx);
#pragma endregion
#pragma region Desktop or OneCore or Application or Games Family
__declspec(dllimport) int __stdcall CompareStringA(
    LCID Locale,
    DWORD dwCmpFlags,
    PCNZCH lpString1,
    int cchCount1,
    PCNZCH lpString2,
    int cchCount2);
#pragma endregion
#pragma region Application or OneCore or Games Family
__declspec(dllimport) int __stdcall FindNLSString(
    LCID Locale,
    DWORD dwFindNLSStringFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    LPINT pcchFound);
#pragma endregion
#pragma region Desktop or OneCore or Games Family
__declspec(dllimport) int __stdcall LCMapStringW(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);
__declspec(dllimport) int __stdcall LCMapStringA(
    LCID Locale,
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) int __stdcall GetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData);
__declspec(dllimport) int __stdcall GetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPSTR lpLCData,
    int cchData);
#pragma endregion
#pragma region Application or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetLocaleInfoA(
        LCID Locale,
        LCTYPE LCType,
        LPCSTR lpLCData);
__declspec(dllimport)
    BOOL
    __stdcall SetLocaleInfoW(
        LCID Locale,
        LCTYPE LCType,
        LPCWSTR lpLCData);
__declspec(dllimport) int __stdcall GetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPSTR lpCalData,
    int cchData,
    LPDWORD lpValue);
__declspec(dllimport) int __stdcall GetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue);
__declspec(dllimport)
    BOOL
    __stdcall SetCalendarInfoA(
        LCID Locale,
        CALID Calendar,
        CALTYPE CalType,
        LPCSTR lpCalData);
__declspec(dllimport)
    BOOL
    __stdcall SetCalendarInfoW(
        LCID Locale,
        CALID Calendar,
        CALTYPE CalType,
        LPCWSTR lpCalData);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall LoadStringByReference(
        DWORD Flags,
        PCWSTR Language,
        PCWSTR SourceString,
        PWSTR Buffer,
        ULONG cchBuffer,
        PCWSTR Directory,
        PULONG pcchBufferOut);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsDBCSLeadByte(
        BYTE TestChar);
__declspec(dllimport)
    BOOL
    __stdcall IsDBCSLeadByteEx(
        UINT CodePage,
        BYTE TestChar);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport)
    LCID
    __stdcall LocaleNameToLCID(
        LPCWSTR lpName,
        DWORD dwFlags);
__declspec(dllimport) int __stdcall LCIDToLocaleName(
    LCID Locale,
    LPWSTR lpName,
    int cchName,
    DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport) int __stdcall GetDurationFormat(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME* lpDuration,
    ULONGLONG ullDuration,
    LPCWSTR lpFormat,
    LPWSTR lpDurationStr,
    int cchDuration);
#pragma endregion
#pragma region Desktop Family or OneCore or Games Family
__declspec(dllimport) int __stdcall GetNumberFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    const NUMBERFMTA* lpFormat,
    LPSTR lpNumberStr,
    int cchNumber);
__declspec(dllimport) int __stdcall GetNumberFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const NUMBERFMTW* lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber);
__declspec(dllimport) int __stdcall GetCurrencyFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    const CURRENCYFMTA* lpFormat,
    LPSTR lpCurrencyStr,
    int cchCurrency);
__declspec(dllimport) int __stdcall GetCurrencyFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const CURRENCYFMTW* lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumCalendarInfoA(
        CALINFO_ENUMPROCA lpCalInfoEnumProc,
        LCID Locale,
        CALID Calendar,
        CALTYPE CalType);
__declspec(dllimport)
    BOOL
    __stdcall EnumCalendarInfoW(
        CALINFO_ENUMPROCW lpCalInfoEnumProc,
        LCID Locale,
        CALID Calendar,
        CALTYPE CalType);
__declspec(dllimport)
    BOOL
    __stdcall EnumCalendarInfoExA(
        CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
        LCID Locale,
        CALID Calendar,
        CALTYPE CalType);
__declspec(dllimport)
    BOOL
    __stdcall EnumCalendarInfoExW(
        CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
        LCID Locale,
        CALID Calendar,
        CALTYPE CalType);
__declspec(dllimport)
    BOOL
    __stdcall EnumTimeFormatsA(
        TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
        LCID Locale,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumTimeFormatsW(
        TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
        LCID Locale,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDateFormatsA(
        DATEFMT_ENUMPROCA lpDateFmtEnumProc,
        LCID Locale,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDateFormatsW(
        DATEFMT_ENUMPROCW lpDateFmtEnumProc,
        LCID Locale,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDateFormatsExA(
        DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
        LCID Locale,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumDateFormatsExW(
        DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
        LCID Locale,
        DWORD dwFlags);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsValidLanguageGroup(
        LGRPID LanguageGroup,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall GetNLSVersion(
        NLS_FUNCTION Function,
        LCID Locale,
        LPNLSVERSIONINFO lpVersionInformation);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall IsValidLocale(
        LCID Locale,
        DWORD dwFlags);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) int __stdcall GetGeoInfoA(
    GEOID Location,
    GEOTYPE GeoType,
    LPSTR lpGeoData,
    int cchData,
    LANGID LangId);
__declspec(dllimport) int __stdcall GetGeoInfoW(
    GEOID Location,
    GEOTYPE GeoType,
    LPWSTR lpGeoData,
    int cchData,
    LANGID LangId);
__declspec(dllimport) int __stdcall GetGeoInfoEx(
    PWSTR location,
    GEOTYPE geoType,
    PWSTR geoData,
    int geoDataCount);
#pragma endregion
#pragma region Desktop or PC Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemGeoID(
        GEOCLASS GeoClass,
        GEOID ParentGeoId,
        GEO_ENUMPROC lpGeoEnumProc);
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemGeoNames(
        GEOCLASS geoClass,
        GEO_ENUMNAMEPROC geoEnumProc,
        LPARAM data);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport)
    GEOID
    __stdcall GetUserGeoID(
        GEOCLASS GeoClass);
__declspec(dllimport) int __stdcall GetUserDefaultGeoName(
    LPWSTR geoName,
    int geoNameCount);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall SetUserGeoID(
        GEOID GeoId);
__declspec(dllimport)
    BOOL
    __stdcall SetUserGeoName(
        PWSTR geoName);
__declspec(dllimport)
    LCID
    __stdcall ConvertDefaultLocale(
        LCID Locale);
__declspec(dllimport)
    LANGID
    __stdcall GetSystemDefaultUILanguage(void);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LCID
    __stdcall GetThreadLocale(void);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadLocale(
        LCID Locale);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LANGID
    __stdcall GetUserDefaultUILanguage(void);
__declspec(dllimport)
    LANGID
    __stdcall GetUserDefaultLangID(void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    LANGID
    __stdcall GetSystemDefaultLangID(void);
__declspec(dllimport)
    LCID
    __stdcall GetSystemDefaultLCID(void);
__declspec(dllimport)
    LCID
    __stdcall GetUserDefaultLCID(void);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    LANGID
    __stdcall SetThreadUILanguage(LANGID LangId);
__declspec(dllimport)
    LANGID
    __stdcall GetThreadUILanguage(void);
__declspec(dllimport)
    BOOL
    __stdcall GetProcessPreferredUILanguages(
        DWORD dwFlags,
        PULONG pulNumLanguages,
        PZZWSTR pwszLanguagesBuffer,
        PULONG pcchLanguagesBuffer);
__declspec(dllimport)
    BOOL
    __stdcall SetProcessPreferredUILanguages(
        DWORD dwFlags,
        PCZZWSTR pwszLanguagesBuffer,
        PULONG pulNumLanguages);
#pragma endregion
#pragma region Desktop Family or Phone Family or OneCore or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetUserPreferredUILanguages(
        DWORD dwFlags,
        PULONG pulNumLanguages,
        PZZWSTR pwszLanguagesBuffer,
        PULONG pcchLanguagesBuffer);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetSystemPreferredUILanguages(
        DWORD dwFlags,
        PULONG pulNumLanguages,
        PZZWSTR pwszLanguagesBuffer,
        PULONG pcchLanguagesBuffer);
__declspec(dllimport)
    BOOL
    __stdcall GetThreadPreferredUILanguages(
        DWORD dwFlags,
        PULONG pulNumLanguages,
        PZZWSTR pwszLanguagesBuffer,
        PULONG pcchLanguagesBuffer);
__declspec(dllimport)
    BOOL
    __stdcall SetThreadPreferredUILanguages(
        DWORD dwFlags,
        PCZZWSTR pwszLanguagesBuffer,
        PULONG pulNumLanguages);
__declspec(dllimport)
    BOOL
    __stdcall GetFileMUIInfo(
        DWORD dwFlags,
        PCWSTR pcwszFilePath,
        PFILEMUIINFO pFileMUIInfo,
        DWORD* pcbFileMUIInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetFileMUIPath(
        DWORD dwFlags,
        PCWSTR pcwszFilePath,
        PWSTR pwszLanguage,
        PULONG pcchLanguage,
        PWSTR pwszFileMUIPath,
        PULONG pcchFileMUIPath,
        PULONGLONG pululEnumerator);
__declspec(dllimport)
    BOOL
    __stdcall GetUILanguageInfo(
        DWORD dwFlags,
        PCZZWSTR pwmszLanguage,
        PZZWSTR pwszFallbackLanguages,
        PDWORD pcchFallbackLanguages,
        PDWORD pAttributes);
#pragma endregion
#pragma region Desktop Family or OneCore Family
struct HSAVEDUILANGUAGES__ {
    int unused;
};
typedef struct HSAVEDUILANGUAGES__* HSAVEDUILANGUAGES;
__declspec(dllimport)
    BOOL
    __stdcall SetThreadPreferredUILanguages2(
        ULONG flags,
        PCZZWSTR languages,
        PULONG numLanguagesSet,
        HSAVEDUILANGUAGES* snapshot);
__declspec(dllimport) void __stdcall RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall NotifyUILanguageChange(
        DWORD dwFlags,
        PCWSTR pcwstrNewLanguage,
        PCWSTR pcwstrPreviousLanguage,
        DWORD dwReserved,
        PDWORD pdwStatusRtrn);
#pragma endregion
#pragma region Desktop or OneCore or Application or Games Family
__declspec(dllimport)
    BOOL
    __stdcall GetStringTypeExA(
        LCID Locale,
        DWORD dwInfoType,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPWORD lpCharType);
__declspec(dllimport)
    BOOL
    __stdcall GetStringTypeA(
        LCID Locale,
        DWORD dwInfoType,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPWORD lpCharType);
__declspec(dllimport) int __stdcall FoldStringA(
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);
#pragma endregion
#pragma region Desktop Family or OneCore or Games Family
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemLocalesA(
        LOCALE_ENUMPROCA lpLocaleEnumProc,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemLocalesW(
        LOCALE_ENUMPROCW lpLocaleEnumProc,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemLanguageGroupsA(
        LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
        DWORD dwFlags,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemLanguageGroupsW(
        LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
        DWORD dwFlags,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumLanguageGroupLocalesA(
        LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
        LGRPID LanguageGroup,
        DWORD dwFlags,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumLanguageGroupLocalesW(
        LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
        LGRPID LanguageGroup,
        DWORD dwFlags,
        LONG_PTR lParam);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumUILanguagesA(
        UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
        DWORD dwFlags,
        LONG_PTR lParam);
__declspec(dllimport)
    BOOL
    __stdcall EnumUILanguagesW(
        UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
        DWORD dwFlags,
        LONG_PTR lParam);
#pragma endregion
#pragma region Desktop or PC Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemCodePagesA(
        CODEPAGE_ENUMPROCA lpCodePageEnumProc,
        DWORD dwFlags);
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemCodePagesW(
        CODEPAGE_ENUMPROCW lpCodePageEnumProc,
        DWORD dwFlags);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) int __stdcall IdnToAscii(DWORD dwFlags,
    LPCWSTR lpUnicodeCharStr,
    int cchUnicodeChar,
    LPWSTR lpASCIICharStr,
    int cchASCIIChar);
__declspec(dllimport) int __stdcall IdnToUnicode(DWORD dwFlags,
    LPCWSTR lpASCIICharStr,
    int cchASCIIChar,
    LPWSTR lpUnicodeCharStr,
    int cchUnicodeChar);
__declspec(dllimport) int __stdcall IdnToNameprepUnicode(DWORD dwFlags,
    LPCWSTR lpUnicodeCharStr,
    int cchUnicodeChar,
    LPWSTR lpNameprepCharStr,
    int cchNameprepChar);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport) int __stdcall NormalizeString(NORM_FORM NormForm,
    LPCWSTR lpSrcString,
    int cwSrcLength,
    LPWSTR lpDstString,
    int cwDstLength);
__declspec(dllimport)
    BOOL
    __stdcall IsNormalizedString(NORM_FORM NormForm,
        LPCWSTR lpString,
        int cwLength);
__declspec(dllimport)
    BOOL
    __stdcall VerifyScripts(
        DWORD dwFlags,
        LPCWSTR lpLocaleScripts,
        int cchLocaleScripts,
        LPCWSTR lpTestScripts,
        int cchTestScripts);
__declspec(dllimport) int __stdcall GetStringScripts(
    DWORD dwFlags,
    LPCWSTR lpString,
    int cchString,
    LPWSTR lpScripts,
    int cchScripts);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) int __stdcall GetLocaleInfoEx(
    LPCWSTR lpLocaleName,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData);
#pragma endregion
#pragma region Desktop or PC Family or OneCore Family
__declspec(dllimport) int __stdcall GetCalendarInfoEx(
    LPCWSTR lpLocaleName,
    CALID Calendar,
    LPCWSTR lpReserved,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport) int __stdcall GetNumberFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const NUMBERFMTW* lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber);
__declspec(dllimport) int __stdcall GetCurrencyFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const CURRENCYFMTW* lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency);
__declspec(dllimport) int __stdcall GetUserDefaultLocaleName(
    LPWSTR lpLocaleName,
    int cchLocaleName);
#pragma endregion
#pragma region Desktop or PC Family or OneCore Family
__declspec(dllimport) int __stdcall GetSystemDefaultLocaleName(
    LPWSTR lpLocaleName,
    int cchLocaleName);
__declspec(dllimport)
    BOOL
    __stdcall IsNLSDefinedString(
        NLS_FUNCTION Function,
        DWORD dwFlags,
        LPNLSVERSIONINFO lpVersionInformation,
        LPCWSTR lpString,
        INT cchStr);
__declspec(dllimport)
    BOOL
    __stdcall GetNLSVersionEx(
        NLS_FUNCTION function,
        LPCWSTR lpLocaleName,
        LPNLSVERSIONINFOEX lpVersionInformation);
__declspec(dllimport)
    DWORD
    __stdcall IsValidNLSVersion(
        NLS_FUNCTION function,
        LPCWSTR lpLocaleName,
        LPNLSVERSIONINFOEX lpVersionInformation);
#pragma endregion
#pragma region Application Family or OneCore or Gamaes Family
__declspec(dllimport) int __stdcall FindNLSStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwFindNLSStringFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    LPINT pcchFound,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM sortHandle);
__declspec(dllimport) int __stdcall LCMapStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM sortHandle);
__declspec(dllimport)
    BOOL
    __stdcall IsValidLocaleName(
        LPCWSTR lpLocaleName);
#pragma endregion
#pragma region Desktop or PC Family or OneCore Family
typedef BOOL(__stdcall* CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);
__declspec(dllimport)
    BOOL
    __stdcall EnumCalendarInfoExEx(
        CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx,
        LPCWSTR lpLocaleName,
        CALID Calendar,
        LPCWSTR lpReserved,
        CALTYPE CalType,
        LPARAM lParam);
typedef BOOL(__stdcall* DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);
__declspec(dllimport)
    BOOL
    __stdcall EnumDateFormatsExEx(
        DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx,
        LPCWSTR lpLocaleName,
        DWORD dwFlags,
        LPARAM lParam);
typedef BOOL(__stdcall* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);
__declspec(dllimport)
    BOOL
    __stdcall EnumTimeFormatsEx(
        TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx,
        LPCWSTR lpLocaleName,
        DWORD dwFlags,
        LPARAM lParam);
#pragma endregion
#pragma region Desktop or PC Family or OneCore or Games Family
typedef BOOL(__stdcall* LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);
__declspec(dllimport)
    BOOL
    __stdcall EnumSystemLocalesEx(
        LOCALE_ENUMPROCEX lpLocaleEnumProcEx,
        DWORD dwFlags,
        LPARAM lParam,
        LPVOID lpReserved);
#pragma endregion
#pragma region Application Family or OneCore or Games Family
__declspec(dllimport) int __stdcall ResolveLocaleName(
    LPCWSTR lpNameToResolve,
    LPWSTR lpLocaleName,
    int cchLocaleName);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma warning(pop)
}
#pragma once
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma once
extern "C" {
#pragma region Application Family
typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;
typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;
typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;
typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;
typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;
typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;
typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;
typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;
typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;
typedef struct _CONSOLE_FONT_INFO {
    DWORD nFont;
    COORD dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;
typedef void* HPCON;
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall AllocConsole(
        void);
__declspec(dllimport)
    BOOL
    __stdcall FreeConsole(
        void);
__declspec(dllimport)
    BOOL
    __stdcall AttachConsole(
        DWORD dwProcessId);
__declspec(dllimport)
    UINT
    __stdcall GetConsoleCP(
        void);
__declspec(dllimport)
    UINT
    __stdcall GetConsoleOutputCP(
        void);
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleMode(
        HANDLE hConsoleHandle,
        LPDWORD lpMode);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleMode(
        HANDLE hConsoleHandle,
        DWORD dwMode);
__declspec(dllimport)
    BOOL
    __stdcall GetNumberOfConsoleInputEvents(
        HANDLE hConsoleInput,
        LPDWORD lpNumberOfEvents);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleInputA(
        HANDLE hConsoleInput,
        PINPUT_RECORD lpBuffer,
        DWORD nLength,
        LPDWORD lpNumberOfEventsRead);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleInputW(
        HANDLE hConsoleInput,
        PINPUT_RECORD lpBuffer,
        DWORD nLength,
        LPDWORD lpNumberOfEventsRead);
__declspec(dllimport)
    BOOL
    __stdcall PeekConsoleInputA(
        HANDLE hConsoleInput,
        PINPUT_RECORD lpBuffer,
        DWORD nLength,
        LPDWORD lpNumberOfEventsRead);
__declspec(dllimport)
    BOOL
    __stdcall PeekConsoleInputW(
        HANDLE hConsoleInput,
        PINPUT_RECORD lpBuffer,
        DWORD nLength,
        LPDWORD lpNumberOfEventsRead);
typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleA(
        HANDLE hConsoleInput,
        LPVOID lpBuffer,
        DWORD nNumberOfCharsToRead,
        LPDWORD lpNumberOfCharsRead,
        PCONSOLE_READCONSOLE_CONTROL pInputControl);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleW(
        HANDLE hConsoleInput,
        LPVOID lpBuffer,
        DWORD nNumberOfCharsToRead,
        LPDWORD lpNumberOfCharsRead,
        PCONSOLE_READCONSOLE_CONTROL pInputControl);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleA(
        HANDLE hConsoleOutput,
        const void* lpBuffer,
        DWORD nNumberOfCharsToWrite,
        LPDWORD lpNumberOfCharsWritten,
        LPVOID lpReserved);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleW(
        HANDLE hConsoleOutput,
        const void* lpBuffer,
        DWORD nNumberOfCharsToWrite,
        LPDWORD lpNumberOfCharsWritten,
        LPVOID lpReserved);
typedef BOOL(__stdcall* PHANDLER_ROUTINE)(
    DWORD CtrlType);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleCtrlHandler(
        PHANDLER_ROUTINE HandlerRoutine,
        BOOL Add);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    HRESULT
    __stdcall CreatePseudoConsole(
        COORD size,
        HANDLE hInput,
        HANDLE hOutput,
        DWORD dwFlags,
        HPCON* phPC);
__declspec(dllimport)
    HRESULT
    __stdcall ResizePseudoConsole(
        HPCON hPC,
        COORD size);
__declspec(dllimport) void __stdcall ClosePseudoConsole(
    HPCON hPC);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall FillConsoleOutputCharacterA(
        HANDLE hConsoleOutput,
        CHAR cCharacter,
        DWORD nLength,
        COORD dwWriteCoord,
        LPDWORD lpNumberOfCharsWritten);
__declspec(dllimport)
    BOOL
    __stdcall FillConsoleOutputCharacterW(
        HANDLE hConsoleOutput,
        WCHAR cCharacter,
        DWORD nLength,
        COORD dwWriteCoord,
        LPDWORD lpNumberOfCharsWritten);
__declspec(dllimport)
    BOOL
    __stdcall FillConsoleOutputAttribute(
        HANDLE hConsoleOutput,
        WORD wAttribute,
        DWORD nLength,
        COORD dwWriteCoord,
        LPDWORD lpNumberOfAttrsWritten);
__declspec(dllimport)
    BOOL
    __stdcall GenerateConsoleCtrlEvent(
        DWORD dwCtrlEvent,
        DWORD dwProcessGroupId);
__declspec(dllimport)
    HANDLE
    __stdcall CreateConsoleScreenBuffer(
        DWORD dwDesiredAccess,
        DWORD dwShareMode,
        const SECURITY_ATTRIBUTES* lpSecurityAttributes,
        DWORD dwFlags,
        LPVOID lpScreenBufferData);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleActiveScreenBuffer(
        HANDLE hConsoleOutput);
__declspec(dllimport)
    BOOL
    __stdcall FlushConsoleInputBuffer(
        HANDLE hConsoleInput);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleCP(
        UINT wCodePageID);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleOutputCP(
        UINT wCodePageID);
typedef struct _CONSOLE_CURSOR_INFO {
    DWORD dwSize;
    BOOL bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleCursorInfo(
        HANDLE hConsoleOutput,
        PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleCursorInfo(
        HANDLE hConsoleOutput,
        const CONSOLE_CURSOR_INFO* lpConsoleCursorInfo);
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleScreenBufferInfo(
        HANDLE hConsoleOutput,
        PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleScreenBufferInfoEx(
        HANDLE hConsoleOutput,
        PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleScreenBufferInfoEx(
        HANDLE hConsoleOutput,
        PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleScreenBufferSize(
        HANDLE hConsoleOutput,
        COORD dwSize);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleCursorPosition(
        HANDLE hConsoleOutput,
        COORD dwCursorPosition);
__declspec(dllimport)
    COORD
    __stdcall GetLargestConsoleWindowSize(
        HANDLE hConsoleOutput);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleTextAttribute(
        HANDLE hConsoleOutput,
        WORD wAttributes);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleWindowInfo(
        HANDLE hConsoleOutput,
        BOOL bAbsolute,
        const SMALL_RECT* lpConsoleWindow);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleOutputCharacterA(
        HANDLE hConsoleOutput,
        LPCSTR lpCharacter,
        DWORD nLength,
        COORD dwWriteCoord,
        LPDWORD lpNumberOfCharsWritten);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleOutputCharacterW(
        HANDLE hConsoleOutput,
        LPCWSTR lpCharacter,
        DWORD nLength,
        COORD dwWriteCoord,
        LPDWORD lpNumberOfCharsWritten);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleOutputAttribute(
        HANDLE hConsoleOutput,
        const WORD* lpAttribute,
        DWORD nLength,
        COORD dwWriteCoord,
        LPDWORD lpNumberOfAttrsWritten);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleOutputCharacterA(
        HANDLE hConsoleOutput,
        LPSTR lpCharacter,
        DWORD nLength,
        COORD dwReadCoord,
        LPDWORD lpNumberOfCharsRead);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleOutputCharacterW(
        HANDLE hConsoleOutput,
        LPWSTR lpCharacter,
        DWORD nLength,
        COORD dwReadCoord,
        LPDWORD lpNumberOfCharsRead);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleOutputAttribute(
        HANDLE hConsoleOutput,
        LPWORD lpAttribute,
        DWORD nLength,
        COORD dwReadCoord,
        LPDWORD lpNumberOfAttrsRead);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleInputA(
        HANDLE hConsoleInput,
        const INPUT_RECORD* lpBuffer,
        DWORD nLength,
        LPDWORD lpNumberOfEventsWritten);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleInputW(
        HANDLE hConsoleInput,
        const INPUT_RECORD* lpBuffer,
        DWORD nLength,
        LPDWORD lpNumberOfEventsWritten);
__declspec(dllimport)
    BOOL
    __stdcall ScrollConsoleScreenBufferA(
        HANDLE hConsoleOutput,
        const SMALL_RECT* lpScrollRectangle,
        const SMALL_RECT* lpClipRectangle,
        COORD dwDestinationOrigin,
        const CHAR_INFO* lpFill);
__declspec(dllimport)
    BOOL
    __stdcall ScrollConsoleScreenBufferW(
        HANDLE hConsoleOutput,
        const SMALL_RECT* lpScrollRectangle,
        const SMALL_RECT* lpClipRectangle,
        COORD dwDestinationOrigin,
        const CHAR_INFO* lpFill);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleOutputA(
        HANDLE hConsoleOutput,
        const CHAR_INFO* lpBuffer,
        COORD dwBufferSize,
        COORD dwBufferCoord,
        PSMALL_RECT lpWriteRegion);
__declspec(dllimport)
    BOOL
    __stdcall WriteConsoleOutputW(
        HANDLE hConsoleOutput,
        const CHAR_INFO* lpBuffer,
        COORD dwBufferSize,
        COORD dwBufferCoord,
        PSMALL_RECT lpWriteRegion);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleOutputA(
        HANDLE hConsoleOutput,
        PCHAR_INFO lpBuffer,
        COORD dwBufferSize,
        COORD dwBufferCoord,
        PSMALL_RECT lpReadRegion);
__declspec(dllimport)
    BOOL
    __stdcall ReadConsoleOutputW(
        HANDLE hConsoleOutput,
        PCHAR_INFO lpBuffer,
        COORD dwBufferSize,
        COORD dwBufferCoord,
        PSMALL_RECT lpReadRegion);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleTitleA(
        LPSTR lpConsoleTitle,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleTitleW(
        LPWSTR lpConsoleTitle,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleOriginalTitleA(
        LPSTR lpConsoleTitle,
        DWORD nSize);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleOriginalTitleW(
        LPWSTR lpConsoleTitle,
        DWORD nSize);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleTitleA(
        LPCSTR lpConsoleTitle);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleTitleW(
        LPCWSTR lpConsoleTitle);
#pragma endregion
}
#pragma once
extern "C" {
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall GetNumberOfConsoleMouseButtons(
        LPDWORD lpNumberOfMouseButtons);
__declspec(dllimport)
    COORD
    __stdcall GetConsoleFontSize(
        HANDLE hConsoleOutput,
        DWORD nFont);
__declspec(dllimport)
    BOOL
    __stdcall GetCurrentConsoleFont(
        HANDLE hConsoleOutput,
        BOOL bMaximumWindow,
        PCONSOLE_FONT_INFO lpConsoleCurrentFont);
typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[32];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
__declspec(dllimport)
    BOOL
    __stdcall GetCurrentConsoleFontEx(
        HANDLE hConsoleOutput,
        BOOL bMaximumWindow,
        PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
__declspec(dllimport)
    BOOL
    __stdcall SetCurrentConsoleFontEx(
        HANDLE hConsoleOutput,
        BOOL bMaximumWindow,
        PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleSelectionInfo(
        PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo);
typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleHistoryInfo(
        PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleHistoryInfo(
        PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
__declspec(dllimport)
    BOOL
    __stdcall GetConsoleDisplayMode(
        LPDWORD lpModeFlags);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleDisplayMode(
        HANDLE hConsoleOutput,
        DWORD dwFlags,
        PCOORD lpNewScreenBufferDimensions);
__declspec(dllimport)
    HWND
    __stdcall GetConsoleWindow(
        void);
__declspec(dllimport)
    BOOL
    __stdcall AddConsoleAliasA(
        LPSTR Source,
        LPSTR Target,
        LPSTR ExeName);
__declspec(dllimport)
    BOOL
    __stdcall AddConsoleAliasW(
        LPWSTR Source,
        LPWSTR Target,
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasA(
        LPSTR Source,
        LPSTR TargetBuffer,
        DWORD TargetBufferLength,
        LPSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasW(
        LPWSTR Source,
        LPWSTR TargetBuffer,
        DWORD TargetBufferLength,
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasesLengthA(
        LPSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasesLengthW(
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasExesLengthA(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasExesLengthW(
        void);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasesA(
        LPSTR AliasBuffer,
        DWORD AliasBufferLength,
        LPSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasesW(
        LPWSTR AliasBuffer,
        DWORD AliasBufferLength,
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasExesA(
        LPSTR ExeNameBuffer,
        DWORD ExeNameBufferLength);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleAliasExesW(
        LPWSTR ExeNameBuffer,
        DWORD ExeNameBufferLength);
__declspec(dllimport) void __stdcall ExpungeConsoleCommandHistoryA(
    LPSTR ExeName);
__declspec(dllimport) void __stdcall ExpungeConsoleCommandHistoryW(
    LPWSTR ExeName);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleNumberOfCommandsA(
        DWORD Number,
        LPSTR ExeName);
__declspec(dllimport)
    BOOL
    __stdcall SetConsoleNumberOfCommandsW(
        DWORD Number,
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleCommandHistoryLengthA(
        LPSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleCommandHistoryLengthW(
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleCommandHistoryA(
        LPSTR Commands,
        DWORD CommandBufferLength,
        LPSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleCommandHistoryW(
        LPWSTR Commands,
        DWORD CommandBufferLength,
        LPWSTR ExeName);
__declspec(dllimport)
    DWORD
    __stdcall GetConsoleProcessList(
        LPDWORD lpdwProcessList,
        DWORD dwProcessCount);
#pragma endregion
}
#pragma warning(pop)
}
#pragma region Application Family or OneCore Family or Games Family
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
extern "C" {
typedef struct tagVS_FIXEDFILEINFO {
    DWORD dwSignature;
    DWORD dwStrucVersion;
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;
    DWORD dwProductVersionMS;
    DWORD dwProductVersionLS;
    DWORD dwFileFlagsMask;
    DWORD dwFileFlags;
    DWORD dwFileOS;
    DWORD dwFileType;
    DWORD dwFileSubtype;
    DWORD dwFileDateMS;
    DWORD dwFileDateLS;
} VS_FIXEDFILEINFO;
}
#pragma endregion
extern "C" {
#pragma region Desktop Family or OneCore Family
DWORD
__stdcall VerFindFileA(
    DWORD uFlags,
    LPCSTR szFileName,
    LPCSTR szWinDir,
    LPCSTR szAppDir,
    LPSTR szCurDir,
    PUINT puCurDirLen,
    LPSTR szDestDir,
    PUINT puDestDirLen);
DWORD
__stdcall VerFindFileW(
    DWORD uFlags,
    LPCWSTR szFileName,
    LPCWSTR szWinDir,
    LPCWSTR szAppDir,
    LPWSTR szCurDir,
    PUINT puCurDirLen,
    LPWSTR szDestDir,
    PUINT puDestDirLen);
#pragma endregion
#pragma region Desktop Family
DWORD
__stdcall VerInstallFileA(
    DWORD uFlags,
    LPCSTR szSrcFileName,
    LPCSTR szDestFileName,
    LPCSTR szSrcDir,
    LPCSTR szDestDir,
    LPCSTR szCurDir,
    LPSTR szTmpFile,
    PUINT puTmpFileLen);
DWORD
__stdcall VerInstallFileW(
    DWORD uFlags,
    LPCWSTR szSrcFileName,
    LPCWSTR szDestFileName,
    LPCWSTR szSrcDir,
    LPCWSTR szDestDir,
    LPCWSTR szCurDir,
    LPWSTR szTmpFile,
    PUINT puTmpFileLen);
#pragma endregion
#pragma region Application Family or OneCore Family
DWORD
__stdcall GetFileVersionInfoSizeA(
    LPCSTR lptstrFilename,
    LPDWORD lpdwHandle);
DWORD
__stdcall GetFileVersionInfoSizeW(
    LPCWSTR lptstrFilename,
    LPDWORD lpdwHandle);
BOOL __stdcall GetFileVersionInfoA(
    LPCSTR lptstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData);
BOOL __stdcall GetFileVersionInfoW(
    LPCWSTR lptstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData);
DWORD __stdcall GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle);
BOOL __stdcall GetFileVersionInfoExA(DWORD dwFlags,
    LPCSTR lpwstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData);
BOOL __stdcall GetFileVersionInfoExW(DWORD dwFlags,
    LPCWSTR lpwstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData);
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma region Application Family or OneCore Family
DWORD
__stdcall VerLanguageNameA(
    DWORD wLang,
    LPSTR szLang,
    DWORD cchLang);
DWORD
__stdcall VerLanguageNameW(
    DWORD wLang,
    LPWSTR szLang,
    DWORD cchLang);
BOOL __stdcall VerQueryValueA(
    LPCVOID pBlock,
    LPCSTR lpSubBlock,
    LPVOID* lplpBuffer,
    PUINT puLen);
BOOL __stdcall VerQueryValueW(
    LPCVOID pBlock,
    LPCWSTR lpSubBlock,
    LPVOID* lplpBuffer,
    PUINT puLen);
#pragma endregion
}
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Application Family or Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or Desktop Family or OneCore Family or Games Family
typedef LONG LSTATUS;
#pragma endregion
#pragma region Application Family or Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or Desktop Family or OneCore Family or Games Family
typedef ACCESS_MASK REGSAM;
#pragma endregion
#pragma region Application Family or Desktop Family or OneCore Family
struct val_context {
    int valuelen;
    LPVOID value_context;
    LPVOID val_buff_ptr;
};
typedef struct val_context* PVALCONTEXT;
typedef struct pvalueA {
    LPSTR pv_valuename;
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
} PVALUEA, *PPVALUEA;
typedef struct pvalueW {
    LPWSTR pv_valuename;
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
} PVALUEW, *PPVALUEW;
typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;
typedef DWORD __cdecl QUERYHANDLER(LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
    LPVOID outputbuffer, DWORD* total_outlen, DWORD input_blen);
typedef QUERYHANDLER* PQUERYHANDLER;
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;
    LPVOID pi_key_context;
} REG_PROVIDER;
typedef struct provider_info* PPROVIDER;
typedef struct value_entA {
    LPSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
} VALENTA, *PVALENTA;
typedef struct value_entW {
    LPWSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
} VALENTW, *PVALENTW;
typedef VALENTW VALENT;
typedef PVALENTW PVALENT;
#pragma endregion
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegCloseKey(
        HKEY hKey);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegOverridePredefKey(
        HKEY hKey,
        HKEY hNewHKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenUserClassesRoot(
        HANDLE hToken,
        DWORD dwOptions,
        REGSAM samDesired,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenCurrentUser(
        REGSAM samDesired,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDisablePredefinedCache(
        void);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDisablePredefinedCacheEx(
        void);
__declspec(dllimport)
    LSTATUS
    __stdcall RegConnectRegistryA(
        LPCSTR lpMachineName,
        HKEY hKey,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegConnectRegistryW(
        LPCWSTR lpMachineName,
        HKEY hKey,
        PHKEY phkResult);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegConnectRegistryExA(
        LPCSTR lpMachineName,
        HKEY hKey,
        ULONG Flags,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegConnectRegistryExW(
        LPCWSTR lpMachineName,
        HKEY hKey,
        ULONG Flags,
        PHKEY phkResult);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegCreateKeyA(
        HKEY hKey,
        LPCSTR lpSubKey,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegCreateKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegCreateKeyExA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD Reserved,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition);
__declspec(dllimport)
    LSTATUS
    __stdcall RegCreateKeyExW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD Reserved,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegCreateKeyTransactedA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD Reserved,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        HANDLE hTransaction,
        PVOID pExtendedParemeter);
__declspec(dllimport)
    LSTATUS
    __stdcall RegCreateKeyTransactedW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD Reserved,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        HANDLE hTransaction,
        PVOID pExtendedParemeter);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyExA(
        HKEY hKey,
        LPCSTR lpSubKey,
        REGSAM samDesired,
        DWORD Reserved);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyExW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        REGSAM samDesired,
        DWORD Reserved);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyTransactedA(
        HKEY hKey,
        LPCSTR lpSubKey,
        REGSAM samDesired,
        DWORD Reserved,
        HANDLE hTransaction,
        PVOID pExtendedParameter);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyTransactedW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        REGSAM samDesired,
        DWORD Reserved,
        HANDLE hTransaction,
        PVOID pExtendedParameter);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    LONG
    __stdcall RegDisableReflectionKey(
        HKEY hBase);
__declspec(dllimport)
    LONG
    __stdcall RegEnableReflectionKey(
        HKEY hBase);
__declspec(dllimport)
    LONG
    __stdcall RegQueryReflectionKey(
        HKEY hBase,
        BOOL* bIsReflectionDisabled);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteValueA(
        HKEY hKey,
        LPCSTR lpValueName);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteValueW(
        HKEY hKey,
        LPCWSTR lpValueName);
__declspec(dllimport)
    LSTATUS
    __stdcall RegEnumKeyA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpName,
        DWORD cchName);
__declspec(dllimport)
    LSTATUS
    __stdcall RegEnumKeyW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpName,
        DWORD cchName);
__declspec(dllimport)
    LSTATUS
    __stdcall RegEnumKeyExA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpName,
        LPDWORD lpcchName,
        LPDWORD lpReserved,
        LPSTR lpClass,
        LPDWORD lpcchClass,
        PFILETIME lpftLastWriteTime);
__declspec(dllimport)
    LSTATUS
    __stdcall RegEnumKeyExW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpName,
        LPDWORD lpcchName,
        LPDWORD lpReserved,
        LPWSTR lpClass,
        LPDWORD lpcchClass,
        PFILETIME lpftLastWriteTime);
__declspec(dllimport)
    LSTATUS
    __stdcall RegEnumValueA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpValueName,
        LPDWORD lpcchValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegEnumValueW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpValueName,
        LPDWORD lpcchValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegFlushKey(
        HKEY hKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegGetKeySecurity(
        HKEY hKey,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        LPDWORD lpcbSecurityDescriptor);
__declspec(dllimport)
    LSTATUS
    __stdcall RegLoadKeyA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPCSTR lpFile);
__declspec(dllimport)
    LSTATUS
    __stdcall RegLoadKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpFile);
__declspec(dllimport)
    LSTATUS
    __stdcall RegNotifyChangeKeyValue(
        HKEY hKey,
        BOOL bWatchSubtree,
        DWORD dwNotifyFilter,
        HANDLE hEvent,
        BOOL fAsynchronous);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenKeyA(
        HKEY hKey,
        LPCSTR lpSubKey,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenKeyExA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD ulOptions,
        REGSAM samDesired,
        PHKEY phkResult);
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenKeyExW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD ulOptions,
        REGSAM samDesired,
        PHKEY phkResult);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenKeyTransactedA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD ulOptions,
        REGSAM samDesired,
        PHKEY phkResult,
        HANDLE hTransaction,
        PVOID pExtendedParemeter);
__declspec(dllimport)
    LSTATUS
    __stdcall RegOpenKeyTransactedW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD ulOptions,
        REGSAM samDesired,
        PHKEY phkResult,
        HANDLE hTransaction,
        PVOID pExtendedParemeter);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryInfoKeyA(
        HKEY hKey,
        LPSTR lpClass,
        LPDWORD lpcchClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime);
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryInfoKeyW(
        HKEY hKey,
        LPWSTR lpClass,
        LPDWORD lpcchClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpData,
        PLONG lpcbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpData,
        PLONG lpcbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryMultipleValuesA(
        HKEY hKey,
        PVALENTA val_list,
        DWORD num_vals,
        LPSTR lpValueBuf,
        LPDWORD ldwTotsize);
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryMultipleValuesW(
        HKEY hKey,
        PVALENTW val_list,
        DWORD num_vals,
        LPWSTR lpValueBuf,
        LPDWORD ldwTotsize);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryValueExA(
        HKEY hKey,
        LPCSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegQueryValueExW(
        HKEY hKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegReplaceKeyA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPCSTR lpNewFile,
        LPCSTR lpOldFile);
__declspec(dllimport)
    LSTATUS
    __stdcall RegReplaceKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpNewFile,
        LPCWSTR lpOldFile);
__declspec(dllimport)
    LSTATUS
    __stdcall RegRestoreKeyA(
        HKEY hKey,
        LPCSTR lpFile,
        DWORD dwFlags);
__declspec(dllimport)
    LSTATUS
    __stdcall RegRestoreKeyW(
        HKEY hKey,
        LPCWSTR lpFile,
        DWORD dwFlags);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegRenameKey(
        HKEY hKey,
        LPCWSTR lpSubKeyName,
        LPCWSTR lpNewKeyName);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegSaveKeyA(
        HKEY hKey,
        LPCSTR lpFile,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSaveKeyW(
        HKEY hKey,
        LPCWSTR lpFile,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetKeySecurity(
        HKEY hKey,
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurityDescriptor);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD dwType,
        LPCSTR lpData,
        DWORD cbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD dwType,
        LPCWSTR lpData,
        DWORD cbData);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetValueExA(
        HKEY hKey,
        LPCSTR lpValueName,
        DWORD Reserved,
        DWORD dwType,
        const BYTE* lpData,
        DWORD cbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetValueExW(
        HKEY hKey,
        LPCWSTR lpValueName,
        DWORD Reserved,
        DWORD dwType,
        const BYTE* lpData,
        DWORD cbData);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegUnLoadKeyA(
        HKEY hKey,
        LPCSTR lpSubKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegUnLoadKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPCSTR lpValueName);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteKeyValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetKeyValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPCSTR lpValueName,
        DWORD dwType,
        LPCVOID lpData,
        DWORD cbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSetKeyValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName,
        DWORD dwType,
        LPCVOID lpData,
        DWORD cbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteTreeA(
        HKEY hKey,
        LPCSTR lpSubKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegDeleteTreeW(
        HKEY hKey,
        LPCWSTR lpSubKey);
__declspec(dllimport)
    LSTATUS
    __stdcall RegCopyTreeA(
        HKEY hKeySrc,
        LPCSTR lpSubKey,
        HKEY hKeyDest);
__declspec(dllimport)
    LSTATUS
    __stdcall RegGetValueA(
        HKEY hkey,
        LPCSTR lpSubKey,
        LPCSTR lpValue,
        DWORD dwFlags,
        LPDWORD pdwType,
        PVOID pvData,
        LPDWORD pcbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegGetValueW(
        HKEY hkey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValue,
        DWORD dwFlags,
        LPDWORD pdwType,
        PVOID pvData,
        LPDWORD pcbData);
__declspec(dllimport)
    LSTATUS
    __stdcall RegCopyTreeW(
        HKEY hKeySrc,
        LPCWSTR lpSubKey,
        HKEY hKeyDest);
__declspec(dllimport)
    LSTATUS
    __stdcall RegLoadMUIStringA(
        HKEY hKey,
        LPCSTR pszValue,
        LPSTR pszOutBuf,
        DWORD cbOutBuf,
        LPDWORD pcbData,
        DWORD Flags,
        LPCSTR pszDirectory);
__declspec(dllimport)
    LSTATUS
    __stdcall RegLoadMUIStringW(
        HKEY hKey,
        LPCWSTR pszValue,
        LPWSTR pszOutBuf,
        DWORD cbOutBuf,
        LPDWORD pcbData,
        DWORD Flags,
        LPCWSTR pszDirectory);
__declspec(dllimport)
    LSTATUS
    __stdcall RegLoadAppKeyA(
        LPCSTR lpFile,
        PHKEY phkResult,
        REGSAM samDesired,
        DWORD dwOptions,
        DWORD Reserved);
__declspec(dllimport)
    LSTATUS
    __stdcall RegLoadAppKeyW(
        LPCWSTR lpFile,
        PHKEY phkResult,
        REGSAM samDesired,
        DWORD dwOptions,
        DWORD Reserved);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall InitiateSystemShutdownA(
        LPSTR lpMachineName,
        LPSTR lpMessage,
        DWORD dwTimeout,
        BOOL bForceAppsClosed,
        BOOL bRebootAfterShutdown);
__declspec(dllimport)
    BOOL
    __stdcall InitiateSystemShutdownW(
        LPWSTR lpMachineName,
        LPWSTR lpMessage,
        DWORD dwTimeout,
        BOOL bForceAppsClosed,
        BOOL bRebootAfterShutdown);
__declspec(dllimport)
    BOOL
    __stdcall AbortSystemShutdownA(
        LPSTR lpMachineName);
__declspec(dllimport)
    BOOL
    __stdcall AbortSystemShutdownW(
        LPWSTR lpMachineName);
#pragma once
#pragma region Desktop Family
#pragma endregion
__declspec(dllimport)
    BOOL
    __stdcall InitiateSystemShutdownExA(
        LPSTR lpMachineName,
        LPSTR lpMessage,
        DWORD dwTimeout,
        BOOL bForceAppsClosed,
        BOOL bRebootAfterShutdown,
        DWORD dwReason);
__declspec(dllimport)
    BOOL
    __stdcall InitiateSystemShutdownExW(
        LPWSTR lpMachineName,
        LPWSTR lpMessage,
        DWORD dwTimeout,
        BOOL bForceAppsClosed,
        BOOL bRebootAfterShutdown,
        DWORD dwReason);
__declspec(dllimport)
    DWORD
    __stdcall InitiateShutdownA(
        LPSTR lpMachineName,
        LPSTR lpMessage,
        DWORD dwGracePeriod,
        DWORD dwShutdownFlags,
        DWORD dwReason);
__declspec(dllimport)
    DWORD
    __stdcall InitiateShutdownW(
        LPWSTR lpMachineName,
        LPWSTR lpMessage,
        DWORD dwGracePeriod,
        DWORD dwShutdownFlags,
        DWORD dwReason);
__declspec(dllimport)
    DWORD
    __stdcall CheckForHiberboot(
        PBOOLEAN pHiberboot,
        BOOLEAN bClearFlag);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport)
    LSTATUS
    __stdcall RegSaveKeyExA(
        HKEY hKey,
        LPCSTR lpFile,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD Flags);
__declspec(dllimport)
    LSTATUS
    __stdcall RegSaveKeyExW(
        HKEY hKey,
        LPCWSTR lpFile,
        const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        DWORD Flags);
#pragma endregion
#pragma warning(pop)
}
#pragma once
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family or System Family
#pragma region Desktop Family or OneCore Family
#pragma endregion
typedef struct _NETRESOURCEA {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPSTR lpLocalName;
    LPSTR lpRemoteName;
    LPSTR lpComment;
    LPSTR lpProvider;
} NETRESOURCEA, *LPNETRESOURCEA;
typedef struct _NETRESOURCEW {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPWSTR lpLocalName;
    LPWSTR lpRemoteName;
    LPWSTR lpComment;
    LPWSTR lpProvider;
} NETRESOURCEW, *LPNETRESOURCEW;
typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;
DWORD __stdcall WNetAddConnectionA(
    LPCSTR lpRemoteName,
    LPCSTR lpPassword,
    LPCSTR lpLocalName);
DWORD __stdcall WNetAddConnectionW(
    LPCWSTR lpRemoteName,
    LPCWSTR lpPassword,
    LPCWSTR lpLocalName);
DWORD __stdcall WNetAddConnection2A(
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserName,
    DWORD dwFlags);
DWORD __stdcall WNetAddConnection2W(
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserName,
    DWORD dwFlags);
DWORD __stdcall WNetAddConnection3A(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserName,
    DWORD dwFlags);
DWORD __stdcall WNetAddConnection3W(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserName,
    DWORD dwFlags);
DWORD __stdcall WNetAddConnection4A(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    PVOID pAuthBuffer,
    DWORD cbAuthBuffer,
    DWORD dwFlags,
    PBYTE lpUseOptions,
    DWORD cbUseOptions);
DWORD __stdcall WNetAddConnection4W(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    PVOID pAuthBuffer,
    DWORD cbAuthBuffer,
    DWORD dwFlags,
    PBYTE lpUseOptions,
    DWORD cbUseOptions);
DWORD __stdcall WNetCancelConnectionA(
    LPCSTR lpName,
    BOOL fForce);
DWORD __stdcall WNetCancelConnectionW(
    LPCWSTR lpName,
    BOOL fForce);
DWORD __stdcall WNetCancelConnection2A(
    LPCSTR lpName,
    DWORD dwFlags,
    BOOL fForce);
DWORD __stdcall WNetCancelConnection2W(
    LPCWSTR lpName,
    DWORD dwFlags,
    BOOL fForce);
DWORD __stdcall WNetGetConnectionA(
    LPCSTR lpLocalName,
    LPSTR lpRemoteName,
    LPDWORD lpnLength);
DWORD __stdcall WNetGetConnectionW(
    LPCWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpnLength);
#pragma endregion
#pragma region Desktop Family
DWORD __stdcall WNetRestoreSingleConnectionW(
    HWND hwndParent,
    LPCWSTR lpDevice,
    BOOL fUseUI);
#pragma endregion
#pragma region Desktop Family or System Family
DWORD __stdcall WNetUseConnectionA(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserId,
    DWORD dwFlags,
    LPSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult);
DWORD __stdcall WNetUseConnectionW(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserId,
    DWORD dwFlags,
    LPWSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult);
DWORD __stdcall WNetUseConnection4A(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    PVOID pAuthBuffer,
    DWORD cbAuthBuffer,
    DWORD dwFlags,
    PBYTE lpUseOptions,
    DWORD cbUseOptions,
    LPSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult);
DWORD __stdcall WNetUseConnection4W(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    PVOID pAuthBuffer,
    DWORD cbAuthBuffer,
    DWORD dwFlags,
    PBYTE lpUseOptions,
    DWORD cbUseOptions,
    LPWSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult);
DWORD __stdcall WNetConnectionDialog(
    HWND hwnd,
    DWORD dwType);
DWORD __stdcall WNetDisconnectDialog(
    HWND hwnd,
    DWORD dwType);
typedef struct _CONNECTDLGSTRUCTA {
    DWORD cbStructure;
    HWND hwndOwner;
    LPNETRESOURCEA lpConnRes;
    DWORD dwFlags;
    DWORD dwDevNum;
} CONNECTDLGSTRUCTA, *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW {
    DWORD cbStructure;
    HWND hwndOwner;
    LPNETRESOURCEW lpConnRes;
    DWORD dwFlags;
    DWORD dwDevNum;
} CONNECTDLGSTRUCTW, *LPCONNECTDLGSTRUCTW;
typedef CONNECTDLGSTRUCTW CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTW LPCONNECTDLGSTRUCT;
DWORD __stdcall WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct);
DWORD __stdcall WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct);
typedef struct _DISCDLGSTRUCTA {
    DWORD cbStructure;
    HWND hwndOwner;
    LPSTR lpLocalName;
    LPSTR lpRemoteName;
    DWORD dwFlags;
} DISCDLGSTRUCTA, *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW {
    DWORD cbStructure;
    HWND hwndOwner;
    LPWSTR lpLocalName;
    LPWSTR lpRemoteName;
    DWORD dwFlags;
} DISCDLGSTRUCTW, *LPDISCDLGSTRUCTW;
typedef DISCDLGSTRUCTW DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTW LPDISCDLGSTRUCT;
DWORD __stdcall WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct);
DWORD __stdcall WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct);
DWORD __stdcall WNetOpenEnumA(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEA lpNetResource,
    LPHANDLE lphEnum);
DWORD __stdcall WNetOpenEnumW(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEW lpNetResource,
    LPHANDLE lphEnum);
DWORD __stdcall WNetEnumResourceA(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize);
DWORD __stdcall WNetEnumResourceW(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize);
DWORD __stdcall WNetCloseEnum(
    HANDLE hEnum);
DWORD __stdcall WNetGetResourceParentA(
    LPNETRESOURCEA lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer);
DWORD __stdcall WNetGetResourceParentW(
    LPNETRESOURCEW lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer);
DWORD __stdcall WNetGetResourceInformationA(
    LPNETRESOURCEA lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPSTR* lplpSystem);
DWORD __stdcall WNetGetResourceInformationW(
    LPNETRESOURCEW lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPWSTR* lplpSystem);
typedef struct _UNIVERSAL_NAME_INFOA {
    LPSTR lpUniversalName;
} UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct _UNIVERSAL_NAME_INFOW {
    LPWSTR lpUniversalName;
} UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;
typedef UNIVERSAL_NAME_INFOW UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOW LPUNIVERSAL_NAME_INFO;
typedef struct _REMOTE_NAME_INFOA {
    LPSTR lpUniversalName;
    LPSTR lpConnectionName;
    LPSTR lpRemainingPath;
} REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct _REMOTE_NAME_INFOW {
    LPWSTR lpUniversalName;
    LPWSTR lpConnectionName;
    LPWSTR lpRemainingPath;
} REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;
typedef REMOTE_NAME_INFOW REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOW LPREMOTE_NAME_INFO;
DWORD __stdcall WNetGetUniversalNameA(
    LPCSTR lpLocalPath,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize);
DWORD __stdcall WNetGetUniversalNameW(
    LPCWSTR lpLocalPath,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize);
DWORD __stdcall WNetGetUserA(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength);
DWORD __stdcall WNetGetUserW(
    LPCWSTR lpName,
    LPWSTR lpUserName,
    LPDWORD lpnLength);
DWORD __stdcall WNetGetProviderNameA(
    DWORD dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize);
DWORD __stdcall WNetGetProviderNameW(
    DWORD dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize);
typedef struct _NETINFOSTRUCT {
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT, *LPNETINFOSTRUCT;
DWORD __stdcall WNetGetNetworkInformationA(
    LPCSTR lpProvider,
    LPNETINFOSTRUCT lpNetInfoStruct);
DWORD __stdcall WNetGetNetworkInformationW(
    LPCWSTR lpProvider,
    LPNETINFOSTRUCT lpNetInfoStruct);
DWORD __stdcall WNetGetLastErrorA(
    LPDWORD lpError,
    LPSTR lpErrorBuf,
    DWORD nErrorBufSize,
    LPSTR lpNameBuf,
    DWORD nNameBufSize);
DWORD __stdcall WNetGetLastErrorW(
    LPDWORD lpError,
    LPWSTR lpErrorBuf,
    DWORD nErrorBufSize,
    LPWSTR lpNameBuf,
    DWORD nNameBufSize);
typedef struct _NETCONNECTINFOSTRUCT {
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT, *LPNETCONNECTINFOSTRUCT;
DWORD __stdcall MultinetGetConnectionPerformanceA(
    LPNETRESOURCEA lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct);
DWORD __stdcall MultinetGetConnectionPerformanceW(
    LPNETRESOURCEW lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct);
#pragma endregion
#pragma warning(pop)
}
extern "C" {
#pragma region Desktop Family
#pragma warning(push)
#pragma warning(disable : 4127)
LPUWSTR
__stdcall uaw_CharUpperW(
    LPUWSTR String);
int __stdcall uaw_lstrcmpW(
    PCUWSTR String1,
    PCUWSTR String2);
int __stdcall uaw_lstrcmpiW(
    PCUWSTR String1,
    PCUWSTR String2);
int __stdcall uaw_lstrlenW(
    LPCUWSTR String);
PUWSTR
__cdecl uaw_wcschr(
    PCUWSTR String,
    WCHAR Character);
PUWSTR
__cdecl uaw_wcscpy(
    PUWSTR Destination,
    PCUWSTR Source);
int __cdecl uaw_wcsicmp(
    PCUWSTR String1,
    PCUWSTR String2);
size_t __cdecl uaw_wcslen(
    PCUWSTR String);
PUWSTR
__cdecl uaw_wcsrchr(
    PCUWSTR String,
    WCHAR Character);
__inline LPUWSTR static ua_CharUpperW(
    LPUWSTR String)
{
    if (1) {
        return CharUpperW((PWSTR)String);
    } else {
        return uaw_CharUpperW(String);
    }
}
__inline int static ua_lstrcmpW(
    LPCUWSTR String1,
    LPCUWSTR String2)
{
    if (1 && 1) {
        return lstrcmpW((LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpW(String1, String2);
    }
}
__inline int static ua_lstrcmpiW(
    LPCUWSTR String1,
    LPCUWSTR String2)
{
    if (1 && 1) {
        return lstrcmpiW((LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpiW(String1, String2);
    }
}
__inline int static ua_lstrlenW(
    LPCUWSTR String)
{
    if (1) {
#pragma warning(suppress : 28750)
        return lstrlenW((PCWSTR)String);
    } else {
        return uaw_lstrlenW(String);
    }
}
typedef const WCHAR __unaligned* PUWSTR_C;
__inline PUWSTR_C static ua_wcschr(
    PCUWSTR String,
    WCHAR Character)
{
    if (1) {
        return wcschr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcschr(String, Character);
    }
}
__inline PUWSTR_C static ua_wcsrchr(
    PCUWSTR String,
    WCHAR Character)
{
    if (1) {
        return wcsrchr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcsrchr(String, Character);
    }
}
__inline PUWSTR static __declspec(deprecated)
    ua_wcscpy(
        PUWSTR Destination,
        PCUWSTR Source)
{
    if (1 && 1) {
#pragma warning(push)
#pragma warning(disable : 4995)
#pragma warning(disable : 4996)
        return wcscpy((PWSTR)Destination, (PCWSTR)Source);
#pragma warning(pop)
    } else {
        return uaw_wcscpy(Destination, Source);
    }
}
__inline PUWSTR static ua_wcscpy_s(
    PUWSTR Destination,
    size_t DestinationSize,
    PCUWSTR Source)
{
    if (1 && 1) {
        return (wcscpy_s((PWSTR)Destination, DestinationSize, (PCWSTR)Source) == 0 ? Destination : 0);
    } else {
        return uaw_wcscpy(Destination, Source);
    }
}
__inline size_t static ua_wcslen(
    PCUWSTR String)
{
    if (1) {
        return wcslen((PCWSTR)String);
    } else {
        return uaw_wcslen(String);
    }
}
__inline int static ua_wcsicmp(
    PCUWSTR String1,
    PCUWSTR String2)
{
    if (1 && 1) {
        return _wcsicmp((LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_wcsicmp(String1, String2);
    }
}
#pragma warning(pop)
#pragma endregion
}
#pragma warning(push)
#pragma warning(disable : 4820)
extern "C" {
#pragma region Desktop Family or OneCore Family
extern "C" const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID;
extern "C" const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID;
extern "C" const GUID DOMAIN_JOIN_GUID;
extern "C" const GUID DOMAIN_LEAVE_GUID;
extern "C" const GUID FIREWALL_PORT_OPEN_GUID;
extern "C" const GUID FIREWALL_PORT_CLOSE_GUID;
extern "C" const GUID MACHINE_POLICY_PRESENT_GUID;
extern "C" const GUID USER_POLICY_PRESENT_GUID;
extern "C" const GUID RPC_INTERFACE_EVENT_GUID;
extern "C" const GUID NAMED_PIPE_EVENT_GUID;
extern "C" const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID;
typedef struct
{
    DWORD Data[2];
} SERVICE_TRIGGER_CUSTOM_STATE_ID;
typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
    union {
        SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
        struct {
            DWORD DataOffset;
            BYTE Data[1];
        } s;
    } u;
} SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM, *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;
typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;
typedef SERVICE_DESCRIPTIONW SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONW LPSERVICE_DESCRIPTION;
typedef enum _SC_ACTION_TYPE {
    SC_ACTION_NONE = 0,
    SC_ACTION_RESTART = 1,
    SC_ACTION_REBOOT = 2,
    SC_ACTION_RUN_COMMAND = 3,
    SC_ACTION_OWN_RESTART = 4
} SC_ACTION_TYPE;
typedef struct _SC_ACTION {
    SC_ACTION_TYPE Type;
    DWORD Delay;
} SC_ACTION, *LPSC_ACTION;
typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD dwResetPeriod;
    LPSTR lpRebootMsg;
    LPSTR lpCommand;
    DWORD cActions;
    SC_ACTION* lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD dwResetPeriod;
    LPWSTR lpRebootMsg;
    LPWSTR lpCommand;
    DWORD cActions;
    SC_ACTION* lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;
typedef SERVICE_FAILURE_ACTIONSW SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSW LPSERVICE_FAILURE_ACTIONS;
typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL fDelayedAutostart;
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;
typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL fFailureActionsOnNonCrashFailures;
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;
typedef struct _SERVICE_SID_INFO {
    DWORD dwServiceSidType;
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR pmszRequiredPrivileges;
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR pmszRequiredPrivileges;
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;
typedef SERVICE_REQUIRED_PRIVILEGES_INFOW SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOW LPSERVICE_REQUIRED_PRIVILEGES_INFO;
typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD dwPreshutdownTimeout;
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;
typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
    DWORD dwDataType;
    DWORD cbData;
    PBYTE pData;
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
typedef struct _SERVICE_TRIGGER {
    DWORD dwTriggerType;
    DWORD dwAction;
    GUID* pTriggerSubtype;
    DWORD cDataItems;
    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM pDataItems;
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;
typedef struct _SERVICE_TRIGGER_INFO {
    DWORD cTriggers;
    PSERVICE_TRIGGER pTriggers;
    PBYTE pReserved;
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;
typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT usPreferredNode;
    BOOLEAN fDelete;
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;
typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER liNewTime;
    LARGE_INTEGER liOldTime;
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;
typedef struct _SERVICE_LAUNCH_PROTECTED_INFO {
    DWORD dwLaunchProtected;
} SERVICE_LAUNCH_PROTECTED_INFO, *PSERVICE_LAUNCH_PROTECTED_INFO;
struct SC_HANDLE__ {
    int unused;
};
typedef struct SC_HANDLE__* SC_HANDLE;
typedef SC_HANDLE* LPSC_HANDLE;
struct SERVICE_STATUS_HANDLE__ {
    int unused;
};
typedef struct SERVICE_STATUS_HANDLE__* SERVICE_STATUS_HANDLE;
typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO = 0
} SC_STATUS_TYPE;
typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO = 0
} SC_ENUM_TYPE;
typedef struct _SERVICE_STATUS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;
typedef struct _SERVICE_STATUS_PROCESS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
    DWORD dwProcessId;
    DWORD dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;
typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR lpServiceName;
    LPSTR lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR lpServiceName;
    LPWSTR lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
typedef ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSW LPENUM_SERVICE_STATUS;
typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR lpServiceName;
    LPSTR lpDisplayName;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR lpServiceName;
    LPWSTR lpDisplayName;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;
typedef ENUM_SERVICE_STATUS_PROCESSW ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSW LPENUM_SERVICE_STATUS_PROCESS;
typedef LPVOID SC_LOCK;
typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD fIsLocked;
    LPSTR lpLockOwner;
    DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD fIsLocked;
    LPWSTR lpLockOwner;
    DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
typedef QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSW LPQUERY_SERVICE_LOCK_STATUS;
typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPSTR lpBinaryPathName;
    LPSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPSTR lpDependencies;
    LPSTR lpServiceStartName;
    LPSTR lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPWSTR lpBinaryPathName;
    LPWSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPWSTR lpDependencies;
    LPWSTR lpServiceStartName;
    LPWSTR lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
typedef QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGW LPQUERY_SERVICE_CONFIG;
typedef void __stdcall SERVICE_MAIN_FUNCTIONW(
    DWORD dwNumServicesArgs,
    LPWSTR* lpServiceArgVectors);
typedef void __stdcall SERVICE_MAIN_FUNCTIONA(
    DWORD dwNumServicesArgs,
    LPTSTR* lpServiceArgVectors);
typedef void(__stdcall* LPSERVICE_MAIN_FUNCTIONW)(
    DWORD dwNumServicesArgs,
    LPWSTR* lpServiceArgVectors);
typedef void(__stdcall* LPSERVICE_MAIN_FUNCTIONA)(
    DWORD dwNumServicesArgs,
    LPSTR* lpServiceArgVectors);
typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
} SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
} SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
typedef SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYW LPSERVICE_TABLE_ENTRY;
typedef void __stdcall HANDLER_FUNCTION(
    DWORD dwControl);
typedef DWORD __stdcall HANDLER_FUNCTION_EX(
    DWORD dwControl,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpContext);
typedef void(__stdcall* LPHANDLER_FUNCTION)(
    DWORD dwControl);
typedef DWORD(__stdcall* LPHANDLER_FUNCTION_EX)(
    DWORD dwControl,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpContext);
typedef void(__stdcall* PFN_SC_NOTIFY_CALLBACK)(
    PVOID pParameter);
typedef struct _SERVICE_NOTIFY_1 {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;
typedef struct _SERVICE_NOTIFY_2A {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationTriggered;
    LPSTR pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationTriggered;
    LPWSTR pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2W PSERVICE_NOTIFY_2;
typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;
typedef SERVICE_NOTIFYW SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYW PSERVICE_NOTIFY;
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD dwReason;
    LPSTR pszComment;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD dwReason;
    LPWSTR pszComment;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;
typedef SERVICE_CONTROL_STATUS_REASON_PARAMSW SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSW PSERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef struct _SERVICE_START_REASON {
    DWORD dwReason;
} SERVICE_START_REASON, *PSERVICE_START_REASON;
__declspec(dllimport)
    BOOL
    __stdcall ChangeServiceConfigA(
        SC_HANDLE hService,
        DWORD dwServiceType,
        DWORD dwStartType,
        DWORD dwErrorControl,
        LPCSTR lpBinaryPathName,
        LPCSTR lpLoadOrderGroup,
        LPDWORD lpdwTagId,
        LPCSTR lpDependencies,
        LPCSTR lpServiceStartName,
        LPCSTR lpPassword,
        LPCSTR lpDisplayName);
__declspec(dllimport)
    BOOL
    __stdcall ChangeServiceConfigW(
        SC_HANDLE hService,
        DWORD dwServiceType,
        DWORD dwStartType,
        DWORD dwErrorControl,
        LPCWSTR lpBinaryPathName,
        LPCWSTR lpLoadOrderGroup,
        LPDWORD lpdwTagId,
        LPCWSTR lpDependencies,
        LPCWSTR lpServiceStartName,
        LPCWSTR lpPassword,
        LPCWSTR lpDisplayName);
__declspec(dllimport)
    BOOL
    __stdcall ChangeServiceConfig2A(
        SC_HANDLE hService,
        DWORD dwInfoLevel,
        LPVOID lpInfo);
__declspec(dllimport)
    BOOL
    __stdcall ChangeServiceConfig2W(
        SC_HANDLE hService,
        DWORD dwInfoLevel,
        LPVOID lpInfo);
__declspec(dllimport)
    BOOL
    __stdcall CloseServiceHandle(
        SC_HANDLE hSCObject);
__declspec(dllimport)
    BOOL
    __stdcall ControlService(
        SC_HANDLE hService,
        DWORD dwControl,
        LPSERVICE_STATUS lpServiceStatus);
__declspec(dllimport)
    SC_HANDLE
    __stdcall CreateServiceA(
        SC_HANDLE hSCManager,
        LPCSTR lpServiceName,
        LPCSTR lpDisplayName,
        DWORD dwDesiredAccess,
        DWORD dwServiceType,
        DWORD dwStartType,
        DWORD dwErrorControl,
        LPCSTR lpBinaryPathName,
        LPCSTR lpLoadOrderGroup,
        LPDWORD lpdwTagId,
        LPCSTR lpDependencies,
        LPCSTR lpServiceStartName,
        LPCSTR lpPassword);
__declspec(dllimport)
    SC_HANDLE
    __stdcall CreateServiceW(
        SC_HANDLE hSCManager,
        LPCWSTR lpServiceName,
        LPCWSTR lpDisplayName,
        DWORD dwDesiredAccess,
        DWORD dwServiceType,
        DWORD dwStartType,
        DWORD dwErrorControl,
        LPCWSTR lpBinaryPathName,
        LPCWSTR lpLoadOrderGroup,
        LPDWORD lpdwTagId,
        LPCWSTR lpDependencies,
        LPCWSTR lpServiceStartName,
        LPCWSTR lpPassword);
__declspec(dllimport)
    BOOL
    __stdcall DeleteService(
        SC_HANDLE hService);
__declspec(dllimport)
    BOOL
    __stdcall EnumDependentServicesA(
        SC_HANDLE hService,
        DWORD dwServiceState,
        LPENUM_SERVICE_STATUSA lpServices,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded,
        LPDWORD lpServicesReturned);
__declspec(dllimport)
    BOOL
    __stdcall EnumDependentServicesW(
        SC_HANDLE hService,
        DWORD dwServiceState,
        LPENUM_SERVICE_STATUSW lpServices,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded,
        LPDWORD lpServicesReturned);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall EnumServicesStatusA(
        SC_HANDLE hSCManager,
        DWORD dwServiceType,
        DWORD dwServiceState,
        LPENUM_SERVICE_STATUSA lpServices,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded,
        LPDWORD lpServicesReturned,
        LPDWORD lpResumeHandle);
__declspec(dllimport)
    BOOL
    __stdcall EnumServicesStatusW(
        SC_HANDLE hSCManager,
        DWORD dwServiceType,
        DWORD dwServiceState,
        LPENUM_SERVICE_STATUSW lpServices,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded,
        LPDWORD lpServicesReturned,
        LPDWORD lpResumeHandle);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall EnumServicesStatusExA(
        SC_HANDLE hSCManager,
        SC_ENUM_TYPE InfoLevel,
        DWORD dwServiceType,
        DWORD dwServiceState,
        LPBYTE lpServices,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded,
        LPDWORD lpServicesReturned,
        LPDWORD lpResumeHandle,
        LPCSTR pszGroupName);
__declspec(dllimport)
    BOOL
    __stdcall EnumServicesStatusExW(
        SC_HANDLE hSCManager,
        SC_ENUM_TYPE InfoLevel,
        DWORD dwServiceType,
        DWORD dwServiceState,
        LPBYTE lpServices,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded,
        LPDWORD lpServicesReturned,
        LPDWORD lpResumeHandle,
        LPCWSTR pszGroupName);
__declspec(dllimport)
    BOOL
    __stdcall GetServiceKeyNameA(
        SC_HANDLE hSCManager,
        LPCSTR lpDisplayName,
        LPSTR lpServiceName,
        LPDWORD lpcchBuffer);
__declspec(dllimport)
    BOOL
    __stdcall GetServiceKeyNameW(
        SC_HANDLE hSCManager,
        LPCWSTR lpDisplayName,
        LPWSTR lpServiceName,
        LPDWORD lpcchBuffer);
__declspec(dllimport)
    BOOL
    __stdcall GetServiceDisplayNameA(
        SC_HANDLE hSCManager,
        LPCSTR lpServiceName,
        LPSTR lpDisplayName,
        LPDWORD lpcchBuffer);
__declspec(dllimport)
    BOOL
    __stdcall GetServiceDisplayNameW(
        SC_HANDLE hSCManager,
        LPCWSTR lpServiceName,
        LPWSTR lpDisplayName,
        LPDWORD lpcchBuffer);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    SC_LOCK
    __stdcall LockServiceDatabase(
        SC_HANDLE hSCManager);
__declspec(dllimport)
    BOOL
    __stdcall NotifyBootConfigStatus(
        BOOL BootAcceptable);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    SC_HANDLE
    __stdcall OpenSCManagerA(
        LPCSTR lpMachineName,
        LPCSTR lpDatabaseName,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    SC_HANDLE
    __stdcall OpenSCManagerW(
        LPCWSTR lpMachineName,
        LPCWSTR lpDatabaseName,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    SC_HANDLE
    __stdcall OpenServiceA(
        SC_HANDLE hSCManager,
        LPCSTR lpServiceName,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    SC_HANDLE
    __stdcall OpenServiceW(
        SC_HANDLE hSCManager,
        LPCWSTR lpServiceName,
        DWORD dwDesiredAccess);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceConfigA(
        SC_HANDLE hService,
        LPQUERY_SERVICE_CONFIGA lpServiceConfig,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceConfigW(
        SC_HANDLE hService,
        LPQUERY_SERVICE_CONFIGW lpServiceConfig,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceConfig2A(
        SC_HANDLE hService,
        DWORD dwInfoLevel,
        LPBYTE lpBuffer,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceConfig2W(
        SC_HANDLE hService,
        DWORD dwInfoLevel,
        LPBYTE lpBuffer,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceLockStatusA(
        SC_HANDLE hSCManager,
        LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceLockStatusW(
        SC_HANDLE hSCManager,
        LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceObjectSecurity(
        SC_HANDLE hService,
        SECURITY_INFORMATION dwSecurityInformation,
        PSECURITY_DESCRIPTOR lpSecurityDescriptor,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceStatus(
        SC_HANDLE hService,
        LPSERVICE_STATUS lpServiceStatus);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceStatusEx(
        SC_HANDLE hService,
        SC_STATUS_TYPE InfoLevel,
        LPBYTE lpBuffer,
        DWORD cbBufSize,
        LPDWORD pcbBytesNeeded);
__declspec(dllimport)
    SERVICE_STATUS_HANDLE
    __stdcall RegisterServiceCtrlHandlerA(
        LPCSTR lpServiceName,
        LPHANDLER_FUNCTION lpHandlerProc);
__declspec(dllimport)
    SERVICE_STATUS_HANDLE
    __stdcall RegisterServiceCtrlHandlerW(
        LPCWSTR lpServiceName,
        LPHANDLER_FUNCTION lpHandlerProc);
__declspec(dllimport)
    SERVICE_STATUS_HANDLE
    __stdcall RegisterServiceCtrlHandlerExA(
        LPCSTR lpServiceName,
        LPHANDLER_FUNCTION_EX lpHandlerProc,
        LPVOID lpContext);
__declspec(dllimport)
    SERVICE_STATUS_HANDLE
    __stdcall RegisterServiceCtrlHandlerExW(
        LPCWSTR lpServiceName,
        LPHANDLER_FUNCTION_EX lpHandlerProc,
        LPVOID lpContext);
__declspec(dllimport)
    BOOL
    __stdcall SetServiceObjectSecurity(
        SC_HANDLE hService,
        SECURITY_INFORMATION dwSecurityInformation,
        PSECURITY_DESCRIPTOR lpSecurityDescriptor);
__declspec(dllimport)
    BOOL
    __stdcall SetServiceStatus(
        SERVICE_STATUS_HANDLE hServiceStatus,
        LPSERVICE_STATUS lpServiceStatus);
__declspec(dllimport)
    BOOL
    __stdcall StartServiceCtrlDispatcherA(
        const SERVICE_TABLE_ENTRYA* lpServiceStartTable);
__declspec(dllimport)
    BOOL
    __stdcall StartServiceCtrlDispatcherW(
        const SERVICE_TABLE_ENTRYW* lpServiceStartTable);
__declspec(dllimport)
    BOOL
    __stdcall StartServiceA(
        SC_HANDLE hService,
        DWORD dwNumServiceArgs,
        LPCSTR* lpServiceArgVectors);
__declspec(dllimport)
    BOOL
    __stdcall StartServiceW(
        SC_HANDLE hService,
        DWORD dwNumServiceArgs,
        LPCWSTR* lpServiceArgVectors);
#pragma endregion
#pragma region Desktop Family
__declspec(dllimport)
    BOOL
    __stdcall UnlockServiceDatabase(
        SC_LOCK ScLock);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport)
    DWORD
    __stdcall NotifyServiceStatusChangeA(
        SC_HANDLE hService,
        DWORD dwNotifyMask,
        PSERVICE_NOTIFYA pNotifyBuffer);
__declspec(dllimport)
    DWORD
    __stdcall NotifyServiceStatusChangeW(
        SC_HANDLE hService,
        DWORD dwNotifyMask,
        PSERVICE_NOTIFYW pNotifyBuffer);
__declspec(dllimport)
    BOOL
    __stdcall ControlServiceExA(
        SC_HANDLE hService,
        DWORD dwControl,
        DWORD dwInfoLevel,
        PVOID pControlParams);
__declspec(dllimport)
    BOOL
    __stdcall ControlServiceExW(
        SC_HANDLE hService,
        DWORD dwControl,
        DWORD dwInfoLevel,
        PVOID pControlParams);
__declspec(dllimport)
    BOOL
    __stdcall QueryServiceDynamicInformation(
        SERVICE_STATUS_HANDLE hServiceStatus,
        DWORD dwInfoLevel,
        PVOID* ppDynamicInfo);
typedef enum _SC_EVENT_TYPE {
    SC_EVENT_DATABASE_CHANGE,
    SC_EVENT_PROPERTY_CHANGE,
    SC_EVENT_STATUS_CHANGE
} SC_EVENT_TYPE,
    *PSC_EVENT_TYPE;
typedef void __stdcall SC_NOTIFICATION_CALLBACK(
    DWORD dwNotify,
    PVOID pCallbackContext);
typedef SC_NOTIFICATION_CALLBACK* PSC_NOTIFICATION_CALLBACK;
typedef struct _SC_NOTIFICATION_REGISTRATION* PSC_NOTIFICATION_REGISTRATION;
__declspec(dllimport)
    DWORD
    __stdcall SubscribeServiceChangeNotifications(
        SC_HANDLE hService,
        SC_EVENT_TYPE eEventType,
        PSC_NOTIFICATION_CALLBACK pCallback,
        PVOID pCallbackContext,
        PSC_NOTIFICATION_REGISTRATION* pSubscription);
__declspec(dllimport) void __stdcall UnsubscribeServiceChangeNotifications(
    PSC_NOTIFICATION_REGISTRATION pSubscription);
__declspec(dllimport)
    DWORD
    __stdcall WaitServiceState(
        SC_HANDLE hService,
        DWORD dwNotify,
        DWORD dwTimeout,
        HANDLE hCancelEvent);
typedef enum SERVICE_REGISTRY_STATE_TYPE {
    ServiceRegistryStateParameters = 0,
    ServiceRegistryStatePersistent = 1,
    MaxServiceRegistryStateType = 2,
} SERVICE_REGISTRY_STATE_TYPE;
DWORD
__stdcall GetServiceRegistryStateKey(
    SERVICE_STATUS_HANDLE ServiceStatusHandle,
    SERVICE_REGISTRY_STATE_TYPE StateType,
    DWORD AccessMask,
    HKEY* ServiceStateKey);
typedef enum SERVICE_DIRECTORY_TYPE {
    ServiceDirectoryPersistentState = 0,
    ServiceDirectoryTypeMax = 1,
} SERVICE_DIRECTORY_TYPE;
DWORD
__stdcall GetServiceDirectory(
    SERVICE_STATUS_HANDLE hServiceStatus,
    SERVICE_DIRECTORY_TYPE eDirectoryType,
    PWCHAR lpPathBuffer,
    DWORD cchPathBufferLength,
    DWORD* lpcchRequiredBufferLength);
typedef enum SERVICE_SHARED_REGISTRY_STATE_TYPE {
    ServiceSharedRegistryPersistentState = 0
} SERVICE_SHARED_REGISTRY_STATE_TYPE;
DWORD
__stdcall GetSharedServiceRegistryStateKey(
    SC_HANDLE ServiceHandle,
    SERVICE_SHARED_REGISTRY_STATE_TYPE StateType,
    DWORD AccessMask,
    HKEY* ServiceStateKey);
typedef enum SERVICE_SHARED_DIRECTORY_TYPE {
    ServiceSharedDirectoryPersistentState = 0
} SERVICE_SHARED_DIRECTORY_TYPE;
DWORD
__stdcall GetSharedServiceDirectory(
    SC_HANDLE ServiceHandle,
    SERVICE_SHARED_DIRECTORY_TYPE DirectoryType,
    PWCHAR PathBuffer,
    DWORD PathBufferLength,
    DWORD* RequiredBufferLength);
#pragma endregion
}
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
typedef struct _MODEMDEVCAPS {
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;
    DWORD dwModemProviderVersion;
    DWORD dwModemManufacturerOffset;
    DWORD dwModemManufacturerSize;
    DWORD dwModemModelOffset;
    DWORD dwModemModelSize;
    DWORD dwModemVersionOffset;
    DWORD dwModemVersionSize;
    DWORD dwDialOptions;
    DWORD dwCallSetupFailTimer;
    DWORD dwInactivityTimeout;
    DWORD dwSpeakerVolume;
    DWORD dwSpeakerMode;
    DWORD dwModemOptions;
    DWORD dwMaxDTERate;
    DWORD dwMaxDCERate;
    BYTE abVariablePortion[1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;
typedef struct _MODEMSETTINGS {
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;
    DWORD dwCallSetupFailTimer;
    DWORD dwInactivityTimeout;
    DWORD dwSpeakerVolume;
    DWORD dwSpeakerMode;
    DWORD dwPreferredModemOptions;
    DWORD dwNegotiatedModemOptions;
    DWORD dwNegotiatedDCERate;
    BYTE abVariablePortion[1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;
#pragma warning(pop)
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Application Family
struct HIMC__ {
    int unused;
};
typedef struct HIMC__* HIMC;
struct HIMCC__ {
    int unused;
};
typedef struct HIMCC__* HIMCC;
#pragma endregion
#pragma region Desktop Family
typedef HKL* LPHKL;
typedef UINT* LPUINT;
#pragma endregion
#pragma region Application Family
typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, *NPCOMPOSITIONFORM, *LPCOMPOSITIONFORM;
typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, *NPCANDIDATEFORM, *LPCANDIDATEFORM;
#pragma endregion
#pragma region Desktop Family
typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, *NPCANDIDATELIST, *LPCANDIDATELIST;
#pragma endregion
#pragma region Application Family
typedef struct tagREGISTERWORDA {
    LPSTR lpReading;
    LPSTR lpWord;
} REGISTERWORDA, *PREGISTERWORDA, *NPREGISTERWORDA, *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR lpReading;
    LPWSTR lpWord;
} REGISTERWORDW, *PREGISTERWORDW, *NPREGISTERWORDW, *LPREGISTERWORDW;
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#pragma endregion
#pragma region Desktop Family
typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, *NPRECONVERTSTRING, *LPRECONVERTSTRING;
#pragma endregion
#pragma region Application Family
typedef struct tagSTYLEBUFA {
    DWORD dwStyle;
    CHAR szDescription[32];
} STYLEBUFA, *PSTYLEBUFA, *NPSTYLEBUFA, *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD dwStyle;
    WCHAR szDescription[32];
} STYLEBUFW, *PSTYLEBUFW, *NPSTYLEBUFW, *LPSTYLEBUFW;
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#pragma endregion
#pragma region Desktop Family
typedef struct tagIMEMENUITEMINFOA {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[80];
    HBITMAP hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, *NPIMEMENUITEMINFOA, *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[80];
    HBITMAP hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, *NPIMEMENUITEMINFOW, *LPIMEMENUITEMINFOW;
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
typedef struct tagIMECHARPOSITION {
    DWORD dwSize;
    DWORD dwCharPos;
    POINT pt;
    UINT cLineHeight;
    RECT rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, *NPIMECHARPOSITION, *LPIMECHARPOSITION;
typedef BOOL(__stdcall* IMCENUMPROC)(HIMC, LPARAM);
#pragma endregion
#pragma region Desktop Family
HKL __stdcall ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL __stdcall ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
HWND __stdcall ImmGetDefaultIMEWnd(HWND);
UINT __stdcall ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen);
UINT __stdcall ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen);
UINT __stdcall ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen);
UINT __stdcall ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen);
DWORD __stdcall ImmGetProperty(HKL, DWORD);
BOOL __stdcall ImmIsIME(HKL);
BOOL __stdcall ImmSimulateHotKey(HWND, DWORD);
HIMC __stdcall ImmCreateContext(void);
BOOL __stdcall ImmDestroyContext(HIMC);
HIMC __stdcall ImmGetContext(HWND);
BOOL __stdcall ImmReleaseContext(HWND, HIMC);
HIMC __stdcall ImmAssociateContext(HWND, HIMC);
BOOL __stdcall ImmAssociateContextEx(HWND, HIMC, DWORD);
LONG __stdcall ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
LONG __stdcall ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
BOOL __stdcall ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
BOOL __stdcall ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
DWORD __stdcall ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount);
DWORD __stdcall ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);
DWORD __stdcall ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);
DWORD __stdcall ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);
DWORD __stdcall ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen);
DWORD __stdcall ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen);
BOOL __stdcall ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence);
BOOL __stdcall ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL __stdcall ImmGetOpenStatus(HIMC);
BOOL __stdcall ImmSetOpenStatus(HIMC, BOOL);
BOOL __stdcall ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf);
BOOL __stdcall ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf);
BOOL __stdcall ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf);
BOOL __stdcall ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf);
BOOL __stdcall ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL __stdcall ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
LRESULT __stdcall ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT __stdcall ImmEscapeW(HKL, HIMC, UINT, LPVOID);
DWORD __stdcall ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);
DWORD __stdcall ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);
BOOL __stdcall ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
BOOL __stdcall ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos);
BOOL __stdcall ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos);
BOOL __stdcall ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate);
BOOL __stdcall ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate);
BOOL __stdcall ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL __stdcall ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
UINT __stdcall ImmGetVirtualKey(HWND);
typedef int(__stdcall* REGISTERWORDENUMPROCA)(LPCSTR lpszReading, DWORD, LPCSTR lpszString, LPVOID);
typedef int(__stdcall* REGISTERWORDENUMPROCW)(LPCWSTR lpszReading, DWORD, LPCWSTR lpszString, LPVOID);
BOOL __stdcall ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
BOOL __stdcall ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
BOOL __stdcall ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
BOOL __stdcall ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
UINT __stdcall ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
UINT __stdcall ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);
UINT __stdcall ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
UINT __stdcall ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);
BOOL __stdcall ImmDisableIME(DWORD);
BOOL __stdcall ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD __stdcall ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize);
DWORD __stdcall ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize);
BOOL __stdcall ImmDisableTextFrameService(DWORD idThread);
BOOL __stdcall ImmDisableLegacyIME(void);
#pragma endregion
#pragma once
#pragma warning(pop)
}
#pragma warning(pop)
#pragma endregion
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    typedef struct _iobuf {
        void* _Placeholder;
    } FILE;
    __declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);
    __declspec(dllimport) wint_t __cdecl fgetwc(
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);
    __declspec(dllimport) wint_t __cdecl fputwc(
        wchar_t _Character,
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl _fputwchar(
        wchar_t _Character);
    __declspec(dllimport) wint_t __cdecl getwc(
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl getwchar(void);
    __declspec(dllimport) wchar_t* __cdecl fgetws(
        wchar_t * _Buffer,
        int _BufferCount,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl fputws(
        wchar_t const* _Buffer,
        FILE* _Stream);
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
        wchar_t * _Buffer,
        size_t _BufferCount);
    extern "C++" {
    template <size_t _Size>
    inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); }
    }
    __declspec(dllimport) wint_t __cdecl putwc(
        wchar_t _Character,
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl putwchar(
        wchar_t _Character);
    __declspec(dllimport) int __cdecl _putws(
        wchar_t const* _Buffer);
    __declspec(dllimport) wint_t __cdecl ungetwc(
        wint_t _Character,
        FILE * _Stream);
    __declspec(dllimport) FILE* __cdecl _wfdopen(
        int _FileHandle,
        wchar_t const* _Mode);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wfopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) FILE* __cdecl _wfopen(wchar_t const* _FileName,
        wchar_t const* _Mode);
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
        FILE * *_Stream,
        wchar_t const* _FileName,
        wchar_t const* _Mode);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wfreopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) FILE* __cdecl _wfreopen(wchar_t const* _FileName,
        wchar_t const* _Mode,
        FILE* _OldStream);
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
        FILE * *_Stream,
        wchar_t const* _FileName,
        wchar_t const* _Mode,
        FILE* _OldStream);
    __declspec(dllimport) FILE* __cdecl _wfsopen(
        wchar_t const* _FileName,
        wchar_t const* _Mode,
        int _ShFlag);
    __declspec(dllimport) void __cdecl _wperror(
        wchar_t const* _ErrorMessage);
    __declspec(dllimport) FILE* __cdecl _wpopen(
        wchar_t const* _Command,
        wchar_t const* _Mode);
    __declspec(dllimport) int __cdecl _wremove(
        wchar_t const* _FileName);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
        wchar_t const* _Directory,
        wchar_t const* _FilePrefix);
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
        wchar_t * _Buffer,
        size_t _BufferCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wtmpnam_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wtmpnam(wchar_t * _Buffer);
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
        wchar_t _Character,
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
        wchar_t _Character,
        FILE * _Stream);
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
        wint_t _Character,
        FILE * _Stream);
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __inline int __cdecl _vfwprintf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfwprintf(
        FILE* const _Stream,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vfwprintf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfwprintf_s(
        FILE* const _Stream,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vfwprintf_p_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vfwprintf_p(
        FILE* const _Stream,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vwprintf(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _vwprintf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vwprintf_s(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _vwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vwprintf_p(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _fwprintf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl fwprintf(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fwprintf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl fwprintf_s(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fwprintf_p_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fwprintf_p(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _wprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl wprintf(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _wprintf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl wprintf_s(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _wprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _wprintf_p(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __inline int __cdecl _vfwscanf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options()),
            _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfwscanf(
        FILE* const _Stream,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vfwscanf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfwscanf_s(
        FILE* const _Stream,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vwscanf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vwscanf(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _vwscanf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vwscanf_s(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_fwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _fwscanf_l(FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "fwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl fwscanf(FILE* const _Stream,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fwscanf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl fwscanf_s(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _wscanf_l(wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl wscanf(wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _wscanf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl wscanf_s(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        size_t _MaxCount,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwprintf_l(wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vsnwprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vsnwprintf_s(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwprintf(wchar_t * _Buffer, size_t _BufferCount, wchar_t const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwprintf(wchar_t * _Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwprintf(wchar_t * _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        va_list _ArgList)
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
    }
    __inline int __cdecl _vswprintf_c_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vswprintf_c(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vswprintf_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl __vswprintf_l(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vswprintf(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    __inline int __cdecl vswprintf(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vswprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl vswprintf_s(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); }
    }
    __inline int __cdecl _vswprintf_p_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vswprintf_p(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vscwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vscwprintf(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _vscwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vscwprintf_p(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl __swprintf_l(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _swprintf_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _swprintf(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl swprintf(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "__swprintf_l_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl __swprintf_l(wchar_t * _Buffer, wchar_t const* _Format, _locale_t _Locale, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vswprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl __vswprintf_l(wchar_t * _Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "swprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _swprintf(wchar_t * _Buffer, wchar_t const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "vswprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vswprintf(wchar_t * _Buffer, wchar_t const* _Format, va_list _Args);
    __inline int __cdecl _swprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl swprintf_s(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw()
    {
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        return vswprintf_s(_Buffer, _Size, _Format, _ArgList);
    }
    }
    __inline int __cdecl _swprintf_p_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _swprintf_p(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _swprintf_c_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _swprintf_c(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwprintf_l(wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snwprintf(
        wchar_t * _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snwprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snwprintf_s(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw()
    {
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
    }
    }
    __inline int __cdecl _scwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scwprintf(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scwprintf_p(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#pragma warning(push)
#pragma warning(disable : 4141 6054)
    extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, "
                                       "adding an extra character count parameter. To use the traditional "
                                       "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                                                       "swprintf_s"
                                                                                                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                                                       "See online help for details.")) inline int
    swprintf(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        ...) throw()
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, "
                                       "adding an extra character count parameter. To use the traditional "
                                       "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                                                       "vswprintf_s"
                                                                                                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                                                       "See online help for details.")) inline int __cdecl vswprintf(wchar_t* const _Buffer,
        wchar_t const* const _Format,
        va_list _ArgList) throw()
    {
        return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
    }
    extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, "
                                       "adding an extra character count parameter. To use the traditional "
                                       "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                                                       "_swprintf_s_l"
                                                                                                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                                                       "See online help for details.")) inline int
    _swprintf_l(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...) throw()
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, "
                                       "adding an extra character count parameter. To use the traditional "
                                       "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                                                       "_vswprintf_s_l"
                                                                                                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                                                       "See online help for details.")) inline int __cdecl _vswprintf_l(wchar_t* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList) throw()
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
#pragma warning(pop)
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
        unsigned __int64 _Options,
        wchar_t const* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __inline int __cdecl _vswscanf_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vswscanf(
        wchar_t const* _Buffer,
        wchar_t const* _Format,
        va_list _ArgList)
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vswscanf_s_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vswscanf_s(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwscanf_l(wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vsnwscanf_s_l(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_swscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _swscanf_l(wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "swscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl swscanf(wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _swscanf_s_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl swscanf_s(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwscanf_l(wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwscanf(wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snwscanf_s_l(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snwscanf_s(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    typedef __int64 fpos_t;
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
        FILE * _Stream,
        char*** _Base,
        char*** _Pointer,
        int** _Count);
    __declspec(dllimport) errno_t __cdecl clearerr_s(
        FILE * _Stream);
    __declspec(dllimport) errno_t __cdecl fopen_s(
        FILE * *_Stream,
        char const* _FileName,
        char const* _Mode);
    __declspec(dllimport) size_t __cdecl fread_s(
        void* _Buffer,
        size_t _BufferSize,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream);
    __declspec(dllimport) errno_t __cdecl freopen_s(
        FILE * *_Stream,
        char const* _FileName,
        char const* _Mode,
        FILE* _OldStream);
    __declspec(dllimport) char* __cdecl gets_s(
        char* _Buffer,
        rsize_t _Size);
    __declspec(dllimport) errno_t __cdecl tmpfile_s(
        FILE * *_Stream);
    __declspec(dllimport) errno_t __cdecl tmpnam_s(
        char* _Buffer,
        rsize_t _Size);
    __declspec(dllimport) void __cdecl clearerr(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl fclose(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _fcloseall(void);
    __declspec(dllimport) FILE* __cdecl _fdopen(
        int _FileHandle,
        char const* _Mode);
    __declspec(dllimport) int __cdecl feof(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl ferror(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl fflush(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl fgetc(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _fgetchar(void);
    __declspec(dllimport) int __cdecl fgetpos(
        FILE * _Stream,
        fpos_t * _Position);
    __declspec(dllimport) char* __cdecl fgets(
        char* _Buffer,
        int _MaxCount,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl _fileno(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _flushall(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "fopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) FILE* __cdecl fopen(char const* _FileName,
        char const* _Mode);
    __declspec(dllimport) int __cdecl fputc(
        int _Character,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl _fputchar(
        int _Character);
    __declspec(dllimport) int __cdecl fputs(
        char const* _Buffer,
        FILE* _Stream);
    __declspec(dllimport) size_t __cdecl fread(
        void* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "freopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) FILE* __cdecl freopen(char const* _FileName,
        char const* _Mode,
        FILE* _Stream);
    __declspec(dllimport) FILE* __cdecl _fsopen(
        char const* _FileName,
        char const* _Mode,
        int _ShFlag);
    __declspec(dllimport) int __cdecl fsetpos(
        FILE * _Stream,
        fpos_t const* _Position);
    __declspec(dllimport) int __cdecl fseek(
        FILE * _Stream,
        long _Offset,
        int _Origin);
    __declspec(dllimport) int __cdecl _fseeki64(
        FILE * _Stream,
        __int64 _Offset,
        int _Origin);
    __declspec(dllimport) long __cdecl ftell(
        FILE * _Stream);
    __declspec(dllimport) __int64 __cdecl _ftelli64(
        FILE * _Stream);
    __declspec(dllimport) size_t __cdecl fwrite(
        void const* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl getc(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl getchar(void);
    __declspec(dllimport) int __cdecl _getmaxstdio(void);
    extern "C++" {
    template <size_t _Size>
    inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); }
    }
    __declspec(dllimport) int __cdecl _getw(
        FILE * _Stream);
    __declspec(dllimport) void __cdecl perror(
        char const* _ErrorMessage);
    __declspec(dllimport) int __cdecl _pclose(
        FILE * _Stream);
    __declspec(dllimport) FILE* __cdecl _popen(
        char const* _Command,
        char const* _Mode);
    __declspec(dllimport) int __cdecl putc(
        int _Character,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl putchar(
        int _Character);
    __declspec(dllimport) int __cdecl puts(
        char const* _Buffer);
    __declspec(dllimport) int __cdecl _putw(
        int _Word,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl remove(
        char const* _FileName);
    __declspec(dllimport) int __cdecl rename(
        char const* _OldFileName,
        char const* _NewFileName);
    __declspec(dllimport) int __cdecl _unlink(
        char const* _FileName);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_unlink"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl unlink(char const* _FileName);
    __declspec(dllimport) void __cdecl rewind(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _rmtmp(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "setvbuf"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl setbuf(FILE * _Stream,
        char* _Buffer);
    __declspec(dllimport) int __cdecl _setmaxstdio(
        int _Maximum);
    __declspec(dllimport) int __cdecl setvbuf(
        FILE * _Stream,
        char* _Buffer,
        int _Mode,
        size_t _Size);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
        char const* _DirectoryName,
        char const* _FilePrefix);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "tmpfile_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) FILE* __cdecl tmpfile(void);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "tmpnam_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl tmpnam(char* _Buffer);
    __declspec(dllimport) int __cdecl ungetc(
        int _Character,
        FILE* _Stream);
    __declspec(dllimport) void __cdecl _lock_file(
        FILE * _Stream);
    __declspec(dllimport) void __cdecl _unlock_file(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _fclose_nolock(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _fflush_nolock(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _fgetc_nolock(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _fputc_nolock(
        int _Character,
        FILE* _Stream);
    __declspec(dllimport) size_t __cdecl _fread_nolock(
        void* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream);
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
        void* _Buffer,
        size_t _BufferSize,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl _fseek_nolock(
        FILE * _Stream,
        long _Offset,
        int _Origin);
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
        FILE * _Stream,
        __int64 _Offset,
        int _Origin);
    __declspec(dllimport) long __cdecl _ftell_nolock(
        FILE * _Stream);
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
        FILE * _Stream);
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
        void const* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl _getc_nolock(
        FILE * _Stream);
    __declspec(dllimport) int __cdecl _putc_nolock(
        int _Character,
        FILE* _Stream);
    __declspec(dllimport) int __cdecl _ungetc_nolock(
        int _Character,
        FILE* _Stream);
    __declspec(dllimport) int* __cdecl __p__commode(void);
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __inline int __cdecl _vfprintf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfprintf(
        FILE* const _Stream,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vfprintf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfprintf_s(
        FILE* const _Stream,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vfprintf_p_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vfprintf_p(
        FILE* const _Stream,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vprintf_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vprintf(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _vprintf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vprintf_s(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _vprintf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vprintf_p(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _fprintf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl fprintf(
        FILE* const _Stream,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl _set_printf_count_output(
        int _Value);
    __declspec(dllimport) int __cdecl _get_printf_count_output(void);
    __inline int __cdecl _fprintf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl fprintf_s(
        FILE* const _Stream,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fprintf_p_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fprintf_p(
        FILE* const _Stream,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _printf_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl printf(
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _printf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl printf_s(
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _printf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _printf_p(
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
        va_list _Arglist);
    __inline int __cdecl _vfscanf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options()),
            _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfscanf(
        FILE* const _Stream,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vfscanf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vfscanf_s(
        FILE* const _Stream,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vscanf_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vscanf(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    __inline int __cdecl _vscanf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vscanf_s(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_fscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _fscanf_l(FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "fscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl fscanf(FILE* const _Stream,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _fscanf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl fscanf_s(
        FILE* const _Stream,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_scanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _scanf_l(char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "scanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl scanf(char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scanf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl scanf_s(
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        size_t _MaxCount,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnprintf_l(char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vsnprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    __inline int __cdecl vsnprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsprintf_l(char* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "vsprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl vsprintf(char* const _Buffer,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vsprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl vsprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); }
    }
    __inline int __cdecl _vsprintf_p_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vsprintf_p(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vsnprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vsnprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
    }
    __inline int __cdecl vsnprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); }
    }
    __inline int __cdecl _vscprintf_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vscprintf(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _vscprintf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vscprintf_p(
        char const* const _Format,
        va_list _ArgList)
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _vsnprintf_c_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    __inline int __cdecl _vsnprintf_c(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_sprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _sprintf_l(char* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl sprintf(
        char* const _Buffer,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "sprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl sprintf(char* _Buffer, char const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "vsprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl vsprintf(char* _Buffer, char const* _Format, va_list _Args);
    __inline int __cdecl _sprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl sprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw()
    {
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        return vsprintf_s(_Buffer, _Size, _Format, _ArgList);
    }
    }
    __inline int __cdecl _sprintf_p_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _sprintf_p(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snprintf_l(char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl snprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl _snprintf(char* _Buffer, size_t _BufferCount, char const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl _vsnprintf(char* _Buffer, size_t _BufferCount, char const* _Format, va_list _Args);
    __inline int __cdecl _snprintf_c_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snprintf_c(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw()
    {
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
    }
    }
    __inline int __cdecl _scprintf_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scprintf(
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scprintf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _scprintf_p(
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
        unsigned __int64 _Options,
        char const* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __inline int __cdecl _vsscanf_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    __inline int __cdecl vsscanf(
        char const* const _Buffer,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    __inline int __cdecl _vsscanf_s_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
#pragma warning(push)
#pragma warning(disable : 6530)
    __inline int __cdecl vsscanf_s(
        char const* const _Buffer,
        char const* const _Format,
        va_list _ArgList)
    {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
    extern "C++" {
    template <size_t _Size>
    inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); }
    }
#pragma warning(pop)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_sscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _sscanf_l(char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "sscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl sscanf(char const* const _Buffer,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _sscanf_s_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl sscanf_s(
        char const* const _Buffer,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vsscanf_s(_Buffer, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#pragma warning(push)
#pragma warning(disable : 6530)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snscanf_l(char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snscanf(char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snscanf_s_l(
        char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _snscanf_s(
        char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#pragma warning(pop)
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_tempnam"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl tempnam(char const* _Directory,
        char const* _FilePrefix);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fcloseall"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fdopen"
                          ". See online help for details.")) __declspec(dllimport) FILE* __cdecl fdopen(int _FileHandle, char const* _Format);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fgetchar"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fileno"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fileno(FILE * _Stream);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_flushall"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fputchar"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar(int _Ch);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_getw"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl getw(FILE * _Stream);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_putw"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl putw(int _Ch, FILE* _Stream);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_rmtmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma external_header(push)
#pragma once
    typedef enum MH_STATUS {
        MH_UNKNOWN = -1,
        MH_OK = 0,
        MH_ERROR_ALREADY_INITIALIZED,
        MH_ERROR_NOT_INITIALIZED,
        MH_ERROR_ALREADY_CREATED,
        MH_ERROR_NOT_CREATED,
        MH_ERROR_ENABLED,
        MH_ERROR_DISABLED,
        MH_ERROR_NOT_EXECUTABLE,
        MH_ERROR_UNSUPPORTED_FUNCTION,
        MH_ERROR_MEMORY_ALLOC,
        MH_ERROR_MEMORY_PROTECT,
        MH_ERROR_MODULE_NOT_FOUND,
        MH_ERROR_FUNCTION_NOT_FOUND
    } MH_STATUS;
extern "C" {
MH_STATUS __stdcall MH_Initialize(void);
MH_STATUS __stdcall MH_Uninitialize(void);
MH_STATUS __stdcall MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID* ppOriginal);
MH_STATUS __stdcall MH_CreateHookApi(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID* ppOriginal);
MH_STATUS __stdcall MH_CreateHookApiEx(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID* ppOriginal, LPVOID* ppTarget);
MH_STATUS __stdcall MH_RemoveHook(LPVOID pTarget);
MH_STATUS __stdcall MH_EnableHook(LPVOID pTarget);
MH_STATUS __stdcall MH_DisableHook(LPVOID pTarget);
MH_STATUS __stdcall MH_QueueEnableHook(LPVOID pTarget);
MH_STATUS __stdcall MH_QueueDisableHook(LPVOID pTarget);
MH_STATUS __stdcall MH_ApplyQueued(void);
const char* __stdcall MH_StatusToString(MH_STATUS status);
}
#pragma external_header(pop)
#pragma region Desktop Family
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _calloc_base(
        size_t _Count,
        size_t _Size);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl calloc(
        __declspec(guard(overflow)) size_t _Count,
        __declspec(guard(overflow)) size_t _Size);
    __declspec(dllimport) int __cdecl _callnewh(
        size_t _Size);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand(
        void* _Block,
        __declspec(guard(overflow)) size_t _Size);
    __declspec(dllimport) void __cdecl _free_base(
        void* _Block);
    __declspec(dllimport) void __cdecl free(
        void* _Block);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _malloc_base(
        size_t _Size);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl malloc(
        __declspec(guard(overflow)) size_t _Size);
    __declspec(dllimport)
        size_t __cdecl _msize_base(
            void* _Block) noexcept;
    __declspec(dllimport)
        size_t __cdecl _msize(
            void* _Block);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _realloc_base(
        void* _Block,
        size_t _Size);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl realloc(
        void* _Block,
        __declspec(guard(overflow)) size_t _Size);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _recalloc_base(
        void* _Block,
        size_t _Count,
        size_t _Size);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _recalloc(
        void* _Block,
        __declspec(guard(overflow)) size_t _Count,
        __declspec(guard(overflow)) size_t _Size);
    __declspec(dllimport) void __cdecl _aligned_free(
        void* _Block);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_malloc(
        __declspec(guard(overflow)) size_t _Size,
        size_t _Alignment);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_offset_malloc(
        __declspec(guard(overflow)) size_t _Size,
        size_t _Alignment,
        size_t _Offset);
    __declspec(dllimport)
        size_t __cdecl _aligned_msize(
            void* _Block,
            size_t _Alignment,
            size_t _Offset);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_offset_realloc(
        void* _Block,
        __declspec(guard(overflow)) size_t _Size,
        size_t _Alignment,
        size_t _Offset);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_offset_recalloc(
        void* _Block,
        __declspec(guard(overflow)) size_t _Count,
        __declspec(guard(overflow)) size_t _Size,
        size_t _Alignment,
        size_t _Offset);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_realloc(
        void* _Block,
        __declspec(guard(overflow)) size_t _Size,
        size_t _Alignment);
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_recalloc(
        void* _Block,
        __declspec(guard(overflow)) size_t _Count,
        __declspec(guard(overflow)) size_t _Size,
        size_t _Alignment);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    namespace std {
        typedef decltype(__nullptr) nullptr_t;
    }
    using ::std::nullptr_t;
    __declspec(dllimport) int* __cdecl _errno(void);
    __declspec(dllimport) errno_t __cdecl _set_errno(int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(int* _Value);
    __declspec(dllimport) extern unsigned long __cdecl __threadid(void);
    __declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    typedef int(__cdecl * _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int(__cdecl * _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);
    __declspec(dllimport) void* __cdecl bsearch_s(
        void const* _Key,
        void const* _Base,
        rsize_t _NumOfElements,
        rsize_t _SizeOfElements,
        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        void* _Context);
    __declspec(dllimport) void __cdecl qsort_s(
        void* _Base,
        rsize_t _NumOfElements,
        rsize_t _SizeOfElements,
        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        void* _Context);
    __declspec(dllimport) void* __cdecl bsearch(
        void const* _Key,
        void const* _Base,
        size_t _NumOfElements,
        size_t _SizeOfElements,
        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    __declspec(dllimport) void __cdecl qsort(
        void* _Base,
        size_t _NumOfElements,
        size_t _SizeOfElements,
        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    __declspec(dllimport) void* __cdecl _lfind_s(
        void const* _Key,
        void const* _Base,
        unsigned int* _NumOfElements,
        size_t _SizeOfElements,
        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        void* _Context);
    __declspec(dllimport) void* __cdecl _lfind(
        void const* _Key,
        void const* _Base,
        unsigned int* _NumOfElements,
        unsigned int _SizeOfElements,
        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    __declspec(dllimport) void* __cdecl _lsearch_s(
        void const* _Key,
        void* _Base,
        unsigned int* _NumOfElements,
        size_t _SizeOfElements,
        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        void* _Context);
    __declspec(dllimport) void* __cdecl _lsearch(
        void const* _Key,
        void* _Base,
        unsigned int* _NumOfElements,
        unsigned int _SizeOfElements,
        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_lfind"
                          ". See online help for details.")) __declspec(dllimport) void* __cdecl lfind(void const* _Key,
        void const* _Base,
        unsigned int* _NumOfElements,
        unsigned int _SizeOfElements,
        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_lsearch"
                          ". See online help for details.")) __declspec(dllimport) void* __cdecl lsearch(void const* _Key,
        void* _Base,
        unsigned int* _NumOfElements,
        unsigned int _SizeOfElements,
        _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl _itow_s(
        int _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_itow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow(int _Value, wchar_t* _Buffer, int _Radix);
    __declspec(dllimport) errno_t __cdecl _ltow_s(
        long _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ltow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow(long _Value, wchar_t* _Buffer, int _Radix);
    __declspec(dllimport) errno_t __cdecl _ultow_s(
        unsigned long _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ultow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t* _Buffer, int _Radix);
    __declspec(dllimport) double __cdecl wcstod(
        wchar_t const* _String,
        wchar_t** _EndPtr);
    __declspec(dllimport) double __cdecl _wcstod_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        _locale_t _Locale);
    __declspec(dllimport) long __cdecl wcstol(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix);
    __declspec(dllimport) long __cdecl _wcstol_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) long long __cdecl wcstoll(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix);
    __declspec(dllimport) long long __cdecl _wcstoll_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) unsigned long __cdecl wcstoul(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix);
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix);
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) long double __cdecl wcstold(
        wchar_t const* _String,
        wchar_t** _EndPtr);
    __declspec(dllimport) long double __cdecl _wcstold_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        _locale_t _Locale);
    __declspec(dllimport) float __cdecl wcstof(
        wchar_t const* _String,
        wchar_t** _EndPtr);
    __declspec(dllimport) float __cdecl _wcstof_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        _locale_t _Locale);
    __declspec(dllimport) double __cdecl _wtof(
        wchar_t const* _String);
    __declspec(dllimport) double __cdecl _wtof_l(
        wchar_t const* _String,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _wtoi(
        wchar_t const* _String);
    __declspec(dllimport) int __cdecl _wtoi_l(
        wchar_t const* _String,
        _locale_t _Locale);
    __declspec(dllimport) long __cdecl _wtol(
        wchar_t const* _String);
    __declspec(dllimport) long __cdecl _wtol_l(
        wchar_t const* _String,
        _locale_t _Locale);
    __declspec(dllimport) long long __cdecl _wtoll(
        wchar_t const* _String);
    __declspec(dllimport) long long __cdecl _wtoll_l(
        wchar_t const* _String,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
        __int64 _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_i64tow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _i64tow(__int64 _Value,
        wchar_t* _Buffer,
        int _Radix);
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
        unsigned __int64 _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ui64tow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ui64tow(unsigned __int64 _Value,
        wchar_t* _Buffer,
        int _Radix);
    __declspec(dllimport) __int64 __cdecl _wtoi64(
        wchar_t const* _String);
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
        wchar_t const* _String,
        _locale_t _Locale);
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix);
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix);
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
        wchar_t * _Buffer,
        wchar_t const* _Path,
        size_t _BufferCount);
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
        wchar_t * _Buffer,
        size_t _BufferCount,
        wchar_t const* _Drive,
        wchar_t const* _Dir,
        wchar_t const* _Filename,
        wchar_t const* _Ext);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wmakepath_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(wchar_t * _Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);
    __declspec(dllimport) void __cdecl _wperror(
        wchar_t const* _ErrorMessage);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wsplitpath_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _wsplitpath(wchar_t const* _FullPath,
        wchar_t* _Drive,
        wchar_t* _Dir,
        wchar_t* _Filename,
        wchar_t* _Ext);
    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
        wchar_t const* _FullPath,
        wchar_t* _Drive,
        size_t _DriveCount,
        wchar_t* _Dir,
        size_t _DirCount,
        wchar_t* _Filename,
        size_t _FilenameCount,
        wchar_t* _Ext,
        size_t _ExtCount);
    extern "C++" {
    template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
    inline errno_t __cdecl _wsplitpath_s(wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); }
    }
    __declspec(dllimport) errno_t __cdecl _wdupenv_s(
        wchar_t * *_Buffer,
        size_t * _BufferCount,
        wchar_t const* _VarName);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wdupenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wgetenv(wchar_t const* _VarName);
    __declspec(dllimport) errno_t __cdecl _wgetenv_s(
        size_t * _RequiredCount,
        wchar_t * _Buffer,
        size_t _BufferCount,
        wchar_t const* _VarName);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); }
    }
    __declspec(dllimport) int __cdecl _wputenv(
        wchar_t const* _EnvString);
    __declspec(dllimport) errno_t __cdecl _wputenv_s(
        wchar_t const* _Name,
        wchar_t const* _Value);
    __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
        wchar_t const* _Filename,
        wchar_t const* _VarName,
        wchar_t* _Buffer,
        size_t _BufferCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wsearchenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t* _ResultPath);
    __declspec(dllimport) int __cdecl _wsystem(
        wchar_t const* _Command);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4514 4820)
    __pragma(pack(push, 8)) extern "C"
{
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
        int _SizeInBytes);
    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
    __declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
        unsigned int _Flags,
        unsigned int _Mask);
    typedef int(__cdecl * _onexit_t)(void);
    int __cdecl atexit(void(__cdecl*)(void));
    _onexit_t __cdecl _onexit(_onexit_t _Func);
    int __cdecl at_quick_exit(void(__cdecl*)(void));
    typedef void(__cdecl * _purecall_handler)(void);
    typedef void(__cdecl * _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t);
    _purecall_handler __cdecl _set_purecall_handler(
        _purecall_handler _Handler);
    _purecall_handler __cdecl _get_purecall_handler(void);
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
        _invalid_parameter_handler _Handler);
    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
        _invalid_parameter_handler _Handler);
    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
    __declspec(dllimport) int __cdecl _set_error_mode(int _Mode);
    __declspec(dllimport) int* __cdecl _errno(void);
    __declspec(dllimport) errno_t __cdecl _set_errno(int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(int* _Value);
    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    __declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long* _Value);
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                "strerror"
                                                " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                "See online help for details.")) char** __cdecl __sys_errlist(void);
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                "strerror"
                                                " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                "See online help for details.")) int* __cdecl __sys_nerr(void);
    __declspec(dllimport) void __cdecl perror(char const* _ErrMsg);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_pgmptr"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char** __cdecl __p__pgmptr(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_wpgmptr"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_fmode"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int* __cdecl __p__fmode(void);
    __declspec(dllimport) errno_t __cdecl _get_pgmptr(char** _Value);
    __declspec(dllimport) errno_t __cdecl _get_wpgmptr(wchar_t * *_Value);
    __declspec(dllimport) errno_t __cdecl _set_fmode(int _Mode);
    __declspec(dllimport) errno_t __cdecl _get_fmode(int* _PMode);
    typedef struct _div_t {
        int quot;
        int rem;
    } div_t;
    typedef struct _ldiv_t {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct _lldiv_t {
        long long quot;
        long long rem;
    } lldiv_t;
    int __cdecl abs(int _Number);
    long __cdecl labs(long _Number);
    long long __cdecl llabs(long long _Number);
    __int64 __cdecl _abs64(__int64 _Number);
    unsigned short __cdecl _byteswap_ushort(unsigned short _Number);
    unsigned long __cdecl _byteswap_ulong(unsigned long _Number);
    unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Number);
    __declspec(dllimport) div_t __cdecl div(int _Numerator, int _Denominator);
    __declspec(dllimport) ldiv_t __cdecl ldiv(long _Numerator, long _Denominator);
    __declspec(dllimport) lldiv_t __cdecl lldiv(long long _Numerator, long long _Denominator);
#pragma warning(push)
#pragma warning(disable : 6540)
    unsigned int __cdecl _rotl(
        unsigned int _Value,
        int _Shift);
    unsigned long __cdecl _lrotl(
        unsigned long _Value,
        int _Shift);
    unsigned __int64 __cdecl _rotl64(
        unsigned __int64 _Value,
        int _Shift);
    unsigned int __cdecl _rotr(
        unsigned int _Value,
        int _Shift);
    unsigned long __cdecl _lrotr(
        unsigned long _Value,
        int _Shift);
    unsigned __int64 __cdecl _rotr64(
        unsigned __int64 _Value,
        int _Shift);
#pragma warning(pop)
    __declspec(dllimport) void __cdecl srand(unsigned int _Seed);
    __declspec(dllimport) int __cdecl rand(void);
    extern "C++" {
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }
    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }
    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
    }
#pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
#pragma pack(pop)
    typedef struct
    {
        double x;
    } _CRT_DOUBLE;
    typedef struct
    {
        float f;
    } _CRT_FLOAT;
    typedef struct
    {
        long double x;
    } _LONGDOUBLE;
#pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld12[12];
    } _LDBL12;
#pragma pack(pop)
    __declspec(dllimport) double __cdecl atof(char const* _String);
    __declspec(dllimport) int __cdecl atoi(char const* _String);
    __declspec(dllimport) long __cdecl atol(char const* _String);
    __declspec(dllimport) long long __cdecl atoll(char const* _String);
    __declspec(dllimport) __int64 __cdecl _atoi64(char const* _String);
    __declspec(dllimport) double __cdecl _atof_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _atoi_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) long __cdecl _atol_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) long long __cdecl _atoll_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) __int64 __cdecl _atoi64_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * _Result, char const* _String);
    __declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * _Result, char* _String);
    __declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * _Result, char* _String);
    __declspec(dllimport) int __cdecl _atoflt_l(
        _CRT_FLOAT * _Result,
        char const* _String,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _atodbl_l(
        _CRT_DOUBLE * _Result,
        char* _String,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl _atoldbl_l(
        _LDOUBLE * _Result,
        char* _String,
        _locale_t _Locale);
    __declspec(dllimport) float __cdecl strtof(
        char const* _String,
        char** _EndPtr);
    __declspec(dllimport) float __cdecl _strtof_l(
        char const* _String,
        char** _EndPtr,
        _locale_t _Locale);
    __declspec(dllimport) double __cdecl strtod(
        char const* _String,
        char** _EndPtr);
    __declspec(dllimport) double __cdecl _strtod_l(
        char const* _String,
        char** _EndPtr,
        _locale_t _Locale);
    __declspec(dllimport) long double __cdecl strtold(
        char const* _String,
        char** _EndPtr);
    __declspec(dllimport) long double __cdecl _strtold_l(
        char const* _String,
        char** _EndPtr,
        _locale_t _Locale);
    __declspec(dllimport) long __cdecl strtol(
        char const* _String,
        char** _EndPtr,
        int _Radix);
    __declspec(dllimport) long __cdecl _strtol_l(
        char const* _String,
        char** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) long long __cdecl strtoll(
        char const* _String,
        char** _EndPtr,
        int _Radix);
    __declspec(dllimport) long long __cdecl _strtoll_l(
        char const* _String,
        char** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) unsigned long __cdecl strtoul(
        char const* _String,
        char** _EndPtr,
        int _Radix);
    __declspec(dllimport) unsigned long __cdecl _strtoul_l(
        char const* _String,
        char** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) unsigned long long __cdecl strtoull(
        char const* _String,
        char** _EndPtr,
        int _Radix);
    __declspec(dllimport) unsigned long long __cdecl _strtoull_l(
        char const* _String,
        char** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) __int64 __cdecl _strtoi64(
        char const* _String,
        char** _EndPtr,
        int _Radix);
    __declspec(dllimport) __int64 __cdecl _strtoi64_l(
        char const* _String,
        char** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
        char const* _String,
        char** _EndPtr,
        int _Radix);
    __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
        char const* _String,
        char** _EndPtr,
        int _Radix,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl _itoa_s(
        int _Value,
        char* _Buffer,
        size_t _BufferCount,
        int _Radix);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_itoa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa(int _Value, char* _Buffer, int _Radix);
    __declspec(dllimport) errno_t __cdecl _ltoa_s(
        long _Value,
        char* _Buffer,
        size_t _BufferCount,
        int _Radix);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ltoa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa(long _Value, char* _Buffer, int _Radix);
    __declspec(dllimport) errno_t __cdecl _ultoa_s(
        unsigned long _Value,
        char* _Buffer,
        size_t _BufferCount,
        int _Radix);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ultoa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value, char* _Buffer, int _Radix);
    __declspec(dllimport) errno_t __cdecl _i64toa_s(
        __int64 _Value,
        char* _Buffer,
        size_t _BufferCount,
        int _Radix);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_i64toa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _i64toa(__int64 _Value,
        char* _Buffer,
        int _Radix);
    __declspec(dllimport) errno_t __cdecl _ui64toa_s(
        unsigned __int64 _Value,
        char* _Buffer,
        size_t _BufferCount,
        int _Radix);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ui64toa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ui64toa(unsigned __int64 _Value,
        char* _Buffer,
        int _Radix);
    __declspec(dllimport) errno_t __cdecl _ecvt_s(
        char* _Buffer,
        size_t _BufferCount,
        double _Value,
        int _DigitCount,
        int* _PtDec,
        int* _PtSign);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ecvt_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ecvt(double _Value,
        int _DigitCount,
        int* _PtDec,
        int* _PtSign);
    __declspec(dllimport) errno_t __cdecl _fcvt_s(
        char* _Buffer,
        size_t _BufferCount,
        double _Value,
        int _FractionalDigitCount,
        int* _PtDec,
        int* _PtSign);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_fcvt_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _fcvt(double _Value,
        int _FractionalDigitCount,
        int* _PtDec,
        int* _PtSign);
    __declspec(dllimport) errno_t __cdecl _gcvt_s(
        char* _Buffer,
        size_t _BufferCount,
        double _Value,
        int _DigitCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_gcvt_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _gcvt(double _Value,
        int _DigitCount,
        char* _Buffer);
    __declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
        size_t _MaxCount);
    __declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) size_t __cdecl _mbstrlen(
        char const* _String);
    __declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
        _locale_t _Locale);
    __declspec(dllimport) size_t __cdecl _mbstrnlen(
        char const* _String,
        size_t _MaxCount);
    __declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
        size_t _MaxCount,
        _locale_t _Locale);
    __declspec(dllimport) int __cdecl mbtowc(
        wchar_t * _DstCh,
        char const* _SrcCh,
        size_t _SrcSizeInBytes);
    __declspec(dllimport) int __cdecl _mbtowc_l(
        wchar_t * _DstCh,
        char const* _SrcCh,
        size_t _SrcSizeInBytes,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl mbstowcs_s(
        size_t * _PtNumOfCharConverted,
        wchar_t * _DstBuf,
        size_t _SizeInWords,
        char const* _SrcBuf,
        size_t _MaxCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "mbstowcs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs(wchar_t * _Dest, char const* _Source, size_t _MaxCount);
    __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
        size_t * _PtNumOfCharConverted,
        wchar_t * _DstBuf,
        size_t _SizeInWords,
        char const* _SrcBuf,
        size_t _MaxCount,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_mbstowcs_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(wchar_t * _Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wctomb_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int __cdecl wctomb(char* _MbCh,
        wchar_t _WCh);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wctomb_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int __cdecl _wctomb_l(char* _MbCh,
        wchar_t _WCh,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl wctomb_s(
        int* _SizeConverted,
        char* _MbCh,
        rsize_t _SizeInBytes,
        wchar_t _WCh);
    __declspec(dllimport) errno_t __cdecl _wctomb_s_l(
        int* _SizeConverted,
        char* _MbCh,
        size_t _SizeInBytes,
        wchar_t _WCh,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl wcstombs_s(
        size_t * _PtNumOfCharConverted,
        char* _Dst,
        size_t _DstSizeInBytes,
        wchar_t const* _Src,
        size_t _MaxCountInBytes);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcstombs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs(char* _Dest, wchar_t const* _Source, size_t _MaxCount);
    __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
        size_t * _PtNumOfCharConverted,
        char* _Dst,
        size_t _DstSizeInBytes,
        wchar_t const* _Src,
        size_t _MaxCountInBytes,
        _locale_t _Locale);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcstombs_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(char* _Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
        char* _Buffer,
        char const* _Path,
        size_t _BufferCount);
    __declspec(dllimport) errno_t __cdecl _makepath_s(
        char* _Buffer,
        size_t _BufferCount,
        char const* _Drive,
        char const* _Dir,
        char const* _Filename,
        char const* _Ext);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_makepath_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(char* _Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_splitpath_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _splitpath(char const* _FullPath,
        char* _Drive,
        char* _Dir,
        char* _Filename,
        char* _Ext);
    __declspec(dllimport) errno_t __cdecl _splitpath_s(
        char const* _FullPath,
        char* _Drive,
        size_t _DriveCount,
        char* _Dir,
        size_t _DirCount,
        char* _Filename,
        size_t _FilenameCount,
        char* _Ext,
        size_t _ExtCount);
    extern "C++" {
    template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
    inline errno_t __cdecl _splitpath_s(char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); }
    }
    __declspec(dllimport) errno_t __cdecl getenv_s(
        size_t * _RequiredCount,
        char* _Buffer,
        rsize_t _BufferCount,
        char const* _VarName);
    __declspec(dllimport) int* __cdecl __p___argc(void);
    __declspec(dllimport) char*** __cdecl __p___argv(void);
    __declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);
    __declspec(dllimport) char*** __cdecl __p__environ(void);
    __declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_dupenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl getenv(char const* _VarName);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); }
    }
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
        char** _Buffer,
        size_t* _BufferCount,
        char const* _VarName);
    __declspec(dllimport) int __cdecl system(
        char const* _Command);
#pragma warning(push)
#pragma warning(disable : 6540)
    __declspec(dllimport) int __cdecl _putenv(
        char const* _EnvString);
    __declspec(dllimport) errno_t __cdecl _putenv_s(
        char const* _Name,
        char const* _Value);
#pragma warning(pop)
    __declspec(dllimport) errno_t __cdecl _searchenv_s(
        char const* _Filename,
        char const* _VarName,
        char* _Buffer,
        size_t _BufferCount);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_searchenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char* _Buffer);
    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "SetErrorMode"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(int _Mode);
    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "Beep"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(unsigned _Frequency,
        unsigned _Duration);
    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "Sleep"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(unsigned long _Duration);
#pragma warning(push)
#pragma warning(disable : 4141)
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_ecvt"
                          ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                   "_ecvt_s"
                                                                                   " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                   "See online help for details.")) __declspec(dllimport) char* __cdecl ecvt(double _Value,
        int _DigitCount,
        int* _PtDec,
        int* _PtSign);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fcvt"
                          ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                   "_fcvt_s"
                                                                                   " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                   "See online help for details.")) __declspec(dllimport) char* __cdecl fcvt(double _Value,
        int _FractionalDigitCount,
        int* _PtDec,
        int* _PtSign);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_gcvt"
                          ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                   "_fcvt_s"
                                                                                   " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                   "See online help for details.")) __declspec(dllimport) char* __cdecl gcvt(double _Value,
        int _DigitCount,
        char* _DstBuf);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_itoa"
                          ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                   "_itoa_s"
                                                                                   " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                   "See online help for details.")) __declspec(dllimport) char* __cdecl itoa(int _Value,
        char* _Buffer,
        int _Radix);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_ltoa"
                          ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                   "_ltoa_s"
                                                                                   " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                   "See online help for details.")) __declspec(dllimport) char* __cdecl ltoa(long _Value,
        char* _Buffer,
        int _Radix);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_swab"
                          ". See online help for details.")) __declspec(dllimport) void __cdecl swab(char* _Buf1,
        char* _Buf2,
        int _SizeInBytes);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_ultoa"
                          ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                   "_ultoa_s"
                                                                                   " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                   "See online help for details.")) __declspec(dllimport) char* __cdecl ultoa(unsigned long _Value,
        char* _Buffer,
        int _Radix);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_putenv"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl putenv(char const* _EnvString);
#pragma warning(pop)
    _onexit_t __cdecl onexit(_onexit_t _Func);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
    extern "C"
{
#pragma warning(disable : 4103)
#pragma pack(push, 8)
    typedef void* I_RPC_HANDLE;
    typedef long RPC_STATUS;
#pragma once
    extern "C" {
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
#pragma region Application Family or OneCore Family or Games Family
    typedef unsigned char* RPC_CSTR;
    typedef unsigned short* RPC_WSTR;
    typedef const unsigned short* RPC_CWSTR;
    typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
    typedef RPC_BINDING_HANDLE handle_t;
    typedef GUID UUID;
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef struct _RPC_BINDING_VECTOR {
        unsigned long Count;
        RPC_BINDING_HANDLE BindingH[1];
    } RPC_BINDING_VECTOR;
    typedef struct _UUID_VECTOR {
        unsigned long Count;
        UUID* Uuid[1];
    } UUID_VECTOR;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
    typedef void* RPC_IF_HANDLE;
    typedef struct _RPC_IF_ID {
        UUID Uuid;
        unsigned short VersMajor;
        unsigned short VersMinor;
    } RPC_IF_ID;
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef struct _RPC_PROTSEQ_VECTORA {
        unsigned int Count;
        unsigned char* Protseq[1];
    } RPC_PROTSEQ_VECTORA;
    typedef struct _RPC_PROTSEQ_VECTORW {
        unsigned int Count;
        unsigned short* Protseq[1];
    } RPC_PROTSEQ_VECTORW;
    typedef struct _RPC_POLICY {
        unsigned int Length;
        unsigned long EndpointFlags;
        unsigned long NICFlags;
    } RPC_POLICY, *PRPC_POLICY;
    typedef void __stdcall RPC_OBJECT_INQ_FN(
        UUID* ObjectUuid,
        UUID* TypeUuid,
        RPC_STATUS* Status);
    typedef RPC_STATUS __stdcall RPC_IF_CALLBACK_FN(
        RPC_IF_HANDLE InterfaceUuid,
        void* Context);
    typedef void __stdcall RPC_SECURITY_CALLBACK_FN(
        void* Context);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
    typedef struct
    {
        unsigned int Count;
        unsigned long Stats[1];
    } RPC_STATS_VECTOR;
    typedef struct
    {
        unsigned long Count;
        RPC_IF_ID* IfId[1];
    } RPC_IF_ID_VECTOR;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingCopy(
            RPC_BINDING_HANDLE SourceBinding,
            RPC_BINDING_HANDLE* DestinationBinding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingFree(
            RPC_BINDING_HANDLE* Binding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingSetOption(
            RPC_BINDING_HANDLE hBinding,
            unsigned long option,
            ULONG_PTR optionValue);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqOption(
            RPC_BINDING_HANDLE hBinding,
            unsigned long option,
            ULONG_PTR* pOptionValue);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingFromStringBindingA(
            RPC_CSTR StringBinding,
            RPC_BINDING_HANDLE* Binding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingFromStringBindingW(
            RPC_WSTR StringBinding,
            RPC_BINDING_HANDLE* Binding);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcSsGetContextBinding(
            void* ContextHandle,
            RPC_BINDING_HANDLE* Binding);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqMaxCalls(
            RPC_BINDING_HANDLE Binding,
            unsigned int* MaxCalls);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqObject(
            RPC_BINDING_HANDLE Binding,
            UUID* ObjectUuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingReset(
            RPC_BINDING_HANDLE Binding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingSetObject(
            RPC_BINDING_HANDLE Binding,
            UUID* ObjectUuid);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtInqDefaultProtectLevel(
            unsigned long AuthnSvc,
            unsigned long* AuthnLevel);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingToStringBindingA(
            RPC_BINDING_HANDLE Binding,
            RPC_CSTR* StringBinding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingToStringBindingW(
            RPC_BINDING_HANDLE Binding,
            RPC_WSTR* StringBinding);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingVectorFree(
            RPC_BINDING_VECTOR** BindingVector);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcStringBindingComposeA(
            RPC_CSTR ObjUuid,
            RPC_CSTR ProtSeq,
            RPC_CSTR NetworkAddr,
            RPC_CSTR Endpoint,
            RPC_CSTR Options,
            RPC_CSTR* StringBinding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcStringBindingComposeW(
            RPC_WSTR ObjUuid,
            RPC_WSTR ProtSeq,
            RPC_WSTR NetworkAddr,
            RPC_WSTR Endpoint,
            RPC_WSTR Options,
            RPC_WSTR* StringBinding);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcStringBindingParseA(
            RPC_CSTR StringBinding,
            RPC_CSTR* ObjUuid,
            RPC_CSTR* Protseq,
            RPC_CSTR* NetworkAddr,
            RPC_CSTR* Endpoint,
            RPC_CSTR* NetworkOptions);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcStringBindingParseW(
            RPC_WSTR StringBinding,
            RPC_WSTR* ObjUuid,
            RPC_WSTR* Protseq,
            RPC_WSTR* NetworkAddr,
            RPC_WSTR* Endpoint,
            RPC_WSTR* NetworkOptions);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcStringFreeA(
            RPC_CSTR* String);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcStringFreeW(
            RPC_WSTR* String);
#pragma endregion
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcIfInqId(
            RPC_IF_HANDLE RpcIfHandle,
            RPC_IF_ID* RpcIfId);
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcNetworkIsProtseqValidA(
            RPC_CSTR Protseq);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcNetworkIsProtseqValidW(
            RPC_WSTR Protseq);
#pragma endregion
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtInqComTimeout(
            RPC_BINDING_HANDLE Binding,
            unsigned int* Timeout);
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtSetComTimeout(
            RPC_BINDING_HANDLE Binding,
            unsigned int Timeout);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtSetCancelTimeout(
            long Timeout);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcNetworkInqProtseqsA(
            RPC_PROTSEQ_VECTORA** ProtseqVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcNetworkInqProtseqsW(
            RPC_PROTSEQ_VECTORW** ProtseqVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcObjectInqType(
            UUID* ObjUuid,
            UUID* TypeUuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcObjectSetInqFn(
            RPC_OBJECT_INQ_FN* InquiryFn);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcObjectSetType(
            UUID* ObjUuid,
            UUID* TypeUuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcProtseqVectorFreeA(
            RPC_PROTSEQ_VECTORA** ProtseqVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcProtseqVectorFreeW(
            RPC_PROTSEQ_VECTORW** ProtseqVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqBindings(
            RPC_BINDING_VECTOR** BindingVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqBindingsEx(
            void* SecurityDescriptor,
            RPC_BINDING_VECTOR** BindingVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqIf(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            void** MgrEpv);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerListen(
            unsigned int MinimumCallThreads,
            unsigned int MaxCalls,
            unsigned int DontWait);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerRegisterIf(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            void* MgrEpv);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerRegisterIfEx(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            void* MgrEpv,
            unsigned int Flags,
            unsigned int MaxCalls,
            RPC_IF_CALLBACK_FN* IfCallback);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerRegisterIf2(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            void* MgrEpv,
            unsigned int Flags,
            unsigned int MaxCalls,
            unsigned int MaxRpcSize,
            RPC_IF_CALLBACK_FN* IfCallbackFn);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerRegisterIf3(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            void* MgrEpv,
            unsigned int Flags,
            unsigned int MaxCalls,
            unsigned int MaxRpcSize,
            RPC_IF_CALLBACK_FN* IfCallback,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUnregisterIf(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            unsigned int WaitForCallsToComplete);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUnregisterIfEx(
            RPC_IF_HANDLE IfSpec,
            UUID* MgrTypeUuid,
            int RundownContextHandles);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseAllProtseqs(
            unsigned int MaxCalls,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseAllProtseqsEx(
            unsigned int MaxCalls,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseAllProtseqsIf(
            unsigned int MaxCalls,
            RPC_IF_HANDLE IfSpec,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseAllProtseqsIfEx(
            unsigned int MaxCalls,
            RPC_IF_HANDLE IfSpec,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqA(
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqExA(
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqW(
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqExW(
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqEpA(
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            RPC_CSTR Endpoint,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqEpExA(
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            RPC_CSTR Endpoint,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqEpW(
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            RPC_WSTR Endpoint,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqEpExW(
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            RPC_WSTR Endpoint,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqIfA(
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            RPC_IF_HANDLE IfSpec,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqIfExA(
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            RPC_IF_HANDLE IfSpec,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqIfW(
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            RPC_IF_HANDLE IfSpec,
            void* SecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUseProtseqIfExW(
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            RPC_IF_HANDLE IfSpec,
            void* SecurityDescriptor,
            PRPC_POLICY Policy);
    __declspec(dllimport) void __stdcall RpcServerYield(
        void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtStatsVectorFree(
            RPC_STATS_VECTOR** StatsVector);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtInqStats(
            RPC_BINDING_HANDLE Binding,
            RPC_STATS_VECTOR** Statistics);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtIsServerListening(
            RPC_BINDING_HANDLE Binding);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtStopServerListening(
            RPC_BINDING_HANDLE Binding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtWaitServerListen(
            void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtSetServerStackSize(
            unsigned long ThreadStackSize);
    __declspec(dllimport) void __stdcall RpcSsDontSerializeContext(
        void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtEnableIdleCleanup(
            void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtInqIfIds(
            RPC_BINDING_HANDLE Binding,
            RPC_IF_ID_VECTOR** IfIdVector);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcIfIdVectorFree(
            RPC_IF_ID_VECTOR** IfIdVector);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtInqServerPrincNameA(
            RPC_BINDING_HANDLE Binding,
            unsigned long AuthnSvc,
            RPC_CSTR* ServerPrincName);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtInqServerPrincNameW(
            RPC_BINDING_HANDLE Binding,
            unsigned long AuthnSvc,
            RPC_WSTR* ServerPrincName);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqDefaultPrincNameA(
            unsigned long AuthnSvc,
            RPC_CSTR* PrincName);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqDefaultPrincNameW(
            unsigned long AuthnSvc,
            RPC_WSTR* PrincName);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcEpResolveBinding(
            RPC_BINDING_HANDLE Binding,
            RPC_IF_HANDLE IfSpec);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcNsBindingInqEntryNameA(
            RPC_BINDING_HANDLE Binding,
            unsigned long EntryNameSyntax,
            RPC_CSTR* EntryName);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcNsBindingInqEntryNameW(
            RPC_BINDING_HANDLE Binding,
            unsigned long EntryNameSyntax,
            RPC_WSTR* EntryName);
#pragma endregion
#pragma region Application Family or OneCore Family
    typedef void* RPC_AUTH_IDENTITY_HANDLE;
    typedef void* RPC_AUTHZ_HANDLE;
    typedef struct _RPC_SECURITY_QOS {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
    } RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;
    typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
        unsigned short* User;
        unsigned long UserLength;
        unsigned short* Domain;
        unsigned long DomainLength;
        unsigned short* Password;
        unsigned long PasswordLength;
        unsigned long Flags;
    } SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;
    typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
        unsigned char* User;
        unsigned long UserLength;
        unsigned char* Domain;
        unsigned long DomainLength;
        unsigned char* Password;
        unsigned long PasswordLength;
        unsigned long Flags;
    } SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;
    typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W {
        SEC_WINNT_AUTH_IDENTITY_W* TransportCredentials;
        unsigned long Flags;
        unsigned long AuthenticationTarget;
        unsigned long NumberOfAuthnSchemes;
        unsigned long* AuthnSchemes;
        unsigned short* ServerCertificateSubject;
    } RPC_HTTP_TRANSPORT_CREDENTIALS_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_W;
    typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A {
        SEC_WINNT_AUTH_IDENTITY_A* TransportCredentials;
        unsigned long Flags;
        unsigned long AuthenticationTarget;
        unsigned long NumberOfAuthnSchemes;
        unsigned long* AuthnSchemes;
        unsigned char* ServerCertificateSubject;
    } RPC_HTTP_TRANSPORT_CREDENTIALS_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_A;
    typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W {
        SEC_WINNT_AUTH_IDENTITY_W* TransportCredentials;
        unsigned long Flags;
        unsigned long AuthenticationTarget;
        unsigned long NumberOfAuthnSchemes;
        unsigned long* AuthnSchemes;
        unsigned short* ServerCertificateSubject;
        SEC_WINNT_AUTH_IDENTITY_W* ProxyCredentials;
        unsigned long NumberOfProxyAuthnSchemes;
        unsigned long* ProxyAuthnSchemes;
    } RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
    typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A {
        SEC_WINNT_AUTH_IDENTITY_A* TransportCredentials;
        unsigned long Flags;
        unsigned long AuthenticationTarget;
        unsigned long NumberOfAuthnSchemes;
        unsigned long* AuthnSchemes;
        unsigned char* ServerCertificateSubject;
        SEC_WINNT_AUTH_IDENTITY_A* ProxyCredentials;
        unsigned long NumberOfProxyAuthnSchemes;
        unsigned long* ProxyAuthnSchemes;
    } RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
    typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W {
        RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
        unsigned long Flags;
        unsigned long AuthenticationTarget;
        unsigned long NumberOfAuthnSchemes;
        unsigned long* AuthnSchemes;
        unsigned short* ServerCertificateSubject;
        RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
        unsigned long NumberOfProxyAuthnSchemes;
        unsigned long* ProxyAuthnSchemes;
    } RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
    typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A {
        RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
        unsigned long Flags;
        unsigned long AuthenticationTarget;
        unsigned long NumberOfAuthnSchemes;
        unsigned long* AuthnSchemes;
        unsigned char* ServerCertificateSubject;
        RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
        unsigned long NumberOfProxyAuthnSchemes;
        unsigned long* ProxyAuthnSchemes;
    } RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
    typedef struct _RPC_SECURITY_QOS_V2_W {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
        } u;
    } RPC_SECURITY_QOS_V2_W, *PRPC_SECURITY_QOS_V2_W;
    typedef struct _RPC_SECURITY_QOS_V2_A {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
        } u;
    } RPC_SECURITY_QOS_V2_A, *PRPC_SECURITY_QOS_V2_A;
    typedef struct _RPC_SECURITY_QOS_V3_W {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
        } u;
        void* Sid;
    } RPC_SECURITY_QOS_V3_W, *PRPC_SECURITY_QOS_V3_W;
    typedef struct _RPC_SECURITY_QOS_V3_A {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
        } u;
        void* Sid;
    } RPC_SECURITY_QOS_V3_A, *PRPC_SECURITY_QOS_V3_A;
    typedef struct _RPC_SECURITY_QOS_V4_W {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
        } u;
        void* Sid;
        unsigned int EffectiveOnly;
    } RPC_SECURITY_QOS_V4_W, *PRPC_SECURITY_QOS_V4_W;
    typedef struct _RPC_SECURITY_QOS_V4_A {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
        } u;
        void* Sid;
        unsigned int EffectiveOnly;
    } RPC_SECURITY_QOS_V4_A, *PRPC_SECURITY_QOS_V4_A;
    typedef struct _RPC_SECURITY_QOS_V5_W {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
        } u;
        void* Sid;
        unsigned int EffectiveOnly;
        void* ServerSecurityDescriptor;
    } RPC_SECURITY_QOS_V5_W, *PRPC_SECURITY_QOS_V5_W;
    typedef struct _RPC_SECURITY_QOS_V5_A {
        unsigned long Version;
        unsigned long Capabilities;
        unsigned long IdentityTracking;
        unsigned long ImpersonationType;
        unsigned long AdditionalSecurityInfoType;
        union {
            RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
        } u;
        void* Sid;
        unsigned int EffectiveOnly;
        void* ServerSecurityDescriptor;
    } RPC_SECURITY_QOS_V5_A, *PRPC_SECURITY_QOS_V5_A;
#pragma endregion
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family
    typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_W {
        unsigned long Version;
        unsigned long Flags;
        unsigned long ProtocolSequence;
        unsigned short* NetworkAddress;
        unsigned short* StringEndpoint;
        union {
            unsigned short* Reserved;
        } u1;
        UUID ObjectUuid;
    } RPC_BINDING_HANDLE_TEMPLATE_V1_W, *PRPC_BINDING_HANDLE_TEMPLATE_V1_W;
    typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_A {
        unsigned long Version;
        unsigned long Flags;
        unsigned long ProtocolSequence;
        unsigned char* NetworkAddress;
        unsigned char* StringEndpoint;
        union {
            unsigned char* Reserved;
        } u1;
        UUID ObjectUuid;
    } RPC_BINDING_HANDLE_TEMPLATE_V1_A, *PRPC_BINDING_HANDLE_TEMPLATE_V1_A;
    typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_W {
        unsigned long Version;
        unsigned short* ServerPrincName;
        unsigned long AuthnLevel;
        unsigned long AuthnSvc;
        SEC_WINNT_AUTH_IDENTITY_W* AuthIdentity;
        RPC_SECURITY_QOS* SecurityQos;
    } RPC_BINDING_HANDLE_SECURITY_V1_W, *PRPC_BINDING_HANDLE_SECURITY_V1_W;
    typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_A {
        unsigned long Version;
        unsigned char* ServerPrincName;
        unsigned long AuthnLevel;
        unsigned long AuthnSvc;
        SEC_WINNT_AUTH_IDENTITY_A* AuthIdentity;
        RPC_SECURITY_QOS* SecurityQos;
    } RPC_BINDING_HANDLE_SECURITY_V1_A, *PRPC_BINDING_HANDLE_SECURITY_V1_A;
    typedef struct _RPC_BINDING_HANDLE_OPTIONS_V1 {
        unsigned long Version;
        unsigned long Flags;
        unsigned long ComTimeout;
        unsigned long CallTimeout;
    } RPC_BINDING_HANDLE_OPTIONS_V1, *PRPC_BINDING_HANDLE_OPTIONS_V1;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingCreateA(
            RPC_BINDING_HANDLE_TEMPLATE_V1_A* Template,
            RPC_BINDING_HANDLE_SECURITY_V1_A* Security,
            RPC_BINDING_HANDLE_OPTIONS_V1* Options,
            RPC_BINDING_HANDLE* Binding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingCreateW(
            RPC_BINDING_HANDLE_TEMPLATE_V1_W* Template,
            RPC_BINDING_HANDLE_SECURITY_V1_W* Security,
            RPC_BINDING_HANDLE_OPTIONS_V1* Options,
            RPC_BINDING_HANDLE* Binding);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingGetTrainingContextHandle(
            RPC_BINDING_HANDLE Binding,
            void** ContextHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqBindingHandle(
            RPC_BINDING_HANDLE* Binding);
#pragma endregion
#pragma region Application Family or OneCore Family
    typedef enum _RPC_HTTP_REDIRECTOR_STAGE {
        RPCHTTP_RS_REDIRECT = 1,
        RPCHTTP_RS_ACCESS_1,
        RPCHTTP_RS_SESSION,
        RPCHTTP_RS_ACCESS_2,
        RPCHTTP_RS_INTERFACE
    } RPC_HTTP_REDIRECTOR_STAGE;
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef RPC_STATUS(__stdcall* RPC_NEW_HTTP_PROXY_CHANNEL)(
        RPC_HTTP_REDIRECTOR_STAGE RedirectorStage,
        RPC_WSTR ServerName,
        RPC_WSTR ServerPort,
        RPC_WSTR RemoteUser,
        RPC_WSTR AuthType,
        void* ResourceUuid,
        void* SessionId,
        void* Interface,
        void* Reserved,
        unsigned long Flags,
        RPC_WSTR* NewServerName,
        RPC_WSTR* NewServerPort);
    typedef void(__stdcall* RPC_HTTP_PROXY_FREE_STRING)(
        RPC_WSTR String);
#pragma endregion
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcImpersonateClient(
            RPC_BINDING_HANDLE BindingHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcImpersonateClient2(
            RPC_BINDING_HANDLE BindingHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcRevertToSelfEx(
            RPC_BINDING_HANDLE BindingHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcRevertToSelf(
            void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcImpersonateClientContainer(
            RPC_BINDING_HANDLE BindingHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcRevertContainerImpersonation(
            void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthClientA(
            RPC_BINDING_HANDLE ClientBinding,
            RPC_AUTHZ_HANDLE* Privs,
            RPC_CSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            unsigned long* AuthzSvc);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthClientW(
            RPC_BINDING_HANDLE ClientBinding,
            RPC_AUTHZ_HANDLE* Privs,
            RPC_WSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            unsigned long* AuthzSvc);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthClientExA(
            RPC_BINDING_HANDLE ClientBinding,
            RPC_AUTHZ_HANDLE* Privs,
            RPC_CSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            unsigned long* AuthzSvc,
            unsigned long Flags);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthClientExW(
            RPC_BINDING_HANDLE ClientBinding,
            RPC_AUTHZ_HANDLE* Privs,
            RPC_WSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            unsigned long* AuthzSvc,
            unsigned long Flags);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthInfoA(
            RPC_BINDING_HANDLE Binding,
            RPC_CSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
            unsigned long* AuthzSvc);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthInfoW(
            RPC_BINDING_HANDLE Binding,
            RPC_WSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
            unsigned long* AuthzSvc);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingSetAuthInfoA(
            RPC_BINDING_HANDLE Binding,
            RPC_CSTR ServerPrincName,
            unsigned long AuthnLevel,
            unsigned long AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
            unsigned long AuthzSvc);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingSetAuthInfoExA(
            RPC_BINDING_HANDLE Binding,
            RPC_CSTR ServerPrincName,
            unsigned long AuthnLevel,
            unsigned long AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
            unsigned long AuthzSvc,
            RPC_SECURITY_QOS* SecurityQos);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingSetAuthInfoW(
            RPC_BINDING_HANDLE Binding,
            RPC_WSTR ServerPrincName,
            unsigned long AuthnLevel,
            unsigned long AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
            unsigned long AuthzSvc);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingSetAuthInfoExW(
            RPC_BINDING_HANDLE Binding,
            RPC_WSTR ServerPrincName,
            unsigned long AuthnLevel,
            unsigned long AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
            unsigned long AuthzSvc,
            RPC_SECURITY_QOS* SecurityQOS);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthInfoExA(
            RPC_BINDING_HANDLE Binding,
            RPC_CSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
            unsigned long* AuthzSvc,
            unsigned long RpcQosVersion,
            RPC_SECURITY_QOS* SecurityQOS);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingInqAuthInfoExW(
            RPC_BINDING_HANDLE Binding,
            RPC_WSTR* ServerPrincName,
            unsigned long* AuthnLevel,
            unsigned long* AuthnSvc,
            RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
            unsigned long* AuthzSvc,
            unsigned long RpcQosVersion,
            RPC_SECURITY_QOS* SecurityQOS);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef void(__stdcall* RPC_AUTH_KEY_RETRIEVAL_FN)(
        void* Arg,
        RPC_WSTR ServerPrincName,
        unsigned long KeyVer,
        void** Key,
        RPC_STATUS* Status);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerCompleteSecurityCallback(
            RPC_BINDING_HANDLE BindingHandle,
            RPC_STATUS Status);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerRegisterAuthInfoA(
            RPC_CSTR ServerPrincName,
            unsigned long AuthnSvc,
            RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
            void* Arg);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerRegisterAuthInfoW(
            RPC_WSTR ServerPrincName,
            unsigned long AuthnSvc,
            RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
            void* Arg);
#pragma endregion
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef struct {
        unsigned char* UserName;
        unsigned char* ComputerName;
        unsigned short Privilege;
        unsigned long AuthFlags;
    } RPC_CLIENT_INFORMATION1, *PRPC_CLIENT_INFORMATION1;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingServerFromClient(
            RPC_BINDING_HANDLE ClientBinding,
            RPC_BINDING_HANDLE* ServerBinding);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport) __declspec(noreturn) void __stdcall RpcRaiseException(
        RPC_STATUS exception);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcTestCancel(
            void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerTestCancel(
            RPC_BINDING_HANDLE BindingHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcCancelThread(
            void* Thread);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcCancelThreadEx(
            void* Thread,
            long Timeout);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidCreate(
            UUID* Uuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidCreateSequential(
            UUID* Uuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidToStringA(
            const UUID* Uuid,
            RPC_CSTR* StringUuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidFromStringA(
            RPC_CSTR StringUuid,
            UUID* Uuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidToStringW(
            const UUID* Uuid,
            RPC_WSTR* StringUuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidFromStringW(
            RPC_WSTR StringUuid,
            UUID* Uuid);
    __declspec(dllimport) signed int __stdcall UuidCompare(
        UUID* Uuid1,
        UUID* Uuid2,
        RPC_STATUS* Status);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall UuidCreateNil(
            UUID* NilUuid);
    __declspec(dllimport) int __stdcall UuidEqual(
        UUID* Uuid1,
        UUID* Uuid2,
        RPC_STATUS* Status);
    __declspec(dllimport) unsigned short __stdcall UuidHash(
        UUID* Uuid,
        RPC_STATUS* Status);
    __declspec(dllimport) int __stdcall UuidIsNil(
        UUID* Uuid,
        RPC_STATUS* Status);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcEpRegisterNoReplaceA(
            RPC_IF_HANDLE IfSpec,
            RPC_BINDING_VECTOR* BindingVector,
            UUID_VECTOR* UuidVector,
            RPC_CSTR Annotation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcEpRegisterNoReplaceW(
            RPC_IF_HANDLE IfSpec,
            RPC_BINDING_VECTOR* BindingVector,
            UUID_VECTOR* UuidVector,
            RPC_WSTR Annotation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcEpRegisterA(
            RPC_IF_HANDLE IfSpec,
            RPC_BINDING_VECTOR* BindingVector,
            UUID_VECTOR* UuidVector,
            RPC_CSTR Annotation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcEpRegisterW(
            RPC_IF_HANDLE IfSpec,
            RPC_BINDING_VECTOR* BindingVector,
            UUID_VECTOR* UuidVector,
            RPC_WSTR Annotation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcEpUnregister(
            RPC_IF_HANDLE IfSpec,
            RPC_BINDING_VECTOR* BindingVector,
            UUID_VECTOR* UuidVector);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall DceErrorInqTextA(
            RPC_STATUS RpcStatus,
            RPC_CSTR ErrorText);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall DceErrorInqTextW(
            RPC_STATUS RpcStatus,
            RPC_WSTR ErrorText);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef I_RPC_HANDLE* RPC_EP_INQ_HANDLE;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtEpEltInqBegin(
            RPC_BINDING_HANDLE EpBinding,
            unsigned long InquiryType,
            RPC_IF_ID* IfId,
            unsigned long VersOption,
            UUID* ObjectUuid,
            RPC_EP_INQ_HANDLE* InquiryContext);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtEpEltInqDone(
            RPC_EP_INQ_HANDLE* InquiryContext);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtEpEltInqNextA(
            RPC_EP_INQ_HANDLE InquiryContext,
            RPC_IF_ID* IfId,
            RPC_BINDING_HANDLE* Binding,
            UUID* ObjectUuid,
            RPC_CSTR* Annotation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtEpEltInqNextW(
            RPC_EP_INQ_HANDLE InquiryContext,
            RPC_IF_ID* IfId,
            RPC_BINDING_HANDLE* Binding,
            UUID* ObjectUuid,
            RPC_WSTR* Annotation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtEpUnregister(
            RPC_BINDING_HANDLE EpBinding,
            RPC_IF_ID* IfId,
            RPC_BINDING_HANDLE Binding,
            UUID* ObjectUuid);
    typedef int(__stdcall* RPC_MGMT_AUTHORIZATION_FN)(
        RPC_BINDING_HANDLE ClientBinding,
        unsigned long RequestedMgmtOperation,
        RPC_STATUS* Status);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcMgmtSetAuthorizationFn(
            RPC_MGMT_AUTHORIZATION_FN AuthorizationFn);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport) int __stdcall RpcExceptionFilter(
        unsigned long ExceptionCode);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef void *RPC_INTERFACE_GROUP, **PRPC_INTERFACE_GROUP;
    typedef struct
    {
        unsigned long Version;
        RPC_WSTR ProtSeq;
        RPC_WSTR Endpoint;
        void* SecurityDescriptor;
        unsigned long Backlog;
    } RPC_ENDPOINT_TEMPLATEW, *PRPC_ENDPOINT_TEMPLATEW;
    typedef struct
    {
        unsigned long Version;
        RPC_CSTR ProtSeq;
        RPC_CSTR Endpoint;
        void* SecurityDescriptor;
        unsigned long Backlog;
    } RPC_ENDPOINT_TEMPLATEA, *PRPC_ENDPOINT_TEMPLATEA;
    typedef struct
    {
        unsigned long Version;
        RPC_IF_HANDLE IfSpec;
        UUID* MgrTypeUuid;
        void* MgrEpv;
        unsigned int Flags;
        unsigned int MaxCalls;
        unsigned int MaxRpcSize;
        RPC_IF_CALLBACK_FN* IfCallback;
        UUID_VECTOR* UuidVector;
        RPC_CSTR Annotation;
        void* SecurityDescriptor;
    } RPC_INTERFACE_TEMPLATEA, *PRPC_INTERFACE_TEMPLATEA;
    typedef struct
    {
        unsigned long Version;
        RPC_IF_HANDLE IfSpec;
        UUID* MgrTypeUuid;
        void* MgrEpv;
        unsigned int Flags;
        unsigned int MaxCalls;
        unsigned int MaxRpcSize;
        RPC_IF_CALLBACK_FN* IfCallback;
        UUID_VECTOR* UuidVector;
        RPC_WSTR Annotation;
        void* SecurityDescriptor;
    } RPC_INTERFACE_TEMPLATEW, *PRPC_INTERFACE_TEMPLATEW;
    typedef void __stdcall RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN(
        RPC_INTERFACE_GROUP IfGroup,
        void* IdleCallbackContext,
        unsigned long IsGroupIdle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInterfaceGroupCreateW(
            RPC_INTERFACE_TEMPLATEW* Interfaces,
            unsigned long NumIfs,
            RPC_ENDPOINT_TEMPLATEW* Endpoints,
            unsigned long NumEndpoints,
            unsigned long IdlePeriod,
            RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN IdleCallbackFn,
            void* IdleCallbackContext,
            PRPC_INTERFACE_GROUP IfGroup);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInterfaceGroupCreateA(
            RPC_INTERFACE_TEMPLATEA* Interfaces,
            unsigned long NumIfs,
            RPC_ENDPOINT_TEMPLATEA* Endpoints,
            unsigned long NumEndpoints,
            unsigned long IdlePeriod,
            RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN IdleCallbackFn,
            void* IdleCallbackContext,
            PRPC_INTERFACE_GROUP IfGroup);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInterfaceGroupClose(
            RPC_INTERFACE_GROUP IfGroup);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInterfaceGroupActivate(
            RPC_INTERFACE_GROUP IfGroup);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInterfaceGroupDeactivate(
            RPC_INTERFACE_GROUP IfGroup,
            unsigned long ForceDeactivation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInterfaceGroupInqBindings(
            RPC_INTERFACE_GROUP IfGroup,
            RPC_BINDING_VECTOR** BindingVector);
#pragma endregion
#pragma warning(pop)
#pragma once
    extern "C" {
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
#pragma region Application Family or OneCore Family or Games Family
    typedef struct _RPC_VERSION {
        unsigned short MajorVersion;
        unsigned short MinorVersion;
    } RPC_VERSION;
    typedef struct _RPC_SYNTAX_IDENTIFIER {
        GUID SyntaxGUID;
        RPC_VERSION SyntaxVersion;
    } RPC_SYNTAX_IDENTIFIER, *PRPC_SYNTAX_IDENTIFIER;
    typedef struct _RPC_MESSAGE {
        RPC_BINDING_HANDLE Handle;
        unsigned long DataRepresentation;
        void* Buffer;
        unsigned int BufferLength;
        unsigned int ProcNum;
        PRPC_SYNTAX_IDENTIFIER TransferSyntax;
        void* RpcInterfaceInformation;
        void* ReservedForRuntime;
        void* ManagerEpv;
        void* ImportContext;
        unsigned long RpcFlags;
    } RPC_MESSAGE, *PRPC_MESSAGE;
#pragma endregion
#pragma region Desktop Family or OneCore Family
    typedef RPC_STATUS __stdcall RPC_FORWARD_FUNCTION(
        UUID* InterfaceId,
        RPC_VERSION* InterfaceVersion,
        UUID* ObjectId,
        unsigned char* Rpcpro,
        void** ppDestEndpoint);
    enum RPC_ADDRESS_CHANGE_TYPE {
        PROTOCOL_NOT_LOADED = 1,
        PROTOCOL_LOADED,
        PROTOCOL_ADDRESS_CHANGE
    };
    typedef void __stdcall RPC_ADDRESS_CHANGE_FN(
        void* arg);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
    typedef void(__stdcall* RPC_DISPATCH_FUNCTION)(
        PRPC_MESSAGE Message);
    typedef struct {
        unsigned int DispatchTableCount;
        RPC_DISPATCH_FUNCTION* DispatchTable;
        LONG_PTR Reserved;
    } RPC_DISPATCH_TABLE, *PRPC_DISPATCH_TABLE;
    typedef struct _RPC_PROTSEQ_ENDPOINT {
        unsigned char* RpcProtocolSequence;
        unsigned char* Endpoint;
    } RPC_PROTSEQ_ENDPOINT, *PRPC_PROTSEQ_ENDPOINT;
    typedef struct _RPC_SERVER_INTERFACE {
        unsigned int Length;
        RPC_SYNTAX_IDENTIFIER InterfaceId;
        RPC_SYNTAX_IDENTIFIER TransferSyntax;
        PRPC_DISPATCH_TABLE DispatchTable;
        unsigned int RpcProtseqEndpointCount;
        PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
        void* DefaultManagerEpv;
        void const* InterpreterInfo;
        unsigned int Flags;
    } RPC_SERVER_INTERFACE, *PRPC_SERVER_INTERFACE;
    typedef struct _RPC_CLIENT_INTERFACE {
        unsigned int Length;
        RPC_SYNTAX_IDENTIFIER InterfaceId;
        RPC_SYNTAX_IDENTIFIER TransferSyntax;
        PRPC_DISPATCH_TABLE DispatchTable;
        unsigned int RpcProtseqEndpointCount;
        PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
        ULONG_PTR Reserved;
        void const* InterpreterInfo;
        unsigned int Flags;
    } RPC_CLIENT_INTERFACE, *PRPC_CLIENT_INTERFACE;
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcNegotiateTransferSyntax(
            RPC_MESSAGE* Message);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcGetBuffer(
            RPC_MESSAGE* Message);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcGetBufferWithObject(
            RPC_MESSAGE* Message,
            UUID* ObjectUuid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcSendReceive(
            RPC_MESSAGE* Message);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcFreeBuffer(
            RPC_MESSAGE* Message);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcSend(
            PRPC_MESSAGE Message);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcReceive(
            PRPC_MESSAGE Message,
            unsigned int Size);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcFreePipeBuffer(
            RPC_MESSAGE* Message);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcReallocPipeBuffer(
            PRPC_MESSAGE Message,
            unsigned int NewSize);
    typedef void* I_RPC_MUTEX;
    __declspec(dllimport) void __stdcall I_RpcRequestMutex(
        I_RPC_MUTEX* Mutex);
    __declspec(dllimport) void __stdcall I_RpcClearMutex(
        I_RPC_MUTEX Mutex);
    __declspec(dllimport) void __stdcall I_RpcDeleteMutex(
        I_RPC_MUTEX Mutex);
    __declspec(dllimport) void* __stdcall I_RpcAllocate(
        unsigned int Size);
    __declspec(dllimport) void __stdcall I_RpcFree(
        void* Object);
    __declspec(dllimport) unsigned long __stdcall I_RpcFreeSystemHandleCollection(
        void* CallObj,
        unsigned long FreeFlags);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcSetSystemHandle(
            void* Handle,
            unsigned char Type,
            unsigned long AccessMask,
            void* CallObj,
            unsigned long* HandleIndex);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcGetSystemHandle(
            unsigned char* pMemory,
            unsigned char Type,
            unsigned long AccessMask,
            unsigned long HandleIndex,
            void* CallObj);
    __declspec(dllimport) void __stdcall I_RpcFreeSystemHandle(
        unsigned char Type,
        void* Handle);
    __declspec(dllimport) void __stdcall I_RpcPauseExecution(
        unsigned long Milliseconds);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcGetExtendedError(
            void);
    typedef enum _LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION {
        MarshalDirectionMarshal,
        MarshalDirectionUnmarshal
    } LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcSystemHandleTypeSpecificWork(
            void* Handle,
            unsigned char ActualType,
            unsigned char IdlType,
            LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION MarshalDirection);
    typedef void(__stdcall* PRPC_RUNDOWN)(
        void* AssociationContext);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcMonitorAssociation(
            RPC_BINDING_HANDLE Handle,
            PRPC_RUNDOWN RundownRoutine,
            void* Context);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcStopMonitorAssociation(
            RPC_BINDING_HANDLE Handle);
    __declspec(dllimport)
        RPC_BINDING_HANDLE
        __stdcall I_RpcGetCurrentCallHandle(
            void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcGetAssociationContext(
            RPC_BINDING_HANDLE BindingHandle,
            void** AssociationContext);
    __declspec(dllimport) void* __stdcall I_RpcGetServerContextList(
        RPC_BINDING_HANDLE BindingHandle);
    __declspec(dllimport) void __stdcall I_RpcSetServerContextList(
        RPC_BINDING_HANDLE BindingHandle,
        void* ServerContextList);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcNsInterfaceExported(
            unsigned long EntryNameSyntax,
            unsigned short* EntryName,
            RPC_SERVER_INTERFACE* RpcInterfaceInformation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcNsInterfaceUnexported(
            unsigned long EntryNameSyntax,
            unsigned short* EntryName,
            RPC_SERVER_INTERFACE* RpcInterfaceInformation);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingToStaticStringBindingW(
            RPC_BINDING_HANDLE Binding,
            unsigned short** StringBinding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqSecurityContext(
            RPC_BINDING_HANDLE Binding,
            void** SecurityContextHandle);
    typedef struct _RPC_SEC_CONTEXT_KEY_INFO {
        unsigned long EncryptAlgorithm;
        unsigned long KeySize;
        unsigned long SignatureAlgorithm;
    } RPC_SEC_CONTEXT_KEY_INFO, *PRPC_SEC_CONTEXT_KEY_INFO;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqSecurityContextKeyInfo(
            RPC_BINDING_HANDLE Binding,
            void* KeyInfo);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqWireIdForSnego(
            RPC_BINDING_HANDLE Binding,
            unsigned char* WireId);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqMarshalledTargetInfo(
            RPC_BINDING_HANDLE Binding,
            unsigned long* MarshalledTargetInfoSize,
            RPC_CSTR* MarshalledTargetInfo);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqLocalClientPID(
            RPC_BINDING_HANDLE Binding,
            unsigned long* Pid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingHandleToAsyncHandle(
            RPC_BINDING_HANDLE Binding,
            void** AsyncHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcNsBindingSetEntryNameW(
            RPC_BINDING_HANDLE Binding,
            unsigned long EntryNameSyntax,
            RPC_WSTR EntryName);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcNsBindingSetEntryNameA(
            RPC_BINDING_HANDLE Binding,
            unsigned long EntryNameSyntax,
            RPC_CSTR EntryName);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerUseProtseqEp2A(
            RPC_CSTR NetworkAddress,
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            RPC_CSTR Endpoint,
            void* SecurityDescriptor,
            void* Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerUseProtseqEp2W(
            RPC_WSTR NetworkAddress,
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            RPC_WSTR Endpoint,
            void* SecurityDescriptor,
            void* Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerUseProtseq2W(
            RPC_WSTR NetworkAddress,
            RPC_WSTR Protseq,
            unsigned int MaxCalls,
            void* SecurityDescriptor,
            void* Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerUseProtseq2A(
            RPC_CSTR NetworkAddress,
            RPC_CSTR Protseq,
            unsigned int MaxCalls,
            void* SecurityDescriptor,
            void* Policy);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerStartService(
            RPC_WSTR Protseq,
            RPC_WSTR Endpoint,
            RPC_IF_HANDLE IfSpec);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqDynamicEndpointW(
            RPC_BINDING_HANDLE Binding,
            RPC_WSTR* DynamicEndpoint);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqDynamicEndpointA(
            RPC_BINDING_HANDLE Binding,
            RPC_CSTR* DynamicEndpoint);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerCheckClientRestriction(
            RPC_BINDING_HANDLE Context);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqTransportType(
            RPC_BINDING_HANDLE Binding,
            unsigned int* Type);
    typedef struct _RPC_TRANSFER_SYNTAX {
        UUID Uuid;
        unsigned short VersMajor;
        unsigned short VersMinor;
    } RPC_TRANSFER_SYNTAX;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcIfInqTransferSyntaxes(
            RPC_IF_HANDLE RpcIfHandle,
            RPC_TRANSFER_SYNTAX* TransferSyntaxes,
            unsigned int TransferSyntaxSize,
            unsigned int* TransferSyntaxCount);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_UuidCreate(
            UUID* Uuid);
    __declspec(dllimport) void __stdcall I_RpcUninitializeNdrOle(
        void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingCopy(
            RPC_BINDING_HANDLE SourceBinding,
            RPC_BINDING_HANDLE* DestinationBinding);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingIsClientLocal(
            RPC_BINDING_HANDLE BindingHandle,
            unsigned int* ClientLocalFlag);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqConnId(
            RPC_BINDING_HANDLE Binding,
            void** ConnId,
            int* pfFirstCall);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingCreateNP(
            RPC_WSTR ServerName,
            RPC_WSTR ServiceName,
            RPC_WSTR NetworkOptions,
            RPC_BINDING_HANDLE* Binding);
    __declspec(dllimport) void __stdcall I_RpcSsDontSerializeContext(
        void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcLaunchDatagramReceiveThread(
            void* pAddress);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerRegisterForwardFunction(
            RPC_FORWARD_FUNCTION* pForwardFunction);
    RPC_ADDRESS_CHANGE_FN* __stdcall I_RpcServerInqAddressChangeFn(
        void);
    RPC_STATUS __stdcall I_RpcServerSetAddressChangeFn(
        RPC_ADDRESS_CHANGE_FN* pAddressChangeFn);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerInqLocalConnAddress(
            RPC_BINDING_HANDLE Binding,
            void* Buffer,
            unsigned long* BufferSize,
            unsigned long* AddressFormat);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerInqRemoteConnAddress(
            RPC_BINDING_HANDLE Binding,
            void* Buffer,
            unsigned long* BufferSize,
            unsigned long* AddressFormat);
    __declspec(dllimport) void __stdcall I_RpcSessionStrictContextHandle(
        void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcTurnOnEEInfoPropagation(
            void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcConnectionInqSockBuffSize(
            unsigned long* RecvBuffSize,
            unsigned long* SendBuffSize);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcConnectionSetSockBuffSize(
            unsigned long RecvBuffSize,
            unsigned long SendBuffSize);
    typedef void (*RPCLT_PDU_FILTER_FUNC)(
        void* Buffer,
        unsigned int BufferLength,
        int fDatagram);
    typedef void(__cdecl* RPC_SETFILTER_FUNC)(
        RPCLT_PDU_FILTER_FUNC pfnFilter);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerStartListening(
            void* hWnd);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerStopListening(
            void);
    typedef RPC_STATUS (*RPC_BLOCKING_FN)(
        void* hWnd,
        void* Context,
        void* hSyncEvent);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingSetAsync(
            RPC_BINDING_HANDLE Binding,
            RPC_BLOCKING_FN BlockingFn,
            unsigned long ServerTid);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcSetThreadParams(
            int fClientFree,
            void* Context,
            void* hWndClient);
    __declspec(dllimport) unsigned int __stdcall I_RpcWindowProc(
        void* hWnd,
        unsigned int Message,
        unsigned int wParam,
        unsigned long lParam);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerUnregisterEndpointA(
            RPC_CSTR Protseq,
            RPC_CSTR Endpoint);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerUnregisterEndpointW(
            RPC_WSTR Protseq,
            RPC_WSTR Endpoint);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcServerInqTransportType(
            unsigned int* Type);
    __declspec(dllimport) long __stdcall I_RpcMapWin32Status(
        RPC_STATUS Status);
    typedef struct _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR {
        unsigned long BufferSize;
        char* Buffer;
    } RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;
    typedef struct _RDR_CALLOUT_STATE {
        RPC_STATUS LastError;
        void* LastEEInfo;
        RPC_HTTP_REDIRECTOR_STAGE LastCalledStage;
        unsigned short* ServerName;
        unsigned short* ServerPort;
        unsigned short* RemoteUser;
        unsigned short* AuthType;
        unsigned char ResourceTypePresent;
        unsigned char SessionIdPresent;
        unsigned char InterfacePresent;
        UUID ResourceType;
        UUID SessionId;
        RPC_SYNTAX_IDENTIFIER Interface;
        void* CertContext;
    } RDR_CALLOUT_STATE;
    typedef RPC_STATUS(__stdcall* I_RpcProxyIsValidMachineFn)(
        RPC_WSTR Machine,
        RPC_WSTR DotMachine,
        unsigned long PortNumber);
    typedef RPC_STATUS(__stdcall* I_RpcProxyGetClientAddressFn)(
        void* Context,
        char* Buffer,
        unsigned long* BufferLength);
    typedef RPC_STATUS(__stdcall* I_RpcProxyGetConnectionTimeoutFn)(
        unsigned long* ConnectionTimeout);
    typedef RPC_STATUS(__stdcall* I_RpcPerformCalloutFn)(
        void* Context,
        RDR_CALLOUT_STATE* CallOutState,
        RPC_HTTP_REDIRECTOR_STAGE Stage);
    typedef void(__stdcall* I_RpcFreeCalloutStateFn)(
        RDR_CALLOUT_STATE* CallOutState);
    typedef RPC_STATUS(__stdcall* I_RpcProxyGetClientSessionAndResourceUUID)(
        void* Context,
        int* SessionIdPresent,
        UUID* SessionId,
        int* ResourceIdPresent,
        UUID* ResourceId);
    typedef RPC_STATUS(__stdcall* I_RpcProxyFilterIfFn)(
        void* Context,
        UUID* IfUuid,
        unsigned short IfMajorVersion,
        int* fAllow);
    typedef enum RpcProxyPerfCounters {
        RpcCurrentUniqueUser = 1,
        RpcBackEndConnectionAttempts,
        RpcBackEndConnectionFailed,
        RpcRequestsPerSecond,
        RpcIncomingConnections,
        RpcIncomingBandwidth,
        RpcOutgoingBandwidth,
        RpcAttemptedLbsDecisions,
        RpcFailedLbsDecisions,
        RpcAttemptedLbsMessages,
        RpcFailedLbsMessages,
        RpcLastCounter
    } RpcPerfCounters;
    typedef void(__stdcall* I_RpcProxyUpdatePerfCounterFn)(
        RpcPerfCounters Counter,
        int ModifyTrend,
        unsigned long Size);
    typedef void(__stdcall* I_RpcProxyUpdatePerfCounterBackendServerFn)(
        unsigned short* MachineName,
        int IsConnectEvent);
    typedef struct tagI_RpcProxyCallbackInterface {
        I_RpcProxyIsValidMachineFn IsValidMachineFn;
        I_RpcProxyGetClientAddressFn GetClientAddressFn;
        I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
        I_RpcPerformCalloutFn PerformCalloutFn;
        I_RpcFreeCalloutStateFn FreeCalloutStateFn;
        I_RpcProxyGetClientSessionAndResourceUUID GetClientSessionAndResourceUUIDFn;
        I_RpcProxyFilterIfFn ProxyFilterIfFn;
        I_RpcProxyUpdatePerfCounterFn RpcProxyUpdatePerfCounterFn;
        I_RpcProxyUpdatePerfCounterBackendServerFn RpcProxyUpdatePerfCounterBackendServerFn;
    } I_RpcProxyCallbackInterface;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcProxyNewConnection(
            unsigned long ConnectionType,
            unsigned short* ServerAddress,
            unsigned short* ServerPort,
            unsigned short* MinConnTimeout,
            void* ConnectionParameter,
            RDR_CALLOUT_STATE* CallOutState,
            I_RpcProxyCallbackInterface* ProxyCallbackInterface);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcReplyToClientWithStatus(
            void* ConnectionParameter,
            RPC_STATUS RpcStatus);
    __declspec(dllimport) void __stdcall I_RpcRecordCalloutFailure(
        RPC_STATUS RpcStatus,
        RDR_CALLOUT_STATE* CallOutState,
        unsigned short* DllName);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcMgmtEnableDedicatedThreadPool(
            void);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcGetDefaultSD(
            void** ppSecurityDescriptor);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcOpenClientProcess(
            RPC_BINDING_HANDLE Binding,
            unsigned long DesiredAccess,
            void** ClientProcess);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingIsServerLocal(
            RPC_BINDING_HANDLE Binding,
            unsigned int* ServerLocalFlag);
    RPC_STATUS __stdcall I_RpcBindingSetPrivateOption(
        RPC_BINDING_HANDLE hBinding,
        unsigned long option,
        ULONG_PTR optionValue);
    RPC_STATUS
    __stdcall I_RpcServerSubscribeForDisconnectNotification(
        RPC_BINDING_HANDLE Binding,
        void* hEvent);
    RPC_STATUS
    __stdcall I_RpcServerGetAssociationID(
        RPC_BINDING_HANDLE Binding,
        unsigned long* AssociationID);
    __declspec(dllimport) long __stdcall I_RpcServerDisableExceptionFilter(
        void);
    RPC_STATUS
    __stdcall I_RpcServerSubscribeForDisconnectNotification2(
        RPC_BINDING_HANDLE Binding,
        void* hEvent,
        UUID* SubscriptionId);
    RPC_STATUS
    __stdcall I_RpcServerUnsubscribeForDisconnectNotification(
        RPC_BINDING_HANDLE Binding,
        UUID SubscriptionId);
#pragma endregion
#pragma warning(pop)
    }
    }
#pragma once
#pragma region Desktop Family
    typedef void* RPC_NS_HANDLE;
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingExportA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        RPC_BINDING_VECTOR* BindingVec,
        UUID_VECTOR* ObjectUuidVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingUnexportA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID_VECTOR* ObjectUuidVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingExportW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        RPC_BINDING_VECTOR* BindingVec,
        UUID_VECTOR* ObjectUuidVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingUnexportW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID_VECTOR* ObjectUuidVec);
    RPC_STATUS __stdcall RpcNsBindingExportPnPA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID_VECTOR* ObjectVector);
    RPC_STATUS __stdcall RpcNsBindingUnexportPnPA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID_VECTOR* ObjectVector);
    RPC_STATUS __stdcall RpcNsBindingExportPnPW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID_VECTOR* ObjectVector);
    RPC_STATUS __stdcall RpcNsBindingUnexportPnPW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID_VECTOR* ObjectVector);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupBeginA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID* ObjUuid,
        unsigned long BindingMaxCount,
        RPC_NS_HANDLE* LookupContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupBeginW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID* ObjUuid,
        unsigned long BindingMaxCount,
        RPC_NS_HANDLE* LookupContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupNext(
        RPC_NS_HANDLE LookupContext,
        RPC_BINDING_VECTOR * *BindingVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupDone(
        RPC_NS_HANDLE * LookupContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupDeleteA(
        unsigned long GroupNameSyntax,
        RPC_CSTR GroupName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrAddA(
        unsigned long GroupNameSyntax,
        RPC_CSTR GroupName,
        unsigned long MemberNameSyntax,
        RPC_CSTR MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrRemoveA(
        unsigned long GroupNameSyntax,
        RPC_CSTR GroupName,
        unsigned long MemberNameSyntax,
        RPC_CSTR MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqBeginA(
        unsigned long GroupNameSyntax,
        RPC_CSTR GroupName,
        unsigned long MemberNameSyntax,
        RPC_NS_HANDLE* InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqNextA(
        RPC_NS_HANDLE InquiryContext,
        RPC_CSTR * MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupDeleteW(
        unsigned long GroupNameSyntax,
        RPC_WSTR GroupName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrAddW(
        unsigned long GroupNameSyntax,
        RPC_WSTR GroupName,
        unsigned long MemberNameSyntax,
        RPC_WSTR MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrRemoveW(
        unsigned long GroupNameSyntax,
        RPC_WSTR GroupName,
        unsigned long MemberNameSyntax,
        RPC_WSTR MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqBeginW(
        unsigned long GroupNameSyntax,
        RPC_WSTR GroupName,
        unsigned long MemberNameSyntax,
        RPC_NS_HANDLE* InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqNextW(
        RPC_NS_HANDLE InquiryContext,
        RPC_WSTR * MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqDone(
        RPC_NS_HANDLE * InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileDeleteA(
        unsigned long ProfileNameSyntax,
        RPC_CSTR ProfileName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltAddA(
        unsigned long ProfileNameSyntax,
        RPC_CSTR ProfileName,
        RPC_IF_ID* IfId,
        unsigned long MemberNameSyntax,
        RPC_CSTR MemberName,
        unsigned long Priority,
        RPC_CSTR Annotation);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltRemoveA(
        unsigned long ProfileNameSyntax,
        RPC_CSTR ProfileName,
        RPC_IF_ID* IfId,
        unsigned long MemberNameSyntax,
        RPC_CSTR MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqBeginA(
        unsigned long ProfileNameSyntax,
        RPC_CSTR ProfileName,
        unsigned long InquiryType,
        RPC_IF_ID* IfId,
        unsigned long VersOption,
        unsigned long MemberNameSyntax,
        RPC_CSTR MemberName,
        RPC_NS_HANDLE* InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqNextA(
        RPC_NS_HANDLE InquiryContext,
        RPC_IF_ID * IfId,
        RPC_CSTR * MemberName,
        unsigned long* Priority,
        RPC_CSTR* Annotation);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileDeleteW(
        unsigned long ProfileNameSyntax,
        RPC_WSTR ProfileName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltAddW(
        unsigned long ProfileNameSyntax,
        RPC_WSTR ProfileName,
        RPC_IF_ID* IfId,
        unsigned long MemberNameSyntax,
        RPC_WSTR MemberName,
        unsigned long Priority,
        RPC_WSTR Annotation);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltRemoveW(
        unsigned long ProfileNameSyntax,
        RPC_WSTR ProfileName,
        RPC_IF_ID* IfId,
        unsigned long MemberNameSyntax,
        RPC_WSTR MemberName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqBeginW(
        unsigned long ProfileNameSyntax,
        RPC_WSTR ProfileName,
        unsigned long InquiryType,
        RPC_IF_ID* IfId,
        unsigned long VersOption,
        unsigned long MemberNameSyntax,
        RPC_WSTR MemberName,
        RPC_NS_HANDLE* InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqNextW(
        RPC_NS_HANDLE InquiryContext,
        RPC_IF_ID * IfId,
        RPC_WSTR * MemberName,
        unsigned long* Priority,
        RPC_WSTR* Annotation);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqDone(
        RPC_NS_HANDLE * InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryObjectInqBeginA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_NS_HANDLE* InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryObjectInqBeginW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_NS_HANDLE* InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryObjectInqNext(
        RPC_NS_HANDLE InquiryContext,
        UUID * ObjUuid);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryObjectInqDone(
        RPC_NS_HANDLE * InquiryContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryExpandNameA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_CSTR* ExpandedName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtBindingUnexportA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_ID* IfId,
        unsigned long VersOption,
        UUID_VECTOR* ObjectUuidVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryCreateA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryDeleteA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryInqIfIdsA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_ID_VECTOR** IfIdVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtHandleSetExpAge(
        RPC_NS_HANDLE NsHandle,
        unsigned long ExpirationAge);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtInqExpAge(
        unsigned long* ExpirationAge);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtSetExpAge(
        unsigned long ExpirationAge);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryExpandNameW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_WSTR* ExpandedName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtBindingUnexportW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_ID* IfId,
        unsigned long VersOption,
        UUID_VECTOR* ObjectUuidVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryCreateW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryDeleteW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryInqIfIdsW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_ID_VECTOR** IfIdVec);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportBeginA(
        unsigned long EntryNameSyntax,
        RPC_CSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID* ObjUuid,
        RPC_NS_HANDLE* ImportContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportBeginW(
        unsigned long EntryNameSyntax,
        RPC_WSTR EntryName,
        RPC_IF_HANDLE IfSpec,
        UUID* ObjUuid,
        RPC_NS_HANDLE* ImportContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportNext(
        RPC_NS_HANDLE ImportContext,
        RPC_BINDING_HANDLE * Binding);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportDone(
        RPC_NS_HANDLE * ImportContext);
    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingSelect(
        RPC_BINDING_VECTOR * BindingVec,
        RPC_BINDING_HANDLE * Binding);
#pragma endregion
#pragma once
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma warning(pop)
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma once
#pragma warning(disable : 4103)
#pragma pack(push, 8)
    extern "C" {
#pragma region Application Family or OneCore Family
#pragma warning(push)
#pragma warning(disable : 4820)
    typedef enum _RPC_NOTIFICATION_TYPES {
        RpcNotificationTypeNone,
        RpcNotificationTypeEvent,
        RpcNotificationTypeApc,
        RpcNotificationTypeIoc,
        RpcNotificationTypeHwnd,
        RpcNotificationTypeCallback
    } RPC_NOTIFICATION_TYPES;
    typedef enum _RPC_ASYNC_EVENT {
        RpcCallComplete,
        RpcSendComplete,
        RpcReceiveComplete,
        RpcClientDisconnect,
        RpcClientCancel
    } RPC_ASYNC_EVENT;
    struct _RPC_ASYNC_STATE;
    typedef void __stdcall RPCNOTIFICATION_ROUTINE(
        struct _RPC_ASYNC_STATE* pAsync,
        void* Context,
        RPC_ASYNC_EVENT Event);
    typedef RPCNOTIFICATION_ROUTINE* PFN_RPCNOTIFICATION_ROUTINE;
    typedef union _RPC_ASYNC_NOTIFICATION_INFO {
        struct {
            PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
            HANDLE hThread;
        } APC;
        struct {
            HANDLE hIOPort;
            DWORD dwNumberOfBytesTransferred;
            DWORD_PTR dwCompletionKey;
            LPOVERLAPPED lpOverlapped;
        } IOC;
        struct {
            HWND hWnd;
            UINT Msg;
        } HWND;
        HANDLE hEvent;
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
    } RPC_ASYNC_NOTIFICATION_INFO, *PRPC_ASYNC_NOTIFICATION_INFO;
    typedef struct _RPC_ASYNC_STATE {
        unsigned int Size;
        unsigned long Signature;
        long Lock;
        unsigned long Flags;
        void* StubInfo;
        void* UserInfo;
        void* RuntimeInfo;
        RPC_ASYNC_EVENT Event;
        RPC_NOTIFICATION_TYPES NotificationType;
        RPC_ASYNC_NOTIFICATION_INFO u;
        LONG_PTR Reserved[4];
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncRegisterInfo(
            PRPC_ASYNC_STATE pAsync);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncInitializeHandle(
            PRPC_ASYNC_STATE pAsync,
            unsigned int Size);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncGetCallStatus(
            PRPC_ASYNC_STATE pAsync);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncCompleteCall(
            PRPC_ASYNC_STATE pAsync,
            void* Reply);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncAbortCall(
            PRPC_ASYNC_STATE pAsync,
            unsigned long ExceptionCode);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncCancelCall(
            PRPC_ASYNC_STATE pAsync,
            BOOL fAbort);
    typedef enum tagExtendedErrorParamTypes {
        eeptAnsiString = 1,
        eeptUnicodeString,
        eeptLongVal,
        eeptShortVal,
        eeptPointerVal,
        eeptNone,
        eeptBinary
    } ExtendedErrorParamTypes;
    typedef struct tagBinaryParam {
        void* Buffer;
        short Size;
    } BinaryParam;
    typedef struct tagRPC_EE_INFO_PARAM {
        ExtendedErrorParamTypes ParameterType;
        union {
            LPSTR AnsiString;
            LPWSTR UnicodeString;
            long LVal;
            short SVal;
            ULONGLONG PVal;
            BinaryParam BVal;
        } u;
    } RPC_EE_INFO_PARAM;
    typedef struct tagRPC_EXTENDED_ERROR_INFO {
        ULONG Version;
        LPWSTR ComputerName;
        ULONG ProcessID;
        union {
            SYSTEMTIME SystemTime;
            FILETIME FileTime;
        } u;
        ULONG GeneratingComponent;
        ULONG Status;
        USHORT DetectionLocation;
        USHORT Flags;
        int NumberOfParameters;
        RPC_EE_INFO_PARAM Parameters[4];
    } RPC_EXTENDED_ERROR_INFO;
    typedef struct tagRPC_ERROR_ENUM_HANDLE {
        ULONG Signature;
        void* CurrentPos;
        void* Head;
    } RPC_ERROR_ENUM_HANDLE;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorStartEnumeration(
            RPC_ERROR_ENUM_HANDLE* EnumHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorGetNextRecord(
            RPC_ERROR_ENUM_HANDLE* EnumHandle,
            BOOL CopyStrings,
            RPC_EXTENDED_ERROR_INFO* ErrorInfo);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorEndEnumeration(
            RPC_ERROR_ENUM_HANDLE* EnumHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorResetEnumeration(
            RPC_ERROR_ENUM_HANDLE* EnumHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorGetNumberOfRecords(
            RPC_ERROR_ENUM_HANDLE* EnumHandle,
            int* Records);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorSaveErrorInfo(
            RPC_ERROR_ENUM_HANDLE* EnumHandle,
            PVOID* ErrorBlob,
            size_t* BlobSize);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorLoadErrorInfo(
            PVOID ErrorBlob,
            size_t BlobSize,
            RPC_ERROR_ENUM_HANDLE* EnumHandle);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcErrorAddRecord(
            RPC_EXTENDED_ERROR_INFO* ErrorInfo);
    __declspec(dllimport) void __stdcall RpcErrorClearInformation(
        void);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcAsyncCleanupThread(
            DWORD dwTimeout);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcGetAuthorizationContextForClient(
            RPC_BINDING_HANDLE ClientBinding,
            BOOL ImpersonateOnReturn,
            PVOID Reserved1,
            PLARGE_INTEGER pExpirationTime,
            LUID Reserved2,
            DWORD Reserved3,
            PVOID Reserved4,
            PVOID* pAuthzClientContext);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcFreeAuthorizationContext(
            PVOID* pAuthzClientContext);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcSsContextLockExclusive(
            RPC_BINDING_HANDLE ServerBindingHandle,
            PVOID UserContext);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcSsContextLockShared(
            RPC_BINDING_HANDLE ServerBindingHandle,
            PVOID UserContext);
    typedef enum tagRpcLocalAddressFormat {
        rlafInvalid = 0,
        rlafIPv4,
        rlafIPv6
    } RpcLocalAddressFormat;
    typedef struct _RPC_CALL_LOCAL_ADDRESS_V1 {
        unsigned int Version;
        void* Buffer;
        unsigned long BufferSize;
        RpcLocalAddressFormat AddressFormat;
    } RPC_CALL_LOCAL_ADDRESS_V1, *PRPC_CALL_LOCAL_ADDRESS_V1;
    typedef struct tagRPC_CALL_ATTRIBUTES_V1_W {
        unsigned int Version;
        unsigned long Flags;
        unsigned long ServerPrincipalNameBufferLength;
        unsigned short* ServerPrincipalName;
        unsigned long ClientPrincipalNameBufferLength;
        unsigned short* ClientPrincipalName;
        unsigned long AuthenticationLevel;
        unsigned long AuthenticationService;
        BOOL NullSession;
    } RPC_CALL_ATTRIBUTES_V1_W;
    typedef struct tagRPC_CALL_ATTRIBUTES_V1_A {
        unsigned int Version;
        unsigned long Flags;
        unsigned long ServerPrincipalNameBufferLength;
        unsigned char* ServerPrincipalName;
        unsigned long ClientPrincipalNameBufferLength;
        unsigned char* ClientPrincipalName;
        unsigned long AuthenticationLevel;
        unsigned long AuthenticationService;
        BOOL NullSession;
    } RPC_CALL_ATTRIBUTES_V1_A;
    typedef enum tagRpcCallType {
        rctInvalid = 0,
        rctNormal,
        rctTraining,
        rctGuaranteed
    } RpcCallType;
    typedef enum tagRpcCallClientLocality {
        rcclInvalid = 0,
        rcclLocal,
        rcclRemote,
        rcclClientUnknownLocality
    } RpcCallClientLocality;
    typedef struct tagRPC_CALL_ATTRIBUTES_V2_W {
        unsigned int Version;
        unsigned long Flags;
        unsigned long ServerPrincipalNameBufferLength;
        unsigned short* ServerPrincipalName;
        unsigned long ClientPrincipalNameBufferLength;
        unsigned short* ClientPrincipalName;
        unsigned long AuthenticationLevel;
        unsigned long AuthenticationService;
        BOOL NullSession;
        BOOL KernelModeCaller;
        unsigned long ProtocolSequence;
        RpcCallClientLocality IsClientLocal;
        HANDLE ClientPID;
        unsigned long CallStatus;
        RpcCallType CallType;
        RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
        unsigned short OpNum;
        UUID InterfaceUuid;
    } RPC_CALL_ATTRIBUTES_V2_W;
    typedef struct tagRPC_CALL_ATTRIBUTES_V2_A {
        unsigned int Version;
        unsigned long Flags;
        unsigned long ServerPrincipalNameBufferLength;
        unsigned char* ServerPrincipalName;
        unsigned long ClientPrincipalNameBufferLength;
        unsigned char* ClientPrincipalName;
        unsigned long AuthenticationLevel;
        unsigned long AuthenticationService;
        BOOL NullSession;
        BOOL KernelModeCaller;
        unsigned long ProtocolSequence;
        unsigned long IsClientLocal;
        HANDLE ClientPID;
        unsigned long CallStatus;
        RpcCallType CallType;
        RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
        unsigned short OpNum;
        UUID InterfaceUuid;
    } RPC_CALL_ATTRIBUTES_V2_A;
    typedef struct tagRPC_CALL_ATTRIBUTES_V3_W {
        unsigned int Version;
        unsigned long Flags;
        unsigned long ServerPrincipalNameBufferLength;
        unsigned short* ServerPrincipalName;
        unsigned long ClientPrincipalNameBufferLength;
        unsigned short* ClientPrincipalName;
        unsigned long AuthenticationLevel;
        unsigned long AuthenticationService;
        BOOL NullSession;
        BOOL KernelModeCaller;
        unsigned long ProtocolSequence;
        RpcCallClientLocality IsClientLocal;
        HANDLE ClientPID;
        unsigned long CallStatus;
        RpcCallType CallType;
        RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
        unsigned short OpNum;
        UUID InterfaceUuid;
        unsigned long ClientIdentifierBufferLength;
        unsigned char* ClientIdentifier;
    } RPC_CALL_ATTRIBUTES_V3_W;
    typedef struct tagRPC_CALL_ATTRIBUTES_V3_A {
        unsigned int Version;
        unsigned long Flags;
        unsigned long ServerPrincipalNameBufferLength;
        unsigned char* ServerPrincipalName;
        unsigned long ClientPrincipalNameBufferLength;
        unsigned char* ClientPrincipalName;
        unsigned long AuthenticationLevel;
        unsigned long AuthenticationService;
        BOOL NullSession;
        BOOL KernelModeCaller;
        unsigned long ProtocolSequence;
        unsigned long IsClientLocal;
        HANDLE ClientPID;
        unsigned long CallStatus;
        RpcCallType CallType;
        RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
        unsigned short OpNum;
        UUID InterfaceUuid;
        unsigned long ClientIdentifierBufferLength;
        unsigned char* ClientIdentifier;
    } RPC_CALL_ATTRIBUTES_V3_A;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqCallAttributesW(
            RPC_BINDING_HANDLE ClientBinding,
            void* RpcCallAttributes);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerInqCallAttributesA(
            RPC_BINDING_HANDLE ClientBinding,
            void* RpcCallAttributes);
    typedef RPC_CALL_ATTRIBUTES_V3_W RPC_CALL_ATTRIBUTES;
    typedef enum _RPC_NOTIFICATIONS {
        RpcNotificationCallNone = 0,
        RpcNotificationClientDisconnect = 1,
        RpcNotificationCallCancel = 2
    } RPC_NOTIFICATIONS;
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerSubscribeForNotification(
            RPC_BINDING_HANDLE Binding,
            RPC_NOTIFICATIONS Notification,
            RPC_NOTIFICATION_TYPES NotificationType,
            RPC_ASYNC_NOTIFICATION_INFO* NotificationInfo);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcServerUnsubscribeForNotification(
            RPC_BINDING_HANDLE Binding,
            RPC_NOTIFICATIONS Notification,
            unsigned long* NotificationsQueued);
#pragma endregion
#pragma region Application Family or OneCore Family
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingBind(
            PRPC_ASYNC_STATE pAsync,
            RPC_BINDING_HANDLE Binding,
            RPC_IF_HANDLE IfSpec);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall RpcBindingUnbind(
            RPC_BINDING_HANDLE Binding);
#pragma endregion
#pragma region Desktop Family or OneCore Family
    RPC_STATUS __stdcall I_RpcAsyncSetHandle(
        PRPC_MESSAGE Message,
        PRPC_ASYNC_STATE pAsync);
    RPC_STATUS __stdcall I_RpcAsyncAbortCall(
        PRPC_ASYNC_STATE pAsync,
        unsigned long ExceptionCode);
    int __stdcall I_RpcExceptionFilter(
        unsigned long ExceptionCode);
    __declspec(dllimport)
        RPC_STATUS
        __stdcall I_RpcBindingInqClientTokenAttributes(
            RPC_BINDING_HANDLE Binding,
            LUID* TokenId,
            LUID* AuthenticationId,
            LUID* ModifiedId);
#pragma warning(pop)
#pragma endregion
    }
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma warning(disable : 4103)
#pragma pack(pop)
}
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4255)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
#pragma once
#pragma warning(disable : 4103)
#pragma pack(push, 8)
#pragma once
extern "C" {
#pragma region Desktop Family
typedef struct
{
    RPC_NS_HANDLE LookupContext;
    RPC_BINDING_HANDLE ProposedHandle;
    RPC_BINDING_VECTOR* Bindings;
} RPC_IMPORT_CONTEXT_P, *PRPC_IMPORT_CONTEXT_P;
__declspec(dllimport)
    RPC_STATUS
    __stdcall I_RpcNsGetBuffer(
        PRPC_MESSAGE Message);
__declspec(dllimport)
    RPC_STATUS
    __stdcall I_RpcNsSendReceive(
        PRPC_MESSAGE Message,
        RPC_BINDING_HANDLE* Handle);
__declspec(dllimport) void __stdcall I_RpcNsRaiseException(
    PRPC_MESSAGE Message,
    RPC_STATUS Status);
__declspec(dllimport)
    RPC_STATUS
    __stdcall I_RpcReBindBuffer(
        PRPC_MESSAGE Message);
__declspec(dllimport)
    RPC_STATUS
    __stdcall I_NsServerBindSearch(
        void);
__declspec(dllimport)
    RPC_STATUS
    __stdcall I_NsClientBindSearch(
        void);
__declspec(dllimport) void __stdcall I_NsClientBindDone(
    void);
#pragma endregion
}
#pragma once
extern "C" {
}
extern "C" {
#pragma region Application Family or OneCore Family or Games Family
typedef unsigned char byte;
typedef byte cs_byte;
typedef unsigned char boolean;
void* __stdcall MIDL_user_allocate(size_t size);
void __stdcall MIDL_user_free(void*);
void* __stdcall I_RpcDefaultAllocate(
    handle_t bh, size_t size, void* (*RealAlloc)(size_t));
void __stdcall I_RpcDefaultFree(
    handle_t bh, void*, void (*RealFree)(void*));
typedef void* NDR_CCONTEXT;
typedef struct _NDR_SCONTEXT {
    void* pad[2];
    void* userContext;
} * NDR_SCONTEXT;
typedef void(__stdcall* NDR_RUNDOWN)(void* context);
typedef void(__stdcall* NDR_NOTIFY_ROUTINE)(void);
typedef void(__stdcall* NDR_NOTIFY2_ROUTINE)(boolean flag);
typedef struct _SCONTEXT_QUEUE {
    unsigned long NumberOfObjects;
    NDR_SCONTEXT* ArrayOfObjects;
} SCONTEXT_QUEUE, *PSCONTEXT_QUEUE;
__declspec(dllimport)
    RPC_BINDING_HANDLE
    __stdcall NDRCContextBinding(
        NDR_CCONTEXT CContext);
__declspec(dllimport) void __stdcall NDRCContextMarshall(
    NDR_CCONTEXT CContext,
    void* pBuff);
__declspec(dllimport) void __stdcall NDRCContextUnmarshall(
    NDR_CCONTEXT* pCContext,
    RPC_BINDING_HANDLE hBinding,
    void* pBuff,
    unsigned long DataRepresentation);
__declspec(dllimport) void __stdcall NDRCContextUnmarshall2(
    NDR_CCONTEXT* pCContext,
    RPC_BINDING_HANDLE hBinding,
    void* pBuff,
    unsigned long DataRepresentation);
__declspec(dllimport) void __stdcall NDRSContextMarshall(
    NDR_SCONTEXT CContext,
    void* pBuff,
    NDR_RUNDOWN userRunDownIn);
__declspec(dllimport)
    NDR_SCONTEXT
    __stdcall NDRSContextUnmarshall(
        void* pBuff,
        unsigned long DataRepresentation);
__declspec(dllimport) void __stdcall NDRSContextMarshallEx(
    RPC_BINDING_HANDLE BindingHandle,
    NDR_SCONTEXT CContext,
    void* pBuff,
    NDR_RUNDOWN userRunDownIn);
__declspec(dllimport) void __stdcall NDRSContextMarshall2(
    RPC_BINDING_HANDLE BindingHandle,
    NDR_SCONTEXT CContext,
    void* pBuff,
    NDR_RUNDOWN userRunDownIn,
    void* CtxGuard,
    unsigned long Flags);
__declspec(dllimport)
    NDR_SCONTEXT
    __stdcall NDRSContextUnmarshallEx(
        RPC_BINDING_HANDLE BindingHandle,
        void* pBuff,
        unsigned long DataRepresentation);
__declspec(dllimport)
    NDR_SCONTEXT
    __stdcall NDRSContextUnmarshall2(
        RPC_BINDING_HANDLE BindingHandle,
        void* pBuff,
        unsigned long DataRepresentation,
        void* CtxGuard,
        unsigned long Flags);
__declspec(dllimport) void __stdcall RpcSsDestroyClientContext(
    void** ContextHandle);
typedef unsigned long error_status_t;
struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;
typedef unsigned char* RPC_BUFPTR;
typedef unsigned long RPC_LENGTH;
typedef void(__stdcall* EXPR_EVAL)(struct _MIDL_STUB_MESSAGE*);
typedef const unsigned char* PFORMAT_STRING;
typedef struct
{
    long Dimension;
    unsigned long* BufferConformanceMark;
    unsigned long* BufferVarianceMark;
    unsigned long* MaxCountArray;
    unsigned long* OffsetArray;
    unsigned long* ActualCountArray;
} ARRAY_INFO, *PARRAY_INFO;
typedef struct _NDR_ASYNC_MESSAGE* PNDR_ASYNC_MESSAGE;
typedef struct _NDR_CORRELATION_INFO* PNDR_CORRELATION_INFO;
typedef const unsigned char* PFORMAT_STRING;
typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;
struct NDR_ALLOC_ALL_NODES_CONTEXT;
struct NDR_POINTER_QUEUE_STATE;
struct _NDR_PROC_CONTEXT;
typedef struct _MIDL_STUB_MESSAGE {
    PRPC_MESSAGE RpcMsg;
    unsigned char* Buffer;
    unsigned char* BufferStart;
    unsigned char* BufferEnd;
    unsigned char* BufferMark;
    unsigned long BufferLength;
    unsigned long MemorySize;
    unsigned char* Memory;
    unsigned char IsClient;
    unsigned char Pad;
    unsigned short uFlags2;
    int ReuseBuffer;
    struct NDR_ALLOC_ALL_NODES_CONTEXT* pAllocAllNodesContext;
    struct NDR_POINTER_QUEUE_STATE* pPointerQueueState;
    int IgnoreEmbeddedPointers;
    unsigned char* PointerBufferMark;
    unsigned char CorrDespIncrement;
    unsigned char uFlags;
    unsigned short UniquePtrCount;
    ULONG_PTR MaxCount;
    unsigned long Offset;
    unsigned long ActualCount;
    void*(__stdcall* pfnAllocate)(size_t);
    void(__stdcall* pfnFree)(void*);
    unsigned char* StackTop;
    unsigned char* pPresentedType;
    unsigned char* pTransmitType;
    handle_t SavedHandle;
    const struct _MIDL_STUB_DESC* StubDesc;
    struct _FULL_PTR_XLAT_TABLES* FullPtrXlatTables;
    unsigned long FullPtrRefId;
    unsigned long PointerLength;
    int fInDontFree : 1;
    int fDontCallFreeInst : 1;
    int fUnused1 : 1;
    int fHasReturn : 1;
    int fHasExtensions : 1;
    int fHasNewCorrDesc : 1;
    int fIsIn : 1;
    int fIsOut : 1;
    int fIsOicf : 1;
    int fBufferValid : 1;
    int fHasMemoryValidateCallback : 1;
    int fInFree : 1;
    int fNeedMCCP : 1;
    int fUnused2 : 3;
    int fUnused3 : 16;
    unsigned long dwDestContext;
    void* pvDestContext;
    NDR_SCONTEXT* SavedContextHandles;
    long ParamNumber;
    struct IRpcChannelBuffer* pRpcChannelBuffer;
    PARRAY_INFO pArrayInfo;
    unsigned long* SizePtrCountArray;
    unsigned long* SizePtrOffsetArray;
    unsigned long* SizePtrLengthArray;
    void* pArgQueue;
    unsigned long dwStubPhase;
    void* LowStackMark;
    PNDR_ASYNC_MESSAGE pAsyncMsg;
    PNDR_CORRELATION_INFO pCorrInfo;
    unsigned char* pCorrMemory;
    void* pMemoryList;
    INT_PTR pCSInfo;
    unsigned char* ConformanceMark;
    unsigned char* VarianceMark;
    INT_PTR Unused;
    struct _NDR_PROC_CONTEXT* pContext;
    void* ContextHandleHash;
    void* pUserMarshalList;
    INT_PTR Reserved51_3;
    INT_PTR Reserved51_4;
    INT_PTR Reserved51_5;
} MIDL_STUB_MESSAGE, *PMIDL_STUB_MESSAGE;
typedef struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE, *PMIDL_STUB_MESSAGE;
typedef void*(__stdcall* GENERIC_BINDING_ROUTINE)(void*);
typedef void(__stdcall* GENERIC_UNBIND_ROUTINE)(void*, unsigned char*);
typedef struct _GENERIC_BINDING_ROUTINE_PAIR {
    GENERIC_BINDING_ROUTINE pfnBind;
    GENERIC_UNBIND_ROUTINE pfnUnbind;
} GENERIC_BINDING_ROUTINE_PAIR, *PGENERIC_BINDING_ROUTINE_PAIR;
typedef struct __GENERIC_BINDING_INFO {
    void* pObj;
    unsigned int Size;
    GENERIC_BINDING_ROUTINE pfnBind;
    GENERIC_UNBIND_ROUTINE pfnUnbind;
} GENERIC_BINDING_INFO, *PGENERIC_BINDING_INFO;
typedef void(__stdcall* XMIT_HELPER_ROUTINE)(PMIDL_STUB_MESSAGE);
typedef struct _XMIT_ROUTINE_QUINTUPLE {
    XMIT_HELPER_ROUTINE pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE pfnFreeXmit;
    XMIT_HELPER_ROUTINE pfnFreeInst;
} XMIT_ROUTINE_QUINTUPLE, *PXMIT_ROUTINE_QUINTUPLE;
typedef unsigned long(__stdcall* USER_MARSHAL_SIZING_ROUTINE)(unsigned long*,
    unsigned long,
    void*);
typedef unsigned char*(__stdcall* USER_MARSHAL_MARSHALLING_ROUTINE)(unsigned long*,
    unsigned char*,
    void*);
typedef unsigned char*(__stdcall* USER_MARSHAL_UNMARSHALLING_ROUTINE)(unsigned long*,
    unsigned char*,
    void*);
typedef void(__stdcall* USER_MARSHAL_FREEING_ROUTINE)(unsigned long*,
    void*);
typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE {
    USER_MARSHAL_SIZING_ROUTINE pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE pfnFree;
} USER_MARSHAL_ROUTINE_QUADRUPLE;
typedef enum _USER_MARSHAL_CB_TYPE {
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE
} USER_MARSHAL_CB_TYPE;
typedef struct _USER_MARSHAL_CB {
    unsigned long Flags;
    PMIDL_STUB_MESSAGE pStubMsg;
    PFORMAT_STRING pReserve;
    unsigned long Signature;
    USER_MARSHAL_CB_TYPE CBType;
    PFORMAT_STRING pFormat;
    PFORMAT_STRING pTypeFormat;
} USER_MARSHAL_CB;
typedef struct _MALLOC_FREE_STRUCT {
    void*(__stdcall* pfnAllocate)(size_t);
    void(__stdcall* pfnFree)(void*);
} MALLOC_FREE_STRUCT;
typedef struct _COMM_FAULT_OFFSETS {
    short CommOffset;
    short FaultOffset;
} COMM_FAULT_OFFSETS;
typedef enum _IDL_CS_CONVERT {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT
} IDL_CS_CONVERT;
typedef void(__stdcall* CS_TYPE_NET_SIZE_ROUTINE)(RPC_BINDING_HANDLE hBinding,
    unsigned long ulNetworkCodeSet,
    unsigned long ulLocalBufferSize,
    IDL_CS_CONVERT* conversionType,
    unsigned long* pulNetworkBufferSize,
    error_status_t* pStatus);
typedef void(__stdcall* CS_TYPE_LOCAL_SIZE_ROUTINE)(RPC_BINDING_HANDLE hBinding,
    unsigned long ulNetworkCodeSet,
    unsigned long ulNetworkBufferSize,
    IDL_CS_CONVERT* conversionType,
    unsigned long* pulLocalBufferSize,
    error_status_t* pStatus);
typedef void(__stdcall* CS_TYPE_TO_NETCS_ROUTINE)(RPC_BINDING_HANDLE hBinding,
    unsigned long ulNetworkCodeSet,
    void* pLocalData,
    unsigned long ulLocalDataLength,
    byte* pNetworkData,
    unsigned long* pulNetworkDataLength,
    error_status_t* pStatus);
typedef void(__stdcall* CS_TYPE_FROM_NETCS_ROUTINE)(RPC_BINDING_HANDLE hBinding,
    unsigned long ulNetworkCodeSet,
    byte* pNetworkData,
    unsigned long ulNetworkDataLength,
    unsigned long ulLocalBufferSize,
    void* pLocalData,
    unsigned long* pulLocalDataLength,
    error_status_t* pStatus);
typedef void(__stdcall* CS_TAG_GETTING_ROUTINE)(RPC_BINDING_HANDLE hBinding,
    int fServerSide,
    unsigned long* pulSendingTag,
    unsigned long* pulDesiredReceivingTag,
    unsigned long* pulReceivingTag,
    error_status_t* pStatus);
void __stdcall RpcCsGetTags(
    RPC_BINDING_HANDLE hBinding,
    int fServerSide,
    unsigned long* pulSendingTag,
    unsigned long* pulDesiredReceivingTag,
    unsigned long* pulReceivingTag,
    error_status_t* pStatus);
typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES {
    CS_TYPE_NET_SIZE_ROUTINE pfnNetSize;
    CS_TYPE_TO_NETCS_ROUTINE pfnToNetCs;
    CS_TYPE_LOCAL_SIZE_ROUTINE pfnLocalSize;
    CS_TYPE_FROM_NETCS_ROUTINE pfnFromNetCs;
} NDR_CS_SIZE_CONVERT_ROUTINES;
typedef struct _NDR_CS_ROUTINES {
    NDR_CS_SIZE_CONVERT_ROUTINES* pSizeConvertRoutines;
    CS_TAG_GETTING_ROUTINE* pTagGettingRoutines;
} NDR_CS_ROUTINES;
typedef struct _NDR_EXPR_DESC {
    const unsigned short* pOffset;
    PFORMAT_STRING pFormatExpr;
} NDR_EXPR_DESC;
typedef struct _MIDL_STUB_DESC {
    void* RpcInterfaceInformation;
    void*(__stdcall* pfnAllocate)(size_t);
    void(__stdcall* pfnFree)(void*);
    union {
        handle_t* pAutoHandle;
        handle_t* pPrimitiveHandle;
        PGENERIC_BINDING_INFO pGenericBindingInfo;
    } IMPLICIT_HANDLE_INFO;
    const NDR_RUNDOWN* apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR* aGenericBindingRoutinePairs;
    const EXPR_EVAL* apfnExprEval;
    const XMIT_ROUTINE_QUINTUPLE* aXmitQuintuple;
    const unsigned char* pFormatTypes;
    int fCheckBounds;
    unsigned long Version;
    MALLOC_FREE_STRUCT* pMallocFreeStruct;
    long MIDLVersion;
    const COMM_FAULT_OFFSETS* CommFaultOffsets;
    const USER_MARSHAL_ROUTINE_QUADRUPLE* aUserMarshalQuadruple;
    const NDR_NOTIFY_ROUTINE* NotifyRoutineTable;
    ULONG_PTR mFlags;
    const NDR_CS_ROUTINES* CsRoutineTables;
    void* ProxyServerInfo;
    const NDR_EXPR_DESC* pExprInfo;
} MIDL_STUB_DESC;
typedef const MIDL_STUB_DESC* PMIDL_STUB_DESC;
typedef void* PMIDL_XMIT_TYPE;
#pragma warning(push)
#pragma warning(disable : 4200)
typedef struct _MIDL_FORMAT_STRING {
    short Pad;
    unsigned char Format[];
} MIDL_FORMAT_STRING;
#pragma warning(pop)
typedef void(__stdcall* STUB_THUNK)(PMIDL_STUB_MESSAGE);
typedef long(__stdcall* SERVER_ROUTINE)();
typedef struct _MIDL_METHOD_PROPERTY {
    unsigned long Id;
    ULONG_PTR Value;
} MIDL_METHOD_PROPERTY, *PMIDL_METHOD_PROPERTY;
typedef struct _MIDL_METHOD_PROPERTY_MAP {
    unsigned long Count;
    const MIDL_METHOD_PROPERTY* Properties;
} MIDL_METHOD_PROPERTY_MAP, *PMIDL_METHOD_PROPERTY_MAP;
typedef struct _MIDL_INTERFACE_METHOD_PROPERTIES {
    unsigned short MethodCount;
    const MIDL_METHOD_PROPERTY_MAP* const* MethodProperties;
} MIDL_INTERFACE_METHOD_PROPERTIES;
typedef struct _MIDL_SERVER_INFO_ {
    PMIDL_STUB_DESC pStubDesc;
    const SERVER_ROUTINE* DispatchTable;
    PFORMAT_STRING ProcString;
    const unsigned short* FmtStringOffset;
    const STUB_THUNK* ThunkTable;
    PRPC_SYNTAX_IDENTIFIER pTransferSyntax;
    ULONG_PTR nCount;
    PMIDL_SYNTAX_INFO pSyntaxInfo;
} MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;
typedef struct _MIDL_STUBLESS_PROXY_INFO {
    PMIDL_STUB_DESC pStubDesc;
    PFORMAT_STRING ProcFormatString;
    const unsigned short* FormatStringOffset;
    PRPC_SYNTAX_IDENTIFIER pTransferSyntax;
    ULONG_PTR nCount;
    PMIDL_SYNTAX_INFO pSyntaxInfo;
} MIDL_STUBLESS_PROXY_INFO;
typedef MIDL_STUBLESS_PROXY_INFO* PMIDL_STUBLESS_PROXY_INFO;
typedef struct _MIDL_SYNTAX_INFO {
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    RPC_DISPATCH_TABLE* DispatchTable;
    PFORMAT_STRING ProcString;
    const unsigned short* FmtStringOffset;
    PFORMAT_STRING TypeString;
    const void* aUserMarshalQuadruple;
    const MIDL_INTERFACE_METHOD_PROPERTIES* pMethodProperties;
    ULONG_PTR pReserved2;
} MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;
typedef unsigned short *PARAM_OFFSETTABLE, *PPARAM_OFFSETTABLE;
typedef union _CLIENT_CALL_RETURN {
    void* Pointer;
    LONG_PTR Simple;
} CLIENT_CALL_RETURN;
typedef enum {
    XLAT_SERVER = 1,
    XLAT_CLIENT
} XLAT_SIDE;
typedef struct _FULL_PTR_XLAT_TABLES {
    void* RefIdToPointer;
    void* PointerToRefId;
    unsigned long NextRefId;
    XLAT_SIDE XlatSide;
} FULL_PTR_XLAT_TABLES, *PFULL_PTR_XLAT_TABLES;
typedef enum _system_handle_t {
    SYSTEM_HANDLE_FILE = 0,
    SYSTEM_HANDLE_SEMAPHORE = 1,
    SYSTEM_HANDLE_EVENT = 2,
    SYSTEM_HANDLE_MUTEX = 3,
    SYSTEM_HANDLE_PROCESS = 4,
    SYSTEM_HANDLE_TOKEN = 5,
    SYSTEM_HANDLE_SECTION = 6,
    SYSTEM_HANDLE_REG_KEY = 7,
    SYSTEM_HANDLE_THREAD = 8,
    SYSTEM_HANDLE_COMPOSITION_OBJECT = 9,
    SYSTEM_HANDLE_SOCKET = 10,
    SYSTEM_HANDLE_JOB = 11,
    SYSTEM_HANDLE_PIPE = 12,
    SYSTEM_HANDLE_MAX = 12,
    SYSTEM_HANDLE_INVALID = 0xFF,
} system_handle_t;
enum {
    MidlInterceptionInfoVersionOne = 1
};
enum {
    MidlWinrtTypeSerializationInfoVersionOne = 1
};
typedef struct _MIDL_INTERCEPTION_INFO {
    unsigned long Version;
    PFORMAT_STRING ProcString;
    const unsigned short* ProcFormatOffsetTable;
    unsigned long ProcCount;
    PFORMAT_STRING TypeString;
} MIDL_INTERCEPTION_INFO, *PMIDL_INTERCEPTION_INFO;
typedef struct _MIDL_WINRT_TYPE_SERIALIZATION_INFO {
    unsigned long Version;
    PFORMAT_STRING TypeFormatString;
    unsigned short FormatStringSize;
    unsigned short TypeOffset;
    PMIDL_STUB_DESC StubDesc;
} MIDL_WINRT_TYPE_SERIALIZATION_INFO, *PMIDL_WINRT_TYPE_SERIALIZATION_INFO;
RPC_STATUS __stdcall NdrClientGetSupportedSyntaxes(
    RPC_CLIENT_INTERFACE* pInf,
    unsigned long* pCount,
    MIDL_SYNTAX_INFO** pArr);
RPC_STATUS __stdcall NdrServerGetSupportedSyntaxes(
    RPC_SERVER_INTERFACE* pInf,
    unsigned long* pCount,
    MIDL_SYNTAX_INFO** pArr,
    unsigned long* pPreferSyntaxIndex);
#pragma warning(push)
#pragma warning(disable : 28740)
__declspec(dllimport) void __stdcall NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    unsigned char FormatChar);
__declspec(dllimport) unsigned char* __stdcall NdrPointerMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrCsArrayMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrCsTagMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    NDR_CCONTEXT ContextHandle,
    int fCheck);
__declspec(dllimport) void __stdcall NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    NDR_SCONTEXT ContextHandle,
    NDR_RUNDOWN RundownRoutine);
__declspec(dllimport) void __stdcall NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    NDR_SCONTEXT ContextHandle,
    NDR_RUNDOWN RundownRoutine,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    unsigned char FormatChar);
__declspec(dllimport) unsigned char* __stdcall NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) void __stdcall NdrCorrelationInitialize(
    PMIDL_STUB_MESSAGE pStubMsg,
    void* pMemory,
    unsigned long CacheSize,
    unsigned long flags);
__declspec(dllimport) void __stdcall NdrCorrelationPass(
    PMIDL_STUB_MESSAGE pStubMsg);
__declspec(dllimport) void __stdcall NdrCorrelationFree(
    PMIDL_STUB_MESSAGE pStubMsg);
__declspec(dllimport) unsigned char* __stdcall NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) unsigned char* __stdcall NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char** ppMemory,
    PFORMAT_STRING pFormat,
    unsigned char fMustAlloc);
__declspec(dllimport) void __stdcall NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    NDR_CCONTEXT* pContextHandle,
    RPC_BINDING_HANDLE BindHandle);
__declspec(dllimport)
    NDR_SCONTEXT
    __stdcall NdrServerContextUnmarshall(
        PMIDL_STUB_MESSAGE pStubMsg);
__declspec(dllimport)
    NDR_SCONTEXT
    __stdcall NdrContextHandleInitialize(
        PMIDL_STUB_MESSAGE pStubMsg,
        PFORMAT_STRING pFormat);
__declspec(dllimport)
    NDR_SCONTEXT
    __stdcall NdrServerContextNewUnmarshall(
        PMIDL_STUB_MESSAGE pStubMsg,
        PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrContextHandleSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrContextHandleMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned long __stdcall NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrPointerFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrCsArrayFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantStructFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrComplexStructFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pMemory,
    PFORMAT_STRING pFormat);
__declspec(dllimport) void __stdcall NdrConvert2(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat,
    long NumberParams);
__declspec(dllimport) void __stdcall NdrConvert(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport) unsigned char* __stdcall NdrUserMarshalSimpleTypeConvert(
    unsigned long* pFlags,
    unsigned char* pBuffer,
    unsigned char FormatChar);
__declspec(dllimport) void __stdcall NdrClientInitializeNew(
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor,
    unsigned int ProcNum);
__declspec(dllimport) unsigned char* __stdcall NdrServerInitializeNew(
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor);
__declspec(dllimport) void __stdcall NdrServerInitializePartial(
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor,
    unsigned long RequestedBufferSize);
__declspec(dllimport) void __stdcall NdrClientInitialize(
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor,
    unsigned int ProcNum);
__declspec(dllimport) unsigned char* __stdcall NdrServerInitialize(
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor);
__declspec(dllimport) unsigned char* __stdcall NdrServerInitializeUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor,
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) void __stdcall NdrServerInitializeMarshall(
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg);
__declspec(dllimport) unsigned char* __stdcall NdrGetBuffer(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned long BufferLength,
    RPC_BINDING_HANDLE Handle);
__declspec(dllimport) unsigned char* __stdcall NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned long BufferLength,
    RPC_BINDING_HANDLE Handle);
__declspec(dllimport) unsigned char* __stdcall NdrSendReceive(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pBufferEnd);
__declspec(dllimport) unsigned char* __stdcall NdrNsSendReceive(
    PMIDL_STUB_MESSAGE pStubMsg,
    unsigned char* pBufferEnd,
    RPC_BINDING_HANDLE* pAutoHandle);
__declspec(dllimport) void __stdcall NdrFreeBuffer(
    PMIDL_STUB_MESSAGE pStubMsg);
__declspec(dllimport)
    HRESULT
    __stdcall NdrGetDcomProtocolVersion(
        PMIDL_STUB_MESSAGE pStubMsg,
        RPC_VERSION* pVersion);
#pragma warning(pop)
CLIENT_CALL_RETURN __cdecl NdrClientCall2(
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...);
CLIENT_CALL_RETURN __cdecl NdrClientCall(
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...);
CLIENT_CALL_RETURN __cdecl NdrAsyncClientCall(
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...);
#pragma endregion
#pragma region Desktop Family or OneCore Family
CLIENT_CALL_RETURN __cdecl NdrDcomAsyncClientCall(
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...);
#pragma endregion
#pragma region Application Family or OneCore Family
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
} STUB_PHASE;
typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
} PROXY_PHASE;
struct IRpcStubBuffer;
__declspec(dllimport) void __stdcall NdrAsyncServerCall(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) long __stdcall NdrAsyncStubCall(
    struct IRpcStubBuffer* pThis,
    struct IRpcChannelBuffer* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) long __stdcall NdrDcomAsyncStubCall(
    struct IRpcStubBuffer* pThis,
    struct IRpcChannelBuffer* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
__declspec(dllimport) long __stdcall NdrStubCall2(
    void* pThis,
    void* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
__declspec(dllimport) void __stdcall NdrServerCall2(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) long __stdcall NdrStubCall(
    void* pThis,
    void* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
__declspec(dllimport) void __stdcall NdrServerCall(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) int __stdcall NdrServerUnmarshall(
    void* pChannel,
    PRPC_MESSAGE pRpcMsg,
    PMIDL_STUB_MESSAGE pStubMsg,
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    void* pParamList);
__declspec(dllimport) void __stdcall NdrServerMarshall(
    void* pThis,
    void* pChannel,
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat);
__declspec(dllimport)
    RPC_STATUS
    __stdcall NdrMapCommAndFaultStatus(
        PMIDL_STUB_MESSAGE pStubMsg,
        unsigned long* pCommStatus,
        unsigned long* pFaultStatus,
        RPC_STATUS Status);
typedef void* RPC_SS_THREAD_HANDLE;
typedef void* __stdcall RPC_CLIENT_ALLOC(
    size_t Size);
typedef void __stdcall RPC_CLIENT_FREE(
    void* Ptr);
__declspec(dllimport) void* __stdcall RpcSsAllocate(
    size_t Size);
__declspec(dllimport) void __stdcall RpcSsDisableAllocate(
    void);
__declspec(dllimport) void __stdcall RpcSsEnableAllocate(
    void);
__declspec(dllimport) void __stdcall RpcSsFree(
    void* NodeToFree);
__declspec(dllimport)
    RPC_SS_THREAD_HANDLE
    __stdcall RpcSsGetThreadHandle(
        void);
__declspec(dllimport) void __stdcall RpcSsSetClientAllocFree(
    RPC_CLIENT_ALLOC* ClientAlloc,
    RPC_CLIENT_FREE* ClientFree);
__declspec(dllimport) void __stdcall RpcSsSetThreadHandle(
    RPC_SS_THREAD_HANDLE Id);
__declspec(dllimport) void __stdcall RpcSsSwapClientAllocFree(
    RPC_CLIENT_ALLOC* ClientAlloc,
    RPC_CLIENT_FREE* ClientFree,
    RPC_CLIENT_ALLOC** OldClientAlloc,
    RPC_CLIENT_FREE** OldClientFree);
__declspec(dllimport) void* __stdcall RpcSmAllocate(
    size_t Size,
    RPC_STATUS* pStatus);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmClientFree(
        void* pNodeToFree);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmDestroyClientContext(
        void** ContextHandle);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmDisableAllocate(
        void);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmEnableAllocate(
        void);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmFree(
        void* NodeToFree);
__declspec(dllimport)
    RPC_SS_THREAD_HANDLE
    __stdcall RpcSmGetThreadHandle(
        RPC_STATUS* pStatus);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmSetClientAllocFree(
        RPC_CLIENT_ALLOC* ClientAlloc,
        RPC_CLIENT_FREE* ClientFree);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmSetThreadHandle(
        RPC_SS_THREAD_HANDLE Id);
__declspec(dllimport)
    RPC_STATUS
    __stdcall RpcSmSwapClientAllocFree(
        RPC_CLIENT_ALLOC* ClientAlloc,
        RPC_CLIENT_FREE* ClientFree,
        RPC_CLIENT_ALLOC** OldClientAlloc,
        RPC_CLIENT_FREE** OldClientFree);
__declspec(dllimport) void __stdcall NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE pMessage);
__declspec(dllimport) void __stdcall NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE pMessage);
__declspec(dllimport) void __stdcall NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE pMessage);
__declspec(dllimport) void* __stdcall NdrRpcSmClientAllocate(
    size_t Size);
__declspec(dllimport) void __stdcall NdrRpcSmClientFree(
    void* NodeToFree);
__declspec(dllimport) void* __stdcall NdrRpcSsDefaultAllocate(
    size_t Size);
__declspec(dllimport) void __stdcall NdrRpcSsDefaultFree(
    void* NodeToFree);
__declspec(dllimport)
    PFULL_PTR_XLAT_TABLES
    __stdcall NdrFullPointerXlatInit(
        unsigned long NumberOfPointers,
        XLAT_SIDE XlatSide);
__declspec(dllimport) void __stdcall NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES pXlatTables);
__declspec(dllimport) void* __stdcall NdrAllocate(
    PMIDL_STUB_MESSAGE pStubMsg,
    size_t Len);
__declspec(dllimport) void __stdcall NdrClearOutParameters(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING pFormat,
    void* ArgAddr);
__declspec(dllimport) void* __stdcall NdrOleAllocate(
    size_t Size);
__declspec(dllimport) void __stdcall NdrOleFree(
    void* NodeToFree);
typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1 {
    void* Buffer;
    unsigned long BufferSize;
    void*(__stdcall* pfnAllocate)(size_t);
    void(__stdcall* pfnFree)(void*);
    struct IRpcChannelBuffer* pRpcChannelBuffer;
    ULONG_PTR Reserved[5];
} NDR_USER_MARSHAL_INFO_LEVEL1;
#pragma warning(push)
#pragma warning(disable : 4201)
typedef struct _NDR_USER_MARSHAL_INFO {
    unsigned long InformationLevel;
    union {
        NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
    };
} NDR_USER_MARSHAL_INFO;
#pragma warning(pop)
RPC_STATUS
__stdcall NdrGetUserMarshalInfo(
    unsigned long* pFlags,
    unsigned long InformationLevel,
    NDR_USER_MARSHAL_INFO* pMarshalInfo);
RPC_STATUS __stdcall NdrCreateServerInterfaceFromStub(
    struct IRpcStubBuffer* pStub,
    RPC_SERVER_INTERFACE* pServerIf);
CLIENT_CALL_RETURN __cdecl NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long nProcNum,
    void* pReturnValue,
    ...);
CLIENT_CALL_RETURN __cdecl Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long nProcNum,
    void* pReturnValue,
    ...);
#pragma endregion
#pragma region Desktop Family or OneCore Family
CLIENT_CALL_RETURN __cdecl Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long nProcNum,
    void* pReturnValue,
    ...);
__declspec(dllimport) void __stdcall Ndr64AsyncServerCall(
    PRPC_MESSAGE pRpcMsg);
#pragma endregion
#pragma region Application Family or OneCore Family
struct IRpcStubBuffer;
__declspec(dllimport) void __stdcall Ndr64AsyncServerCall64(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) void __stdcall Ndr64AsyncServerCallAll(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) long __stdcall Ndr64AsyncStubCall(
    struct IRpcStubBuffer* pThis,
    struct IRpcChannelBuffer* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
__declspec(dllimport) long __stdcall Ndr64DcomAsyncStubCall(
    struct IRpcStubBuffer* pThis,
    struct IRpcChannelBuffer* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
#pragma endregion
#pragma region Application Family or OneCore Family
__declspec(dllimport) long __stdcall NdrStubCall3(
    void* pThis,
    void* pChannel,
    PRPC_MESSAGE pRpcMsg,
    unsigned long* pdwStubPhase);
__declspec(dllimport) void __stdcall NdrServerCallAll(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) void __stdcall NdrServerCallNdr64(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) void __stdcall NdrServerCall3(
    PRPC_MESSAGE pRpcMsg);
__declspec(dllimport) void __stdcall NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    void* pMemory);
__declspec(dllimport) void __stdcall NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    void** ppMemory);
__declspec(dllimport) void __stdcall NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    void* pMemory);
__declspec(dllimport) void __stdcall NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE pStubMsg,
    void** ppMemory,
    PFORMAT_STRING pFormat);
void __stdcall RpcUserFree(handle_t AsyncHandle, void* pBuffer);
#pragma endregion
}
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma warning(pop)
#pragma once
#pragma warning(disable : 4103)
#pragma pack(push, 8)
#pragma once
#pragma warning(disable : 4103)
#pragma pack(push, 8)
#pragma region Application or OneCore Family or Games Family
extern "C++" {
template <typename T>
void** IID_PPV_ARGS_Helper(T** pp);
}
typedef enum tagREGCLS {
    REGCLS_SINGLEUSE = 0,
    REGCLS_MULTIPLEUSE = 1,
    REGCLS_MULTI_SEPARATE = 2,
    REGCLS_SUSPENDED = 4,
    REGCLS_SURROGATE = 8,
    REGCLS_AGILE = 0x10,
} REGCLS;
typedef struct IRpcStubBuffer IRpcStubBuffer;
typedef struct IRpcChannelBuffer IRpcChannelBuffer;
typedef enum tagCOINITBASE {
    COINITBASE_MULTITHREADED = 0x0,
} COINITBASE;
#pragma once
extern "C" {
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec;
typedef WCHAR OLECHAR;
typedef OLECHAR* LPOLESTR;
typedef const OLECHAR* LPCOLESTR;
typedef unsigned char UCHAR;
typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;
typedef double DOUBLE;
typedef struct _COAUTHIDENTITY {
    USHORT* User;
    ULONG UserLength;
    USHORT* Domain;
    ULONG DomainLength;
    USHORT* Password;
    ULONG PasswordLength;
    ULONG Flags;
} COAUTHIDENTITY;
typedef struct _COAUTHINFO {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    LPWSTR pwszServerPrincName;
    DWORD dwAuthnLevel;
    DWORD dwImpersonationLevel;
    COAUTHIDENTITY* pAuthIdentityData;
    DWORD dwCapabilities;
} COAUTHINFO;
typedef LONG SCODE;
typedef SCODE* PSCODE;
typedef enum tagMEMCTX {
    MEMCTX_TASK = 1,
    MEMCTX_SHARED = 2,
    MEMCTX_MACSYSTEM = 3,
    MEMCTX_UNKNOWN = -1,
    MEMCTX_SAME = -2
} MEMCTX;
typedef enum tagCLSCTX {
    CLSCTX_INPROC_SERVER = 0x1,
    CLSCTX_INPROC_HANDLER = 0x2,
    CLSCTX_LOCAL_SERVER = 0x4,
    CLSCTX_INPROC_SERVER16 = 0x8,
    CLSCTX_REMOTE_SERVER = 0x10,
    CLSCTX_INPROC_HANDLER16 = 0x20,
    CLSCTX_RESERVED1 = 0x40,
    CLSCTX_RESERVED2 = 0x80,
    CLSCTX_RESERVED3 = 0x100,
    CLSCTX_RESERVED4 = 0x200,
    CLSCTX_NO_CODE_DOWNLOAD = 0x400,
    CLSCTX_RESERVED5 = 0x800,
    CLSCTX_NO_CUSTOM_MARSHAL = 0x1000,
    CLSCTX_ENABLE_CODE_DOWNLOAD = 0x2000,
    CLSCTX_NO_FAILURE_LOG = 0x4000,
    CLSCTX_DISABLE_AAA = 0x8000,
    CLSCTX_ENABLE_AAA = 0x10000,
    CLSCTX_FROM_DEFAULT_CONTEXT = 0x20000,
    CLSCTX_ACTIVATE_X86_SERVER = 0x40000,
    CLSCTX_ACTIVATE_32_BIT_SERVER = CLSCTX_ACTIVATE_X86_SERVER,
    CLSCTX_ACTIVATE_64_BIT_SERVER = 0x80000,
    CLSCTX_ENABLE_CLOAKING = 0x100000,
    CLSCTX_APPCONTAINER = 0x400000,
    CLSCTX_ACTIVATE_AAA_AS_IU = 0x800000,
    CLSCTX_RESERVED6 = 0x1000000,
    CLSCTX_ACTIVATE_ARM32_SERVER = 0x2000000,
    CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION = 0x4000000,
    CLSCTX_PS_DLL = 0x80000000
} CLSCTX;
typedef enum tagMSHLFLAGS {
    MSHLFLAGS_NORMAL = 0,
    MSHLFLAGS_TABLESTRONG = 1,
    MSHLFLAGS_TABLEWEAK = 2,
    MSHLFLAGS_NOPING = 4,
    MSHLFLAGS_RESERVED1 = 8,
    MSHLFLAGS_RESERVED2 = 16,
    MSHLFLAGS_RESERVED3 = 32,
    MSHLFLAGS_RESERVED4 = 64
} MSHLFLAGS;
typedef enum tagMSHCTX {
    MSHCTX_LOCAL = 0,
    MSHCTX_NOSHAREDMEM = 1,
    MSHCTX_DIFFERENTMACHINE = 2,
    MSHCTX_INPROC = 3,
    MSHCTX_CROSSCTX = 4,
    MSHCTX_CONTAINER = 5
} MSHCTX;
typedef struct _BYTE_BLOB {
    ULONG clSize;
    byte abData[1];
} BYTE_BLOB;
typedef BYTE_BLOB* UP_BYTE_BLOB;
typedef struct _WORD_BLOB {
    ULONG clSize;
    unsigned short asData[1];
} WORD_BLOB;
typedef WORD_BLOB* UP_WORD_BLOB;
typedef struct _DWORD_BLOB {
    ULONG clSize;
    ULONG alData[1];
} DWORD_BLOB;
typedef DWORD_BLOB* UP_DWORD_BLOB;
typedef struct _FLAGGED_BYTE_BLOB {
    ULONG fFlags;
    ULONG clSize;
    byte abData[1];
} FLAGGED_BYTE_BLOB;
typedef FLAGGED_BYTE_BLOB* UP_FLAGGED_BYTE_BLOB;
typedef struct _FLAGGED_WORD_BLOB {
    ULONG fFlags;
    ULONG clSize;
    unsigned short asData[1];
} FLAGGED_WORD_BLOB;
typedef FLAGGED_WORD_BLOB* UP_FLAGGED_WORD_BLOB;
typedef struct _BYTE_SIZEDARR {
    ULONG clSize;
    byte* pData;
} BYTE_SIZEDARR;
typedef struct _SHORT_SIZEDARR {
    ULONG clSize;
    unsigned short* pData;
} WORD_SIZEDARR;
typedef struct _LONG_SIZEDARR {
    ULONG clSize;
    ULONG* pData;
} DWORD_SIZEDARR;
typedef struct _HYPER_SIZEDARR {
    ULONG clSize;
    __int64* pData;
} HYPER_SIZEDARR;
extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec;
typedef boolean BOOLEAN;
typedef struct tagBLOB {
    ULONG cbSize;
    BYTE* pBlobData;
} BLOB;
typedef struct tagBLOB* LPBLOB;
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec;
}
#pragma once
typedef struct IUnknown IUnknown;
typedef struct AsyncIUnknown AsyncIUnknown;
typedef struct IClassFactory IClassFactory;
extern "C" {
#pragma once
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0000_v0_0_s_ifspec;
typedef IUnknown* LPUNKNOWN;
extern "C" const IID IID_IUnknown;
extern "C++" {
struct __declspec(uuid("00000000-0000-0000-C000-000000000046")) __declspec(novtable)
    IUnknown {
public:
    virtual HRESULT __stdcall QueryInterface(
        const IID& riid,
        void** ppvObject)
        = 0;
    virtual ULONG __stdcall AddRef(void) = 0;
    virtual ULONG __stdcall Release(void) = 0;
    template <class Q>
    HRESULT __stdcall QueryInterface(Q** pp)
    {
        return QueryInterface(__uuidof(Q), (void**)pp);
    }
};
}
HRESULT __stdcall IUnknown_QueryInterface_Proxy(
    IUnknown* This,
    const IID& riid,
    void** ppvObject);
void __stdcall IUnknown_QueryInterface_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
ULONG __stdcall IUnknown_AddRef_Proxy(
    IUnknown* This);
void __stdcall IUnknown_AddRef_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
ULONG __stdcall IUnknown_Release_Proxy(
    IUnknown* This);
void __stdcall IUnknown_Release_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0001_v0_0_s_ifspec;
extern "C" const IID IID_AsyncIUnknown;
struct __declspec(uuid("000e0000-0000-0000-C000-000000000046")) __declspec(novtable)
    AsyncIUnknown : public IUnknown {
public:
    virtual HRESULT __stdcall Begin_QueryInterface(
        const IID& riid)
        = 0;
    virtual HRESULT __stdcall Finish_QueryInterface(
        void** ppvObject)
        = 0;
    virtual HRESULT __stdcall Begin_AddRef(void) = 0;
    virtual ULONG __stdcall Finish_AddRef(void) = 0;
    virtual HRESULT __stdcall Begin_Release(void) = 0;
    virtual ULONG __stdcall Finish_Release(void) = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0002_v0_0_s_ifspec;
typedef IClassFactory* LPCLASSFACTORY;
extern "C" const IID IID_IClassFactory;
struct __declspec(uuid("00000001-0000-0000-C000-000000000046")) __declspec(novtable)
    IClassFactory : public IUnknown {
public:
    virtual HRESULT __stdcall CreateInstance(
        IUnknown* pUnkOuter,
        const IID& riid,
        void** ppvObject)
        = 0;
    virtual HRESULT __stdcall LockServer(
        BOOL fLock)
        = 0;
};
HRESULT __stdcall IClassFactory_RemoteCreateInstance_Proxy(
    IClassFactory* This,
    const IID& riid,
    IUnknown** ppvObject);
void __stdcall IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy(
    IClassFactory* This,
    BOOL fLock);
void __stdcall IClassFactory_RemoteLockServer_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0003_v0_0_s_ifspec;
HRESULT __stdcall IClassFactory_CreateInstance_Proxy(
    IClassFactory* This,
    IUnknown* pUnkOuter,
    const IID& riid,
    void** ppvObject);
HRESULT __stdcall IClassFactory_CreateInstance_Stub(
    IClassFactory* This,
    const IID& riid,
    IUnknown** ppvObject);
HRESULT __stdcall IClassFactory_LockServer_Proxy(
    IClassFactory* This,
    BOOL fLock);
HRESULT __stdcall IClassFactory_LockServer_Stub(
    IClassFactory* This,
    BOOL fLock);
}
extern "C++" {
template <typename T>
void** IID_PPV_ARGS_Helper(T** pp)
{
#pragma prefast(suppress : 6269, "Tool issue with unused static_cast")
    (void)static_cast<IUnknown*>(*pp);
    return reinterpret_cast<void**>(pp);
}
}
#pragma once
typedef struct IMarshal IMarshal;
typedef struct INoMarshal INoMarshal;
typedef struct IAgileObject IAgileObject;
typedef struct IActivationFilter IActivationFilter;
typedef struct IMarshal2 IMarshal2;
typedef struct IMalloc IMalloc;
typedef struct IStdMarshalInfo IStdMarshalInfo;
typedef struct IExternalConnection IExternalConnection;
typedef struct IMultiQI IMultiQI;
typedef struct AsyncIMultiQI AsyncIMultiQI;
typedef struct IInternalUnknown IInternalUnknown;
typedef struct IEnumUnknown IEnumUnknown;
typedef struct IEnumString IEnumString;
typedef struct ISequentialStream ISequentialStream;
typedef struct IStream IStream;
typedef struct IRpcChannelBuffer IRpcChannelBuffer;
typedef struct IRpcChannelBuffer2 IRpcChannelBuffer2;
typedef struct IAsyncRpcChannelBuffer IAsyncRpcChannelBuffer;
typedef struct IRpcChannelBuffer3 IRpcChannelBuffer3;
typedef struct IRpcSyntaxNegotiate IRpcSyntaxNegotiate;
typedef struct IRpcProxyBuffer IRpcProxyBuffer;
typedef struct IRpcStubBuffer IRpcStubBuffer;
typedef struct IPSFactoryBuffer IPSFactoryBuffer;
typedef struct IChannelHook IChannelHook;
typedef struct IClientSecurity IClientSecurity;
typedef struct IServerSecurity IServerSecurity;
typedef struct IRpcOptions IRpcOptions;
typedef struct IGlobalOptions IGlobalOptions;
typedef struct ISurrogate ISurrogate;
typedef struct IGlobalInterfaceTable IGlobalInterfaceTable;
typedef struct ISynchronize ISynchronize;
typedef struct ISynchronizeHandle ISynchronizeHandle;
typedef struct ISynchronizeEvent ISynchronizeEvent;
typedef struct ISynchronizeContainer ISynchronizeContainer;
typedef struct ISynchronizeMutex ISynchronizeMutex;
typedef struct ICancelMethodCalls ICancelMethodCalls;
typedef struct IAsyncManager IAsyncManager;
typedef struct ICallFactory ICallFactory;
typedef struct IRpcHelper IRpcHelper;
typedef struct IReleaseMarshalBuffers IReleaseMarshalBuffers;
typedef struct IWaitMultiple IWaitMultiple;
typedef struct IAddrTrackingControl IAddrTrackingControl;
typedef struct IAddrExclusionControl IAddrExclusionControl;
typedef struct IPipeByte IPipeByte;
typedef struct AsyncIPipeByte AsyncIPipeByte;
typedef struct IPipeLong IPipeLong;
typedef struct AsyncIPipeLong AsyncIPipeLong;
typedef struct IPipeDouble IPipeDouble;
typedef struct AsyncIPipeDouble AsyncIPipeDouble;
typedef struct IEnumContextProps IEnumContextProps;
typedef struct IContext IContext;
typedef struct IObjContext IObjContext;
typedef struct IComThreadingInfo IComThreadingInfo;
typedef struct IProcessInitControl IProcessInitControl;
typedef struct IFastRundown IFastRundown;
typedef struct IMarshalingStream IMarshalingStream;
typedef struct IAgileReference IAgileReference;
typedef struct IMachineGlobalObjectTable IMachineGlobalObjectTable;
typedef struct ISupportAllowLowerTrustActivation ISupportAllowLowerTrustActivation;
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma once
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct _COSERVERINFO {
    DWORD dwReserved1;
    LPWSTR pwszName;
    COAUTHINFO* pAuthInfo;
    DWORD dwReserved2;
} COSERVERINFO;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0000_v0_0_s_ifspec;
typedef IMarshal* LPMARSHAL;
extern "C" const IID IID_IMarshal;
struct __declspec(uuid("00000003-0000-0000-C000-000000000046")) __declspec(novtable)
    IMarshal : public IUnknown {
public:
    virtual HRESULT __stdcall GetUnmarshalClass(
        const IID& riid,
        void* pv,
        DWORD dwDestContext,
        void* pvDestContext,
        DWORD mshlflags,
        CLSID* pCid)
        = 0;
    virtual HRESULT __stdcall GetMarshalSizeMax(
        const IID& riid,
        void* pv,
        DWORD dwDestContext,
        void* pvDestContext,
        DWORD mshlflags,
        DWORD* pSize)
        = 0;
    virtual HRESULT __stdcall MarshalInterface(
        IStream* pStm,
        const IID& riid,
        void* pv,
        DWORD dwDestContext,
        void* pvDestContext,
        DWORD mshlflags)
        = 0;
    virtual HRESULT __stdcall UnmarshalInterface(
        IStream* pStm,
        const IID& riid,
        void** ppv)
        = 0;
    virtual HRESULT __stdcall ReleaseMarshalData(
        IStream* pStm)
        = 0;
    virtual HRESULT __stdcall DisconnectObject(
        DWORD dwReserved)
        = 0;
};
extern "C" const IID IID_INoMarshal;
struct __declspec(uuid("ecc8691b-c1db-4dc0-855e-65f6c551af49")) __declspec(novtable)
    INoMarshal : public IUnknown {
public:
};
extern "C" const IID IID_IAgileObject;
struct __declspec(uuid("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")) __declspec(novtable)
    IAgileObject : public IUnknown {
public:
};
#pragma endregion
#pragma region Desktop Family or OneCore Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0003_v0_0_s_ifspec;
typedef enum tagACTIVATIONTYPE {
    ACTIVATIONTYPE_UNCATEGORIZED = 0,
    ACTIVATIONTYPE_FROM_MONIKER = 0x1,
    ACTIVATIONTYPE_FROM_DATA = 0x2,
    ACTIVATIONTYPE_FROM_STORAGE = 0x4,
    ACTIVATIONTYPE_FROM_STREAM = 0x8,
    ACTIVATIONTYPE_FROM_FILE = 0x10
} ACTIVATIONTYPE;
extern "C" const IID IID_IActivationFilter;
struct __declspec(uuid("00000017-0000-0000-C000-000000000046")) __declspec(novtable)
    IActivationFilter : public IUnknown {
public:
    virtual HRESULT __stdcall HandleActivation(
        DWORD dwActivationType,
        const IID& rclsid,
        CLSID* pReplacementClsId)
        = 0;
};
typedef IMarshal2* LPMARSHAL2;
extern "C" const IID IID_IMarshal2;
struct __declspec(uuid("000001cf-0000-0000-C000-000000000046")) __declspec(novtable)
    IMarshal2 : public IMarshal {
public:
};
typedef IMalloc* LPMALLOC;
extern "C" const IID IID_IMalloc;
struct __declspec(uuid("00000002-0000-0000-C000-000000000046")) __declspec(novtable)
    IMalloc : public IUnknown {
public:
    virtual void* __stdcall Alloc(
        SIZE_T cb)
        = 0;
    virtual void* __stdcall Realloc(
        void* pv,
        SIZE_T cb)
        = 0;
    virtual void __stdcall Free(
        void* pv)
        = 0;
    virtual SIZE_T __stdcall GetSize(
        void* pv)
        = 0;
    virtual int __stdcall DidAlloc(
        void* pv)
        = 0;
    virtual void __stdcall HeapMinimize(void) = 0;
};
typedef IStdMarshalInfo* LPSTDMARSHALINFO;
extern "C" const IID IID_IStdMarshalInfo;
struct __declspec(uuid("00000018-0000-0000-C000-000000000046")) __declspec(novtable)
    IStdMarshalInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetClassForHandler(
        DWORD dwDestContext,
        void* pvDestContext,
        CLSID* pClsid)
        = 0;
};
typedef IExternalConnection* LPEXTERNALCONNECTION;
typedef enum tagEXTCONN {
    EXTCONN_STRONG = 0x1,
    EXTCONN_WEAK = 0x2,
    EXTCONN_CALLABLE = 0x4
} EXTCONN;
extern "C" const IID IID_IExternalConnection;
struct __declspec(uuid("00000019-0000-0000-C000-000000000046")) __declspec(novtable)
    IExternalConnection : public IUnknown {
public:
    virtual DWORD __stdcall AddConnection(
        DWORD extconn,
        DWORD reserved)
        = 0;
    virtual DWORD __stdcall ReleaseConnection(
        DWORD extconn,
        DWORD reserved,
        BOOL fLastReleaseCloses)
        = 0;
};
typedef IMultiQI* LPMULTIQI;
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct tagMULTI_QI {
    const IID* pIID;
    IUnknown* pItf;
    HRESULT hr;
} MULTI_QI;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0008_v0_0_s_ifspec;
extern "C" const IID IID_IMultiQI;
struct __declspec(uuid("00000020-0000-0000-C000-000000000046")) __declspec(novtable)
    IMultiQI : public IUnknown {
public:
    virtual HRESULT __stdcall QueryMultipleInterfaces(
        ULONG cMQIs,
        MULTI_QI* pMQIs)
        = 0;
};
extern "C" const IID IID_AsyncIMultiQI;
struct __declspec(uuid("000e0020-0000-0000-C000-000000000046")) __declspec(novtable)
    AsyncIMultiQI : public IUnknown {
public:
    virtual HRESULT __stdcall Begin_QueryMultipleInterfaces(
        ULONG cMQIs,
        MULTI_QI* pMQIs)
        = 0;
    virtual HRESULT __stdcall Finish_QueryMultipleInterfaces(
        MULTI_QI* pMQIs)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0009_v0_0_s_ifspec;
extern "C" const IID IID_IInternalUnknown;
struct __declspec(uuid("00000021-0000-0000-C000-000000000046")) __declspec(novtable)
    IInternalUnknown : public IUnknown {
public:
    virtual HRESULT __stdcall QueryInternalInterface(
        const IID& riid,
        void** ppv)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0010_v0_0_s_ifspec;
typedef IEnumUnknown* LPENUMUNKNOWN;
extern "C" const IID IID_IEnumUnknown;
struct __declspec(uuid("00000100-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumUnknown : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        IUnknown** rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumUnknown** ppenum)
        = 0;
};
HRESULT __stdcall IEnumUnknown_RemoteNext_Proxy(
    IEnumUnknown* This,
    ULONG celt,
    IUnknown** rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumUnknown_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IEnumString* LPENUMSTRING;
extern "C" const IID IID_IEnumString;
struct __declspec(uuid("00000101-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumString : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        LPOLESTR* rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumString** ppenum)
        = 0;
};
HRESULT __stdcall IEnumString_RemoteNext_Proxy(
    IEnumString* This,
    ULONG celt,
    LPOLESTR* rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumString_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern "C" const IID IID_ISequentialStream;
struct __declspec(uuid("0c733a30-2a1c-11ce-ade5-00aa0044773d")) __declspec(novtable)
    ISequentialStream : public IUnknown {
public:
    virtual HRESULT __stdcall Read(
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
        = 0;
    virtual HRESULT __stdcall Write(
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
        = 0;
};
HRESULT __stdcall ISequentialStream_RemoteRead_Proxy(
    ISequentialStream* This,
    byte* pv,
    ULONG cb,
    ULONG* pcbRead);
void __stdcall ISequentialStream_RemoteRead_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ISequentialStream_RemoteWrite_Proxy(
    ISequentialStream* This,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
void __stdcall ISequentialStream_RemoteWrite_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IStream* LPSTREAM;
typedef struct tagSTATSTG {
    LPOLESTR pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;
typedef enum tagSTGTY {
    STGTY_STORAGE = 1,
    STGTY_STREAM = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY = 4
} STGTY;
typedef enum tagSTREAM_SEEK {
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;
typedef enum tagLOCKTYPE {
    LOCK_WRITE = 1,
    LOCK_EXCLUSIVE = 2,
    LOCK_ONLYONCE = 4
} LOCKTYPE;
extern "C" const IID IID_IStream;
struct __declspec(uuid("0000000c-0000-0000-C000-000000000046")) __declspec(novtable)
    IStream : public ISequentialStream {
public:
    virtual HRESULT __stdcall Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER* plibNewPosition)
        = 0;
    virtual HRESULT __stdcall SetSize(
        ULARGE_INTEGER libNewSize)
        = 0;
    virtual HRESULT __stdcall CopyTo(
        IStream* pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* pcbRead,
        ULARGE_INTEGER* pcbWritten)
        = 0;
    virtual HRESULT __stdcall Commit(
        DWORD grfCommitFlags)
        = 0;
    virtual HRESULT __stdcall Revert(void) = 0;
    virtual HRESULT __stdcall LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
        = 0;
    virtual HRESULT __stdcall UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
        = 0;
    virtual HRESULT __stdcall Stat(
        STATSTG* pstatstg,
        DWORD grfStatFlag)
        = 0;
    virtual HRESULT __stdcall Clone(
        IStream** ppstm)
        = 0;
};
HRESULT __stdcall IStream_RemoteSeek_Proxy(
    IStream* This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER* plibNewPosition);
void __stdcall IStream_RemoteSeek_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IStream_RemoteCopyTo_Proxy(
    IStream* This,
    IStream* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* pcbRead,
    ULARGE_INTEGER* pcbWritten);
void __stdcall IStream_RemoteCopyTo_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef ULONG RPCOLEDATAREP;
typedef struct tagRPCOLEMESSAGE {
    void* reserved1;
    RPCOLEDATAREP dataRepresentation;
    void* Buffer;
    ULONG cbBuffer;
    ULONG iMethod;
    void* reserved2[5];
    ULONG rpcFlags;
} RPCOLEMESSAGE;
typedef RPCOLEMESSAGE* PRPCOLEMESSAGE;
extern "C" const IID IID_IRpcChannelBuffer;
struct __declspec(uuid("D5F56B60-593B-101A-B569-08002B2DBF7A")) __declspec(novtable)
    IRpcChannelBuffer : public IUnknown {
public:
    virtual HRESULT __stdcall GetBuffer(
        RPCOLEMESSAGE* pMessage,
        const IID& riid)
        = 0;
    virtual HRESULT __stdcall SendReceive(
        RPCOLEMESSAGE* pMessage,
        ULONG* pStatus)
        = 0;
    virtual HRESULT __stdcall FreeBuffer(
        RPCOLEMESSAGE* pMessage)
        = 0;
    virtual HRESULT __stdcall GetDestCtx(
        DWORD* pdwDestContext,
        void** ppvDestContext)
        = 0;
    virtual HRESULT __stdcall IsConnected(void) = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0015_v0_0_s_ifspec;
extern "C" const IID IID_IRpcChannelBuffer2;
struct __declspec(uuid("594f31d0-7f19-11d0-b194-00a0c90dc8bf")) __declspec(novtable)
    IRpcChannelBuffer2 : public IRpcChannelBuffer {
public:
    virtual HRESULT __stdcall GetProtocolVersion(
        DWORD* pdwVersion)
        = 0;
};
extern "C" const IID IID_IAsyncRpcChannelBuffer;
struct __declspec(uuid("a5029fb6-3c34-11d1-9c99-00c04fb998aa")) __declspec(novtable)
    IAsyncRpcChannelBuffer : public IRpcChannelBuffer2 {
public:
    virtual HRESULT __stdcall Send(
        RPCOLEMESSAGE* pMsg,
        ISynchronize* pSync,
        ULONG* pulStatus)
        = 0;
    virtual HRESULT __stdcall Receive(
        RPCOLEMESSAGE* pMsg,
        ULONG* pulStatus)
        = 0;
    virtual HRESULT __stdcall GetDestCtxEx(
        RPCOLEMESSAGE* pMsg,
        DWORD* pdwDestContext,
        void** ppvDestContext)
        = 0;
};
extern "C" const IID IID_IRpcChannelBuffer3;
struct __declspec(uuid("25B15600-0115-11d0-BF0D-00AA00B8DFD2")) __declspec(novtable)
    IRpcChannelBuffer3 : public IRpcChannelBuffer2 {
public:
    virtual HRESULT __stdcall Send(
        RPCOLEMESSAGE* pMsg,
        ULONG* pulStatus)
        = 0;
    virtual HRESULT __stdcall Receive(
        RPCOLEMESSAGE* pMsg,
        ULONG ulSize,
        ULONG* pulStatus)
        = 0;
    virtual HRESULT __stdcall Cancel(
        RPCOLEMESSAGE* pMsg)
        = 0;
    virtual HRESULT __stdcall GetCallContext(
        RPCOLEMESSAGE* pMsg,
        const IID& riid,
        void** pInterface)
        = 0;
    virtual HRESULT __stdcall GetDestCtxEx(
        RPCOLEMESSAGE* pMsg,
        DWORD* pdwDestContext,
        void** ppvDestContext)
        = 0;
    virtual HRESULT __stdcall GetState(
        RPCOLEMESSAGE* pMsg,
        DWORD* pState)
        = 0;
    virtual HRESULT __stdcall RegisterAsync(
        RPCOLEMESSAGE* pMsg,
        IAsyncManager* pAsyncMgr)
        = 0;
};
extern "C" const IID IID_IRpcSyntaxNegotiate;
struct __declspec(uuid("58a08519-24c8-4935-b482-3fd823333a4f")) __declspec(novtable)
    IRpcSyntaxNegotiate : public IUnknown {
public:
    virtual HRESULT __stdcall NegotiateSyntax(
        RPCOLEMESSAGE* pMsg)
        = 0;
};
extern "C" const IID IID_IRpcProxyBuffer;
struct __declspec(uuid("D5F56A34-593B-101A-B569-08002B2DBF7A")) __declspec(novtable)
    IRpcProxyBuffer : public IUnknown {
public:
    virtual HRESULT __stdcall Connect(
        IRpcChannelBuffer* pRpcChannelBuffer)
        = 0;
    virtual void __stdcall Disconnect(void) = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0020_v0_0_s_ifspec;
extern "C" const IID IID_IRpcStubBuffer;
struct __declspec(uuid("D5F56AFC-593B-101A-B569-08002B2DBF7A")) __declspec(novtable)
    IRpcStubBuffer : public IUnknown {
public:
    virtual HRESULT __stdcall Connect(
        IUnknown* pUnkServer)
        = 0;
    virtual void __stdcall Disconnect(void) = 0;
    virtual HRESULT __stdcall Invoke(
        RPCOLEMESSAGE* _prpcmsg,
        IRpcChannelBuffer* _pRpcChannelBuffer)
        = 0;
    virtual IRpcStubBuffer* __stdcall IsIIDSupported(
        const IID& riid)
        = 0;
    virtual ULONG __stdcall CountRefs(void) = 0;
    virtual HRESULT __stdcall DebugServerQueryInterface(
        void** ppv)
        = 0;
    virtual void __stdcall DebugServerRelease(
        void* pv)
        = 0;
};
extern "C" const IID IID_IPSFactoryBuffer;
struct __declspec(uuid("D5F569D0-593B-101A-B569-08002B2DBF7A")) __declspec(novtable)
    IPSFactoryBuffer : public IUnknown {
public:
    virtual HRESULT __stdcall CreateProxy(
        IUnknown* pUnkOuter,
        const IID& riid,
        IRpcProxyBuffer** ppProxy,
        void** ppv)
        = 0;
    virtual HRESULT __stdcall CreateStub(
        const IID& riid,
        IUnknown* pUnkServer,
        IRpcStubBuffer** ppStub)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef struct SChannelHookCallInfo {
    IID iid;
    DWORD cbSize;
    GUID uCausality;
    DWORD dwServerPid;
    DWORD iMethod;
    void* pObject;
} SChannelHookCallInfo;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0022_v0_0_s_ifspec;
extern "C" const IID IID_IChannelHook;
struct __declspec(uuid("1008c4a0-7613-11cf-9af1-0020af6e72f4")) __declspec(novtable)
    IChannelHook : public IUnknown {
public:
    virtual void __stdcall ClientGetSize(
        const GUID& uExtent,
        const IID& riid,
        ULONG* pDataSize)
        = 0;
    virtual void __stdcall ClientFillBuffer(
        const GUID& uExtent,
        const IID& riid,
        ULONG* pDataSize,
        void* pDataBuffer)
        = 0;
    virtual void __stdcall ClientNotify(
        const GUID& uExtent,
        const IID& riid,
        ULONG cbDataSize,
        void* pDataBuffer,
        DWORD lDataRep,
        HRESULT hrFault)
        = 0;
    virtual void __stdcall ServerNotify(
        const GUID& uExtent,
        const IID& riid,
        ULONG cbDataSize,
        void* pDataBuffer,
        DWORD lDataRep)
        = 0;
    virtual void __stdcall ServerGetSize(
        const GUID& uExtent,
        const IID& riid,
        HRESULT hrFault,
        ULONG* pDataSize)
        = 0;
    virtual void __stdcall ServerFillBuffer(
        const GUID& uExtent,
        const IID& riid,
        ULONG* pDataSize,
        void* pDataBuffer,
        HRESULT hrFault)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0023_v0_0_s_ifspec;
typedef struct tagSOLE_AUTHENTICATION_SERVICE {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    OLECHAR* pPrincipalName;
    HRESULT hr;
} SOLE_AUTHENTICATION_SERVICE;
typedef SOLE_AUTHENTICATION_SERVICE* PSOLE_AUTHENTICATION_SERVICE;
typedef enum tagEOLE_AUTHENTICATION_CAPABILITIES {
    EOAC_NONE = 0,
    EOAC_MUTUAL_AUTH = 0x1,
    EOAC_STATIC_CLOAKING = 0x20,
    EOAC_DYNAMIC_CLOAKING = 0x40,
    EOAC_ANY_AUTHORITY = 0x80,
    EOAC_MAKE_FULLSIC = 0x100,
    EOAC_DEFAULT = 0x800,
    EOAC_SECURE_REFS = 0x2,
    EOAC_ACCESS_CONTROL = 0x4,
    EOAC_APPID = 0x8,
    EOAC_DYNAMIC = 0x10,
    EOAC_REQUIRE_FULLSIC = 0x200,
    EOAC_AUTO_IMPERSONATE = 0x400,
    EOAC_DISABLE_AAA = 0x1000,
    EOAC_NO_CUSTOM_MARSHAL = 0x2000,
    EOAC_RESERVED1 = 0x4000
} EOLE_AUTHENTICATION_CAPABILITIES;
typedef struct tagSOLE_AUTHENTICATION_INFO {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    void* pAuthInfo;
} SOLE_AUTHENTICATION_INFO;
typedef struct tagSOLE_AUTHENTICATION_INFO* PSOLE_AUTHENTICATION_INFO;
typedef struct tagSOLE_AUTHENTICATION_LIST {
    DWORD cAuthInfo;
    SOLE_AUTHENTICATION_INFO* aAuthInfo;
} SOLE_AUTHENTICATION_LIST;
typedef struct tagSOLE_AUTHENTICATION_LIST* PSOLE_AUTHENTICATION_LIST;
extern "C" const IID IID_IClientSecurity;
struct __declspec(uuid("0000013D-0000-0000-C000-000000000046")) __declspec(novtable)
    IClientSecurity : public IUnknown {
public:
    virtual HRESULT __stdcall QueryBlanket(
        IUnknown* pProxy,
        DWORD* pAuthnSvc,
        DWORD* pAuthzSvc,
        OLECHAR** pServerPrincName,
        DWORD* pAuthnLevel,
        DWORD* pImpLevel,
        void** pAuthInfo,
        DWORD* pCapabilites)
        = 0;
    virtual HRESULT __stdcall SetBlanket(
        IUnknown* pProxy,
        DWORD dwAuthnSvc,
        DWORD dwAuthzSvc,
        OLECHAR* pServerPrincName,
        DWORD dwAuthnLevel,
        DWORD dwImpLevel,
        void* pAuthInfo,
        DWORD dwCapabilities)
        = 0;
    virtual HRESULT __stdcall CopyProxy(
        IUnknown* pProxy,
        IUnknown** ppCopy)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0024_v0_0_s_ifspec;
extern "C" const IID IID_IServerSecurity;
struct __declspec(uuid("0000013E-0000-0000-C000-000000000046")) __declspec(novtable)
    IServerSecurity : public IUnknown {
public:
    virtual HRESULT __stdcall QueryBlanket(
        DWORD* pAuthnSvc,
        DWORD* pAuthzSvc,
        OLECHAR** pServerPrincName,
        DWORD* pAuthnLevel,
        DWORD* pImpLevel,
        void** pPrivs,
        DWORD* pCapabilities)
        = 0;
    virtual HRESULT __stdcall ImpersonateClient(void) = 0;
    virtual HRESULT __stdcall RevertToSelf(void) = 0;
    virtual BOOL __stdcall IsImpersonating(void) = 0;
};
typedef enum tagRPCOPT_PROPERTIES {
    COMBND_RPCTIMEOUT = 0x1,
    COMBND_SERVER_LOCALITY = 0x2,
    COMBND_RESERVED1 = 0x4,
    COMBND_RESERVED2 = 0x5,
    COMBND_RESERVED3 = 0x8,
    COMBND_RESERVED4 = 0x10
} RPCOPT_PROPERTIES;
typedef enum tagRPCOPT_SERVER_LOCALITY_VALUES {
    SERVER_LOCALITY_PROCESS_LOCAL = 0,
    SERVER_LOCALITY_MACHINE_LOCAL = 1,
    SERVER_LOCALITY_REMOTE = 2
} RPCOPT_SERVER_LOCALITY_VALUES;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0025_v0_0_s_ifspec;
extern "C" const IID IID_IRpcOptions;
struct __declspec(uuid("00000144-0000-0000-C000-000000000046")) __declspec(novtable)
    IRpcOptions : public IUnknown {
public:
    virtual HRESULT __stdcall Set(
        IUnknown* pPrx,
        RPCOPT_PROPERTIES dwProperty,
        ULONG_PTR dwValue)
        = 0;
    virtual HRESULT __stdcall Query(
        IUnknown* pPrx,
        RPCOPT_PROPERTIES dwProperty,
        ULONG_PTR* pdwValue)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
typedef enum tagGLOBALOPT_PROPERTIES {
    COMGLB_EXCEPTION_HANDLING = 1,
    COMGLB_APPID = 2,
    COMGLB_RPC_THREADPOOL_SETTING = 3,
    COMGLB_RO_SETTINGS = 4,
    COMGLB_UNMARSHALING_POLICY = 5,
    COMGLB_PROPERTIES_RESERVED1 = 6,
    COMGLB_PROPERTIES_RESERVED2 = 7,
    COMGLB_PROPERTIES_RESERVED3 = 8
} GLOBALOPT_PROPERTIES;
typedef enum tagGLOBALOPT_EH_VALUES {
    COMGLB_EXCEPTION_HANDLE = 0,
    COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = 1,
    COMGLB_EXCEPTION_DONOT_HANDLE = COMGLB_EXCEPTION_DONOT_HANDLE_FATAL,
    COMGLB_EXCEPTION_DONOT_HANDLE_ANY = 2
} GLOBALOPT_EH_VALUES;
typedef enum tagGLOBALOPT_RPCTP_VALUES {
    COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = 0,
    COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = 1
} GLOBALOPT_RPCTP_VALUES;
typedef enum tagGLOBALOPT_RO_FLAGS {
    COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 0x1,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 0x2,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 0x4,
    COMGLB_FAST_RUNDOWN = 0x8,
    COMGLB_RESERVED1 = 0x10,
    COMGLB_RESERVED2 = 0x20,
    COMGLB_RESERVED3 = 0x40,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 0x80,
    COMGLB_RESERVED4 = 0x100,
    COMGLB_RESERVED5 = 0x200,
    COMGLB_RESERVED6 = 0x400
} GLOBALOPT_RO_FLAGS;
typedef enum tagGLOBALOPT_UNMARSHALING_POLICY_VALUES {
    COMGLB_UNMARSHALING_POLICY_NORMAL = 0,
    COMGLB_UNMARSHALING_POLICY_STRONG = 1,
    COMGLB_UNMARSHALING_POLICY_HYBRID = 2
} GLOBALOPT_UNMARSHALING_POLICY_VALUES;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0026_v0_0_s_ifspec;
extern "C" const IID IID_IGlobalOptions;
struct __declspec(uuid("0000015B-0000-0000-C000-000000000046")) __declspec(novtable)
    IGlobalOptions : public IUnknown {
public:
    virtual HRESULT __stdcall Set(
        GLOBALOPT_PROPERTIES dwProperty,
        ULONG_PTR dwValue)
        = 0;
    virtual HRESULT __stdcall Query(
        GLOBALOPT_PROPERTIES dwProperty,
        ULONG_PTR* pdwValue)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0027_v0_0_s_ifspec;
typedef ISurrogate* LPSURROGATE;
extern "C" const IID IID_ISurrogate;
struct __declspec(uuid("00000022-0000-0000-C000-000000000046")) __declspec(novtable)
    ISurrogate : public IUnknown {
public:
    virtual HRESULT __stdcall LoadDllServer(
        const IID& Clsid)
        = 0;
    virtual HRESULT __stdcall FreeSurrogate(void) = 0;
};
typedef IGlobalInterfaceTable* LPGLOBALINTERFACETABLE;
extern "C" const IID IID_IGlobalInterfaceTable;
struct __declspec(uuid("00000146-0000-0000-C000-000000000046")) __declspec(novtable)
    IGlobalInterfaceTable : public IUnknown {
public:
    virtual HRESULT __stdcall RegisterInterfaceInGlobal(
        IUnknown* pUnk,
        const IID& riid,
        DWORD* pdwCookie)
        = 0;
    virtual HRESULT __stdcall RevokeInterfaceFromGlobal(
        DWORD dwCookie)
        = 0;
    virtual HRESULT __stdcall GetInterfaceFromGlobal(
        DWORD dwCookie,
        const IID& riid,
        void** ppv)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0029_v0_0_s_ifspec;
extern "C" const IID IID_ISynchronize;
struct __declspec(uuid("00000030-0000-0000-C000-000000000046")) __declspec(novtable)
    ISynchronize : public IUnknown {
public:
    virtual HRESULT __stdcall Wait(
        DWORD dwFlags,
        DWORD dwMilliseconds)
        = 0;
    virtual HRESULT __stdcall Signal(void) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
};
extern "C" const IID IID_ISynchronizeHandle;
struct __declspec(uuid("00000031-0000-0000-C000-000000000046")) __declspec(novtable)
    ISynchronizeHandle : public IUnknown {
public:
    virtual HRESULT __stdcall GetHandle(
        HANDLE* ph)
        = 0;
};
extern "C" const IID IID_ISynchronizeEvent;
struct __declspec(uuid("00000032-0000-0000-C000-000000000046")) __declspec(novtable)
    ISynchronizeEvent : public ISynchronizeHandle {
public:
    virtual HRESULT __stdcall SetEventHandle(
        HANDLE* ph)
        = 0;
};
extern "C" const IID IID_ISynchronizeContainer;
struct __declspec(uuid("00000033-0000-0000-C000-000000000046")) __declspec(novtable)
    ISynchronizeContainer : public IUnknown {
public:
    virtual HRESULT __stdcall AddSynchronize(
        ISynchronize* pSync)
        = 0;
    virtual HRESULT __stdcall WaitMultiple(
        DWORD dwFlags,
        DWORD dwTimeOut,
        ISynchronize** ppSync)
        = 0;
};
extern "C" const IID IID_ISynchronizeMutex;
struct __declspec(uuid("00000025-0000-0000-C000-000000000046")) __declspec(novtable)
    ISynchronizeMutex : public ISynchronize {
public:
    virtual HRESULT __stdcall ReleaseMutex(void) = 0;
};
typedef ICancelMethodCalls* LPCANCELMETHODCALLS;
extern "C" const IID IID_ICancelMethodCalls;
struct __declspec(uuid("00000029-0000-0000-C000-000000000046")) __declspec(novtable)
    ICancelMethodCalls : public IUnknown {
public:
    virtual HRESULT __stdcall Cancel(
        ULONG ulSeconds)
        = 0;
    virtual HRESULT __stdcall TestCancel(void) = 0;
};
typedef enum tagDCOM_CALL_STATE {
    DCOM_NONE = 0,
    DCOM_CALL_COMPLETE = 0x1,
    DCOM_CALL_CANCELED = 0x2
} DCOM_CALL_STATE;
extern "C" const IID IID_IAsyncManager;
struct __declspec(uuid("0000002A-0000-0000-C000-000000000046")) __declspec(novtable)
    IAsyncManager : public IUnknown {
public:
    virtual HRESULT __stdcall CompleteCall(
        HRESULT Result)
        = 0;
    virtual HRESULT __stdcall GetCallContext(
        const IID& riid,
        void** pInterface)
        = 0;
    virtual HRESULT __stdcall GetState(
        ULONG* pulStateFlags)
        = 0;
};
extern "C" const IID IID_ICallFactory;
struct __declspec(uuid("1c733a30-2a1c-11ce-ade5-00aa0044773d")) __declspec(novtable)
    ICallFactory : public IUnknown {
public:
    virtual HRESULT __stdcall CreateCall(
        const IID& riid,
        IUnknown* pCtrlUnk,
        const IID& riid2,
        IUnknown** ppv)
        = 0;
};
extern "C" const IID IID_IRpcHelper;
struct __declspec(uuid("00000149-0000-0000-C000-000000000046")) __declspec(novtable)
    IRpcHelper : public IUnknown {
public:
    virtual HRESULT __stdcall GetDCOMProtocolVersion(
        DWORD* pComVersion)
        = 0;
    virtual HRESULT __stdcall GetIIDFromOBJREF(
        void* pObjRef,
        IID** piid)
        = 0;
};
extern "C" const IID IID_IReleaseMarshalBuffers;
struct __declspec(uuid("eb0cb9e8-7996-11d2-872e-0000f8080859")) __declspec(novtable)
    IReleaseMarshalBuffers : public IUnknown {
public:
    virtual HRESULT __stdcall ReleaseMarshalBuffer(
        RPCOLEMESSAGE* pMsg,
        DWORD dwFlags,
        IUnknown* pChnl)
        = 0;
};
extern "C" const IID IID_IWaitMultiple;
struct __declspec(uuid("0000002B-0000-0000-C000-000000000046")) __declspec(novtable)
    IWaitMultiple : public IUnknown {
public:
    virtual HRESULT __stdcall WaitMultiple(
        DWORD timeout,
        ISynchronize** pSync)
        = 0;
    virtual HRESULT __stdcall AddSynchronize(
        ISynchronize* pSync)
        = 0;
};
typedef IAddrTrackingControl* LPADDRTRACKINGCONTROL;
extern "C" const IID IID_IAddrTrackingControl;
struct __declspec(uuid("00000147-0000-0000-C000-000000000046")) __declspec(novtable)
    IAddrTrackingControl : public IUnknown {
public:
    virtual HRESULT __stdcall EnableCOMDynamicAddrTracking(void) = 0;
    virtual HRESULT __stdcall DisableCOMDynamicAddrTracking(void) = 0;
};
typedef IAddrExclusionControl* LPADDREXCLUSIONCONTROL;
extern "C" const IID IID_IAddrExclusionControl;
struct __declspec(uuid("00000148-0000-0000-C000-000000000046")) __declspec(novtable)
    IAddrExclusionControl : public IUnknown {
public:
    virtual HRESULT __stdcall GetCurrentAddrExclusionList(
        const IID& riid,
        void** ppEnumerator)
        = 0;
    virtual HRESULT __stdcall UpdateAddrExclusionList(
        IUnknown* pEnumerator)
        = 0;
};
extern "C" const IID IID_IPipeByte;
struct __declspec(uuid("DB2F3ACA-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable)
    IPipeByte : public IUnknown {
public:
    virtual HRESULT __stdcall Pull(
        BYTE* buf,
        ULONG cRequest,
        ULONG* pcReturned)
        = 0;
    virtual HRESULT __stdcall Push(
        BYTE* buf,
        ULONG cSent)
        = 0;
};
extern "C" const IID IID_AsyncIPipeByte;
struct __declspec(uuid("DB2F3ACB-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable)
    AsyncIPipeByte : public IUnknown {
public:
    virtual HRESULT __stdcall Begin_Pull(
        ULONG cRequest)
        = 0;
    virtual HRESULT __stdcall Finish_Pull(
        BYTE* buf,
        ULONG* pcReturned)
        = 0;
    virtual HRESULT __stdcall Begin_Push(
        BYTE* buf,
        ULONG cSent)
        = 0;
    virtual HRESULT __stdcall Finish_Push(void) = 0;
};
extern "C" const IID IID_IPipeLong;
struct __declspec(uuid("DB2F3ACC-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable)
    IPipeLong : public IUnknown {
public:
    virtual HRESULT __stdcall Pull(
        LONG* buf,
        ULONG cRequest,
        ULONG* pcReturned)
        = 0;
    virtual HRESULT __stdcall Push(
        LONG* buf,
        ULONG cSent)
        = 0;
};
extern "C" const IID IID_AsyncIPipeLong;
struct __declspec(uuid("DB2F3ACD-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable)
    AsyncIPipeLong : public IUnknown {
public:
    virtual HRESULT __stdcall Begin_Pull(
        ULONG cRequest)
        = 0;
    virtual HRESULT __stdcall Finish_Pull(
        LONG* buf,
        ULONG* pcReturned)
        = 0;
    virtual HRESULT __stdcall Begin_Push(
        LONG* buf,
        ULONG cSent)
        = 0;
    virtual HRESULT __stdcall Finish_Push(void) = 0;
};
extern "C" const IID IID_IPipeDouble;
struct __declspec(uuid("DB2F3ACE-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable)
    IPipeDouble : public IUnknown {
public:
    virtual HRESULT __stdcall Pull(
        DOUBLE* buf,
        ULONG cRequest,
        ULONG* pcReturned)
        = 0;
    virtual HRESULT __stdcall Push(
        DOUBLE* buf,
        ULONG cSent)
        = 0;
};
extern "C" const IID IID_AsyncIPipeDouble;
struct __declspec(uuid("DB2F3ACF-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable)
    AsyncIPipeDouble : public IUnknown {
public:
    virtual HRESULT __stdcall Begin_Pull(
        ULONG cRequest)
        = 0;
    virtual HRESULT __stdcall Finish_Pull(
        DOUBLE* buf,
        ULONG* pcReturned)
        = 0;
    virtual HRESULT __stdcall Begin_Push(
        DOUBLE* buf,
        ULONG cSent)
        = 0;
    virtual HRESULT __stdcall Finish_Push(void) = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
typedef enum _APTTYPEQUALIFIER {
    APTTYPEQUALIFIER_NONE = 0,
    APTTYPEQUALIFIER_IMPLICIT_MTA = 1,
    APTTYPEQUALIFIER_NA_ON_MTA = 2,
    APTTYPEQUALIFIER_NA_ON_STA = 3,
    APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = 4,
    APTTYPEQUALIFIER_NA_ON_MAINSTA = 5,
    APTTYPEQUALIFIER_APPLICATION_STA = 6,
    APTTYPEQUALIFIER_RESERVED_1 = 7
} APTTYPEQUALIFIER;
typedef enum _APTTYPE {
    APTTYPE_CURRENT = -1,
    APTTYPE_STA = 0,
    APTTYPE_MTA = 1,
    APTTYPE_NA = 2,
    APTTYPE_MAINSTA = 3
} APTTYPE;
#pragma endregion
#pragma region Desktop Family or OneCore Family
typedef enum _THDTYPE {
    THDTYPE_BLOCKMESSAGES = 0,
    THDTYPE_PROCESSMESSAGES = 1
} THDTYPE;
typedef DWORD APARTMENTID;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0048_v0_0_s_ifspec;
extern "C" const IID IID_IComThreadingInfo;
struct __declspec(uuid("000001ce-0000-0000-C000-000000000046")) __declspec(novtable)
    IComThreadingInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetCurrentApartmentType(
        APTTYPE* pAptType)
        = 0;
    virtual HRESULT __stdcall GetCurrentThreadType(
        THDTYPE* pThreadType)
        = 0;
    virtual HRESULT __stdcall GetCurrentLogicalThreadId(
        GUID* pguidLogicalThreadId)
        = 0;
    virtual HRESULT __stdcall SetCurrentLogicalThreadId(
        const GUID& rguid)
        = 0;
};
extern "C" const IID IID_IProcessInitControl;
struct __declspec(uuid("72380d55-8d2b-43a3-8513-2b6ef31434e9")) __declspec(novtable)
    IProcessInitControl : public IUnknown {
public:
    virtual HRESULT __stdcall ResetInitializerTimeout(
        DWORD dwSecondsRemaining)
        = 0;
};
extern "C" const IID IID_IFastRundown;
struct __declspec(uuid("00000040-0000-0000-C000-000000000046")) __declspec(novtable)
    IFastRundown : public IUnknown {
public:
};
typedef enum CO_MARSHALING_CONTEXT_ATTRIBUTES {
    CO_MARSHALING_SOURCE_IS_APP_CONTAINER = 0,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = 0x80000000,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = 0x80000001,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = 0x80000002,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = 0x80000003,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = 0x80000004,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = 0x80000005,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = 0x80000006,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = 0x80000007,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = 0x80000008,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = 0x80000009,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = 0x8000000a,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = 0x8000000b,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = 0x8000000c,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = 0x8000000d,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = 0x8000000e,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = 0x8000000f,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = 0x80000010,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = 0x80000011
} CO_MARSHALING_CONTEXT_ATTRIBUTES;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0051_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0051_v0_0_s_ifspec;
extern "C" const IID IID_IMarshalingStream;
struct __declspec(uuid("D8F2F5E6-6102-4863-9F26-389A4676EFDE")) __declspec(novtable)
    IMarshalingStream : public IStream {
public:
    virtual HRESULT __stdcall GetMarshalingContextAttribute(
        CO_MARSHALING_CONTEXT_ATTRIBUTES attribute,
        ULONG_PTR* pAttributeValue)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0052_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0052_v0_0_s_ifspec;
extern "C" const IID IID_IAgileReference;
extern "C++" {
struct __declspec(uuid("C03F6A43-65A4-9818-987E-E0B810D2A6F2")) __declspec(novtable)
    IAgileReference : public IUnknown {
public:
    virtual HRESULT __stdcall Resolve(
        const IID& riid,
        void** ppvObjectReference)
        = 0;
    template <class Q>
    HRESULT __stdcall Resolve(Q** pp)
    {
        return Resolve(__uuidof(Q), (void**)pp);
    }
};
}
#pragma endregion
#pragma region Application Family or OneCore Family
extern "C" const GUID IID_ICallbackWithNoReentrancyToApplicationSTA;
#pragma endregion
#pragma region Application Family or OneCore Family
typedef struct MachineGlobalObjectTableRegistrationToken__ {
    int unused;
} * MachineGlobalObjectTableRegistrationToken;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0053_v0_0_s_ifspec;
extern "C" const IID IID_IMachineGlobalObjectTable;
struct __declspec(uuid("26d709ac-f70b-4421-a96f-d2878fafb00d")) __declspec(novtable)
    IMachineGlobalObjectTable : public IUnknown {
public:
    virtual HRESULT __stdcall RegisterObject(
        const IID& clsid,
        LPCWSTR identifier,
        IUnknown* object,
        MachineGlobalObjectTableRegistrationToken* token)
        = 0;
    virtual HRESULT __stdcall GetObjectW(
        const IID& clsid,
        LPCWSTR identifier,
        const IID& riid,
        void** ppv)
        = 0;
    virtual HRESULT __stdcall RevokeObject(
        MachineGlobalObjectTableRegistrationToken token)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0054_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0054_v0_0_s_ifspec;
extern "C" const IID IID_ISupportAllowLowerTrustActivation;
struct __declspec(uuid("e9956ef2-3828-4b4b-8fa9-7db61dee4954")) __declspec(novtable)
    ISupportAllowLowerTrustActivation : public IUnknown {
public:
};
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0055_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0055_v0_0_s_ifspec;
HRESULT __stdcall IEnumUnknown_Next_Proxy(
    IEnumUnknown* This,
    ULONG celt,
    IUnknown** rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumUnknown_Next_Stub(
    IEnumUnknown* This,
    ULONG celt,
    IUnknown** rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumString_Next_Proxy(
    IEnumString* This,
    ULONG celt,
    LPOLESTR* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumString_Next_Stub(
    IEnumString* This,
    ULONG celt,
    LPOLESTR* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall ISequentialStream_Read_Proxy(
    ISequentialStream* This,
    void* pv,
    ULONG cb,
    ULONG* pcbRead);
HRESULT __stdcall ISequentialStream_Read_Stub(
    ISequentialStream* This,
    byte* pv,
    ULONG cb,
    ULONG* pcbRead);
HRESULT __stdcall ISequentialStream_Write_Proxy(
    ISequentialStream* This,
    const void* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall ISequentialStream_Write_Stub(
    ISequentialStream* This,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall IStream_Seek_Proxy(
    IStream* This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER* plibNewPosition);
HRESULT __stdcall IStream_Seek_Stub(
    IStream* This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER* plibNewPosition);
HRESULT __stdcall IStream_CopyTo_Proxy(
    IStream* This,
    IStream* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* pcbRead,
    ULARGE_INTEGER* pcbWritten);
HRESULT __stdcall IStream_CopyTo_Stub(
    IStream* This,
    IStream* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* pcbRead,
    ULARGE_INTEGER* pcbWritten);
}
#pragma once
#pragma warning(push)
#pragma warning(disable : 4001)
extern "C" {
#pragma region Application Family
extern const IID GUID_NULL;
#pragma endregion
#pragma region Desktop Family
extern const IID CATID_MARSHALER;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const CLSID CLSID_AggStdMarshal;
extern const CLSID CLSID_StdAsyncActManager;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;
extern const CLSID CLSID_DCOMAccessControl;
#pragma endregion
#pragma region Application Family or OneCore Family
extern const CLSID CLSID_GlobalOptions;
#pragma endregion
#pragma region Application Family or OneCore or Games Family
extern const CLSID CLSID_StdGlobalInterfaceTable;
extern const CLSID CLSID_MachineGlobalObjectTable;
extern const CLSID CLSID_ActivationCapabilities;
#pragma endregion
#pragma region Desktop Family
extern const CLSID CLSID_ComBinding;
extern const CLSID CLSID_StdEvent;
extern const CLSID CLSID_ManualResetEvent;
extern const CLSID CLSID_SynchronizeContainer;
extern const CLSID CLSID_AddrControl;
extern const CLSID CLSID_ContextSwitcher;
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;
extern const CLSID CLSID_CStdPropertyFrame;
extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;
extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;
extern const CLSID CLSID_IdentityUnmarshal;
#pragma endregion
#pragma region Application Family
extern const CLSID CLSID_InProcFreeMarshaler;
#pragma endregion
#pragma region Desktop Family
extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;
extern const GUID GUID_TRISTATE;
#pragma endregion
}
#pragma warning(pop)
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetMalloc(
    DWORD dwMemContext,
    LPMALLOC* ppMalloc);
#pragma endregion
#pragma region Application or OneCore or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall CreateStreamOnHGlobal(
    HGLOBAL hGlobal,
    BOOL fDeleteOnRelease,
    LPSTREAM* ppstm);
extern "C" __declspec(dllimport) HRESULT __stdcall GetHGlobalFromStream(
    LPSTREAM pstm,
    HGLOBAL* phglobal);
extern "C" __declspec(dllimport) void __stdcall CoUninitialize(
    void);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) DWORD __stdcall CoGetCurrentProcess(
    void);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoInitializeEx(
    LPVOID pvReserved,
    DWORD dwCoInit);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCallerTID(
    LPDWORD lpdwTID);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCurrentLogicalThreadId(
    GUID* pguid);
#pragma endregion
#pragma region Application or OneCore or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetContextToken(
    ULONG_PTR* pToken);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetDefaultContext(
    APTTYPE aptType,
    const IID& riid,
    void** ppv);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetApartmentType(
    APTTYPE* pAptType,
    APTTYPEQUALIFIER* pAptQualifier);
#pragma endregion
#pragma region Application or OneCore Family
typedef struct tagServerInformation {
    DWORD dwServerPid;
    DWORD dwServerTid;
    UINT64 ui64ServerAddress;
} ServerInformation, *PServerInformation;
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoDecodeProxy(
    DWORD dwClientPid,
    UINT64 ui64ProxyAddress,
    PServerInformation pServerInformation);
#pragma endregion
#pragma region Application or OneCore Family
struct CO_MTA_USAGE_COOKIE__ {
    int unused;
};
typedef struct CO_MTA_USAGE_COOKIE__* CO_MTA_USAGE_COOKIE;
extern "C" __declspec(dllimport) HRESULT __stdcall CoIncrementMTAUsage(
    CO_MTA_USAGE_COOKIE* pCookie);
extern "C" __declspec(dllimport) HRESULT __stdcall CoDecrementMTAUsage(
    CO_MTA_USAGE_COOKIE Cookie);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoAllowUnmarshalerCLSID(
    const IID& clsid);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetObjectContext(
    const IID& riid,
    LPVOID* ppv);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetClassObject(
    const IID& rclsid,
    DWORD dwClsContext,
    LPVOID pvReserved,
    const IID& riid,
    LPVOID* ppv);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterClassObject(
    const IID& rclsid,
    LPUNKNOWN pUnk,
    DWORD dwClsContext,
    DWORD flags,
    LPDWORD lpdwRegister);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeClassObject(
    DWORD dwRegister);
extern "C" __declspec(dllimport) HRESULT __stdcall CoResumeClassObjects(
    void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoSuspendClassObjects(
    void);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) ULONG __stdcall CoAddRefServerProcess(
    void);
extern "C" __declspec(dllimport) ULONG __stdcall CoReleaseServerProcess(
    void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetPSClsid(
    const IID& riid,
    CLSID* pClsid);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterPSClsid(
    const IID& riid,
    const IID& rclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterSurrogate(
    LPSURROGATE pSurrogate);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetMarshalSizeMax(
    ULONG* pulSize,
    const IID& riid,
    LPUNKNOWN pUnk,
    DWORD dwDestContext,
    LPVOID pvDestContext,
    DWORD mshlflags);
extern "C" __declspec(dllimport) HRESULT __stdcall CoMarshalInterface(
    LPSTREAM pStm,
    const IID& riid,
    LPUNKNOWN pUnk,
    DWORD dwDestContext,
    LPVOID pvDestContext,
    DWORD mshlflags);
extern "C" __declspec(dllimport) HRESULT __stdcall CoUnmarshalInterface(
    LPSTREAM pStm,
    const IID& riid,
    LPVOID* ppv);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoMarshalHresult(
    LPSTREAM pstm,
    HRESULT hresult);
extern "C" __declspec(dllimport) HRESULT __stdcall CoUnmarshalHresult(
    LPSTREAM pstm,
    HRESULT* phresult);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoReleaseMarshalData(
    LPSTREAM pStm);
extern "C" __declspec(dllimport) HRESULT __stdcall CoDisconnectObject(
    LPUNKNOWN pUnk,
    DWORD dwReserved);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoLockObjectExternal(
    LPUNKNOWN pUnk,
    BOOL fLock,
    BOOL fLastUnlockReleases);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetStandardMarshal(
    const IID& riid,
    LPUNKNOWN pUnk,
    DWORD dwDestContext,
    LPVOID pvDestContext,
    DWORD mshlflags,
    LPMARSHAL* ppMarshal);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetStdMarshalEx(
    LPUNKNOWN pUnkOuter,
    DWORD smexflags,
    LPUNKNOWN* ppUnkInner);
#pragma endregion
#pragma region Application or OneCore Family
typedef enum tagSTDMSHLFLAGS {
    SMEXF_SERVER = 0x01,
    SMEXF_HANDLER = 0x02
} STDMSHLFLAGS;
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) BOOL __stdcall CoIsHandlerConnected(
    LPUNKNOWN pUnk);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoMarshalInterThreadInterfaceInStream(
    const IID& riid,
    LPUNKNOWN pUnk,
    LPSTREAM* ppStm);
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetInterfaceAndReleaseStream(
    LPSTREAM pStm,
    const IID& iid,
    LPVOID* ppv);
#pragma endregion
#pragma region Application or OneCore or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateFreeThreadedMarshaler(
    LPUNKNOWN punkOuter,
    LPUNKNOWN* ppunkMarshal);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) void __stdcall CoFreeUnusedLibraries(
    void);
extern "C" __declspec(dllimport) void __stdcall CoFreeUnusedLibrariesEx(
    DWORD dwUnloadDelay,
    DWORD dwReserved);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoDisconnectContext(
    DWORD dwTimeout);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoInitializeSecurity(
    PSECURITY_DESCRIPTOR pSecDesc,
    LONG cAuthSvc,
    SOLE_AUTHENTICATION_SERVICE* asAuthSvc,
    void* pReserved1,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    void* pAuthList,
    DWORD dwCapabilities,
    void* pReserved3);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCallContext(
    const IID& riid,
    void** ppInterface);
extern "C" __declspec(dllimport) HRESULT __stdcall CoQueryProxyBlanket(
    IUnknown* pProxy,
    DWORD* pwAuthnSvc,
    DWORD* pAuthzSvc,
    LPOLESTR* pServerPrincName,
    DWORD* pAuthnLevel,
    DWORD* pImpLevel,
    RPC_AUTH_IDENTITY_HANDLE* pAuthInfo,
    DWORD* pCapabilites);
extern "C" __declspec(dllimport) HRESULT __stdcall CoSetProxyBlanket(
    IUnknown* pProxy,
    DWORD dwAuthnSvc,
    DWORD dwAuthzSvc,
    OLECHAR* pServerPrincName,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    DWORD dwCapabilities);
extern "C" __declspec(dllimport) HRESULT __stdcall CoCopyProxy(
    IUnknown* pProxy,
    IUnknown** ppCopy);
extern "C" __declspec(dllimport) HRESULT __stdcall CoQueryClientBlanket(
    DWORD* pAuthnSvc,
    DWORD* pAuthzSvc,
    LPOLESTR* pServerPrincName,
    DWORD* pAuthnLevel,
    DWORD* pImpLevel,
    RPC_AUTHZ_HANDLE* pPrivs,
    DWORD* pCapabilities);
extern "C" __declspec(dllimport) HRESULT __stdcall CoImpersonateClient(
    void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevertToSelf(
    void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoQueryAuthenticationServices(
    DWORD* pcAuthSvc,
    SOLE_AUTHENTICATION_SERVICE** asAuthSvc);
#pragma endregion
#pragma region Application or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoSwitchCallContext(
    IUnknown* pNewObject,
    IUnknown** ppOldObject);
#pragma endregion
#pragma region App or OneCore Family or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateInstance(
    const IID& rclsid,
    LPUNKNOWN pUnkOuter,
    DWORD dwClsContext,
    const IID& riid,
    LPVOID* ppv);
#pragma endregion
#pragma region App or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateInstanceEx(
    const IID& Clsid,
    IUnknown* punkOuter,
    DWORD dwClsCtx,
    COSERVERINFO* pServerInfo,
    DWORD dwCount,
    MULTI_QI* pResults);
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateInstanceFromApp(
    const IID& Clsid,
    IUnknown* punkOuter,
    DWORD dwClsCtx,
    PVOID reserved,
    DWORD dwCount,
    MULTI_QI* pResults);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterActivationFilter(
    IActivationFilter* pActivationFilter);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCancelObject(
    DWORD dwThreadId,
    const IID& iid,
    void** ppUnk);
extern "C" __declspec(dllimport) HRESULT __stdcall CoSetCancelObject(
    IUnknown* pUnk);
extern "C" __declspec(dllimport) HRESULT __stdcall CoCancelCall(
    DWORD dwThreadId,
    ULONG ulTimeout);
extern "C" __declspec(dllimport) HRESULT __stdcall CoTestCancel(
    void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoEnableCallCancellation(
    LPVOID pReserved);
extern "C" __declspec(dllimport) HRESULT __stdcall CoDisableCallCancellation(
    LPVOID pReserved);
#pragma endregion
#pragma region Application or OneCore Family or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall StringFromCLSID(
    const IID& rclsid,
    LPOLESTR* lplpsz);
extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromString(
    LPCOLESTR lpsz,
    LPCLSID pclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall StringFromIID(
    const IID& rclsid,
    LPOLESTR* lplpsz);
extern "C" __declspec(dllimport) HRESULT __stdcall IIDFromString(
    LPCOLESTR lpsz,
    LPIID lpiid);
#pragma endregion
#pragma region Desktop or OneCore or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall ProgIDFromCLSID(
    const IID& clsid,
    LPOLESTR* lplpszProgID);
extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromProgID(
    LPCOLESTR lpszProgID,
    LPCLSID lpclsid);
#pragma endregion
#pragma region Application or OneCore Family or Games Family
extern "C" __declspec(dllimport) int __stdcall StringFromGUID2(
    const GUID& rguid,
    LPOLESTR lpsz,
    int cchMax);
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateGuid(
    GUID* pguid);
typedef struct tagPROPVARIANT PROPVARIANT;
extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantCopy(
    PROPVARIANT* pvarDest,
    const PROPVARIANT* pvarSrc);
extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantClear(
    PROPVARIANT* pvar);
extern "C" __declspec(dllimport) HRESULT __stdcall FreePropVariantArray(
    ULONG cVariants,
    PROPVARIANT* rgvars);
#pragma endregion
#pragma region Desktop or OneCore Family
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoWaitForMultipleHandles(
    DWORD dwFlags,
    DWORD dwTimeout,
    ULONG cHandles,
    LPHANDLE pHandles,
    LPDWORD lpdwindex);
typedef enum tagCOWAIT_FLAGS {
    COWAIT_DEFAULT = 0,
    COWAIT_WAITALL = 1,
    COWAIT_ALERTABLE = 2,
    COWAIT_INPUTAVAILABLE = 4,
    COWAIT_DISPATCH_CALLS = 8,
    COWAIT_DISPATCH_WINDOW_MESSAGES = 0x10,
} COWAIT_FLAGS;
typedef enum CWMO_FLAGS {
    CWMO_DEFAULT = 0,
    CWMO_DISPATCH_CALLS = 1,
    CWMO_DISPATCH_WINDOW_MESSAGES = 2,
} CWMO_FLAGS;
extern "C" __declspec(dllimport) HRESULT __stdcall CoWaitForMultipleObjects(
    DWORD dwFlags,
    DWORD dwTimeout,
    ULONG cHandles,
    const HANDLE* pHandles,
    LPDWORD lpdwindex);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetTreatAsClass(
    const IID& clsidOld,
    LPCLSID pClsidNew);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoInvalidateRemoteMachineBindings(
    LPOLESTR pszMachineName);
#pragma endregion
#pragma region Application or OneCore Family
enum AgileReferenceOptions {
    AGILEREFERENCE_DEFAULT = 0,
    AGILEREFERENCE_DELAYEDMARSHAL = 1,
};
extern "C" __declspec(dllimport) HRESULT __stdcall RoGetAgileReference(
    enum AgileReferenceOptions options,
    const IID& riid,
    IUnknown* pUnk,
    IAgileReference** ppAgileReference);
#pragma endregion
#pragma region Application or OneCore Family or Games Family
typedef HRESULT(__stdcall* LPFNGETCLASSOBJECT)(const IID&, const IID&, LPVOID*);
typedef HRESULT(__stdcall* LPFNCANUNLOADNOW)(void);
extern "C" HRESULT __stdcall DllGetClassObject(const IID& rclsid, const IID& riid, LPVOID* ppv);
extern "C" HRESULT __stdcall DllCanUnloadNow(void);
extern "C" __declspec(dllimport) LPVOID __stdcall CoTaskMemAlloc(
    SIZE_T cb);
extern "C" __declspec(dllimport) LPVOID __stdcall CoTaskMemRealloc(
    LPVOID pv,
    SIZE_T cb);
extern "C" __declspec(dllimport) void __stdcall CoTaskMemFree(
    LPVOID pv);
#pragma endregion
#pragma region Desktop or OneCore Family
extern "C" __declspec(dllimport) HRESULT __stdcall CoFileTimeNow(
    FILETIME* lpFileTime);
extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromProgIDEx(
    LPCOLESTR lpszProgID,
    LPCLSID lpclsid);
struct CO_DEVICE_CATALOG_COOKIE__ {
    int unused;
};
typedef struct CO_DEVICE_CATALOG_COOKIE__* CO_DEVICE_CATALOG_COOKIE;
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterDeviceCatalog(
    PCWSTR deviceInstanceId,
    CO_DEVICE_CATALOG_COOKIE* cookie);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeDeviceCatalog(
    CO_DEVICE_CATALOG_COOKIE cookie);
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
#pragma once
#pragma once
typedef struct IMallocSpy IMallocSpy;
typedef struct IBindCtx IBindCtx;
typedef struct IEnumMoniker IEnumMoniker;
typedef struct IRunnableObject IRunnableObject;
typedef struct IRunningObjectTable IRunningObjectTable;
typedef struct IPersist IPersist;
typedef struct IPersistStream IPersistStream;
typedef struct IMoniker IMoniker;
typedef struct IROTData IROTData;
typedef struct IEnumSTATSTG IEnumSTATSTG;
typedef struct IStorage IStorage;
typedef struct IPersistFile IPersistFile;
typedef struct IPersistStorage IPersistStorage;
typedef struct ILockBytes ILockBytes;
typedef struct IEnumFORMATETC IEnumFORMATETC;
typedef struct IEnumSTATDATA IEnumSTATDATA;
typedef struct IRootStorage IRootStorage;
typedef struct IAdviseSink IAdviseSink;
typedef struct AsyncIAdviseSink AsyncIAdviseSink;
typedef struct IAdviseSink2 IAdviseSink2;
typedef struct AsyncIAdviseSink2 AsyncIAdviseSink2;
typedef struct IDataObject IDataObject;
typedef struct IDataAdviseHolder IDataAdviseHolder;
typedef struct IMessageFilter IMessageFilter;
typedef struct IClassActivator IClassActivator;
typedef struct IFillLockBytes IFillLockBytes;
typedef struct IProgressNotify IProgressNotify;
typedef struct ILayoutStorage ILayoutStorage;
typedef struct IBlockingLock IBlockingLock;
typedef struct ITimeAndNoticeControl ITimeAndNoticeControl;
typedef struct IOplockStorage IOplockStorage;
typedef struct IDirectWriterLock IDirectWriterLock;
typedef struct IUrlMon IUrlMon;
typedef struct IForegroundTransfer IForegroundTransfer;
typedef struct IThumbnailExtractor IThumbnailExtractor;
typedef struct IDummyHICONIncluder IDummyHICONIncluder;
typedef struct IProcessLock IProcessLock;
typedef struct ISurrogateService ISurrogateService;
typedef struct IInitializeSpy IInitializeSpy;
typedef struct IApartmentShutdown IApartmentShutdown;
#pragma once
#pragma once
extern "C" {
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec;
typedef struct tagRemHGLOBAL {
    LONG fNullHGlobal;
    ULONG cbData;
    byte data[1];
} RemHGLOBAL;
typedef struct tagRemHMETAFILEPICT {
    LONG mm;
    LONG xExt;
    LONG yExt;
    ULONG cbData;
    byte data[1];
} RemHMETAFILEPICT;
typedef struct tagRemHENHMETAFILE {
    ULONG cbData;
    byte data[1];
} RemHENHMETAFILE;
typedef struct tagRemHBITMAP {
    ULONG cbData;
    byte data[1];
} RemHBITMAP;
typedef struct tagRemHPALETTE {
    ULONG cbData;
    byte data[1];
} RemHPALETTE;
typedef struct tagRemBRUSH {
    ULONG cbData;
    byte data[1];
} RemHBRUSH;
typedef enum tagDVASPECT {
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;
typedef enum tagSTGC {
    STGC_DEFAULT = 0,
    STGC_OVERWRITE = 1,
    STGC_ONLYIFCURRENT = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    STGC_CONSOLIDATE = 8
} STGC;
typedef enum tagSTGMOVE {
    STGMOVE_MOVE = 0,
    STGMOVE_COPY = 1,
    STGMOVE_SHALLOWCOPY = 2
} STGMOVE;
typedef enum tagSTATFLAG {
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1,
    STATFLAG_NOOPEN = 2
} STATFLAG;
typedef void* HCONTEXT;
typedef DWORD LCID;
typedef USHORT LANGID;
typedef struct _userCLIPFORMAT {
    LONG fContext;
    union __MIDL_IWinTypes_0001 {
        DWORD dwValue;
        wchar_t* pwszName;
    } u;
} userCLIPFORMAT;
typedef userCLIPFORMAT* wireCLIPFORMAT;
typedef WORD CLIPFORMAT;
typedef struct _GDI_NONREMOTE {
    LONG fContext;
    union __MIDL_IWinTypes_0002 {
        LONG hInproc;
        DWORD_BLOB* hRemote;
    } u;
} GDI_NONREMOTE;
typedef struct _userHGLOBAL {
    LONG fContext;
    union __MIDL_IWinTypes_0003 {
        LONG hInproc;
        FLAGGED_BYTE_BLOB* hRemote;
        __int64 hInproc64;
    } u;
} userHGLOBAL;
typedef userHGLOBAL* wireHGLOBAL;
typedef struct _userHMETAFILE {
    LONG fContext;
    union __MIDL_IWinTypes_0004 {
        LONG hInproc;
        BYTE_BLOB* hRemote;
        __int64 hInproc64;
    } u;
} userHMETAFILE;
typedef struct _remoteMETAFILEPICT {
    LONG mm;
    LONG xExt;
    LONG yExt;
    userHMETAFILE* hMF;
} remoteMETAFILEPICT;
typedef struct _userHMETAFILEPICT {
    LONG fContext;
    union __MIDL_IWinTypes_0005 {
        LONG hInproc;
        remoteMETAFILEPICT* hRemote;
        __int64 hInproc64;
    } u;
} userHMETAFILEPICT;
typedef struct _userHENHMETAFILE {
    LONG fContext;
    union __MIDL_IWinTypes_0006 {
        LONG hInproc;
        BYTE_BLOB* hRemote;
        __int64 hInproc64;
    } u;
} userHENHMETAFILE;
typedef struct _userBITMAP {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    ULONG cbSize;
    byte pBuffer[1];
} userBITMAP;
typedef struct _userHBITMAP {
    LONG fContext;
    union __MIDL_IWinTypes_0007 {
        LONG hInproc;
        userBITMAP* hRemote;
        __int64 hInproc64;
    } u;
} userHBITMAP;
typedef struct _userHPALETTE {
    LONG fContext;
    union __MIDL_IWinTypes_0008 {
        LONG hInproc;
        LOGPALETTE* hRemote;
        __int64 hInproc64;
    } u;
} userHPALETTE;
typedef struct _RemotableHandle {
    LONG fContext;
    union __MIDL_IWinTypes_0009 {
        LONG hInproc;
        LONG hRemote;
    } u;
} RemotableHandle;
typedef RemotableHandle* wireHWND;
typedef RemotableHandle* wireHMENU;
typedef RemotableHandle* wireHACCEL;
typedef RemotableHandle* wireHBRUSH;
typedef RemotableHandle* wireHFONT;
typedef RemotableHandle* wireHDC;
typedef RemotableHandle* wireHICON;
typedef RemotableHandle* wireHRGN;
typedef RemotableHandle* wireHMONITOR;
typedef userHBITMAP* wireHBITMAP;
typedef userHPALETTE* wireHPALETTE;
typedef userHENHMETAFILE* wireHENHMETAFILE;
typedef userHMETAFILE* wireHMETAFILE;
typedef userHMETAFILEPICT* wireHMETAFILEPICT;
typedef void* HMETAFILEPICT;
extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
#pragma warning(push)
#pragma warning(disable : 4201)
typedef double DATE;
typedef union tagCY {
    struct {
        ULONG Lo;
        LONG Hi;
    };
    LONGLONG int64;
} CY;
typedef CY* LPCY;
typedef struct tagDEC {
    USHORT wReserved;
    union {
        struct {
            BYTE scale;
            BYTE sign;
        };
        USHORT signscale;
    };
    ULONG Hi32;
    union {
        struct {
            ULONG Lo32;
            ULONG Mid32;
        };
        ULONGLONG Lo64;
    };
} DECIMAL;
typedef DECIMAL* LPDECIMAL;
#pragma warning(pop)
typedef FLAGGED_WORD_BLOB* wireBSTR;
typedef OLECHAR* BSTR;
typedef BSTR* LPBSTR;
typedef short VARIANT_BOOL;
typedef struct tagBSTRBLOB {
    ULONG cbSize;
    BYTE* pData;
} BSTRBLOB;
typedef struct tagBSTRBLOB* LPBSTRBLOB;
typedef struct tagCLIPDATA {
    ULONG cbSize;
    LONG ulClipFmt;
    BYTE* pClipData;
} CLIPDATA;
typedef unsigned short VARTYPE;
enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_INT_PTR = 37,
    VT_UINT_PTR = 38,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VERSIONED_STREAM = 73,
    VT_BSTR_BLOB = 0xfff,
    VT_VECTOR = 0x1000,
    VT_ARRAY = 0x2000,
    VT_BYREF = 0x4000,
    VT_RESERVED = 0x8000,
    VT_ILLEGAL = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK = 0xfff
};
typedef ULONG PROPID;
typedef struct _tagpropertykey {
    GUID fmtid;
    DWORD pid;
} PROPERTYKEY;
typedef struct tagCSPLATFORM {
    DWORD dwPlatformId;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwProcessorArch;
} CSPLATFORM;
typedef struct tagQUERYCONTEXT {
    DWORD dwContext;
    CSPLATFORM Platform;
    LCID Locale;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
} QUERYCONTEXT;
typedef enum tagTYSPEC {
    TYSPEC_CLSID = 0,
    TYSPEC_FILEEXT = (TYSPEC_CLSID + 1),
    TYSPEC_MIMETYPE = (TYSPEC_FILEEXT + 1),
    TYSPEC_FILENAME = (TYSPEC_MIMETYPE + 1),
    TYSPEC_PROGID = (TYSPEC_FILENAME + 1),
    TYSPEC_PACKAGENAME = (TYSPEC_PROGID + 1),
    TYSPEC_OBJECTID = (TYSPEC_PACKAGENAME + 1)
} TYSPEC;
typedef struct __MIDL___MIDL_itf_wtypes_0000_0001_0001 {
    DWORD tyspec;
    union __MIDL___MIDL_itf_wtypes_0000_0001_0005 {
        CLSID clsid;
        LPOLESTR pFileExt;
        LPOLESTR pMimeType;
        LPOLESTR pProgId;
        LPOLESTR pFileName;
        struct
        {
            LPOLESTR pPackageName;
            GUID PolicyId;
        } ByName;
        struct
        {
            GUID ObjectId;
            GUID PolicyId;
        } ByObjectId;
    } tagged_union;
} uCLSSPEC;
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec;
}
extern "C" {
#pragma once
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_s_ifspec;
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_s_ifspec;
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0002_v0_0_s_ifspec;
#pragma endregion
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0003_v0_0_s_ifspec;
HRESULT __stdcall IClassFactory_CreateInstance_Proxy(
    IClassFactory* This,
    IUnknown* pUnkOuter,
    const IID& riid,
    void** ppvObject);
HRESULT __stdcall IClassFactory_CreateInstance_Stub(
    IClassFactory* This,
    const IID& riid,
    IUnknown** ppvObject);
HRESULT __stdcall IClassFactory_LockServer_Proxy(
    IClassFactory* This,
    BOOL fLock);
HRESULT __stdcall IClassFactory_LockServer_Stub(
    IClassFactory* This,
    BOOL fLock);
}
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma once
#pragma warning(pop)
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0055_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0055_v0_0_s_ifspec;
typedef IMallocSpy* LPMALLOCSPY;
extern "C" const IID IID_IMallocSpy;
struct __declspec(uuid("0000001d-0000-0000-C000-000000000046")) __declspec(novtable)
    IMallocSpy : public IUnknown {
public:
    virtual SIZE_T __stdcall PreAlloc(
        SIZE_T cbRequest)
        = 0;
    virtual void* __stdcall PostAlloc(
        void* pActual)
        = 0;
    virtual void* __stdcall PreFree(
        void* pRequest,
        BOOL fSpyed)
        = 0;
    virtual void __stdcall PostFree(
        BOOL fSpyed)
        = 0;
    virtual SIZE_T __stdcall PreRealloc(
        void* pRequest,
        SIZE_T cbRequest,
        void** ppNewRequest,
        BOOL fSpyed)
        = 0;
    virtual void* __stdcall PostRealloc(
        void* pActual,
        BOOL fSpyed)
        = 0;
    virtual void* __stdcall PreGetSize(
        void* pRequest,
        BOOL fSpyed)
        = 0;
    virtual SIZE_T __stdcall PostGetSize(
        SIZE_T cbActual,
        BOOL fSpyed)
        = 0;
    virtual void* __stdcall PreDidAlloc(
        void* pRequest,
        BOOL fSpyed)
        = 0;
    virtual int __stdcall PostDidAlloc(
        void* pRequest,
        BOOL fSpyed,
        int fActual)
        = 0;
    virtual void __stdcall PreHeapMinimize(void) = 0;
    virtual void __stdcall PostHeapMinimize(void) = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0056_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0056_v0_0_s_ifspec;
typedef IBindCtx* LPBC;
typedef IBindCtx* LPBINDCTX;
typedef struct tagBIND_OPTS {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
} BIND_OPTS, *LPBIND_OPTS;
typedef struct tagBIND_OPTS2 : tagBIND_OPTS {
    DWORD dwTrackFlags;
    DWORD dwClassContext;
    LCID locale;
    COSERVERINFO* pServerInfo;
} BIND_OPTS2, *LPBIND_OPTS2;
typedef struct tagBIND_OPTS3 : tagBIND_OPTS2 {
    HWND hwnd;
} BIND_OPTS3, *LPBIND_OPTS3;
typedef enum tagBIND_FLAGS {
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;
extern "C" const IID IID_IBindCtx;
struct __declspec(uuid("0000000e-0000-0000-C000-000000000046")) __declspec(novtable)
    IBindCtx : public IUnknown {
public:
    virtual HRESULT __stdcall RegisterObjectBound(
        IUnknown* punk)
        = 0;
    virtual HRESULT __stdcall RevokeObjectBound(
        IUnknown* punk)
        = 0;
    virtual HRESULT __stdcall ReleaseBoundObjects(void) = 0;
    virtual HRESULT __stdcall SetBindOptions(
        BIND_OPTS* pbindopts)
        = 0;
    virtual HRESULT __stdcall GetBindOptions(
        BIND_OPTS* pbindopts)
        = 0;
    virtual HRESULT __stdcall GetRunningObjectTable(
        IRunningObjectTable** pprot)
        = 0;
    virtual HRESULT __stdcall RegisterObjectParam(
        LPOLESTR pszKey,
        IUnknown* punk)
        = 0;
    virtual HRESULT __stdcall GetObjectParam(
        LPOLESTR pszKey,
        IUnknown** ppunk)
        = 0;
    virtual HRESULT __stdcall EnumObjectParam(
        IEnumString** ppenum)
        = 0;
    virtual HRESULT __stdcall RevokeObjectParam(
        LPOLESTR pszKey)
        = 0;
};
HRESULT __stdcall IBindCtx_RemoteSetBindOptions_Proxy(
    IBindCtx* This,
    BIND_OPTS2* pbindopts);
void __stdcall IBindCtx_RemoteSetBindOptions_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IBindCtx_RemoteGetBindOptions_Proxy(
    IBindCtx* This,
    BIND_OPTS2* pbindopts);
void __stdcall IBindCtx_RemoteGetBindOptions_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IEnumMoniker* LPENUMMONIKER;
extern "C" const IID IID_IEnumMoniker;
struct __declspec(uuid("00000102-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumMoniker : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        IMoniker** rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumMoniker** ppenum)
        = 0;
};
HRESULT __stdcall IEnumMoniker_RemoteNext_Proxy(
    IEnumMoniker* This,
    ULONG celt,
    IMoniker** rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumMoniker_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0058_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0058_v0_0_s_ifspec;
typedef IRunnableObject* LPRUNNABLEOBJECT;
extern "C" const IID IID_IRunnableObject;
struct __declspec(uuid("00000126-0000-0000-C000-000000000046")) __declspec(novtable)
    IRunnableObject : public IUnknown {
public:
    virtual HRESULT __stdcall GetRunningClass(
        LPCLSID lpClsid)
        = 0;
    virtual HRESULT __stdcall Run(
        LPBINDCTX pbc)
        = 0;
    virtual BOOL __stdcall IsRunning(void) = 0;
    virtual HRESULT __stdcall LockRunning(
        BOOL fLock,
        BOOL fLastUnlockCloses)
        = 0;
    virtual HRESULT __stdcall SetContainedObject(
        BOOL fContained)
        = 0;
};
HRESULT __stdcall IRunnableObject_RemoteIsRunning_Proxy(
    IRunnableObject* This);
void __stdcall IRunnableObject_RemoteIsRunning_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IRunningObjectTable* LPRUNNINGOBJECTTABLE;
extern "C" const IID IID_IRunningObjectTable;
struct __declspec(uuid("00000010-0000-0000-C000-000000000046")) __declspec(novtable)
    IRunningObjectTable : public IUnknown {
public:
    virtual HRESULT __stdcall Register(
        DWORD grfFlags,
        IUnknown* punkObject,
        IMoniker* pmkObjectName,
        DWORD* pdwRegister)
        = 0;
    virtual HRESULT __stdcall Revoke(
        DWORD dwRegister)
        = 0;
    virtual HRESULT __stdcall IsRunning(
        IMoniker* pmkObjectName)
        = 0;
    virtual HRESULT __stdcall GetObjectW(
        IMoniker* pmkObjectName,
        IUnknown** ppunkObject)
        = 0;
    virtual HRESULT __stdcall NoteChangeTime(
        DWORD dwRegister,
        FILETIME* pfiletime)
        = 0;
    virtual HRESULT __stdcall GetTimeOfLastChange(
        IMoniker* pmkObjectName,
        FILETIME* pfiletime)
        = 0;
    virtual HRESULT __stdcall EnumRunning(
        IEnumMoniker** ppenumMoniker)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0060_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0060_v0_0_s_ifspec;
typedef IPersist* LPPERSIST;
extern "C" const IID IID_IPersist;
struct __declspec(uuid("0000010c-0000-0000-C000-000000000046")) __declspec(novtable)
    IPersist : public IUnknown {
public:
    virtual HRESULT __stdcall GetClassID(
        CLSID* pClassID)
        = 0;
};
typedef IPersistStream* LPPERSISTSTREAM;
extern "C" const IID IID_IPersistStream;
struct __declspec(uuid("00000109-0000-0000-C000-000000000046")) __declspec(novtable)
    IPersistStream : public IPersist {
public:
    virtual HRESULT __stdcall IsDirty(void) = 0;
    virtual HRESULT __stdcall Load(
        IStream* pStm)
        = 0;
    virtual HRESULT __stdcall Save(
        IStream* pStm,
        BOOL fClearDirty)
        = 0;
    virtual HRESULT __stdcall GetSizeMax(
        ULARGE_INTEGER* pcbSize)
        = 0;
};
typedef IMoniker* LPMONIKER;
typedef enum tagMKSYS {
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5,
    MKSYS_CLASSMONIKER = 7,
    MKSYS_OBJREFMONIKER = 8,
    MKSYS_SESSIONMONIKER = 9,
    MKSYS_LUAMONIKER = 10
} MKSYS;
typedef enum tagMKREDUCE {
    MKRREDUCE_ONE = (3 << 16),
    MKRREDUCE_TOUSER = (2 << 16),
    MKRREDUCE_THROUGHUSER = (1 << 16),
    MKRREDUCE_ALL = 0
} MKRREDUCE;
extern "C" const IID IID_IMoniker;
struct __declspec(uuid("0000000f-0000-0000-C000-000000000046")) __declspec(novtable)
    IMoniker : public IPersistStream {
public:
    virtual HRESULT __stdcall BindToObject(
        IBindCtx* pbc,
        IMoniker* pmkToLeft,
        const IID& riidResult,
        void** ppvResult)
        = 0;
    virtual HRESULT __stdcall BindToStorage(
        IBindCtx* pbc,
        IMoniker* pmkToLeft,
        const IID& riid,
        void** ppvObj)
        = 0;
    virtual HRESULT __stdcall Reduce(
        IBindCtx* pbc,
        DWORD dwReduceHowFar,
        IMoniker** ppmkToLeft,
        IMoniker** ppmkReduced)
        = 0;
    virtual HRESULT __stdcall ComposeWith(
        IMoniker* pmkRight,
        BOOL fOnlyIfNotGeneric,
        IMoniker** ppmkComposite)
        = 0;
    virtual HRESULT __stdcall Enum(
        BOOL fForward,
        IEnumMoniker** ppenumMoniker)
        = 0;
    virtual HRESULT __stdcall IsEqual(
        IMoniker* pmkOtherMoniker)
        = 0;
    virtual HRESULT __stdcall Hash(
        DWORD* pdwHash)
        = 0;
    virtual HRESULT __stdcall IsRunning(
        IBindCtx* pbc,
        IMoniker* pmkToLeft,
        IMoniker* pmkNewlyRunning)
        = 0;
    virtual HRESULT __stdcall GetTimeOfLastChange(
        IBindCtx* pbc,
        IMoniker* pmkToLeft,
        FILETIME* pFileTime)
        = 0;
    virtual HRESULT __stdcall Inverse(
        IMoniker** ppmk)
        = 0;
    virtual HRESULT __stdcall CommonPrefixWith(
        IMoniker* pmkOther,
        IMoniker** ppmkPrefix)
        = 0;
    virtual HRESULT __stdcall RelativePathTo(
        IMoniker* pmkOther,
        IMoniker** ppmkRelPath)
        = 0;
    virtual HRESULT __stdcall GetDisplayName(
        IBindCtx* pbc,
        IMoniker* pmkToLeft,
        LPOLESTR* ppszDisplayName)
        = 0;
    virtual HRESULT __stdcall ParseDisplayName(
        IBindCtx* pbc,
        IMoniker* pmkToLeft,
        LPOLESTR pszDisplayName,
        ULONG* pchEaten,
        IMoniker** ppmkOut)
        = 0;
    virtual HRESULT __stdcall IsSystemMoniker(
        DWORD* pdwMksys)
        = 0;
};
HRESULT __stdcall IMoniker_RemoteBindToObject_Proxy(
    IMoniker* This,
    IBindCtx* pbc,
    IMoniker* pmkToLeft,
    const IID& riidResult,
    IUnknown** ppvResult);
void __stdcall IMoniker_RemoteBindToObject_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IMoniker_RemoteBindToStorage_Proxy(
    IMoniker* This,
    IBindCtx* pbc,
    IMoniker* pmkToLeft,
    const IID& riid,
    IUnknown** ppvObj);
void __stdcall IMoniker_RemoteBindToStorage_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0063_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0063_v0_0_s_ifspec;
extern "C" const IID IID_IROTData;
struct __declspec(uuid("f29f6bc0-5021-11ce-aa15-00006901293f")) __declspec(novtable)
    IROTData : public IUnknown {
public:
    virtual HRESULT __stdcall GetComparisonData(
        byte* pbData,
        ULONG cbMax,
        ULONG* pcbData)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0064_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0064_v0_0_s_ifspec;
typedef IEnumSTATSTG* LPENUMSTATSTG;
extern "C" const IID IID_IEnumSTATSTG;
struct __declspec(uuid("0000000d-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumSTATSTG : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        STATSTG* rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumSTATSTG** ppenum)
        = 0;
};
HRESULT __stdcall IEnumSTATSTG_RemoteNext_Proxy(
    IEnumSTATSTG* This,
    ULONG celt,
    STATSTG* rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumSTATSTG_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IStorage* LPSTORAGE;
typedef struct tagRemSNB {
    ULONG ulCntStr;
    ULONG ulCntChar;
    OLECHAR rgString[1];
} RemSNB;
typedef RemSNB* wireSNB;
typedef LPOLESTR* SNB;
extern "C" const IID IID_IStorage;
struct __declspec(uuid("0000000b-0000-0000-C000-000000000046")) __declspec(novtable)
    IStorage : public IUnknown {
public:
    virtual HRESULT __stdcall CreateStream(
        const OLECHAR* pwcsName,
        DWORD grfMode,
        DWORD reserved1,
        DWORD reserved2,
        IStream** ppstm)
        = 0;
    virtual HRESULT __stdcall OpenStream(
        const OLECHAR* pwcsName,
        void* reserved1,
        DWORD grfMode,
        DWORD reserved2,
        IStream** ppstm)
        = 0;
    virtual HRESULT __stdcall CreateStorage(
        const OLECHAR* pwcsName,
        DWORD grfMode,
        DWORD reserved1,
        DWORD reserved2,
        IStorage** ppstg)
        = 0;
    virtual HRESULT __stdcall OpenStorage(
        const OLECHAR* pwcsName,
        IStorage* pstgPriority,
        DWORD grfMode,
        SNB snbExclude,
        DWORD reserved,
        IStorage** ppstg)
        = 0;
    virtual HRESULT __stdcall CopyTo(
        DWORD ciidExclude,
        const IID* rgiidExclude,
        SNB snbExclude,
        IStorage* pstgDest)
        = 0;
    virtual HRESULT __stdcall MoveElementTo(
        const OLECHAR* pwcsName,
        IStorage* pstgDest,
        const OLECHAR* pwcsNewName,
        DWORD grfFlags)
        = 0;
    virtual HRESULT __stdcall Commit(
        DWORD grfCommitFlags)
        = 0;
    virtual HRESULT __stdcall Revert(void) = 0;
    virtual HRESULT __stdcall EnumElements(
        DWORD reserved1,
        void* reserved2,
        DWORD reserved3,
        IEnumSTATSTG** ppenum)
        = 0;
    virtual HRESULT __stdcall DestroyElement(
        const OLECHAR* pwcsName)
        = 0;
    virtual HRESULT __stdcall RenameElement(
        const OLECHAR* pwcsOldName,
        const OLECHAR* pwcsNewName)
        = 0;
    virtual HRESULT __stdcall SetElementTimes(
        const OLECHAR* pwcsName,
        const FILETIME* pctime,
        const FILETIME* patime,
        const FILETIME* pmtime)
        = 0;
    virtual HRESULT __stdcall SetClass(
        const IID& clsid)
        = 0;
    virtual HRESULT __stdcall SetStateBits(
        DWORD grfStateBits,
        DWORD grfMask)
        = 0;
    virtual HRESULT __stdcall Stat(
        STATSTG* pstatstg,
        DWORD grfStatFlag)
        = 0;
};
HRESULT __stdcall IStorage_RemoteOpenStream_Proxy(
    IStorage* This,
    const OLECHAR* pwcsName,
    ULONG cbReserved1,
    byte* reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream** ppstm);
void __stdcall IStorage_RemoteOpenStream_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IStorage_RemoteCopyTo_Proxy(
    IStorage* This,
    DWORD ciidExclude,
    const IID* rgiidExclude,
    SNB snbExclude,
    IStorage* pstgDest);
void __stdcall IStorage_RemoteCopyTo_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IStorage_RemoteEnumElements_Proxy(
    IStorage* This,
    DWORD reserved1,
    ULONG cbReserved2,
    byte* reserved2,
    DWORD reserved3,
    IEnumSTATSTG** ppenum);
void __stdcall IStorage_RemoteEnumElements_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0066_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0066_v0_0_s_ifspec;
typedef IPersistFile* LPPERSISTFILE;
extern "C" const IID IID_IPersistFile;
struct __declspec(uuid("0000010b-0000-0000-C000-000000000046")) __declspec(novtable)
    IPersistFile : public IPersist {
public:
    virtual HRESULT __stdcall IsDirty(void) = 0;
    virtual HRESULT __stdcall Load(
        LPCOLESTR pszFileName,
        DWORD dwMode)
        = 0;
    virtual HRESULT __stdcall Save(
        LPCOLESTR pszFileName,
        BOOL fRemember)
        = 0;
    virtual HRESULT __stdcall SaveCompleted(
        LPCOLESTR pszFileName)
        = 0;
    virtual HRESULT __stdcall GetCurFile(
        LPOLESTR* ppszFileName)
        = 0;
};
typedef IPersistStorage* LPPERSISTSTORAGE;
extern "C" const IID IID_IPersistStorage;
struct __declspec(uuid("0000010a-0000-0000-C000-000000000046")) __declspec(novtable)
    IPersistStorage : public IPersist {
public:
    virtual HRESULT __stdcall IsDirty(void) = 0;
    virtual HRESULT __stdcall InitNew(
        IStorage* pStg)
        = 0;
    virtual HRESULT __stdcall Load(
        IStorage* pStg)
        = 0;
    virtual HRESULT __stdcall Save(
        IStorage* pStgSave,
        BOOL fSameAsLoad)
        = 0;
    virtual HRESULT __stdcall SaveCompleted(
        IStorage* pStgNew)
        = 0;
    virtual HRESULT __stdcall HandsOffStorage(void) = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0068_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0068_v0_0_s_ifspec;
typedef ILockBytes* LPLOCKBYTES;
extern "C" const IID IID_ILockBytes;
struct __declspec(uuid("0000000a-0000-0000-C000-000000000046")) __declspec(novtable)
    ILockBytes : public IUnknown {
public:
    virtual HRESULT __stdcall ReadAt(
        ULARGE_INTEGER ulOffset,
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
        = 0;
    virtual HRESULT __stdcall WriteAt(
        ULARGE_INTEGER ulOffset,
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
        = 0;
    virtual HRESULT __stdcall Flush(void) = 0;
    virtual HRESULT __stdcall SetSize(
        ULARGE_INTEGER cb)
        = 0;
    virtual HRESULT __stdcall LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
        = 0;
    virtual HRESULT __stdcall UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
        = 0;
    virtual HRESULT __stdcall Stat(
        STATSTG* pstatstg,
        DWORD grfStatFlag)
        = 0;
};
HRESULT __stdcall ILockBytes_RemoteReadAt_Proxy(
    ILockBytes* This,
    ULARGE_INTEGER ulOffset,
    byte* pv,
    ULONG cb,
    ULONG* pcbRead);
void __stdcall ILockBytes_RemoteReadAt_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ILockBytes_RemoteWriteAt_Proxy(
    ILockBytes* This,
    ULARGE_INTEGER ulOffset,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
void __stdcall ILockBytes_RemoteWriteAt_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IEnumFORMATETC* LPENUMFORMATETC;
typedef struct tagDVTARGETDEVICE {
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;
typedef CLIPFORMAT* LPCLIPFORMAT;
typedef struct tagFORMATETC {
    CLIPFORMAT cfFormat;
    DVTARGETDEVICE* ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
} FORMATETC;
typedef struct tagFORMATETC* LPFORMATETC;
extern "C" const IID IID_IEnumFORMATETC;
struct __declspec(uuid("00000103-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumFORMATETC : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        FORMATETC* rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumFORMATETC** ppenum)
        = 0;
};
HRESULT __stdcall IEnumFORMATETC_RemoteNext_Proxy(
    IEnumFORMATETC* This,
    ULONG celt,
    FORMATETC* rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumFORMATETC_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IEnumSTATDATA* LPENUMSTATDATA;
typedef enum tagADVF {
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;
typedef struct tagSTATDATA {
    FORMATETC formatetc;
    DWORD advf;
    IAdviseSink* pAdvSink;
    DWORD dwConnection;
} STATDATA;
typedef STATDATA* LPSTATDATA;
extern "C" const IID IID_IEnumSTATDATA;
struct __declspec(uuid("00000105-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumSTATDATA : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        STATDATA* rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumSTATDATA** ppenum)
        = 0;
};
HRESULT __stdcall IEnumSTATDATA_RemoteNext_Proxy(
    IEnumSTATDATA* This,
    ULONG celt,
    STATDATA* rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumSTATDATA_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IRootStorage* LPROOTSTORAGE;
extern "C" const IID IID_IRootStorage;
struct __declspec(uuid("00000012-0000-0000-C000-000000000046")) __declspec(novtable)
    IRootStorage : public IUnknown {
public:
    virtual HRESULT __stdcall SwitchToFile(
        LPOLESTR pszFile)
        = 0;
};
typedef IAdviseSink* LPADVISESINK;
typedef enum tagTYMED {
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_ENHMF = 64,
    TYMED_NULL = 0
} TYMED;
#pragma warning(push)
#pragma warning(disable : 4200)
typedef struct tagRemSTGMEDIUM {
    DWORD tymed;
    DWORD dwHandleType;
    ULONG pData;
    ULONG pUnkForRelease;
    ULONG cbData;
    byte data[1];
} RemSTGMEDIUM;
#pragma warning(pop)
typedef struct tagSTGMEDIUM {
    DWORD tymed;
    union {
        HBITMAP hBitmap;
        HMETAFILEPICT hMetaFilePict;
        HENHMETAFILE hEnhMetaFile;
        HGLOBAL hGlobal;
        LPOLESTR lpszFileName;
        IStream* pstm;
        IStorage* pstg;
    };
    IUnknown* pUnkForRelease;
} uSTGMEDIUM;
typedef struct _GDI_OBJECT {
    DWORD ObjectType;
    union __MIDL_IAdviseSink_0002 {
        wireHBITMAP hBitmap;
        wireHPALETTE hPalette;
        wireHGLOBAL hGeneric;
    } u;
} GDI_OBJECT;
typedef struct _userSTGMEDIUM {
    struct _STGMEDIUM_UNION {
        DWORD tymed;
        union __MIDL_IAdviseSink_0003 {
            wireHMETAFILEPICT hMetaFilePict;
            wireHENHMETAFILE hHEnhMetaFile;
            GDI_OBJECT* hGdiHandle;
            wireHGLOBAL hGlobal;
            LPOLESTR lpszFileName;
            BYTE_BLOB* pstm;
            BYTE_BLOB* pstg;
        } u;
    };
    IUnknown* pUnkForRelease;
} userSTGMEDIUM;
typedef userSTGMEDIUM* wireSTGMEDIUM;
typedef uSTGMEDIUM STGMEDIUM;
typedef userSTGMEDIUM* wireASYNC_STGMEDIUM;
typedef STGMEDIUM ASYNC_STGMEDIUM;
typedef STGMEDIUM* LPSTGMEDIUM;
typedef struct _userFLAG_STGMEDIUM {
    LONG ContextFlags;
    LONG fPassOwnership;
    userSTGMEDIUM Stgmed;
} userFLAG_STGMEDIUM;
typedef userFLAG_STGMEDIUM* wireFLAG_STGMEDIUM;
typedef struct _FLAG_STGMEDIUM {
    LONG ContextFlags;
    LONG fPassOwnership;
    STGMEDIUM Stgmed;
} FLAG_STGMEDIUM;
extern "C" const IID IID_IAdviseSink;
struct __declspec(uuid("0000010f-0000-0000-C000-000000000046")) __declspec(novtable)
    IAdviseSink : public IUnknown {
public:
    virtual void __stdcall OnDataChange(
        FORMATETC* pFormatetc,
        STGMEDIUM* pStgmed)
        = 0;
    virtual void __stdcall OnViewChange(
        DWORD dwAspect,
        LONG lindex)
        = 0;
    virtual void __stdcall OnRename(
        IMoniker* pmk)
        = 0;
    virtual void __stdcall OnSave(void) = 0;
    virtual void __stdcall OnClose(void) = 0;
};
HRESULT __stdcall IAdviseSink_RemoteOnDataChange_Proxy(
    IAdviseSink* This,
    FORMATETC* pFormatetc,
    ASYNC_STGMEDIUM* pStgmed);
void __stdcall IAdviseSink_RemoteOnDataChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IAdviseSink_RemoteOnViewChange_Proxy(
    IAdviseSink* This,
    DWORD dwAspect,
    LONG lindex);
void __stdcall IAdviseSink_RemoteOnViewChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IAdviseSink_RemoteOnRename_Proxy(
    IAdviseSink* This,
    IMoniker* pmk);
void __stdcall IAdviseSink_RemoteOnRename_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IAdviseSink_RemoteOnSave_Proxy(
    IAdviseSink* This);
void __stdcall IAdviseSink_RemoteOnSave_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IAdviseSink_RemoteOnClose_Proxy(
    IAdviseSink* This);
void __stdcall IAdviseSink_RemoteOnClose_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern "C" const IID IID_AsyncIAdviseSink;
struct __declspec(uuid("00000150-0000-0000-C000-000000000046")) __declspec(novtable)
    AsyncIAdviseSink : public IUnknown {
public:
    virtual void __stdcall Begin_OnDataChange(
        FORMATETC* pFormatetc,
        STGMEDIUM* pStgmed)
        = 0;
    virtual void __stdcall Finish_OnDataChange(void) = 0;
    virtual void __stdcall Begin_OnViewChange(
        DWORD dwAspect,
        LONG lindex)
        = 0;
    virtual void __stdcall Finish_OnViewChange(void) = 0;
    virtual void __stdcall Begin_OnRename(
        IMoniker* pmk)
        = 0;
    virtual void __stdcall Finish_OnRename(void) = 0;
    virtual void __stdcall Begin_OnSave(void) = 0;
    virtual void __stdcall Finish_OnSave(void) = 0;
    virtual void __stdcall Begin_OnClose(void) = 0;
    virtual void __stdcall Finish_OnClose(void) = 0;
};
HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(
    AsyncIAdviseSink* This,
    FORMATETC* pFormatetc,
    ASYNC_STGMEDIUM* pStgmed);
void __stdcall AsyncIAdviseSink_Begin_RemoteOnDataChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_RemoteOnDataChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(
    AsyncIAdviseSink* This,
    DWORD dwAspect,
    LONG lindex);
void __stdcall AsyncIAdviseSink_Begin_RemoteOnViewChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_RemoteOnViewChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(
    AsyncIAdviseSink* This,
    IMoniker* pmk);
void __stdcall AsyncIAdviseSink_Begin_RemoteOnRename_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_RemoteOnRename_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_RemoteOnSave_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_RemoteOnSave_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_RemoteOnClose_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_RemoteOnClose_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0073_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0073_v0_0_s_ifspec;
typedef IAdviseSink2* LPADVISESINK2;
extern "C" const IID IID_IAdviseSink2;
struct __declspec(uuid("00000125-0000-0000-C000-000000000046")) __declspec(novtable)
    IAdviseSink2 : public IAdviseSink {
public:
    virtual void __stdcall OnLinkSrcChange(
        IMoniker* pmk)
        = 0;
};
HRESULT __stdcall IAdviseSink2_RemoteOnLinkSrcChange_Proxy(
    IAdviseSink2* This,
    IMoniker* pmk);
void __stdcall IAdviseSink2_RemoteOnLinkSrcChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern "C" const IID IID_AsyncIAdviseSink2;
struct __declspec(uuid("00000151-0000-0000-C000-000000000046")) __declspec(novtable)
    AsyncIAdviseSink2 : public AsyncIAdviseSink {
public:
    virtual void __stdcall Begin_OnLinkSrcChange(
        IMoniker* pmk)
        = 0;
    virtual void __stdcall Finish_OnLinkSrcChange(void) = 0;
};
HRESULT __stdcall AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(
    AsyncIAdviseSink2* This,
    IMoniker* pmk);
void __stdcall AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(
    AsyncIAdviseSink2* This);
void __stdcall AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0074_v0_0_s_ifspec;
typedef IDataObject* LPDATAOBJECT;
typedef enum tagDATADIR {
    DATADIR_GET = 1,
    DATADIR_SET = 2
} DATADIR;
extern "C" const IID IID_IDataObject;
struct __declspec(uuid("0000010e-0000-0000-C000-000000000046")) __declspec(novtable)
    IDataObject : public IUnknown {
public:
    virtual HRESULT __stdcall GetData(
        FORMATETC* pformatetcIn,
        STGMEDIUM* pmedium)
        = 0;
    virtual HRESULT __stdcall GetDataHere(
        FORMATETC* pformatetc,
        STGMEDIUM* pmedium)
        = 0;
    virtual HRESULT __stdcall QueryGetData(
        FORMATETC* pformatetc)
        = 0;
    virtual HRESULT __stdcall GetCanonicalFormatEtc(
        FORMATETC* pformatectIn,
        FORMATETC* pformatetcOut)
        = 0;
    virtual HRESULT __stdcall SetData(
        FORMATETC* pformatetc,
        STGMEDIUM* pmedium,
        BOOL fRelease)
        = 0;
    virtual HRESULT __stdcall EnumFormatEtc(
        DWORD dwDirection,
        IEnumFORMATETC** ppenumFormatEtc)
        = 0;
    virtual HRESULT __stdcall DAdvise(
        FORMATETC* pformatetc,
        DWORD advf,
        IAdviseSink* pAdvSink,
        DWORD* pdwConnection)
        = 0;
    virtual HRESULT __stdcall DUnadvise(
        DWORD dwConnection)
        = 0;
    virtual HRESULT __stdcall EnumDAdvise(
        IEnumSTATDATA** ppenumAdvise)
        = 0;
};
HRESULT __stdcall IDataObject_RemoteGetData_Proxy(
    IDataObject* This,
    FORMATETC* pformatetcIn,
    STGMEDIUM* pRemoteMedium);
void __stdcall IDataObject_RemoteGetData_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IDataObject_RemoteGetDataHere_Proxy(
    IDataObject* This,
    FORMATETC* pformatetc,
    STGMEDIUM* pRemoteMedium);
void __stdcall IDataObject_RemoteGetDataHere_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IDataObject_RemoteSetData_Proxy(
    IDataObject* This,
    FORMATETC* pformatetc,
    FLAG_STGMEDIUM* pmedium,
    BOOL fRelease);
void __stdcall IDataObject_RemoteSetData_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0075_v0_0_s_ifspec;
typedef IDataAdviseHolder* LPDATAADVISEHOLDER;
extern "C" const IID IID_IDataAdviseHolder;
struct __declspec(uuid("00000110-0000-0000-C000-000000000046")) __declspec(novtable)
    IDataAdviseHolder : public IUnknown {
public:
    virtual HRESULT __stdcall Advise(
        IDataObject* pDataObject,
        FORMATETC* pFetc,
        DWORD advf,
        IAdviseSink* pAdvise,
        DWORD* pdwConnection)
        = 0;
    virtual HRESULT __stdcall Unadvise(
        DWORD dwConnection)
        = 0;
    virtual HRESULT __stdcall EnumAdvise(
        IEnumSTATDATA** ppenumAdvise)
        = 0;
    virtual HRESULT __stdcall SendOnDataChange(
        IDataObject* pDataObject,
        DWORD dwReserved,
        DWORD advf)
        = 0;
};
typedef IMessageFilter* LPMESSAGEFILTER;
typedef enum tagCALLTYPE {
    CALLTYPE_TOPLEVEL = 1,
    CALLTYPE_NESTED = 2,
    CALLTYPE_ASYNC = 3,
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,
    CALLTYPE_ASYNC_CALLPENDING = 5
} CALLTYPE;
typedef enum tagSERVERCALL {
    SERVERCALL_ISHANDLED = 0,
    SERVERCALL_REJECTED = 1,
    SERVERCALL_RETRYLATER = 2
} SERVERCALL;
typedef enum tagPENDINGTYPE {
    PENDINGTYPE_TOPLEVEL = 1,
    PENDINGTYPE_NESTED = 2
} PENDINGTYPE;
typedef enum tagPENDINGMSG {
    PENDINGMSG_CANCELCALL = 0,
    PENDINGMSG_WAITNOPROCESS = 1,
    PENDINGMSG_WAITDEFPROCESS = 2
} PENDINGMSG;
typedef struct tagINTERFACEINFO {
    IUnknown* pUnk;
    IID iid;
    WORD wMethod;
} INTERFACEINFO;
typedef struct tagINTERFACEINFO* LPINTERFACEINFO;
extern "C" const IID IID_IMessageFilter;
struct __declspec(uuid("00000016-0000-0000-C000-000000000046")) __declspec(novtable)
    IMessageFilter : public IUnknown {
public:
    virtual DWORD __stdcall HandleInComingCall(
        DWORD dwCallType,
        HTASK htaskCaller,
        DWORD dwTickCount,
        LPINTERFACEINFO lpInterfaceInfo)
        = 0;
    virtual DWORD __stdcall RetryRejectedCall(
        HTASK htaskCallee,
        DWORD dwTickCount,
        DWORD dwRejectType)
        = 0;
    virtual DWORD __stdcall MessagePending(
        HTASK htaskCallee,
        DWORD dwTickCount,
        DWORD dwPendingType)
        = 0;
};
extern const FMTID FMTID_SummaryInformation;
extern const FMTID FMTID_DocSummaryInformation;
extern const FMTID FMTID_UserDefinedProperties;
extern const FMTID FMTID_DiscardableInformation;
extern const FMTID FMTID_ImageSummaryInformation;
extern const FMTID FMTID_AudioSummaryInformation;
extern const FMTID FMTID_VideoSummaryInformation;
extern const FMTID FMTID_MediaFileSummaryInformation;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0077_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0077_v0_0_s_ifspec;
extern "C" const IID IID_IClassActivator;
struct __declspec(uuid("00000140-0000-0000-C000-000000000046")) __declspec(novtable)
    IClassActivator : public IUnknown {
public:
    virtual HRESULT __stdcall GetClassObject(
        const IID& rclsid,
        DWORD dwClassContext,
        LCID locale,
        const IID& riid,
        void** ppv)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0078_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0078_v0_0_s_ifspec;
extern "C" const IID IID_IFillLockBytes;
struct __declspec(uuid("99caf010-415e-11cf-8814-00aa00b569f5")) __declspec(novtable)
    IFillLockBytes : public IUnknown {
public:
    virtual HRESULT __stdcall FillAppend(
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
        = 0;
    virtual HRESULT __stdcall FillAt(
        ULARGE_INTEGER ulOffset,
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
        = 0;
    virtual HRESULT __stdcall SetFillSize(
        ULARGE_INTEGER ulSize)
        = 0;
    virtual HRESULT __stdcall Terminate(
        BOOL bCanceled)
        = 0;
};
HRESULT __stdcall IFillLockBytes_RemoteFillAppend_Proxy(
    IFillLockBytes* This,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
void __stdcall IFillLockBytes_RemoteFillAppend_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IFillLockBytes_RemoteFillAt_Proxy(
    IFillLockBytes* This,
    ULARGE_INTEGER ulOffset,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
void __stdcall IFillLockBytes_RemoteFillAt_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0079_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0079_v0_0_s_ifspec;
extern "C" const IID IID_IProgressNotify;
struct __declspec(uuid("a9d758a0-4617-11cf-95fc-00aa00680db4")) __declspec(novtable)
    IProgressNotify : public IUnknown {
public:
    virtual HRESULT __stdcall OnProgress(
        DWORD dwProgressCurrent,
        DWORD dwProgressMaximum,
        BOOL fAccurate,
        BOOL fOwner)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0080_v0_0_s_ifspec;
typedef struct tagStorageLayout {
    DWORD LayoutType;
    OLECHAR* pwcsElementName;
    LARGE_INTEGER cOffset;
    LARGE_INTEGER cBytes;
} StorageLayout;
extern "C" const IID IID_ILayoutStorage;
struct __declspec(uuid("0e6d4d90-6738-11cf-9608-00aa00680db4")) __declspec(novtable)
    ILayoutStorage : public IUnknown {
public:
    virtual HRESULT __stdcall LayoutScript(
        StorageLayout* pStorageLayout,
        DWORD nEntries,
        DWORD glfInterleavedFlag)
        = 0;
    virtual HRESULT __stdcall BeginMonitor(void) = 0;
    virtual HRESULT __stdcall EndMonitor(void) = 0;
    virtual HRESULT __stdcall ReLayoutDocfile(
        OLECHAR* pwcsNewDfName)
        = 0;
    virtual HRESULT __stdcall ReLayoutDocfileOnILockBytes(
        ILockBytes* pILockBytes)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0081_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0081_v0_0_s_ifspec;
extern "C" const IID IID_IBlockingLock;
struct __declspec(uuid("30f3d47a-6447-11d1-8e3c-00c04fb9386d")) __declspec(novtable)
    IBlockingLock : public IUnknown {
public:
    virtual HRESULT __stdcall Lock(
        DWORD dwTimeout)
        = 0;
    virtual HRESULT __stdcall Unlock(void) = 0;
};
extern "C" const IID IID_ITimeAndNoticeControl;
struct __declspec(uuid("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4")) __declspec(novtable)
    ITimeAndNoticeControl : public IUnknown {
public:
    virtual HRESULT __stdcall SuppressChanges(
        DWORD res1,
        DWORD res2)
        = 0;
};
extern "C" const IID IID_IOplockStorage;
struct __declspec(uuid("8d19c834-8879-11d1-83e9-00c04fc2c6d4")) __declspec(novtable)
    IOplockStorage : public IUnknown {
public:
    virtual HRESULT __stdcall CreateStorageEx(
        LPCWSTR pwcsName,
        DWORD grfMode,
        DWORD stgfmt,
        DWORD grfAttrs,
        const IID& riid,
        void** ppstgOpen)
        = 0;
    virtual HRESULT __stdcall OpenStorageEx(
        LPCWSTR pwcsName,
        DWORD grfMode,
        DWORD stgfmt,
        DWORD grfAttrs,
        const IID& riid,
        void** ppstgOpen)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0084_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0084_v0_0_s_ifspec;
extern "C" const IID IID_IDirectWriterLock;
struct __declspec(uuid("0e6d4d92-6738-11cf-9608-00aa00680db4")) __declspec(novtable)
    IDirectWriterLock : public IUnknown {
public:
    virtual HRESULT __stdcall WaitForWriteAccess(
        DWORD dwTimeout)
        = 0;
    virtual HRESULT __stdcall ReleaseWriteAccess(void) = 0;
    virtual HRESULT __stdcall HaveWriteAccess(void) = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0085_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0085_v0_0_s_ifspec;
extern "C" const IID IID_IUrlMon;
struct __declspec(uuid("00000026-0000-0000-C000-000000000046")) __declspec(novtable)
    IUrlMon : public IUnknown {
public:
    virtual HRESULT __stdcall AsyncGetClassBits(
        const IID& rclsid,
        LPCWSTR pszTYPE,
        LPCWSTR pszExt,
        DWORD dwFileVersionMS,
        DWORD dwFileVersionLS,
        LPCWSTR pszCodeBase,
        IBindCtx* pbc,
        DWORD dwClassContext,
        const IID& riid,
        DWORD flags)
        = 0;
};
extern "C" const IID IID_IForegroundTransfer;
struct __declspec(uuid("00000145-0000-0000-C000-000000000046")) __declspec(novtable)
    IForegroundTransfer : public IUnknown {
public:
    virtual HRESULT __stdcall AllowForegroundTransfer(
        void* lpvReserved)
        = 0;
};
extern "C" const IID IID_IThumbnailExtractor;
struct __declspec(uuid("969dc708-5c76-11d1-8d86-0000f804b057")) __declspec(novtable)
    IThumbnailExtractor : public IUnknown {
public:
    virtual HRESULT __stdcall ExtractThumbnail(
        IStorage* pStg,
        ULONG ulLength,
        ULONG ulHeight,
        ULONG* pulOutputLength,
        ULONG* pulOutputHeight,
        HBITMAP* phOutputBitmap)
        = 0;
    virtual HRESULT __stdcall OnFileUpdated(
        IStorage* pStg)
        = 0;
};
extern "C" const IID IID_IDummyHICONIncluder;
struct __declspec(uuid("947990de-cc28-11d2-a0f7-00805f858fb1")) __declspec(novtable)
    IDummyHICONIncluder : public IUnknown {
public:
    virtual HRESULT __stdcall Dummy(
        HICON h1,
        HDC h2)
        = 0;
};
typedef enum tagApplicationType {
    ServerApplication = 0,
    LibraryApplication = (ServerApplication + 1)
} ApplicationType;
typedef enum tagShutdownType {
    IdleShutdown = 0,
    ForcedShutdown = (IdleShutdown + 1)
} ShutdownType;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0089_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0089_v0_0_s_ifspec;
extern "C" const IID IID_IProcessLock;
struct __declspec(uuid("000001d5-0000-0000-C000-000000000046")) __declspec(novtable)
    IProcessLock : public IUnknown {
public:
    virtual ULONG __stdcall AddRefOnProcess(void) = 0;
    virtual ULONG __stdcall ReleaseRefOnProcess(void) = 0;
};
extern "C" const IID IID_ISurrogateService;
struct __declspec(uuid("000001d4-0000-0000-C000-000000000046")) __declspec(novtable)
    ISurrogateService : public IUnknown {
public:
    virtual HRESULT __stdcall Init(
        const GUID& rguidProcessID,
        IProcessLock* pProcessLock,
        BOOL* pfApplicationAware)
        = 0;
    virtual HRESULT __stdcall ApplicationLaunch(
        const GUID& rguidApplID,
        ApplicationType appType)
        = 0;
    virtual HRESULT __stdcall ApplicationFree(
        const GUID& rguidApplID)
        = 0;
    virtual HRESULT __stdcall CatalogRefresh(
        ULONG ulReserved)
        = 0;
    virtual HRESULT __stdcall ProcessShutdown(
        ShutdownType shutdownType)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0091_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0091_v0_0_s_ifspec;
typedef IInitializeSpy* LPINITIALIZESPY;
extern "C" const IID IID_IInitializeSpy;
struct __declspec(uuid("00000034-0000-0000-C000-000000000046")) __declspec(novtable)
    IInitializeSpy : public IUnknown {
public:
    virtual HRESULT __stdcall PreInitialize(
        DWORD dwCoInit,
        DWORD dwCurThreadAptRefs)
        = 0;
    virtual HRESULT __stdcall PostInitialize(
        HRESULT hrCoInit,
        DWORD dwCoInit,
        DWORD dwNewThreadAptRefs)
        = 0;
    virtual HRESULT __stdcall PreUninitialize(
        DWORD dwCurThreadAptRefs)
        = 0;
    virtual HRESULT __stdcall PostUninitialize(
        DWORD dwNewThreadAptRefs)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0092_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0092_v0_0_s_ifspec;
extern "C" const IID IID_IApartmentShutdown;
struct __declspec(uuid("A2F05A09-27A2-42B5-BC0E-AC163EF49D9B")) __declspec(novtable)
    IApartmentShutdown : public IUnknown {
public:
    virtual void __stdcall OnUninitialize(
        UINT64 ui64ApartmentIdentifier)
        = 0;
};
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0093_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0093_v0_0_s_ifspec;
unsigned long __stdcall ASYNC_STGMEDIUM_UserSize(unsigned long*, unsigned long, ASYNC_STGMEDIUM*);
unsigned char* __stdcall ASYNC_STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
unsigned char* __stdcall ASYNC_STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
void __stdcall ASYNC_STGMEDIUM_UserFree(unsigned long*, ASYNC_STGMEDIUM*);
unsigned long __stdcall CLIPFORMAT_UserSize(unsigned long*, unsigned long, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserMarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserUnmarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
void __stdcall CLIPFORMAT_UserFree(unsigned long*, CLIPFORMAT*);
unsigned long __stdcall FLAG_STGMEDIUM_UserSize(unsigned long*, unsigned long, FLAG_STGMEDIUM*);
unsigned char* __stdcall FLAG_STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
unsigned char* __stdcall FLAG_STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
void __stdcall FLAG_STGMEDIUM_UserFree(unsigned long*, FLAG_STGMEDIUM*);
unsigned long __stdcall HBITMAP_UserSize(unsigned long*, unsigned long, HBITMAP*);
unsigned char* __stdcall HBITMAP_UserMarshal(unsigned long*, unsigned char*, HBITMAP*);
unsigned char* __stdcall HBITMAP_UserUnmarshal(unsigned long*, unsigned char*, HBITMAP*);
void __stdcall HBITMAP_UserFree(unsigned long*, HBITMAP*);
unsigned long __stdcall HDC_UserSize(unsigned long*, unsigned long, HDC*);
unsigned char* __stdcall HDC_UserMarshal(unsigned long*, unsigned char*, HDC*);
unsigned char* __stdcall HDC_UserUnmarshal(unsigned long*, unsigned char*, HDC*);
void __stdcall HDC_UserFree(unsigned long*, HDC*);
unsigned long __stdcall HICON_UserSize(unsigned long*, unsigned long, HICON*);
unsigned char* __stdcall HICON_UserMarshal(unsigned long*, unsigned char*, HICON*);
unsigned char* __stdcall HICON_UserUnmarshal(unsigned long*, unsigned char*, HICON*);
void __stdcall HICON_UserFree(unsigned long*, HICON*);
unsigned long __stdcall SNB_UserSize(unsigned long*, unsigned long, SNB*);
unsigned char* __stdcall SNB_UserMarshal(unsigned long*, unsigned char*, SNB*);
unsigned char* __stdcall SNB_UserUnmarshal(unsigned long*, unsigned char*, SNB*);
void __stdcall SNB_UserFree(unsigned long*, SNB*);
unsigned long __stdcall STGMEDIUM_UserSize(unsigned long*, unsigned long, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, STGMEDIUM*);
void __stdcall STGMEDIUM_UserFree(unsigned long*, STGMEDIUM*);
unsigned long __stdcall ASYNC_STGMEDIUM_UserSize64(unsigned long*, unsigned long, ASYNC_STGMEDIUM*);
unsigned char* __stdcall ASYNC_STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
unsigned char* __stdcall ASYNC_STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
void __stdcall ASYNC_STGMEDIUM_UserFree64(unsigned long*, ASYNC_STGMEDIUM*);
unsigned long __stdcall CLIPFORMAT_UserSize64(unsigned long*, unsigned long, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserMarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserUnmarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
void __stdcall CLIPFORMAT_UserFree64(unsigned long*, CLIPFORMAT*);
unsigned long __stdcall FLAG_STGMEDIUM_UserSize64(unsigned long*, unsigned long, FLAG_STGMEDIUM*);
unsigned char* __stdcall FLAG_STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
unsigned char* __stdcall FLAG_STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
void __stdcall FLAG_STGMEDIUM_UserFree64(unsigned long*, FLAG_STGMEDIUM*);
unsigned long __stdcall HBITMAP_UserSize64(unsigned long*, unsigned long, HBITMAP*);
unsigned char* __stdcall HBITMAP_UserMarshal64(unsigned long*, unsigned char*, HBITMAP*);
unsigned char* __stdcall HBITMAP_UserUnmarshal64(unsigned long*, unsigned char*, HBITMAP*);
void __stdcall HBITMAP_UserFree64(unsigned long*, HBITMAP*);
unsigned long __stdcall HDC_UserSize64(unsigned long*, unsigned long, HDC*);
unsigned char* __stdcall HDC_UserMarshal64(unsigned long*, unsigned char*, HDC*);
unsigned char* __stdcall HDC_UserUnmarshal64(unsigned long*, unsigned char*, HDC*);
void __stdcall HDC_UserFree64(unsigned long*, HDC*);
unsigned long __stdcall HICON_UserSize64(unsigned long*, unsigned long, HICON*);
unsigned char* __stdcall HICON_UserMarshal64(unsigned long*, unsigned char*, HICON*);
unsigned char* __stdcall HICON_UserUnmarshal64(unsigned long*, unsigned char*, HICON*);
void __stdcall HICON_UserFree64(unsigned long*, HICON*);
unsigned long __stdcall SNB_UserSize64(unsigned long*, unsigned long, SNB*);
unsigned char* __stdcall SNB_UserMarshal64(unsigned long*, unsigned char*, SNB*);
unsigned char* __stdcall SNB_UserUnmarshal64(unsigned long*, unsigned char*, SNB*);
void __stdcall SNB_UserFree64(unsigned long*, SNB*);
unsigned long __stdcall STGMEDIUM_UserSize64(unsigned long*, unsigned long, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
void __stdcall STGMEDIUM_UserFree64(unsigned long*, STGMEDIUM*);
HRESULT __stdcall IEnumUnknown_Next_Proxy(
    IEnumUnknown* This,
    ULONG celt,
    IUnknown** rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumUnknown_Next_Stub(
    IEnumUnknown* This,
    ULONG celt,
    IUnknown** rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumString_Next_Proxy(
    IEnumString* This,
    ULONG celt,
    LPOLESTR* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumString_Next_Stub(
    IEnumString* This,
    ULONG celt,
    LPOLESTR* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall ISequentialStream_Read_Proxy(
    ISequentialStream* This,
    void* pv,
    ULONG cb,
    ULONG* pcbRead);
HRESULT __stdcall ISequentialStream_Read_Stub(
    ISequentialStream* This,
    byte* pv,
    ULONG cb,
    ULONG* pcbRead);
HRESULT __stdcall ISequentialStream_Write_Proxy(
    ISequentialStream* This,
    const void* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall ISequentialStream_Write_Stub(
    ISequentialStream* This,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall IStream_Seek_Proxy(
    IStream* This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER* plibNewPosition);
HRESULT __stdcall IStream_Seek_Stub(
    IStream* This,
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER* plibNewPosition);
HRESULT __stdcall IStream_CopyTo_Proxy(
    IStream* This,
    IStream* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* pcbRead,
    ULARGE_INTEGER* pcbWritten);
HRESULT __stdcall IStream_CopyTo_Stub(
    IStream* This,
    IStream* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* pcbRead,
    ULARGE_INTEGER* pcbWritten);
HRESULT __stdcall IBindCtx_SetBindOptions_Proxy(
    IBindCtx* This,
    BIND_OPTS* pbindopts);
HRESULT __stdcall IBindCtx_SetBindOptions_Stub(
    IBindCtx* This,
    BIND_OPTS2* pbindopts);
HRESULT __stdcall IBindCtx_GetBindOptions_Proxy(
    IBindCtx* This,
    BIND_OPTS* pbindopts);
HRESULT __stdcall IBindCtx_GetBindOptions_Stub(
    IBindCtx* This,
    BIND_OPTS2* pbindopts);
HRESULT __stdcall IEnumMoniker_Next_Proxy(
    IEnumMoniker* This,
    ULONG celt,
    IMoniker** rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumMoniker_Next_Stub(
    IEnumMoniker* This,
    ULONG celt,
    IMoniker** rgelt,
    ULONG* pceltFetched);
BOOL __stdcall IRunnableObject_IsRunning_Proxy(
    IRunnableObject* This);
HRESULT __stdcall IRunnableObject_IsRunning_Stub(
    IRunnableObject* This);
HRESULT __stdcall IMoniker_BindToObject_Proxy(
    IMoniker* This,
    IBindCtx* pbc,
    IMoniker* pmkToLeft,
    const IID& riidResult,
    void** ppvResult);
HRESULT __stdcall IMoniker_BindToObject_Stub(
    IMoniker* This,
    IBindCtx* pbc,
    IMoniker* pmkToLeft,
    const IID& riidResult,
    IUnknown** ppvResult);
HRESULT __stdcall IMoniker_BindToStorage_Proxy(
    IMoniker* This,
    IBindCtx* pbc,
    IMoniker* pmkToLeft,
    const IID& riid,
    void** ppvObj);
HRESULT __stdcall IMoniker_BindToStorage_Stub(
    IMoniker* This,
    IBindCtx* pbc,
    IMoniker* pmkToLeft,
    const IID& riid,
    IUnknown** ppvObj);
HRESULT __stdcall IEnumSTATSTG_Next_Proxy(
    IEnumSTATSTG* This,
    ULONG celt,
    STATSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATSTG_Next_Stub(
    IEnumSTATSTG* This,
    ULONG celt,
    STATSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IStorage_OpenStream_Proxy(
    IStorage* This,
    const OLECHAR* pwcsName,
    void* reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream** ppstm);
HRESULT __stdcall IStorage_OpenStream_Stub(
    IStorage* This,
    const OLECHAR* pwcsName,
    ULONG cbReserved1,
    byte* reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream** ppstm);
HRESULT __stdcall IStorage_CopyTo_Proxy(
    IStorage* This,
    DWORD ciidExclude,
    const IID* rgiidExclude,
    SNB snbExclude,
    IStorage* pstgDest);
HRESULT __stdcall IStorage_CopyTo_Stub(
    IStorage* This,
    DWORD ciidExclude,
    const IID* rgiidExclude,
    SNB snbExclude,
    IStorage* pstgDest);
HRESULT __stdcall IStorage_EnumElements_Proxy(
    IStorage* This,
    DWORD reserved1,
    void* reserved2,
    DWORD reserved3,
    IEnumSTATSTG** ppenum);
HRESULT __stdcall IStorage_EnumElements_Stub(
    IStorage* This,
    DWORD reserved1,
    ULONG cbReserved2,
    byte* reserved2,
    DWORD reserved3,
    IEnumSTATSTG** ppenum);
HRESULT __stdcall ILockBytes_ReadAt_Proxy(
    ILockBytes* This,
    ULARGE_INTEGER ulOffset,
    void* pv,
    ULONG cb,
    ULONG* pcbRead);
HRESULT __stdcall ILockBytes_ReadAt_Stub(
    ILockBytes* This,
    ULARGE_INTEGER ulOffset,
    byte* pv,
    ULONG cb,
    ULONG* pcbRead);
HRESULT __stdcall ILockBytes_WriteAt_Proxy(
    ILockBytes* This,
    ULARGE_INTEGER ulOffset,
    const void* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall ILockBytes_WriteAt_Stub(
    ILockBytes* This,
    ULARGE_INTEGER ulOffset,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall IEnumFORMATETC_Next_Proxy(
    IEnumFORMATETC* This,
    ULONG celt,
    FORMATETC* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumFORMATETC_Next_Stub(
    IEnumFORMATETC* This,
    ULONG celt,
    FORMATETC* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATDATA_Next_Proxy(
    IEnumSTATDATA* This,
    ULONG celt,
    STATDATA* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATDATA_Next_Stub(
    IEnumSTATDATA* This,
    ULONG celt,
    STATDATA* rgelt,
    ULONG* pceltFetched);
void __stdcall IAdviseSink_OnDataChange_Proxy(
    IAdviseSink* This,
    FORMATETC* pFormatetc,
    STGMEDIUM* pStgmed);
HRESULT __stdcall IAdviseSink_OnDataChange_Stub(
    IAdviseSink* This,
    FORMATETC* pFormatetc,
    ASYNC_STGMEDIUM* pStgmed);
void __stdcall IAdviseSink_OnViewChange_Proxy(
    IAdviseSink* This,
    DWORD dwAspect,
    LONG lindex);
HRESULT __stdcall IAdviseSink_OnViewChange_Stub(
    IAdviseSink* This,
    DWORD dwAspect,
    LONG lindex);
void __stdcall IAdviseSink_OnRename_Proxy(
    IAdviseSink* This,
    IMoniker* pmk);
HRESULT __stdcall IAdviseSink_OnRename_Stub(
    IAdviseSink* This,
    IMoniker* pmk);
void __stdcall IAdviseSink_OnSave_Proxy(
    IAdviseSink* This);
HRESULT __stdcall IAdviseSink_OnSave_Stub(
    IAdviseSink* This);
void __stdcall IAdviseSink_OnClose_Proxy(
    IAdviseSink* This);
HRESULT __stdcall IAdviseSink_OnClose_Stub(
    IAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_OnDataChange_Proxy(
    AsyncIAdviseSink* This,
    FORMATETC* pFormatetc,
    STGMEDIUM* pStgmed);
HRESULT __stdcall AsyncIAdviseSink_Begin_OnDataChange_Stub(
    AsyncIAdviseSink* This,
    FORMATETC* pFormatetc,
    ASYNC_STGMEDIUM* pStgmed);
void __stdcall AsyncIAdviseSink_Finish_OnDataChange_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Finish_OnDataChange_Stub(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_OnViewChange_Proxy(
    AsyncIAdviseSink* This,
    DWORD dwAspect,
    LONG lindex);
HRESULT __stdcall AsyncIAdviseSink_Begin_OnViewChange_Stub(
    AsyncIAdviseSink* This,
    DWORD dwAspect,
    LONG lindex);
void __stdcall AsyncIAdviseSink_Finish_OnViewChange_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Finish_OnViewChange_Stub(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_OnRename_Proxy(
    AsyncIAdviseSink* This,
    IMoniker* pmk);
HRESULT __stdcall AsyncIAdviseSink_Begin_OnRename_Stub(
    AsyncIAdviseSink* This,
    IMoniker* pmk);
void __stdcall AsyncIAdviseSink_Finish_OnRename_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Finish_OnRename_Stub(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_OnSave_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Begin_OnSave_Stub(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_OnSave_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Finish_OnSave_Stub(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Begin_OnClose_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Begin_OnClose_Stub(
    AsyncIAdviseSink* This);
void __stdcall AsyncIAdviseSink_Finish_OnClose_Proxy(
    AsyncIAdviseSink* This);
HRESULT __stdcall AsyncIAdviseSink_Finish_OnClose_Stub(
    AsyncIAdviseSink* This);
void __stdcall IAdviseSink2_OnLinkSrcChange_Proxy(
    IAdviseSink2* This,
    IMoniker* pmk);
HRESULT __stdcall IAdviseSink2_OnLinkSrcChange_Stub(
    IAdviseSink2* This,
    IMoniker* pmk);
void __stdcall AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(
    AsyncIAdviseSink2* This,
    IMoniker* pmk);
HRESULT __stdcall AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(
    AsyncIAdviseSink2* This,
    IMoniker* pmk);
void __stdcall AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(
    AsyncIAdviseSink2* This);
HRESULT __stdcall AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(
    AsyncIAdviseSink2* This);
HRESULT __stdcall IDataObject_GetData_Proxy(
    IDataObject* This,
    FORMATETC* pformatetcIn,
    STGMEDIUM* pmedium);
HRESULT __stdcall IDataObject_GetData_Stub(
    IDataObject* This,
    FORMATETC* pformatetcIn,
    STGMEDIUM* pRemoteMedium);
HRESULT __stdcall IDataObject_GetDataHere_Proxy(
    IDataObject* This,
    FORMATETC* pformatetc,
    STGMEDIUM* pmedium);
HRESULT __stdcall IDataObject_GetDataHere_Stub(
    IDataObject* This,
    FORMATETC* pformatetc,
    STGMEDIUM* pRemoteMedium);
HRESULT __stdcall IDataObject_SetData_Proxy(
    IDataObject* This,
    FORMATETC* pformatetc,
    STGMEDIUM* pmedium,
    BOOL fRelease);
HRESULT __stdcall IDataObject_SetData_Stub(
    IDataObject* This,
    FORMATETC* pformatetc,
    FLAG_STGMEDIUM* pmedium,
    BOOL fRelease);
HRESULT __stdcall IFillLockBytes_FillAppend_Proxy(
    IFillLockBytes* This,
    const void* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall IFillLockBytes_FillAppend_Stub(
    IFillLockBytes* This,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall IFillLockBytes_FillAt_Proxy(
    IFillLockBytes* This,
    ULARGE_INTEGER ulOffset,
    const void* pv,
    ULONG cb,
    ULONG* pcbWritten);
HRESULT __stdcall IFillLockBytes_FillAt_Stub(
    IFillLockBytes* This,
    ULARGE_INTEGER ulOffset,
    const byte* pv,
    ULONG cb,
    ULONG* pcbWritten);
}
#pragma once
typedef struct IPropertyStorage IPropertyStorage;
typedef struct IPropertySetStorage IPropertySetStorage;
typedef struct IEnumSTATPROPSTG IEnumSTATPROPSTG;
typedef struct IEnumSTATPROPSETSTG IEnumSTATPROPSETSTG;
#pragma once
typedef struct ICreateTypeInfo ICreateTypeInfo;
typedef struct ICreateTypeInfo2 ICreateTypeInfo2;
typedef struct ICreateTypeLib ICreateTypeLib;
typedef struct ICreateTypeLib2 ICreateTypeLib2;
typedef struct IDispatch IDispatch;
typedef struct IEnumVARIANT IEnumVARIANT;
typedef struct ITypeComp ITypeComp;
typedef struct ITypeInfo ITypeInfo;
typedef struct ITypeInfo2 ITypeInfo2;
typedef struct ITypeLib ITypeLib;
typedef struct ITypeLib2 ITypeLib2;
typedef struct ITypeChangeEvents ITypeChangeEvents;
typedef struct IErrorInfo IErrorInfo;
typedef struct ICreateErrorInfo ICreateErrorInfo;
typedef struct ISupportErrorInfo ISupportErrorInfo;
typedef struct ITypeFactory ITypeFactory;
typedef struct ITypeMarshal ITypeMarshal;
typedef struct IRecordInfo IRecordInfo;
typedef struct IErrorLog IErrorLog;
typedef struct IPropertyBag IPropertyBag;
typedef struct ITypeLibRegistrationReader ITypeLibRegistrationReader;
typedef struct ITypeLibRegistration ITypeLibRegistration;
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma once
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Desktop Family or OneCore Family or OneCore Family
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0000_v0_0_s_ifspec;
typedef CY CURRENCY;
typedef struct tagSAFEARRAYBOUND {
    ULONG cElements;
    LONG lLbound;
} SAFEARRAYBOUND;
typedef struct tagSAFEARRAYBOUND* LPSAFEARRAYBOUND;
typedef struct _wireVARIANT* wireVARIANT;
typedef struct _wireBRECORD* wireBRECORD;
typedef struct _wireSAFEARR_BSTR {
    ULONG Size;
    wireBSTR* aBstr;
} SAFEARR_BSTR;
typedef struct _wireSAFEARR_UNKNOWN {
    ULONG Size;
    IUnknown** apUnknown;
} SAFEARR_UNKNOWN;
typedef struct _wireSAFEARR_DISPATCH {
    ULONG Size;
    IDispatch** apDispatch;
} SAFEARR_DISPATCH;
typedef struct _wireSAFEARR_VARIANT {
    ULONG Size;
    wireVARIANT* aVariant;
} SAFEARR_VARIANT;
typedef struct _wireSAFEARR_BRECORD {
    ULONG Size;
    wireBRECORD* aRecord;
} SAFEARR_BRECORD;
typedef struct _wireSAFEARR_HAVEIID {
    ULONG Size;
    IUnknown** apUnknown;
    IID iid;
} SAFEARR_HAVEIID;
typedef enum tagSF_TYPE {
    SF_ERROR = VT_ERROR,
    SF_I1 = VT_I1,
    SF_I2 = VT_I2,
    SF_I4 = VT_I4,
    SF_I8 = VT_I8,
    SF_BSTR = VT_BSTR,
    SF_UNKNOWN = VT_UNKNOWN,
    SF_DISPATCH = VT_DISPATCH,
    SF_VARIANT = VT_VARIANT,
    SF_RECORD = VT_RECORD,
    SF_HAVEIID = (VT_UNKNOWN | VT_RESERVED)
} SF_TYPE;
typedef struct _wireSAFEARRAY_UNION {
    ULONG sfType;
    union __MIDL_IOleAutomationTypes_0001 {
        SAFEARR_BSTR BstrStr;
        SAFEARR_UNKNOWN UnknownStr;
        SAFEARR_DISPATCH DispatchStr;
        SAFEARR_VARIANT VariantStr;
        SAFEARR_BRECORD RecordStr;
        SAFEARR_HAVEIID HaveIidStr;
        BYTE_SIZEDARR ByteStr;
        WORD_SIZEDARR WordStr;
        DWORD_SIZEDARR LongStr;
        HYPER_SIZEDARR HyperStr;
    } u;
} SAFEARRAYUNION;
typedef struct _wireSAFEARRAY {
    USHORT cDims;
    USHORT fFeatures;
    ULONG cbElements;
    ULONG cLocks;
    SAFEARRAYUNION uArrayStructs;
    SAFEARRAYBOUND rgsabound[1];
} * wireSAFEARRAY;
typedef wireSAFEARRAY* wirePSAFEARRAY;
typedef struct tagSAFEARRAY {
    USHORT cDims;
    USHORT fFeatures;
    ULONG cbElements;
    ULONG cLocks;
    PVOID pvData;
    SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY;
typedef SAFEARRAY* LPSAFEARRAY;
typedef struct tagVARIANT VARIANT;
struct tagVARIANT {
    union {
        struct
        {
            VARTYPE vt;
            WORD wReserved1;
            WORD wReserved2;
            WORD wReserved3;
            union {
                LONGLONG llVal;
                LONG lVal;
                BYTE bVal;
                SHORT iVal;
                FLOAT fltVal;
                DOUBLE dblVal;
                VARIANT_BOOL boolVal;
                VARIANT_BOOL __OBSOLETE__VARIANT_BOOL;
                SCODE scode;
                CY cyVal;
                DATE date;
                BSTR bstrVal;
                IUnknown* punkVal;
                IDispatch* pdispVal;
                SAFEARRAY* parray;
                BYTE* pbVal;
                SHORT* piVal;
                LONG* plVal;
                LONGLONG* pllVal;
                FLOAT* pfltVal;
                DOUBLE* pdblVal;
                VARIANT_BOOL* pboolVal;
                VARIANT_BOOL* __OBSOLETE__VARIANT_PBOOL;
                SCODE* pscode;
                CY* pcyVal;
                DATE* pdate;
                BSTR* pbstrVal;
                IUnknown** ppunkVal;
                IDispatch** ppdispVal;
                SAFEARRAY** pparray;
                VARIANT* pvarVal;
                PVOID byref;
                CHAR cVal;
                USHORT uiVal;
                ULONG ulVal;
                ULONGLONG ullVal;
                INT intVal;
                UINT uintVal;
                DECIMAL* pdecVal;
                CHAR* pcVal;
                USHORT* puiVal;
                ULONG* pulVal;
                ULONGLONG* pullVal;
                INT* pintVal;
                UINT* puintVal;
                struct
                {
                    PVOID pvRecord;
                    IRecordInfo* pRecInfo;
                };
            };
        };
        DECIMAL decVal;
    };
};
typedef VARIANT* LPVARIANT;
typedef VARIANT VARIANTARG;
typedef VARIANT* LPVARIANTARG;
struct _wireBRECORD {
    ULONG fFlags;
    ULONG clSize;
    IRecordInfo* pRecInfo;
    byte* pRecord;
};
struct _wireVARIANT {
    DWORD clSize;
    DWORD rpcReserved;
    USHORT vt;
    USHORT wReserved1;
    USHORT wReserved2;
    USHORT wReserved3;
    union {
        LONGLONG llVal;
        LONG lVal;
        BYTE bVal;
        SHORT iVal;
        FLOAT fltVal;
        DOUBLE dblVal;
        VARIANT_BOOL boolVal;
        SCODE scode;
        CY cyVal;
        DATE date;
        wireBSTR bstrVal;
        IUnknown* punkVal;
        IDispatch* pdispVal;
        wirePSAFEARRAY parray;
        wireBRECORD brecVal;
        BYTE* pbVal;
        SHORT* piVal;
        LONG* plVal;
        LONGLONG* pllVal;
        FLOAT* pfltVal;
        DOUBLE* pdblVal;
        VARIANT_BOOL* pboolVal;
        SCODE* pscode;
        CY* pcyVal;
        DATE* pdate;
        wireBSTR* pbstrVal;
        IUnknown** ppunkVal;
        IDispatch** ppdispVal;
        wirePSAFEARRAY* pparray;
        wireVARIANT* pvarVal;
        CHAR cVal;
        USHORT uiVal;
        ULONG ulVal;
        ULONGLONG ullVal;
        INT intVal;
        UINT uintVal;
        DECIMAL decVal;
        DECIMAL* pdecVal;
        CHAR* pcVal;
        USHORT* puiVal;
        ULONG* pulVal;
        ULONGLONG* pullVal;
        INT* pintVal;
        UINT* puintVal;
    };
};
typedef LONG DISPID;
typedef DISPID MEMBERID;
typedef DWORD HREFTYPE;
typedef enum tagTYPEKIND {
    TKIND_ENUM = 0,
    TKIND_RECORD = (TKIND_ENUM + 1),
    TKIND_MODULE = (TKIND_RECORD + 1),
    TKIND_INTERFACE = (TKIND_MODULE + 1),
    TKIND_DISPATCH = (TKIND_INTERFACE + 1),
    TKIND_COCLASS = (TKIND_DISPATCH + 1),
    TKIND_ALIAS = (TKIND_COCLASS + 1),
    TKIND_UNION = (TKIND_ALIAS + 1),
    TKIND_MAX = (TKIND_UNION + 1)
} TYPEKIND;
typedef struct tagTYPEDESC {
    union {
        struct tagTYPEDESC* lptdesc;
        struct tagARRAYDESC* lpadesc;
        HREFTYPE hreftype;
    };
    VARTYPE vt;
} TYPEDESC;
typedef struct tagARRAYDESC {
    TYPEDESC tdescElem;
    USHORT cDims;
    SAFEARRAYBOUND rgbounds[1];
} ARRAYDESC;
typedef struct tagPARAMDESCEX {
    ULONG cBytes;
    VARIANTARG varDefaultValue;
} PARAMDESCEX;
typedef struct tagPARAMDESCEX* LPPARAMDESCEX;
typedef struct tagPARAMDESC {
    LPPARAMDESCEX pparamdescex;
    USHORT wParamFlags;
} PARAMDESC;
typedef struct tagPARAMDESC* LPPARAMDESC;
typedef struct tagIDLDESC {
    ULONG_PTR dwReserved;
    USHORT wIDLFlags;
} IDLDESC;
typedef struct tagIDLDESC* LPIDLDESC;
typedef struct tagELEMDESC {
    TYPEDESC tdesc;
    union {
        IDLDESC idldesc;
        PARAMDESC paramdesc;
    };
} ELEMDESC, *LPELEMDESC;
typedef struct tagTYPEATTR {
    GUID guid;
    LCID lcid;
    DWORD dwReserved;
    MEMBERID memidConstructor;
    MEMBERID memidDestructor;
    LPOLESTR lpstrSchema;
    ULONG cbSizeInstance;
    TYPEKIND typekind;
    WORD cFuncs;
    WORD cVars;
    WORD cImplTypes;
    WORD cbSizeVft;
    WORD cbAlignment;
    WORD wTypeFlags;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    TYPEDESC tdescAlias;
    IDLDESC idldescType;
} TYPEATTR;
typedef struct tagTYPEATTR* LPTYPEATTR;
typedef struct tagDISPPARAMS {
    VARIANTARG* rgvarg;
    DISPID* rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
} DISPPARAMS;
typedef struct tagEXCEPINFO {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    PVOID pvReserved;
    HRESULT(__stdcall* pfnDeferredFillIn)
    (struct tagEXCEPINFO*);
    SCODE scode;
} EXCEPINFO, *LPEXCEPINFO;
typedef enum tagCALLCONV {
    CC_FASTCALL = 0,
    CC_CDECL = 1,
    CC_MSCPASCAL = (CC_CDECL + 1),
    CC_PASCAL = CC_MSCPASCAL,
    CC_MACPASCAL = (CC_PASCAL + 1),
    CC_STDCALL = (CC_MACPASCAL + 1),
    CC_FPFASTCALL = (CC_STDCALL + 1),
    CC_SYSCALL = (CC_FPFASTCALL + 1),
    CC_MPWCDECL = (CC_SYSCALL + 1),
    CC_MPWPASCAL = (CC_MPWCDECL + 1),
    CC_MAX = (CC_MPWPASCAL + 1)
} CALLCONV;
typedef enum tagFUNCKIND {
    FUNC_VIRTUAL = 0,
    FUNC_PUREVIRTUAL = (FUNC_VIRTUAL + 1),
    FUNC_NONVIRTUAL = (FUNC_PUREVIRTUAL + 1),
    FUNC_STATIC = (FUNC_NONVIRTUAL + 1),
    FUNC_DISPATCH = (FUNC_STATIC + 1)
} FUNCKIND;
typedef enum tagINVOKEKIND {
    INVOKE_FUNC = 1,
    INVOKE_PROPERTYGET = 2,
    INVOKE_PROPERTYPUT = 4,
    INVOKE_PROPERTYPUTREF = 8
} INVOKEKIND;
typedef struct tagFUNCDESC {
    MEMBERID memid;
    SCODE* lprgscode;
    ELEMDESC* lprgelemdescParam;
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    SHORT cScodes;
    ELEMDESC elemdescFunc;
    WORD wFuncFlags;
} FUNCDESC;
typedef struct tagFUNCDESC* LPFUNCDESC;
typedef enum tagVARKIND {
    VAR_PERINSTANCE = 0,
    VAR_STATIC = (VAR_PERINSTANCE + 1),
    VAR_CONST = (VAR_STATIC + 1),
    VAR_DISPATCH = (VAR_CONST + 1)
} VARKIND;
typedef struct tagVARDESC {
    MEMBERID memid;
    LPOLESTR lpstrSchema;
    union {
        ULONG oInst;
        VARIANT* lpvarValue;
    };
    ELEMDESC elemdescVar;
    WORD wVarFlags;
    VARKIND varkind;
} VARDESC;
typedef struct tagVARDESC* LPVARDESC;
typedef enum tagTYPEFLAGS {
    TYPEFLAG_FAPPOBJECT = 0x1,
    TYPEFLAG_FCANCREATE = 0x2,
    TYPEFLAG_FLICENSED = 0x4,
    TYPEFLAG_FPREDECLID = 0x8,
    TYPEFLAG_FHIDDEN = 0x10,
    TYPEFLAG_FCONTROL = 0x20,
    TYPEFLAG_FDUAL = 0x40,
    TYPEFLAG_FNONEXTENSIBLE = 0x80,
    TYPEFLAG_FOLEAUTOMATION = 0x100,
    TYPEFLAG_FRESTRICTED = 0x200,
    TYPEFLAG_FAGGREGATABLE = 0x400,
    TYPEFLAG_FREPLACEABLE = 0x800,
    TYPEFLAG_FDISPATCHABLE = 0x1000,
    TYPEFLAG_FREVERSEBIND = 0x2000,
    TYPEFLAG_FPROXY = 0x4000
} TYPEFLAGS;
typedef enum tagFUNCFLAGS {
    FUNCFLAG_FRESTRICTED = 0x1,
    FUNCFLAG_FSOURCE = 0x2,
    FUNCFLAG_FBINDABLE = 0x4,
    FUNCFLAG_FREQUESTEDIT = 0x8,
    FUNCFLAG_FDISPLAYBIND = 0x10,
    FUNCFLAG_FDEFAULTBIND = 0x20,
    FUNCFLAG_FHIDDEN = 0x40,
    FUNCFLAG_FUSESGETLASTERROR = 0x80,
    FUNCFLAG_FDEFAULTCOLLELEM = 0x100,
    FUNCFLAG_FUIDEFAULT = 0x200,
    FUNCFLAG_FNONBROWSABLE = 0x400,
    FUNCFLAG_FREPLACEABLE = 0x800,
    FUNCFLAG_FIMMEDIATEBIND = 0x1000
} FUNCFLAGS;
typedef enum tagVARFLAGS {
    VARFLAG_FREADONLY = 0x1,
    VARFLAG_FSOURCE = 0x2,
    VARFLAG_FBINDABLE = 0x4,
    VARFLAG_FREQUESTEDIT = 0x8,
    VARFLAG_FDISPLAYBIND = 0x10,
    VARFLAG_FDEFAULTBIND = 0x20,
    VARFLAG_FHIDDEN = 0x40,
    VARFLAG_FRESTRICTED = 0x80,
    VARFLAG_FDEFAULTCOLLELEM = 0x100,
    VARFLAG_FUIDEFAULT = 0x200,
    VARFLAG_FNONBROWSABLE = 0x400,
    VARFLAG_FREPLACEABLE = 0x800,
    VARFLAG_FIMMEDIATEBIND = 0x1000
} VARFLAGS;
typedef struct tagCLEANLOCALSTORAGE {
    IUnknown* pInterface;
    PVOID pStorage;
    DWORD flags;
} CLEANLOCALSTORAGE;
typedef struct tagCUSTDATAITEM {
    GUID guid;
    VARIANTARG varValue;
} CUSTDATAITEM;
typedef struct tagCUSTDATAITEM* LPCUSTDATAITEM;
typedef struct tagCUSTDATA {
    DWORD cCustData;
    LPCUSTDATAITEM prgCustData;
} CUSTDATA;
typedef struct tagCUSTDATA* LPCUSTDATA;
extern RPC_IF_HANDLE IOleAutomationTypes_v1_0_c_ifspec;
extern RPC_IF_HANDLE IOleAutomationTypes_v1_0_s_ifspec;
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0001_v0_0_s_ifspec;
typedef ICreateTypeInfo* LPCREATETYPEINFO;
extern "C" const IID IID_ICreateTypeInfo;
struct __declspec(uuid("00020405-0000-0000-C000-000000000046")) __declspec(novtable)
    ICreateTypeInfo : public IUnknown {
public:
    virtual HRESULT __stdcall SetGuid(
        const GUID& guid)
        = 0;
    virtual HRESULT __stdcall SetTypeFlags(
        UINT uTypeFlags)
        = 0;
    virtual HRESULT __stdcall SetDocString(
        LPOLESTR pStrDoc)
        = 0;
    virtual HRESULT __stdcall SetHelpContext(
        DWORD dwHelpContext)
        = 0;
    virtual HRESULT __stdcall SetVersion(
        WORD wMajorVerNum,
        WORD wMinorVerNum)
        = 0;
    virtual HRESULT __stdcall AddRefTypeInfo(
        ITypeInfo* pTInfo,
        HREFTYPE* phRefType)
        = 0;
    virtual HRESULT __stdcall AddFuncDesc(
        UINT index,
        FUNCDESC* pFuncDesc)
        = 0;
    virtual HRESULT __stdcall AddImplType(
        UINT index,
        HREFTYPE hRefType)
        = 0;
    virtual HRESULT __stdcall SetImplTypeFlags(
        UINT index,
        INT implTypeFlags)
        = 0;
    virtual HRESULT __stdcall SetAlignment(
        WORD cbAlignment)
        = 0;
    virtual HRESULT __stdcall SetSchema(
        LPOLESTR pStrSchema)
        = 0;
    virtual HRESULT __stdcall AddVarDesc(
        UINT index,
        VARDESC* pVarDesc)
        = 0;
    virtual HRESULT __stdcall SetFuncAndParamNames(
        UINT index,
        LPOLESTR* rgszNames,
        UINT cNames)
        = 0;
    virtual HRESULT __stdcall SetVarName(
        UINT index,
        LPOLESTR szName)
        = 0;
    virtual HRESULT __stdcall SetTypeDescAlias(
        TYPEDESC* pTDescAlias)
        = 0;
    virtual HRESULT __stdcall DefineFuncAsDllEntry(
        UINT index,
        LPOLESTR szDllName,
        LPOLESTR szProcName)
        = 0;
    virtual HRESULT __stdcall SetFuncDocString(
        UINT index,
        LPOLESTR szDocString)
        = 0;
    virtual HRESULT __stdcall SetVarDocString(
        UINT index,
        LPOLESTR szDocString)
        = 0;
    virtual HRESULT __stdcall SetFuncHelpContext(
        UINT index,
        DWORD dwHelpContext)
        = 0;
    virtual HRESULT __stdcall SetVarHelpContext(
        UINT index,
        DWORD dwHelpContext)
        = 0;
    virtual HRESULT __stdcall SetMops(
        UINT index,
        BSTR bstrMops)
        = 0;
    virtual HRESULT __stdcall SetTypeIdldesc(
        IDLDESC* pIdlDesc)
        = 0;
    virtual HRESULT __stdcall LayOut(void) = 0;
};
typedef ICreateTypeInfo2* LPCREATETYPEINFO2;
extern "C" const IID IID_ICreateTypeInfo2;
struct __declspec(uuid("0002040E-0000-0000-C000-000000000046")) __declspec(novtable)
    ICreateTypeInfo2 : public ICreateTypeInfo {
public:
    virtual HRESULT __stdcall DeleteFuncDesc(
        UINT index)
        = 0;
    virtual HRESULT __stdcall DeleteFuncDescByMemId(
        MEMBERID memid,
        INVOKEKIND invKind)
        = 0;
    virtual HRESULT __stdcall DeleteVarDesc(
        UINT index)
        = 0;
    virtual HRESULT __stdcall DeleteVarDescByMemId(
        MEMBERID memid)
        = 0;
    virtual HRESULT __stdcall DeleteImplType(
        UINT index)
        = 0;
    virtual HRESULT __stdcall SetCustData(
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall SetFuncCustData(
        UINT index,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall SetParamCustData(
        UINT indexFunc,
        UINT indexParam,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall SetVarCustData(
        UINT index,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall SetImplTypeCustData(
        UINT index,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall SetHelpStringContext(
        ULONG dwHelpStringContext)
        = 0;
    virtual HRESULT __stdcall SetFuncHelpStringContext(
        UINT index,
        ULONG dwHelpStringContext)
        = 0;
    virtual HRESULT __stdcall SetVarHelpStringContext(
        UINT index,
        ULONG dwHelpStringContext)
        = 0;
    virtual HRESULT __stdcall Invalidate(void) = 0;
    virtual HRESULT __stdcall SetName(
        LPOLESTR szName)
        = 0;
};
typedef ICreateTypeLib* LPCREATETYPELIB;
extern "C" const IID IID_ICreateTypeLib;
struct __declspec(uuid("00020406-0000-0000-C000-000000000046")) __declspec(novtable)
    ICreateTypeLib : public IUnknown {
public:
    virtual HRESULT __stdcall CreateTypeInfo(
        LPOLESTR szName,
        TYPEKIND tkind,
        ICreateTypeInfo** ppCTInfo)
        = 0;
    virtual HRESULT __stdcall SetName(
        LPOLESTR szName)
        = 0;
    virtual HRESULT __stdcall SetVersion(
        WORD wMajorVerNum,
        WORD wMinorVerNum)
        = 0;
    virtual HRESULT __stdcall SetGuid(
        const GUID& guid)
        = 0;
    virtual HRESULT __stdcall SetDocString(
        LPOLESTR szDoc)
        = 0;
    virtual HRESULT __stdcall SetHelpFileName(
        LPOLESTR szHelpFileName)
        = 0;
    virtual HRESULT __stdcall SetHelpContext(
        DWORD dwHelpContext)
        = 0;
    virtual HRESULT __stdcall SetLcid(
        LCID lcid)
        = 0;
    virtual HRESULT __stdcall SetLibFlags(
        UINT uLibFlags)
        = 0;
    virtual HRESULT __stdcall SaveAllChanges(void) = 0;
};
typedef ICreateTypeLib2* LPCREATETYPELIB2;
extern "C" const IID IID_ICreateTypeLib2;
struct __declspec(uuid("0002040F-0000-0000-C000-000000000046")) __declspec(novtable)
    ICreateTypeLib2 : public ICreateTypeLib {
public:
    virtual HRESULT __stdcall DeleteTypeInfo(
        LPOLESTR szName)
        = 0;
    virtual HRESULT __stdcall SetCustData(
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall SetHelpStringContext(
        ULONG dwHelpStringContext)
        = 0;
    virtual HRESULT __stdcall SetHelpStringDll(
        LPOLESTR szFileName)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0005_v0_0_s_ifspec;
typedef IDispatch* LPDISPATCH;
extern "C" const IID IID_IDispatch;
struct __declspec(uuid("00020400-0000-0000-C000-000000000046")) __declspec(novtable)
    IDispatch : public IUnknown {
public:
    virtual HRESULT __stdcall GetTypeInfoCount(
        UINT* pctinfo)
        = 0;
    virtual HRESULT __stdcall GetTypeInfo(
        UINT iTInfo,
        LCID lcid,
        ITypeInfo** ppTInfo)
        = 0;
    virtual HRESULT __stdcall GetIDsOfNames(
        const IID& riid,
        LPOLESTR* rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID* rgDispId)
        = 0;
    virtual HRESULT __stdcall Invoke(
        DISPID dispIdMember,
        const IID& riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS* pDispParams,
        VARIANT* pVarResult,
        EXCEPINFO* pExcepInfo,
        UINT* puArgErr)
        = 0;
};
HRESULT __stdcall IDispatch_RemoteInvoke_Proxy(
    IDispatch* This,
    DISPID dispIdMember,
    const IID& riid,
    LCID lcid,
    DWORD dwFlags,
    DISPPARAMS* pDispParams,
    VARIANT* pVarResult,
    EXCEPINFO* pExcepInfo,
    UINT* pArgErr,
    UINT cVarRef,
    UINT* rgVarRefIdx,
    VARIANTARG* rgVarRef);
void __stdcall IDispatch_RemoteInvoke_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IEnumVARIANT* LPENUMVARIANT;
extern "C" const IID IID_IEnumVARIANT;
struct __declspec(uuid("00020404-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumVARIANT : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        VARIANT* rgVar,
        ULONG* pCeltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumVARIANT** ppEnum)
        = 0;
};
HRESULT __stdcall IEnumVARIANT_RemoteNext_Proxy(
    IEnumVARIANT* This,
    ULONG celt,
    VARIANT* rgVar,
    ULONG* pCeltFetched);
void __stdcall IEnumVARIANT_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef ITypeComp* LPTYPECOMP;
typedef enum tagDESCKIND {
    DESCKIND_NONE = 0,
    DESCKIND_FUNCDESC = (DESCKIND_NONE + 1),
    DESCKIND_VARDESC = (DESCKIND_FUNCDESC + 1),
    DESCKIND_TYPECOMP = (DESCKIND_VARDESC + 1),
    DESCKIND_IMPLICITAPPOBJ = (DESCKIND_TYPECOMP + 1),
    DESCKIND_MAX = (DESCKIND_IMPLICITAPPOBJ + 1)
} DESCKIND;
typedef union tagBINDPTR {
    FUNCDESC* lpfuncdesc;
    VARDESC* lpvardesc;
    ITypeComp* lptcomp;
} BINDPTR;
typedef union tagBINDPTR* LPBINDPTR;
extern "C" const IID IID_ITypeComp;
struct __declspec(uuid("00020403-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeComp : public IUnknown {
public:
    virtual HRESULT __stdcall Bind(
        LPOLESTR szName,
        ULONG lHashVal,
        WORD wFlags,
        ITypeInfo** ppTInfo,
        DESCKIND* pDescKind,
        BINDPTR* pBindPtr)
        = 0;
    virtual HRESULT __stdcall BindType(
        LPOLESTR szName,
        ULONG lHashVal,
        ITypeInfo** ppTInfo,
        ITypeComp** ppTComp)
        = 0;
};
HRESULT __stdcall ITypeComp_RemoteBind_Proxy(
    ITypeComp* This,
    LPOLESTR szName,
    ULONG lHashVal,
    WORD wFlags,
    ITypeInfo** ppTInfo,
    DESCKIND* pDescKind,
    LPFUNCDESC* ppFuncDesc,
    LPVARDESC* ppVarDesc,
    ITypeComp** ppTypeComp,
    CLEANLOCALSTORAGE* pDummy);
void __stdcall ITypeComp_RemoteBind_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeComp_RemoteBindType_Proxy(
    ITypeComp* This,
    LPOLESTR szName,
    ULONG lHashVal,
    ITypeInfo** ppTInfo);
void __stdcall ITypeComp_RemoteBindType_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0008_v0_0_s_ifspec;
typedef ITypeInfo* LPTYPEINFO;
extern "C" const IID IID_ITypeInfo;
struct __declspec(uuid("00020401-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetTypeAttr(
        TYPEATTR** ppTypeAttr)
        = 0;
    virtual HRESULT __stdcall GetTypeComp(
        ITypeComp** ppTComp)
        = 0;
    virtual HRESULT __stdcall GetFuncDesc(
        UINT index,
        FUNCDESC** ppFuncDesc)
        = 0;
    virtual HRESULT __stdcall GetVarDesc(
        UINT index,
        VARDESC** ppVarDesc)
        = 0;
    virtual HRESULT __stdcall GetNames(
        MEMBERID memid,
        BSTR* rgBstrNames,
        UINT cMaxNames,
        UINT* pcNames)
        = 0;
    virtual HRESULT __stdcall GetRefTypeOfImplType(
        UINT index,
        HREFTYPE* pRefType)
        = 0;
    virtual HRESULT __stdcall GetImplTypeFlags(
        UINT index,
        INT* pImplTypeFlags)
        = 0;
    virtual HRESULT __stdcall GetIDsOfNames(
        LPOLESTR* rgszNames,
        UINT cNames,
        MEMBERID* pMemId)
        = 0;
    virtual HRESULT __stdcall Invoke(
        PVOID pvInstance,
        MEMBERID memid,
        WORD wFlags,
        DISPPARAMS* pDispParams,
        VARIANT* pVarResult,
        EXCEPINFO* pExcepInfo,
        UINT* puArgErr)
        = 0;
    virtual HRESULT __stdcall GetDocumentation(
        MEMBERID memid,
        BSTR* pBstrName,
        BSTR* pBstrDocString,
        DWORD* pdwHelpContext,
        BSTR* pBstrHelpFile)
        = 0;
    virtual HRESULT __stdcall GetDllEntry(
        MEMBERID memid,
        INVOKEKIND invKind,
        BSTR* pBstrDllName,
        BSTR* pBstrName,
        WORD* pwOrdinal)
        = 0;
    virtual HRESULT __stdcall GetRefTypeInfo(
        HREFTYPE hRefType,
        ITypeInfo** ppTInfo)
        = 0;
    virtual HRESULT __stdcall AddressOfMember(
        MEMBERID memid,
        INVOKEKIND invKind,
        PVOID* ppv)
        = 0;
    virtual HRESULT __stdcall CreateInstance(
        IUnknown* pUnkOuter,
        const IID& riid,
        PVOID* ppvObj)
        = 0;
    virtual HRESULT __stdcall GetMops(
        MEMBERID memid,
        BSTR* pBstrMops)
        = 0;
    virtual HRESULT __stdcall GetContainingTypeLib(
        ITypeLib** ppTLib,
        UINT* pIndex)
        = 0;
    virtual void __stdcall ReleaseTypeAttr(
        TYPEATTR* pTypeAttr)
        = 0;
    virtual void __stdcall ReleaseFuncDesc(
        FUNCDESC* pFuncDesc)
        = 0;
    virtual void __stdcall ReleaseVarDesc(
        VARDESC* pVarDesc)
        = 0;
};
HRESULT __stdcall ITypeInfo_RemoteGetTypeAttr_Proxy(
    ITypeInfo* This,
    LPTYPEATTR* ppTypeAttr,
    CLEANLOCALSTORAGE* pDummy);
void __stdcall ITypeInfo_RemoteGetTypeAttr_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteGetFuncDesc_Proxy(
    ITypeInfo* This,
    UINT index,
    LPFUNCDESC* ppFuncDesc,
    CLEANLOCALSTORAGE* pDummy);
void __stdcall ITypeInfo_RemoteGetFuncDesc_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteGetVarDesc_Proxy(
    ITypeInfo* This,
    UINT index,
    LPVARDESC* ppVarDesc,
    CLEANLOCALSTORAGE* pDummy);
void __stdcall ITypeInfo_RemoteGetVarDesc_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteGetNames_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    BSTR* rgBstrNames,
    UINT cMaxNames,
    UINT* pcNames);
void __stdcall ITypeInfo_RemoteGetNames_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_LocalGetIDsOfNames_Proxy(
    ITypeInfo* This);
void __stdcall ITypeInfo_LocalGetIDsOfNames_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_LocalInvoke_Proxy(
    ITypeInfo* This);
void __stdcall ITypeInfo_LocalInvoke_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteGetDocumentation_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    DWORD refPtrFlags,
    BSTR* pBstrName,
    BSTR* pBstrDocString,
    DWORD* pdwHelpContext,
    BSTR* pBstrHelpFile);
void __stdcall ITypeInfo_RemoteGetDocumentation_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteGetDllEntry_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    INVOKEKIND invKind,
    DWORD refPtrFlags,
    BSTR* pBstrDllName,
    BSTR* pBstrName,
    WORD* pwOrdinal);
void __stdcall ITypeInfo_RemoteGetDllEntry_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_LocalAddressOfMember_Proxy(
    ITypeInfo* This);
void __stdcall ITypeInfo_LocalAddressOfMember_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteCreateInstance_Proxy(
    ITypeInfo* This,
    const IID& riid,
    IUnknown** ppvObj);
void __stdcall ITypeInfo_RemoteCreateInstance_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_RemoteGetContainingTypeLib_Proxy(
    ITypeInfo* This,
    ITypeLib** ppTLib,
    UINT* pIndex);
void __stdcall ITypeInfo_RemoteGetContainingTypeLib_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_LocalReleaseTypeAttr_Proxy(
    ITypeInfo* This);
void __stdcall ITypeInfo_LocalReleaseTypeAttr_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_LocalReleaseFuncDesc_Proxy(
    ITypeInfo* This);
void __stdcall ITypeInfo_LocalReleaseFuncDesc_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeInfo_LocalReleaseVarDesc_Proxy(
    ITypeInfo* This);
void __stdcall ITypeInfo_LocalReleaseVarDesc_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef ITypeInfo2* LPTYPEINFO2;
extern "C" const IID IID_ITypeInfo2;
struct __declspec(uuid("00020412-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeInfo2 : public ITypeInfo {
public:
    virtual HRESULT __stdcall GetTypeKind(
        TYPEKIND* pTypeKind)
        = 0;
    virtual HRESULT __stdcall GetTypeFlags(
        ULONG* pTypeFlags)
        = 0;
    virtual HRESULT __stdcall GetFuncIndexOfMemId(
        MEMBERID memid,
        INVOKEKIND invKind,
        UINT* pFuncIndex)
        = 0;
    virtual HRESULT __stdcall GetVarIndexOfMemId(
        MEMBERID memid,
        UINT* pVarIndex)
        = 0;
    virtual HRESULT __stdcall GetCustData(
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall GetFuncCustData(
        UINT index,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall GetParamCustData(
        UINT indexFunc,
        UINT indexParam,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall GetVarCustData(
        UINT index,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall GetImplTypeCustData(
        UINT index,
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall GetDocumentation2(
        MEMBERID memid,
        LCID lcid,
        BSTR* pbstrHelpString,
        DWORD* pdwHelpStringContext,
        BSTR* pbstrHelpStringDll)
        = 0;
    virtual HRESULT __stdcall GetAllCustData(
        CUSTDATA* pCustData)
        = 0;
    virtual HRESULT __stdcall GetAllFuncCustData(
        UINT index,
        CUSTDATA* pCustData)
        = 0;
    virtual HRESULT __stdcall GetAllParamCustData(
        UINT indexFunc,
        UINT indexParam,
        CUSTDATA* pCustData)
        = 0;
    virtual HRESULT __stdcall GetAllVarCustData(
        UINT index,
        CUSTDATA* pCustData)
        = 0;
    virtual HRESULT __stdcall GetAllImplTypeCustData(
        UINT index,
        CUSTDATA* pCustData)
        = 0;
};
HRESULT __stdcall ITypeInfo2_RemoteGetDocumentation2_Proxy(
    ITypeInfo2* This,
    MEMBERID memid,
    LCID lcid,
    DWORD refPtrFlags,
    BSTR* pbstrHelpString,
    DWORD* pdwHelpStringContext,
    BSTR* pbstrHelpStringDll);
void __stdcall ITypeInfo2_RemoteGetDocumentation2_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0010_v0_0_s_ifspec;
typedef enum tagSYSKIND {
    SYS_WIN16 = 0,
    SYS_WIN32 = (SYS_WIN16 + 1),
    SYS_MAC = (SYS_WIN32 + 1),
    SYS_WIN64 = (SYS_MAC + 1)
} SYSKIND;
typedef enum tagLIBFLAGS {
    LIBFLAG_FRESTRICTED = 0x1,
    LIBFLAG_FCONTROL = 0x2,
    LIBFLAG_FHIDDEN = 0x4,
    LIBFLAG_FHASDISKIMAGE = 0x8
} LIBFLAGS;
typedef ITypeLib* LPTYPELIB;
typedef struct tagTLIBATTR {
    GUID guid;
    LCID lcid;
    SYSKIND syskind;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    WORD wLibFlags;
} TLIBATTR;
typedef struct tagTLIBATTR* LPTLIBATTR;
extern "C" const IID IID_ITypeLib;
struct __declspec(uuid("00020402-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeLib : public IUnknown {
public:
    virtual UINT __stdcall GetTypeInfoCount(void) = 0;
    virtual HRESULT __stdcall GetTypeInfo(
        UINT index,
        ITypeInfo** ppTInfo)
        = 0;
    virtual HRESULT __stdcall GetTypeInfoType(
        UINT index,
        TYPEKIND* pTKind)
        = 0;
    virtual HRESULT __stdcall GetTypeInfoOfGuid(
        const GUID& guid,
        ITypeInfo** ppTinfo)
        = 0;
    virtual HRESULT __stdcall GetLibAttr(
        TLIBATTR** ppTLibAttr)
        = 0;
    virtual HRESULT __stdcall GetTypeComp(
        ITypeComp** ppTComp)
        = 0;
    virtual HRESULT __stdcall GetDocumentation(
        INT index,
        BSTR* pBstrName,
        BSTR* pBstrDocString,
        DWORD* pdwHelpContext,
        BSTR* pBstrHelpFile)
        = 0;
    virtual HRESULT __stdcall IsName(
        LPOLESTR szNameBuf,
        ULONG lHashVal,
        BOOL* pfName)
        = 0;
    virtual HRESULT __stdcall FindName(
        LPOLESTR szNameBuf,
        ULONG lHashVal,
        ITypeInfo** ppTInfo,
        MEMBERID* rgMemId,
        USHORT* pcFound)
        = 0;
    virtual void __stdcall ReleaseTLibAttr(
        TLIBATTR* pTLibAttr)
        = 0;
};
HRESULT __stdcall ITypeLib_RemoteGetTypeInfoCount_Proxy(
    ITypeLib* This,
    UINT* pcTInfo);
void __stdcall ITypeLib_RemoteGetTypeInfoCount_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeLib_RemoteGetLibAttr_Proxy(
    ITypeLib* This,
    LPTLIBATTR* ppTLibAttr,
    CLEANLOCALSTORAGE* pDummy);
void __stdcall ITypeLib_RemoteGetLibAttr_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeLib_RemoteGetDocumentation_Proxy(
    ITypeLib* This,
    INT index,
    DWORD refPtrFlags,
    BSTR* pBstrName,
    BSTR* pBstrDocString,
    DWORD* pdwHelpContext,
    BSTR* pBstrHelpFile);
void __stdcall ITypeLib_RemoteGetDocumentation_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeLib_RemoteIsName_Proxy(
    ITypeLib* This,
    LPOLESTR szNameBuf,
    ULONG lHashVal,
    BOOL* pfName,
    BSTR* pBstrLibName);
void __stdcall ITypeLib_RemoteIsName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeLib_RemoteFindName_Proxy(
    ITypeLib* This,
    LPOLESTR szNameBuf,
    ULONG lHashVal,
    ITypeInfo** ppTInfo,
    MEMBERID* rgMemId,
    USHORT* pcFound,
    BSTR* pBstrLibName);
void __stdcall ITypeLib_RemoteFindName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeLib_LocalReleaseTLibAttr_Proxy(
    ITypeLib* This);
void __stdcall ITypeLib_LocalReleaseTLibAttr_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0011_v0_0_s_ifspec;
typedef ITypeLib2* LPTYPELIB2;
extern "C" const IID IID_ITypeLib2;
struct __declspec(uuid("00020411-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeLib2 : public ITypeLib {
public:
    virtual HRESULT __stdcall GetCustData(
        const GUID& guid,
        VARIANT* pVarVal)
        = 0;
    virtual HRESULT __stdcall GetLibStatistics(
        ULONG* pcUniqueNames,
        ULONG* pcchUniqueNames)
        = 0;
    virtual HRESULT __stdcall GetDocumentation2(
        INT index,
        LCID lcid,
        BSTR* pbstrHelpString,
        DWORD* pdwHelpStringContext,
        BSTR* pbstrHelpStringDll)
        = 0;
    virtual HRESULT __stdcall GetAllCustData(
        CUSTDATA* pCustData)
        = 0;
};
HRESULT __stdcall ITypeLib2_RemoteGetLibStatistics_Proxy(
    ITypeLib2* This,
    ULONG* pcUniqueNames,
    ULONG* pcchUniqueNames);
void __stdcall ITypeLib2_RemoteGetLibStatistics_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall ITypeLib2_RemoteGetDocumentation2_Proxy(
    ITypeLib2* This,
    INT index,
    LCID lcid,
    DWORD refPtrFlags,
    BSTR* pbstrHelpString,
    DWORD* pdwHelpStringContext,
    BSTR* pbstrHelpStringDll);
void __stdcall ITypeLib2_RemoteGetDocumentation2_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef ITypeChangeEvents* LPTYPECHANGEEVENTS;
typedef enum tagCHANGEKIND {
    CHANGEKIND_ADDMEMBER = 0,
    CHANGEKIND_DELETEMEMBER = (CHANGEKIND_ADDMEMBER + 1),
    CHANGEKIND_SETNAMES = (CHANGEKIND_DELETEMEMBER + 1),
    CHANGEKIND_SETDOCUMENTATION = (CHANGEKIND_SETNAMES + 1),
    CHANGEKIND_GENERAL = (CHANGEKIND_SETDOCUMENTATION + 1),
    CHANGEKIND_INVALIDATE = (CHANGEKIND_GENERAL + 1),
    CHANGEKIND_CHANGEFAILED = (CHANGEKIND_INVALIDATE + 1),
    CHANGEKIND_MAX = (CHANGEKIND_CHANGEFAILED + 1)
} CHANGEKIND;
extern "C" const IID IID_ITypeChangeEvents;
struct __declspec(uuid("00020410-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeChangeEvents : public IUnknown {
public:
    virtual HRESULT __stdcall RequestTypeChange(
        CHANGEKIND changeKind,
        ITypeInfo* pTInfoBefore,
        LPOLESTR pStrName,
        INT* pfCancel)
        = 0;
    virtual HRESULT __stdcall AfterTypeChange(
        CHANGEKIND changeKind,
        ITypeInfo* pTInfoAfter,
        LPOLESTR pStrName)
        = 0;
};
typedef IErrorInfo* LPERRORINFO;
extern "C" const IID IID_IErrorInfo;
struct __declspec(uuid("1CF2B120-547D-101B-8E65-08002B2BD119")) __declspec(novtable)
    IErrorInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetGUID(
        GUID* pGUID)
        = 0;
    virtual HRESULT __stdcall GetSource(
        BSTR* pBstrSource)
        = 0;
    virtual HRESULT __stdcall GetDescription(
        BSTR* pBstrDescription)
        = 0;
    virtual HRESULT __stdcall GetHelpFile(
        BSTR* pBstrHelpFile)
        = 0;
    virtual HRESULT __stdcall GetHelpContext(
        DWORD* pdwHelpContext)
        = 0;
};
typedef ICreateErrorInfo* LPCREATEERRORINFO;
extern "C" const IID IID_ICreateErrorInfo;
struct __declspec(uuid("22F03340-547D-101B-8E65-08002B2BD119")) __declspec(novtable)
    ICreateErrorInfo : public IUnknown {
public:
    virtual HRESULT __stdcall SetGUID(
        const GUID& rguid)
        = 0;
    virtual HRESULT __stdcall SetSource(
        LPOLESTR szSource)
        = 0;
    virtual HRESULT __stdcall SetDescription(
        LPOLESTR szDescription)
        = 0;
    virtual HRESULT __stdcall SetHelpFile(
        LPOLESTR szHelpFile)
        = 0;
    virtual HRESULT __stdcall SetHelpContext(
        DWORD dwHelpContext)
        = 0;
};
typedef ISupportErrorInfo* LPSUPPORTERRORINFO;
extern "C" const IID IID_ISupportErrorInfo;
struct __declspec(uuid("DF0B3D60-548F-101B-8E65-08002B2BD119")) __declspec(novtable)
    ISupportErrorInfo : public IUnknown {
public:
    virtual HRESULT __stdcall InterfaceSupportsErrorInfo(
        const IID& riid)
        = 0;
};
extern "C" const IID IID_ITypeFactory;
struct __declspec(uuid("0000002E-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeFactory : public IUnknown {
public:
    virtual HRESULT __stdcall CreateFromTypeInfo(
        ITypeInfo* pTypeInfo,
        const IID& riid,
        IUnknown** ppv)
        = 0;
};
extern "C" const IID IID_ITypeMarshal;
struct __declspec(uuid("0000002D-0000-0000-C000-000000000046")) __declspec(novtable)
    ITypeMarshal : public IUnknown {
public:
    virtual HRESULT __stdcall Size(
        PVOID pvType,
        DWORD dwDestContext,
        PVOID pvDestContext,
        ULONG* pSize)
        = 0;
    virtual HRESULT __stdcall Marshal(
        PVOID pvType,
        DWORD dwDestContext,
        PVOID pvDestContext,
        ULONG cbBufferLength,
        BYTE* pBuffer,
        ULONG* pcbWritten)
        = 0;
    virtual HRESULT __stdcall Unmarshal(
        PVOID pvType,
        DWORD dwFlags,
        ULONG cbBufferLength,
        BYTE* pBuffer,
        ULONG* pcbRead)
        = 0;
    virtual HRESULT __stdcall Free(
        PVOID pvType)
        = 0;
};
typedef IRecordInfo* LPRECORDINFO;
extern "C" const IID IID_IRecordInfo;
struct __declspec(uuid("0000002F-0000-0000-C000-000000000046")) __declspec(novtable)
    IRecordInfo : public IUnknown {
public:
    virtual HRESULT __stdcall RecordInit(
        PVOID pvNew)
        = 0;
    virtual HRESULT __stdcall RecordClear(
        PVOID pvExisting)
        = 0;
    virtual HRESULT __stdcall RecordCopy(
        PVOID pvExisting,
        PVOID pvNew)
        = 0;
    virtual HRESULT __stdcall GetGuid(
        GUID* pguid)
        = 0;
    virtual HRESULT __stdcall GetName(
        BSTR* pbstrName)
        = 0;
    virtual HRESULT __stdcall GetSize(
        ULONG* pcbSize)
        = 0;
    virtual HRESULT __stdcall GetTypeInfo(
        ITypeInfo** ppTypeInfo)
        = 0;
    virtual HRESULT __stdcall GetField(
        PVOID pvData,
        LPCOLESTR szFieldName,
        VARIANT* pvarField)
        = 0;
    virtual HRESULT __stdcall GetFieldNoCopy(
        PVOID pvData,
        LPCOLESTR szFieldName,
        VARIANT* pvarField,
        PVOID* ppvDataCArray)
        = 0;
    virtual HRESULT __stdcall PutField(
        ULONG wFlags,
        PVOID pvData,
        LPCOLESTR szFieldName,
        VARIANT* pvarField)
        = 0;
    virtual HRESULT __stdcall PutFieldNoCopy(
        ULONG wFlags,
        PVOID pvData,
        LPCOLESTR szFieldName,
        VARIANT* pvarField)
        = 0;
    virtual HRESULT __stdcall GetFieldNames(
        ULONG* pcNames,
        BSTR* rgBstrNames)
        = 0;
    virtual BOOL __stdcall IsMatchingType(
        IRecordInfo* pRecordInfo)
        = 0;
    virtual PVOID __stdcall RecordCreate(void) = 0;
    virtual HRESULT __stdcall RecordCreateCopy(
        PVOID pvSource,
        PVOID* ppvDest)
        = 0;
    virtual HRESULT __stdcall RecordDestroy(
        PVOID pvRecord)
        = 0;
};
typedef IErrorLog* LPERRORLOG;
extern "C" const IID IID_IErrorLog;
struct __declspec(uuid("3127CA40-446E-11CE-8135-00AA004BB851")) __declspec(novtable)
    IErrorLog : public IUnknown {
public:
    virtual HRESULT __stdcall AddError(
        LPCOLESTR pszPropName,
        EXCEPINFO* pExcepInfo)
        = 0;
};
typedef IPropertyBag* LPPROPERTYBAG;
extern "C" const IID IID_IPropertyBag;
struct __declspec(uuid("55272A00-42CB-11CE-8135-00AA004BB851")) __declspec(novtable)
    IPropertyBag : public IUnknown {
public:
    virtual HRESULT __stdcall Read(
        LPCOLESTR pszPropName,
        VARIANT* pVar,
        IErrorLog* pErrorLog)
        = 0;
    virtual HRESULT __stdcall Write(
        LPCOLESTR pszPropName,
        VARIANT* pVar)
        = 0;
};
HRESULT __stdcall IPropertyBag_RemoteRead_Proxy(
    IPropertyBag* This,
    LPCOLESTR pszPropName,
    VARIANT* pVar,
    IErrorLog* pErrorLog,
    DWORD varType,
    IUnknown* pUnkObj);
void __stdcall IPropertyBag_RemoteRead_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern "C" const IID IID_ITypeLibRegistrationReader;
struct __declspec(uuid("ED6A8A2A-B160-4E77-8F73-AA7435CD5C27")) __declspec(novtable)
    ITypeLibRegistrationReader : public IUnknown {
public:
    virtual HRESULT __stdcall EnumTypeLibRegistrations(
        IEnumUnknown** ppEnumUnknown)
        = 0;
};
extern "C" const IID IID_ITypeLibRegistration;
struct __declspec(uuid("76A3E735-02DF-4A12-98EB-043AD3600AF3")) __declspec(novtable)
    ITypeLibRegistration : public IUnknown {
public:
    virtual HRESULT __stdcall GetGuid(
        GUID* pGuid)
        = 0;
    virtual HRESULT __stdcall GetVersion(
        BSTR* pVersion)
        = 0;
    virtual HRESULT __stdcall GetLcid(
        LCID* pLcid)
        = 0;
    virtual HRESULT __stdcall GetWin32Path(
        BSTR* pWin32Path)
        = 0;
    virtual HRESULT __stdcall GetWin64Path(
        BSTR* pWin64Path)
        = 0;
    virtual HRESULT __stdcall GetDisplayName(
        BSTR* pDisplayName)
        = 0;
    virtual HRESULT __stdcall GetFlags(
        DWORD* pFlags)
        = 0;
    virtual HRESULT __stdcall GetHelpDir(
        BSTR* pHelpDir)
        = 0;
};
extern "C" const CLSID CLSID_TypeLibRegistrationReader;
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0023_v0_0_s_ifspec;
unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree(unsigned long*, BSTR*);
unsigned long __stdcall CLEANLOCALSTORAGE_UserSize(unsigned long*, unsigned long, CLEANLOCALSTORAGE*);
unsigned char* __stdcall CLEANLOCALSTORAGE_UserMarshal(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
unsigned char* __stdcall CLEANLOCALSTORAGE_UserUnmarshal(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
void __stdcall CLEANLOCALSTORAGE_UserFree(unsigned long*, CLEANLOCALSTORAGE*);
unsigned long __stdcall VARIANT_UserSize(unsigned long*, unsigned long, VARIANT*);
unsigned char* __stdcall VARIANT_UserMarshal(unsigned long*, unsigned char*, VARIANT*);
unsigned char* __stdcall VARIANT_UserUnmarshal(unsigned long*, unsigned char*, VARIANT*);
void __stdcall VARIANT_UserFree(unsigned long*, VARIANT*);
unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);
unsigned long __stdcall CLEANLOCALSTORAGE_UserSize64(unsigned long*, unsigned long, CLEANLOCALSTORAGE*);
unsigned char* __stdcall CLEANLOCALSTORAGE_UserMarshal64(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
unsigned char* __stdcall CLEANLOCALSTORAGE_UserUnmarshal64(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
void __stdcall CLEANLOCALSTORAGE_UserFree64(unsigned long*, CLEANLOCALSTORAGE*);
unsigned long __stdcall VARIANT_UserSize64(unsigned long*, unsigned long, VARIANT*);
unsigned char* __stdcall VARIANT_UserMarshal64(unsigned long*, unsigned char*, VARIANT*);
unsigned char* __stdcall VARIANT_UserUnmarshal64(unsigned long*, unsigned char*, VARIANT*);
void __stdcall VARIANT_UserFree64(unsigned long*, VARIANT*);
HRESULT __stdcall IDispatch_Invoke_Proxy(
    IDispatch* This,
    DISPID dispIdMember,
    const IID& riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS* pDispParams,
    VARIANT* pVarResult,
    EXCEPINFO* pExcepInfo,
    UINT* puArgErr);
HRESULT __stdcall IDispatch_Invoke_Stub(
    IDispatch* This,
    DISPID dispIdMember,
    const IID& riid,
    LCID lcid,
    DWORD dwFlags,
    DISPPARAMS* pDispParams,
    VARIANT* pVarResult,
    EXCEPINFO* pExcepInfo,
    UINT* pArgErr,
    UINT cVarRef,
    UINT* rgVarRefIdx,
    VARIANTARG* rgVarRef);
HRESULT __stdcall IEnumVARIANT_Next_Proxy(
    IEnumVARIANT* This,
    ULONG celt,
    VARIANT* rgVar,
    ULONG* pCeltFetched);
HRESULT __stdcall IEnumVARIANT_Next_Stub(
    IEnumVARIANT* This,
    ULONG celt,
    VARIANT* rgVar,
    ULONG* pCeltFetched);
HRESULT __stdcall ITypeComp_Bind_Proxy(
    ITypeComp* This,
    LPOLESTR szName,
    ULONG lHashVal,
    WORD wFlags,
    ITypeInfo** ppTInfo,
    DESCKIND* pDescKind,
    BINDPTR* pBindPtr);
HRESULT __stdcall ITypeComp_Bind_Stub(
    ITypeComp* This,
    LPOLESTR szName,
    ULONG lHashVal,
    WORD wFlags,
    ITypeInfo** ppTInfo,
    DESCKIND* pDescKind,
    LPFUNCDESC* ppFuncDesc,
    LPVARDESC* ppVarDesc,
    ITypeComp** ppTypeComp,
    CLEANLOCALSTORAGE* pDummy);
HRESULT __stdcall ITypeComp_BindType_Proxy(
    ITypeComp* This,
    LPOLESTR szName,
    ULONG lHashVal,
    ITypeInfo** ppTInfo,
    ITypeComp** ppTComp);
HRESULT __stdcall ITypeComp_BindType_Stub(
    ITypeComp* This,
    LPOLESTR szName,
    ULONG lHashVal,
    ITypeInfo** ppTInfo);
HRESULT __stdcall ITypeInfo_GetTypeAttr_Proxy(
    ITypeInfo* This,
    TYPEATTR** ppTypeAttr);
HRESULT __stdcall ITypeInfo_GetTypeAttr_Stub(
    ITypeInfo* This,
    LPTYPEATTR* ppTypeAttr,
    CLEANLOCALSTORAGE* pDummy);
HRESULT __stdcall ITypeInfo_GetFuncDesc_Proxy(
    ITypeInfo* This,
    UINT index,
    FUNCDESC** ppFuncDesc);
HRESULT __stdcall ITypeInfo_GetFuncDesc_Stub(
    ITypeInfo* This,
    UINT index,
    LPFUNCDESC* ppFuncDesc,
    CLEANLOCALSTORAGE* pDummy);
HRESULT __stdcall ITypeInfo_GetVarDesc_Proxy(
    ITypeInfo* This,
    UINT index,
    VARDESC** ppVarDesc);
HRESULT __stdcall ITypeInfo_GetVarDesc_Stub(
    ITypeInfo* This,
    UINT index,
    LPVARDESC* ppVarDesc,
    CLEANLOCALSTORAGE* pDummy);
HRESULT __stdcall ITypeInfo_GetNames_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    BSTR* rgBstrNames,
    UINT cMaxNames,
    UINT* pcNames);
HRESULT __stdcall ITypeInfo_GetNames_Stub(
    ITypeInfo* This,
    MEMBERID memid,
    BSTR* rgBstrNames,
    UINT cMaxNames,
    UINT* pcNames);
HRESULT __stdcall ITypeInfo_GetIDsOfNames_Proxy(
    ITypeInfo* This,
    LPOLESTR* rgszNames,
    UINT cNames,
    MEMBERID* pMemId);
HRESULT __stdcall ITypeInfo_GetIDsOfNames_Stub(
    ITypeInfo* This);
HRESULT __stdcall ITypeInfo_Invoke_Proxy(
    ITypeInfo* This,
    PVOID pvInstance,
    MEMBERID memid,
    WORD wFlags,
    DISPPARAMS* pDispParams,
    VARIANT* pVarResult,
    EXCEPINFO* pExcepInfo,
    UINT* puArgErr);
HRESULT __stdcall ITypeInfo_Invoke_Stub(
    ITypeInfo* This);
HRESULT __stdcall ITypeInfo_GetDocumentation_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    BSTR* pBstrName,
    BSTR* pBstrDocString,
    DWORD* pdwHelpContext,
    BSTR* pBstrHelpFile);
HRESULT __stdcall ITypeInfo_GetDocumentation_Stub(
    ITypeInfo* This,
    MEMBERID memid,
    DWORD refPtrFlags,
    BSTR* pBstrName,
    BSTR* pBstrDocString,
    DWORD* pdwHelpContext,
    BSTR* pBstrHelpFile);
HRESULT __stdcall ITypeInfo_GetDllEntry_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    INVOKEKIND invKind,
    BSTR* pBstrDllName,
    BSTR* pBstrName,
    WORD* pwOrdinal);
HRESULT __stdcall ITypeInfo_GetDllEntry_Stub(
    ITypeInfo* This,
    MEMBERID memid,
    INVOKEKIND invKind,
    DWORD refPtrFlags,
    BSTR* pBstrDllName,
    BSTR* pBstrName,
    WORD* pwOrdinal);
HRESULT __stdcall ITypeInfo_AddressOfMember_Proxy(
    ITypeInfo* This,
    MEMBERID memid,
    INVOKEKIND invKind,
    PVOID* ppv);
HRESULT __stdcall ITypeInfo_AddressOfMember_Stub(
    ITypeInfo* This);
HRESULT __stdcall ITypeInfo_CreateInstance_Proxy(
    ITypeInfo* This,
    IUnknown* pUnkOuter,
    const IID& riid,
    PVOID* ppvObj);
HRESULT __stdcall ITypeInfo_CreateInstance_Stub(
    ITypeInfo* This,
    const IID& riid,
    IUnknown** ppvObj);
HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Proxy(
    ITypeInfo* This,
    ITypeLib** ppTLib,
    UINT* pIndex);
HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Stub(
    ITypeInfo* This,
    ITypeLib** ppTLib,
    UINT* pIndex);
void __stdcall ITypeInfo_ReleaseTypeAttr_Proxy(
    ITypeInfo* This,
    TYPEATTR* pTypeAttr);
HRESULT __stdcall ITypeInfo_ReleaseTypeAttr_Stub(
    ITypeInfo* This);
void __stdcall ITypeInfo_ReleaseFuncDesc_Proxy(
    ITypeInfo* This,
    FUNCDESC* pFuncDesc);
HRESULT __stdcall ITypeInfo_ReleaseFuncDesc_Stub(
    ITypeInfo* This);
void __stdcall ITypeInfo_ReleaseVarDesc_Proxy(
    ITypeInfo* This,
    VARDESC* pVarDesc);
HRESULT __stdcall ITypeInfo_ReleaseVarDesc_Stub(
    ITypeInfo* This);
HRESULT __stdcall ITypeInfo2_GetDocumentation2_Proxy(
    ITypeInfo2* This,
    MEMBERID memid,
    LCID lcid,
    BSTR* pbstrHelpString,
    DWORD* pdwHelpStringContext,
    BSTR* pbstrHelpStringDll);
HRESULT __stdcall ITypeInfo2_GetDocumentation2_Stub(
    ITypeInfo2* This,
    MEMBERID memid,
    LCID lcid,
    DWORD refPtrFlags,
    BSTR* pbstrHelpString,
    DWORD* pdwHelpStringContext,
    BSTR* pbstrHelpStringDll);
UINT __stdcall ITypeLib_GetTypeInfoCount_Proxy(
    ITypeLib* This);
HRESULT __stdcall ITypeLib_GetTypeInfoCount_Stub(
    ITypeLib* This,
    UINT* pcTInfo);
HRESULT __stdcall ITypeLib_GetLibAttr_Proxy(
    ITypeLib* This,
    TLIBATTR** ppTLibAttr);
HRESULT __stdcall ITypeLib_GetLibAttr_Stub(
    ITypeLib* This,
    LPTLIBATTR* ppTLibAttr,
    CLEANLOCALSTORAGE* pDummy);
HRESULT __stdcall ITypeLib_GetDocumentation_Proxy(
    ITypeLib* This,
    INT index,
    BSTR* pBstrName,
    BSTR* pBstrDocString,
    DWORD* pdwHelpContext,
    BSTR* pBstrHelpFile);
HRESULT __stdcall ITypeLib_GetDocumentation_Stub(
    ITypeLib* This,
    INT index,
    DWORD refPtrFlags,
    BSTR* pBstrName,
    BSTR* pBstrDocString,
    DWORD* pdwHelpContext,
    BSTR* pBstrHelpFile);
HRESULT __stdcall ITypeLib_IsName_Proxy(
    ITypeLib* This,
    LPOLESTR szNameBuf,
    ULONG lHashVal,
    BOOL* pfName);
HRESULT __stdcall ITypeLib_IsName_Stub(
    ITypeLib* This,
    LPOLESTR szNameBuf,
    ULONG lHashVal,
    BOOL* pfName,
    BSTR* pBstrLibName);
HRESULT __stdcall ITypeLib_FindName_Proxy(
    ITypeLib* This,
    LPOLESTR szNameBuf,
    ULONG lHashVal,
    ITypeInfo** ppTInfo,
    MEMBERID* rgMemId,
    USHORT* pcFound);
HRESULT __stdcall ITypeLib_FindName_Stub(
    ITypeLib* This,
    LPOLESTR szNameBuf,
    ULONG lHashVal,
    ITypeInfo** ppTInfo,
    MEMBERID* rgMemId,
    USHORT* pcFound,
    BSTR* pBstrLibName);
void __stdcall ITypeLib_ReleaseTLibAttr_Proxy(
    ITypeLib* This,
    TLIBATTR* pTLibAttr);
HRESULT __stdcall ITypeLib_ReleaseTLibAttr_Stub(
    ITypeLib* This);
HRESULT __stdcall ITypeLib2_GetLibStatistics_Proxy(
    ITypeLib2* This,
    ULONG* pcUniqueNames,
    ULONG* pcchUniqueNames);
HRESULT __stdcall ITypeLib2_GetLibStatistics_Stub(
    ITypeLib2* This,
    ULONG* pcUniqueNames,
    ULONG* pcchUniqueNames);
HRESULT __stdcall ITypeLib2_GetDocumentation2_Proxy(
    ITypeLib2* This,
    INT index,
    LCID lcid,
    BSTR* pbstrHelpString,
    DWORD* pdwHelpStringContext,
    BSTR* pbstrHelpStringDll);
HRESULT __stdcall ITypeLib2_GetDocumentation2_Stub(
    ITypeLib2* This,
    INT index,
    LCID lcid,
    DWORD refPtrFlags,
    BSTR* pbstrHelpString,
    DWORD* pdwHelpStringContext,
    BSTR* pbstrHelpStringDll);
HRESULT __stdcall IPropertyBag_Read_Proxy(
    IPropertyBag* This,
    LPCOLESTR pszPropName,
    VARIANT* pVar,
    IErrorLog* pErrorLog);
HRESULT __stdcall IPropertyBag_Read_Stub(
    IPropertyBag* This,
    LPCOLESTR pszPropName,
    VARIANT* pVar,
    IErrorLog* pErrorLog,
    DWORD varType,
    IUnknown* pUnkObj);
}
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma warning(disable : 4237)
#pragma once
#pragma region Application Family or OneCore Family or Games Family
typedef struct tagVersionedStream {
    GUID guidVersion;
    IStream* pStream;
} VERSIONEDSTREAM;
typedef struct tagVersionedStream* LPVERSIONEDSTREAM;
typedef struct tagPROPVARIANT PROPVARIANT;
typedef struct tagCAC {
    ULONG cElems;
    CHAR* pElems;
} CAC;
typedef struct tagCAUB {
    ULONG cElems;
    UCHAR* pElems;
} CAUB;
typedef struct tagCAI {
    ULONG cElems;
    SHORT* pElems;
} CAI;
typedef struct tagCAUI {
    ULONG cElems;
    USHORT* pElems;
} CAUI;
typedef struct tagCAL {
    ULONG cElems;
    LONG* pElems;
} CAL;
typedef struct tagCAUL {
    ULONG cElems;
    ULONG* pElems;
} CAUL;
typedef struct tagCAFLT {
    ULONG cElems;
    FLOAT* pElems;
} CAFLT;
typedef struct tagCADBL {
    ULONG cElems;
    DOUBLE* pElems;
} CADBL;
typedef struct tagCACY {
    ULONG cElems;
    CY* pElems;
} CACY;
typedef struct tagCADATE {
    ULONG cElems;
    DATE* pElems;
} CADATE;
typedef struct tagCABSTR {
    ULONG cElems;
    BSTR* pElems;
} CABSTR;
typedef struct tagCABSTRBLOB {
    ULONG cElems;
    BSTRBLOB* pElems;
} CABSTRBLOB;
typedef struct tagCABOOL {
    ULONG cElems;
    VARIANT_BOOL* pElems;
} CABOOL;
typedef struct tagCASCODE {
    ULONG cElems;
    SCODE* pElems;
} CASCODE;
typedef struct tagCAPROPVARIANT {
    ULONG cElems;
    PROPVARIANT* pElems;
} CAPROPVARIANT;
typedef struct tagCAH {
    ULONG cElems;
    LARGE_INTEGER* pElems;
} CAH;
typedef struct tagCAUH {
    ULONG cElems;
    ULARGE_INTEGER* pElems;
} CAUH;
typedef struct tagCALPSTR {
    ULONG cElems;
    LPSTR* pElems;
} CALPSTR;
typedef struct tagCALPWSTR {
    ULONG cElems;
    LPWSTR* pElems;
} CALPWSTR;
typedef struct tagCAFILETIME {
    ULONG cElems;
    FILETIME* pElems;
} CAFILETIME;
typedef struct tagCACLIPDATA {
    ULONG cElems;
    CLIPDATA* pElems;
} CACLIPDATA;
typedef struct tagCACLSID {
    ULONG cElems;
    CLSID* pElems;
} CACLSID;
typedef WORD PROPVAR_PAD1;
typedef WORD PROPVAR_PAD2;
typedef WORD PROPVAR_PAD3;
struct tagPROPVARIANT {
    union {
        struct
        {
            VARTYPE vt;
            PROPVAR_PAD1 wReserved1;
            PROPVAR_PAD2 wReserved2;
            PROPVAR_PAD3 wReserved3;
            union {
                CHAR cVal;
                UCHAR bVal;
                SHORT iVal;
                USHORT uiVal;
                LONG lVal;
                ULONG ulVal;
                INT intVal;
                UINT uintVal;
                LARGE_INTEGER hVal;
                ULARGE_INTEGER uhVal;
                FLOAT fltVal;
                DOUBLE dblVal;
                VARIANT_BOOL boolVal;
                VARIANT_BOOL __OBSOLETE__VARIANT_BOOL;
                SCODE scode;
                CY cyVal;
                DATE date;
                FILETIME filetime;
                CLSID* puuid;
                CLIPDATA* pclipdata;
                BSTR bstrVal;
                BSTRBLOB bstrblobVal;
                BLOB blob;
                LPSTR pszVal;
                LPWSTR pwszVal;
                IUnknown* punkVal;
                IDispatch* pdispVal;
                IStream* pStream;
                IStorage* pStorage;
                LPVERSIONEDSTREAM pVersionedStream;
                LPSAFEARRAY parray;
                CAC cac;
                CAUB caub;
                CAI cai;
                CAUI caui;
                CAL cal;
                CAUL caul;
                CAH cah;
                CAUH cauh;
                CAFLT caflt;
                CADBL cadbl;
                CABOOL cabool;
                CASCODE cascode;
                CACY cacy;
                CADATE cadate;
                CAFILETIME cafiletime;
                CACLSID cauuid;
                CACLIPDATA caclipdata;
                CABSTR cabstr;
                CABSTRBLOB cabstrblob;
                CALPSTR calpstr;
                CALPWSTR calpwstr;
                CAPROPVARIANT capropvar;
                CHAR* pcVal;
                UCHAR* pbVal;
                SHORT* piVal;
                USHORT* puiVal;
                LONG* plVal;
                ULONG* pulVal;
                INT* pintVal;
                UINT* puintVal;
                FLOAT* pfltVal;
                DOUBLE* pdblVal;
                VARIANT_BOOL* pboolVal;
                DECIMAL* pdecVal;
                SCODE* pscode;
                CY* pcyVal;
                DATE* pdate;
                BSTR* pbstrVal;
                IUnknown** ppunkVal;
                IDispatch** ppdispVal;
                LPSAFEARRAY* pparray;
                PROPVARIANT* pvarVal;
            };
        };
        DECIMAL decVal;
    };
};
typedef struct tagPROPVARIANT* LPPROPVARIANT;
typedef struct tagPROPSPEC {
    ULONG ulKind;
    union {
        PROPID propid;
        LPOLESTR lpwstr;
    };
} PROPSPEC;
typedef struct tagSTATPROPSTG {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
} STATPROPSTG;
typedef struct tagSTATPROPSETSTG {
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
} STATPROPSETSTG;
extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_IPropertyStorage;
struct __declspec(uuid("00000138-0000-0000-C000-000000000046")) __declspec(novtable)
    IPropertyStorage : public IUnknown {
public:
    virtual HRESULT __stdcall ReadMultiple(
        ULONG cpspec,
        const PROPSPEC rgpspec[],
        PROPVARIANT rgpropvar[])
        = 0;
    virtual HRESULT __stdcall WriteMultiple(
        ULONG cpspec,
        const PROPSPEC rgpspec[],
        const PROPVARIANT rgpropvar[],
        PROPID propidNameFirst)
        = 0;
    virtual HRESULT __stdcall DeleteMultiple(
        ULONG cpspec,
        const PROPSPEC rgpspec[])
        = 0;
    virtual HRESULT __stdcall ReadPropertyNames(
        ULONG cpropid,
        const PROPID rgpropid[],
        LPOLESTR rglpwstrName[])
        = 0;
    virtual HRESULT __stdcall WritePropertyNames(
        ULONG cpropid,
        const PROPID rgpropid[],
        const LPOLESTR rglpwstrName[])
        = 0;
    virtual HRESULT __stdcall DeletePropertyNames(
        ULONG cpropid,
        const PROPID rgpropid[])
        = 0;
    virtual HRESULT __stdcall Commit(
        DWORD grfCommitFlags)
        = 0;
    virtual HRESULT __stdcall Revert(void) = 0;
    virtual HRESULT __stdcall Enum(
        IEnumSTATPROPSTG** ppenum)
        = 0;
    virtual HRESULT __stdcall SetTimes(
        const FILETIME* pctime,
        const FILETIME* patime,
        const FILETIME* pmtime)
        = 0;
    virtual HRESULT __stdcall SetClass(
        const IID& clsid)
        = 0;
    virtual HRESULT __stdcall Stat(
        STATPROPSETSTG* pstatpsstg)
        = 0;
};
typedef IPropertySetStorage* LPPROPERTYSETSTORAGE;
extern "C" const IID IID_IPropertySetStorage;
struct __declspec(uuid("0000013A-0000-0000-C000-000000000046")) __declspec(novtable)
    IPropertySetStorage : public IUnknown {
public:
    virtual HRESULT __stdcall Create(
        const IID& rfmtid,
        const CLSID* pclsid,
        DWORD grfFlags,
        DWORD grfMode,
        IPropertyStorage** ppprstg)
        = 0;
    virtual HRESULT __stdcall Open(
        const IID& rfmtid,
        DWORD grfMode,
        IPropertyStorage** ppprstg)
        = 0;
    virtual HRESULT __stdcall Delete(
        const IID& rfmtid)
        = 0;
    virtual HRESULT __stdcall Enum(
        IEnumSTATPROPSETSTG** ppenum)
        = 0;
};
typedef IEnumSTATPROPSTG* LPENUMSTATPROPSTG;
extern "C" const IID IID_IEnumSTATPROPSTG;
struct __declspec(uuid("00000139-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumSTATPROPSTG : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        STATPROPSTG* rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumSTATPROPSTG** ppenum)
        = 0;
};
HRESULT __stdcall IEnumSTATPROPSTG_RemoteNext_Proxy(
    IEnumSTATPROPSTG* This,
    ULONG celt,
    STATPROPSTG* rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumSTATPROPSTG_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IEnumSTATPROPSETSTG* LPENUMSTATPROPSETSTG;
extern "C" const IID IID_IEnumSTATPROPSETSTG;
struct __declspec(uuid("0000013B-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumSTATPROPSETSTG : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        STATPROPSETSTG* rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumSTATPROPSETSTG** ppenum)
        = 0;
};
HRESULT __stdcall IEnumSTATPROPSETSTG_RemoteNext_Proxy(
    IEnumSTATPROPSETSTG* This,
    ULONG celt,
    STATPROPSETSTG* rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumSTATPROPSETSTG_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IPropertyStorage* LPPROPERTYSTORAGE;
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0004_v0_0_s_ifspec;
unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree(unsigned long*, BSTR*);
unsigned long __stdcall LPSAFEARRAY_UserSize(unsigned long*, unsigned long, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserMarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
void __stdcall LPSAFEARRAY_UserFree(unsigned long*, LPSAFEARRAY*);
unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);
unsigned long __stdcall LPSAFEARRAY_UserSize64(unsigned long*, unsigned long, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserMarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
void __stdcall LPSAFEARRAY_UserFree64(unsigned long*, LPSAFEARRAY*);
HRESULT __stdcall IEnumSTATPROPSTG_Next_Proxy(
    IEnumSTATPROPSTG* This,
    ULONG celt,
    STATPROPSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATPROPSTG_Next_Stub(
    IEnumSTATPROPSTG* This,
    ULONG celt,
    STATPROPSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Proxy(
    IEnumSTATPROPSETSTG* This,
    ULONG celt,
    STATPROPSETSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Stub(
    IEnumSTATPROPSETSTG* This,
    ULONG celt,
    STATPROPSETSTG* rgelt,
    ULONG* pceltFetched);
}
#pragma region Application and Games Family
typedef DWORD STGFMT;
#pragma endregion
#pragma region Application Family
extern "C" __declspec(dllimport) HRESULT __stdcall StgCreateDocfile(
    const WCHAR* pwcsName,
    DWORD grfMode,
    DWORD reserved,
    IStorage** ppstgOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgCreateDocfileOnILockBytes(
    ILockBytes* plkbyt,
    DWORD grfMode,
    DWORD reserved,
    IStorage** ppstgOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenStorage(
    const WCHAR* pwcsName,
    IStorage* pstgPriority,
    DWORD grfMode,
    SNB snbExclude,
    DWORD reserved,
    IStorage** ppstgOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenStorageOnILockBytes(
    ILockBytes* plkbyt,
    IStorage* pstgPriority,
    DWORD grfMode,
    SNB snbExclude,
    DWORD reserved,
    IStorage** ppstgOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgIsStorageFile(
    const WCHAR* pwcsName);
extern "C" __declspec(dllimport) HRESULT __stdcall StgIsStorageILockBytes(
    ILockBytes* plkbyt);
extern "C" __declspec(dllimport) HRESULT __stdcall StgSetTimes(
    const WCHAR* lpszName,
    const FILETIME* pctime,
    const FILETIME* patime,
    const FILETIME* pmtime);
typedef struct tagSTGOPTIONS {
    USHORT usVersion;
    USHORT reserved;
    ULONG ulSectorSize;
    const WCHAR* pwcsTemplateFile;
} STGOPTIONS;
extern "C" __declspec(dllimport) HRESULT __stdcall StgCreateStorageEx(
    const WCHAR* pwcsName,
    DWORD grfMode,
    DWORD stgfmt,
    DWORD grfAttrs,
    STGOPTIONS* pStgOptions,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    const IID& riid,
    void** ppObjectOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenStorageEx(
    const WCHAR* pwcsName,
    DWORD grfMode,
    DWORD stgfmt,
    DWORD grfAttrs,
    STGOPTIONS* pStgOptions,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    const IID& riid,
    void** ppObjectOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgCreatePropStg(
    IUnknown* pUnk,
    const IID& fmtid,
    const CLSID* pclsid,
    DWORD grfFlags,
    DWORD dwReserved,
    IPropertyStorage** ppPropStg);
extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenPropStg(
    IUnknown* pUnk,
    const IID& fmtid,
    DWORD grfFlags,
    DWORD dwReserved,
    IPropertyStorage** ppPropStg);
extern "C" __declspec(dllimport) HRESULT __stdcall StgCreatePropSetStg(
    IStorage* pStorage,
    DWORD dwReserved,
    IPropertySetStorage** ppPropSetStg);
extern "C" __declspec(dllimport) HRESULT __stdcall FmtIdToPropStgName(
    const FMTID* pfmtid,
    LPOLESTR oszName);
extern "C" __declspec(dllimport) HRESULT __stdcall PropStgNameToFmtId(
    const LPOLESTR oszName,
    FMTID* pfmtid);
extern "C" __declspec(dllimport) HRESULT __stdcall ReadClassStg(
    LPSTORAGE pStg,
    CLSID* pclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall WriteClassStg(
    LPSTORAGE pStg,
    const IID& rclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall ReadClassStm(
    LPSTREAM pStm,
    CLSID* pclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall WriteClassStm(
    LPSTREAM pStm,
    const IID& rclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall GetHGlobalFromILockBytes(
    LPLOCKBYTES plkbyt,
    HGLOBAL* phglobal);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateILockBytesOnHGlobal(
    HGLOBAL hGlobal,
    BOOL fDeleteOnRelease,
    LPLOCKBYTES* pplkbyt);
extern "C" __declspec(dllimport) HRESULT __stdcall GetConvertStg(
    LPSTORAGE pStg);
#pragma endregion
typedef enum tagCOINIT {
    COINIT_APARTMENTTHREADED = 0x2,
    COINIT_MULTITHREADED = COINITBASE_MULTITHREADED,
    COINIT_DISABLE_OLE1DDE = 0x4,
    COINIT_SPEED_OVER_MEMORY = 0x8,
} COINIT;
#pragma region Desktop Partition
extern "C" __declspec(dllimport) DWORD __stdcall CoBuildVersion(void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoInitialize(LPVOID pvReserved);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeMallocSpy(void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateStandardMalloc(DWORD memctx, IMalloc** ppMalloc);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterInitializeSpy(IInitializeSpy* pSpy, ULARGE_INTEGER* puliCookie);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie);
typedef enum tagCOMSD {
    SD_LAUNCHPERMISSIONS = 0,
    SD_ACCESSPERMISSIONS = 1,
    SD_LAUNCHRESTRICTIONS = 2,
    SD_ACCESSRESTRICTIONS = 3
} COMSD;
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetSystemSecurityPermissions(COMSD comSDType, PSECURITY_DESCRIPTOR* ppSD);
extern "C" __declspec(dllimport) HINSTANCE __stdcall CoLoadLibrary(LPOLESTR lpszLibName, BOOL bAutoFree);
extern "C" __declspec(dllimport) void __stdcall CoFreeLibrary(HINSTANCE hInst);
extern "C" __declspec(dllimport) void __stdcall CoFreeAllLibraries(void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetInstanceFromFile(
    COSERVERINFO* pServerInfo,
    CLSID* pClsid,
    IUnknown* punkOuter,
    DWORD dwClsCtx,
    DWORD grfMode,
    OLECHAR* pwszName,
    DWORD dwCount,
    MULTI_QI* pResults);
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetInstanceFromIStorage(
    COSERVERINFO* pServerInfo,
    CLSID* pClsid,
    IUnknown* punkOuter,
    DWORD dwClsCtx,
    struct IStorage* pstg,
    DWORD dwCount,
    MULTI_QI* pResults);
extern "C" __declspec(dllimport) HRESULT __stdcall CoAllowSetForegroundWindow(IUnknown* pUnk, LPVOID lpvReserved);
extern "C" __declspec(dllimport) HRESULT __stdcall DcomChannelSetHResult(LPVOID pvReserved, ULONG* pulReserved, HRESULT appsHR);
extern "C" __declspec(dllimport) BOOL __stdcall CoIsOle1Class(const IID& rclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromProgIDEx(LPCOLESTR lpszProgID, LPCLSID lpclsid);
extern "C" __declspec(dllimport) BOOL __stdcall CoFileTimeToDosDateTime(
    FILETIME* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
extern "C" __declspec(dllimport) BOOL __stdcall CoDosDateTimeToFileTime(
    WORD nDosDate, WORD nDosTime, FILETIME* lpFileTime);
extern "C" __declspec(dllimport) HRESULT __stdcall CoFileTimeNow(FILETIME* lpFileTime);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterMessageFilter(LPMESSAGEFILTER lpMessageFilter,
    LPMESSAGEFILTER* lplpMessageFilter);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterChannelHook(const GUID& ExtensionUuid, IChannelHook* pChannelHook);
extern "C" __declspec(dllimport) HRESULT __stdcall CoTreatAsClass(const IID& clsidOld, const IID& clsidNew);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateDataAdviseHolder(LPDATAADVISEHOLDER* ppDAHolder);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateDataCache(LPUNKNOWN pUnkOuter, const IID& rclsid,
    const IID& iid, LPVOID* ppv);
extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenAsyncDocfileOnIFillLockBytes(IFillLockBytes* pflb,
    DWORD grfMode,
    DWORD asyncFlags,
    IStorage** ppstgOpen);
extern "C" __declspec(dllimport) HRESULT __stdcall StgGetIFillLockBytesOnILockBytes(ILockBytes* pilb,
    IFillLockBytes** ppflb);
extern "C" __declspec(dllimport) HRESULT __stdcall StgGetIFillLockBytesOnFile(OLECHAR const* pwcsName,
    IFillLockBytes** ppflb);
extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenLayoutDocfile(OLECHAR const* pwcsDfName,
    DWORD grfMode,
    DWORD reserved,
    IStorage** ppstgOpen);
#pragma endregion
#pragma region Desktop Partition
extern "C" __declspec(dllimport) HRESULT __stdcall CoInstall(
    IBindCtx* pbc,
    DWORD dwFlags,
    uCLSSPEC* pClassSpec,
    QUERYCONTEXT* pQuery,
    LPWSTR pszCodeBase);
#pragma endregion
#pragma region PC Application Partition
extern "C" __declspec(dllimport) HRESULT __stdcall BindMoniker(LPMONIKER pmk, DWORD grfOpt, const IID& iidResult, LPVOID* ppvResult);
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetObject(LPCWSTR pszName, BIND_OPTS* pBindOptions, const IID& riid, void** ppv);
extern "C" __declspec(dllimport) HRESULT __stdcall MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName,
    ULONG* pchEaten, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER* ppmkRelPath, BOOL dwReserved);
extern "C" __declspec(dllimport) HRESULT __stdcall MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
    LPMONIKER* ppmkCommon);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateBindCtx(DWORD reserved, LPBC* ppbc);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER* ppmkComposite);
extern "C" __declspec(dllimport) HRESULT __stdcall GetClassFile(LPCOLESTR szFilename, CLSID* pclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateClassMoniker(const IID& rclsid, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem,
    LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateAntiMoniker(LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateObjrefMoniker(LPUNKNOWN punk, LPMONIKER* ppmk);
#pragma endregion
#pragma region Desktop Partition
extern "C" __declspec(dllimport) HRESULT __stdcall GetRunningObjectTable(DWORD reserved, LPRUNNINGOBJECTTABLE* pprot);
#pragma endregion
#pragma once
typedef struct IPersistMoniker IPersistMoniker;
typedef struct IMonikerProp IMonikerProp;
typedef struct IBindProtocol IBindProtocol;
typedef struct IBinding IBinding;
typedef struct IBindStatusCallback IBindStatusCallback;
typedef struct IBindStatusCallbackEx IBindStatusCallbackEx;
typedef struct IAuthenticate IAuthenticate;
typedef struct IAuthenticateEx IAuthenticateEx;
typedef struct IHttpNegotiate IHttpNegotiate;
typedef struct IHttpNegotiate2 IHttpNegotiate2;
typedef struct IHttpNegotiate3 IHttpNegotiate3;
typedef struct IWinInetFileStream IWinInetFileStream;
typedef struct IWindowForBindingUI IWindowForBindingUI;
typedef struct ICodeInstall ICodeInstall;
typedef struct IUri IUri;
typedef struct IUriContainer IUriContainer;
typedef struct IUriBuilder IUriBuilder;
typedef struct IUriBuilderFactory IUriBuilderFactory;
typedef struct IWinInetInfo IWinInetInfo;
typedef struct IHttpSecurity IHttpSecurity;
typedef struct IWinInetHttpInfo IWinInetHttpInfo;
typedef struct IWinInetHttpTimeouts IWinInetHttpTimeouts;
typedef struct IWinInetCacheHints IWinInetCacheHints;
typedef struct IWinInetCacheHints2 IWinInetCacheHints2;
typedef struct IBindHost IBindHost;
typedef struct IInternet IInternet;
typedef struct IInternetBindInfo IInternetBindInfo;
typedef struct IInternetBindInfoEx IInternetBindInfoEx;
typedef struct IInternetProtocolRoot IInternetProtocolRoot;
typedef struct IInternetProtocol IInternetProtocol;
typedef struct IInternetProtocolEx IInternetProtocolEx;
typedef struct IInternetProtocolSink IInternetProtocolSink;
typedef struct IInternetProtocolSinkStackable IInternetProtocolSinkStackable;
typedef struct IInternetSession IInternetSession;
typedef struct IInternetThreadSwitch IInternetThreadSwitch;
typedef struct IInternetPriority IInternetPriority;
typedef struct IInternetProtocolInfo IInternetProtocolInfo;
typedef struct IInternetSecurityMgrSite IInternetSecurityMgrSite;
typedef struct IInternetSecurityManager IInternetSecurityManager;
typedef struct IInternetSecurityManagerEx IInternetSecurityManagerEx;
typedef struct IInternetSecurityManagerEx2 IInternetSecurityManagerEx2;
typedef struct IZoneIdentifier IZoneIdentifier;
typedef struct IZoneIdentifier2 IZoneIdentifier2;
typedef struct IInternetHostSecurityManager IInternetHostSecurityManager;
typedef struct IInternetZoneManager IInternetZoneManager;
typedef struct IInternetZoneManagerEx IInternetZoneManagerEx;
typedef struct IInternetZoneManagerEx2 IInternetZoneManagerEx2;
typedef struct ISoftDistExt ISoftDistExt;
typedef struct ICatalogFileInfo ICatalogFileInfo;
typedef struct IDataFilter IDataFilter;
typedef struct IEncodingFilterFactory IEncodingFilterFactory;
typedef struct IWrappedProtocol IWrappedProtocol;
typedef struct IGetBindHandle IGetBindHandle;
typedef struct IBindCallbackRedirect IBindCallbackRedirect;
typedef struct IBindHttpSecurity IBindHttpSecurity;
#pragma once
typedef struct IOleAdviseHolder IOleAdviseHolder;
typedef struct IOleCache IOleCache;
typedef struct IOleCache2 IOleCache2;
typedef struct IOleCacheControl IOleCacheControl;
typedef struct IParseDisplayName IParseDisplayName;
typedef struct IOleContainer IOleContainer;
typedef struct IOleClientSite IOleClientSite;
typedef struct IOleObject IOleObject;
typedef struct IOleWindow IOleWindow;
typedef struct IOleLink IOleLink;
typedef struct IOleItemContainer IOleItemContainer;
typedef struct IOleInPlaceUIWindow IOleInPlaceUIWindow;
typedef struct IOleInPlaceActiveObject IOleInPlaceActiveObject;
typedef struct IOleInPlaceFrame IOleInPlaceFrame;
typedef struct IOleInPlaceObject IOleInPlaceObject;
typedef struct IOleInPlaceSite IOleInPlaceSite;
typedef struct IContinue IContinue;
typedef struct IViewObject IViewObject;
typedef struct IViewObject2 IViewObject2;
typedef struct IDropSource IDropSource;
typedef struct IDropTarget IDropTarget;
typedef struct IDropSourceNotify IDropSourceNotify;
typedef struct IEnterpriseDropTarget IEnterpriseDropTarget;
typedef struct IEnumOLEVERB IEnumOLEVERB;
extern "C" {
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0000_v0_0_s_ifspec;
typedef IOleAdviseHolder* LPOLEADVISEHOLDER;
extern "C" const IID IID_IOleAdviseHolder;
struct __declspec(uuid("00000111-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleAdviseHolder : public IUnknown {
public:
    virtual HRESULT __stdcall Advise(
        IAdviseSink* pAdvise,
        DWORD* pdwConnection)
        = 0;
    virtual HRESULT __stdcall Unadvise(
        DWORD dwConnection)
        = 0;
    virtual HRESULT __stdcall EnumAdvise(
        IEnumSTATDATA** ppenumAdvise)
        = 0;
    virtual HRESULT __stdcall SendOnRename(
        IMoniker* pmk)
        = 0;
    virtual HRESULT __stdcall SendOnSave(void) = 0;
    virtual HRESULT __stdcall SendOnClose(void) = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0001_v0_0_s_ifspec;
typedef IOleCache* LPOLECACHE;
extern "C" const IID IID_IOleCache;
struct __declspec(uuid("0000011e-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleCache : public IUnknown {
public:
    virtual HRESULT __stdcall Cache(
        FORMATETC* pformatetc,
        DWORD advf,
        DWORD* pdwConnection)
        = 0;
    virtual HRESULT __stdcall Uncache(
        DWORD dwConnection)
        = 0;
    virtual HRESULT __stdcall EnumCache(
        IEnumSTATDATA** ppenumSTATDATA)
        = 0;
    virtual HRESULT __stdcall InitCache(
        IDataObject* pDataObject)
        = 0;
    virtual HRESULT __stdcall SetData(
        FORMATETC* pformatetc,
        STGMEDIUM* pmedium,
        BOOL fRelease)
        = 0;
};
typedef IOleCache2* LPOLECACHE2;
typedef enum tagDISCARDCACHE {
    DISCARDCACHE_SAVEIFDIRTY = 0,
    DISCARDCACHE_NOSAVE = 1
} DISCARDCACHE;
extern "C" const IID IID_IOleCache2;
struct __declspec(uuid("00000128-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleCache2 : public IOleCache {
public:
    virtual HRESULT __stdcall UpdateCache(
        LPDATAOBJECT pDataObject,
        DWORD grfUpdf,
        LPVOID pReserved)
        = 0;
    virtual HRESULT __stdcall DiscardCache(
        DWORD dwDiscardOptions)
        = 0;
};
HRESULT __stdcall IOleCache2_RemoteUpdateCache_Proxy(
    IOleCache2* This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LONG_PTR pReserved);
void __stdcall IOleCache2_RemoteUpdateCache_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0003_v0_0_s_ifspec;
typedef IOleCacheControl* LPOLECACHECONTROL;
extern "C" const IID IID_IOleCacheControl;
struct __declspec(uuid("00000129-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleCacheControl : public IUnknown {
public:
    virtual HRESULT __stdcall OnRun(
        LPDATAOBJECT pDataObject)
        = 0;
    virtual HRESULT __stdcall OnStop(void) = 0;
};
typedef IParseDisplayName* LPPARSEDISPLAYNAME;
extern "C" const IID IID_IParseDisplayName;
struct __declspec(uuid("0000011a-0000-0000-C000-000000000046")) __declspec(novtable)
    IParseDisplayName : public IUnknown {
public:
    virtual HRESULT __stdcall ParseDisplayName(
        IBindCtx* pbc,
        LPOLESTR pszDisplayName,
        ULONG* pchEaten,
        IMoniker** ppmkOut)
        = 0;
};
typedef IOleContainer* LPOLECONTAINER;
extern "C" const IID IID_IOleContainer;
struct __declspec(uuid("0000011b-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleContainer : public IParseDisplayName {
public:
    virtual HRESULT __stdcall EnumObjects(
        DWORD grfFlags,
        IEnumUnknown** ppenum)
        = 0;
    virtual HRESULT __stdcall LockContainer(
        BOOL fLock)
        = 0;
};
typedef IOleClientSite* LPOLECLIENTSITE;
extern "C" const IID IID_IOleClientSite;
struct __declspec(uuid("00000118-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleClientSite : public IUnknown {
public:
    virtual HRESULT __stdcall SaveObject(void) = 0;
    virtual HRESULT __stdcall GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        IMoniker** ppmk)
        = 0;
    virtual HRESULT __stdcall GetContainer(
        IOleContainer** ppContainer)
        = 0;
    virtual HRESULT __stdcall ShowObject(void) = 0;
    virtual HRESULT __stdcall OnShowWindow(
        BOOL fShow)
        = 0;
    virtual HRESULT __stdcall RequestNewObjectLayout(void) = 0;
};
typedef IOleObject* LPOLEOBJECT;
typedef enum tagOLEGETMONIKER {
    OLEGETMONIKER_ONLYIFTHERE = 1,
    OLEGETMONIKER_FORCEASSIGN = 2,
    OLEGETMONIKER_UNASSIGN = 3,
    OLEGETMONIKER_TEMPFORUSER = 4
} OLEGETMONIKER;
typedef enum tagOLEWHICHMK {
    OLEWHICHMK_CONTAINER = 1,
    OLEWHICHMK_OBJREL = 2,
    OLEWHICHMK_OBJFULL = 3
} OLEWHICHMK;
typedef enum tagUSERCLASSTYPE {
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT = 2,
    USERCLASSTYPE_APPNAME = 3
} USERCLASSTYPE;
typedef enum tagOLEMISC {
    OLEMISC_RECOMPOSEONRESIZE = 0x1,
    OLEMISC_ONLYICONIC = 0x2,
    OLEMISC_INSERTNOTREPLACE = 0x4,
    OLEMISC_STATIC = 0x8,
    OLEMISC_CANTLINKINSIDE = 0x10,
    OLEMISC_CANLINKBYOLE1 = 0x20,
    OLEMISC_ISLINKOBJECT = 0x40,
    OLEMISC_INSIDEOUT = 0x80,
    OLEMISC_ACTIVATEWHENVISIBLE = 0x100,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x200,
    OLEMISC_INVISIBLEATRUNTIME = 0x400,
    OLEMISC_ALWAYSRUN = 0x800,
    OLEMISC_ACTSLIKEBUTTON = 0x1000,
    OLEMISC_ACTSLIKELABEL = 0x2000,
    OLEMISC_NOUIACTIVATE = 0x4000,
    OLEMISC_ALIGNABLE = 0x8000,
    OLEMISC_SIMPLEFRAME = 0x10000,
    OLEMISC_SETCLIENTSITEFIRST = 0x20000,
    OLEMISC_IMEMODE = 0x40000,
    OLEMISC_IGNOREACTIVATEWHENVISIBLE = 0x80000,
    OLEMISC_WANTSTOMENUMERGE = 0x100000,
    OLEMISC_SUPPORTSMULTILEVELUNDO = 0x200000
} OLEMISC;
typedef enum tagOLECLOSE {
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE = 1,
    OLECLOSE_PROMPTSAVE = 2
} OLECLOSE;
extern "C" const IID IID_IOleObject;
struct __declspec(uuid("00000112-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleObject : public IUnknown {
public:
    virtual HRESULT __stdcall SetClientSite(
        IOleClientSite* pClientSite)
        = 0;
    virtual HRESULT __stdcall GetClientSite(
        IOleClientSite** ppClientSite)
        = 0;
    virtual HRESULT __stdcall SetHostNames(
        LPCOLESTR szContainerApp,
        LPCOLESTR szContainerObj)
        = 0;
    virtual HRESULT __stdcall Close(
        DWORD dwSaveOption)
        = 0;
    virtual HRESULT __stdcall SetMoniker(
        DWORD dwWhichMoniker,
        IMoniker* pmk)
        = 0;
    virtual HRESULT __stdcall GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        IMoniker** ppmk)
        = 0;
    virtual HRESULT __stdcall InitFromData(
        IDataObject* pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall GetClipboardData(
        DWORD dwReserved,
        IDataObject** ppDataObject)
        = 0;
    virtual HRESULT __stdcall DoVerb(
        LONG iVerb,
        LPMSG lpmsg,
        IOleClientSite* pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
        = 0;
    virtual HRESULT __stdcall EnumVerbs(
        IEnumOLEVERB** ppEnumOleVerb)
        = 0;
    virtual HRESULT __stdcall Update(void) = 0;
    virtual HRESULT __stdcall IsUpToDate(void) = 0;
    virtual HRESULT __stdcall GetUserClassID(
        CLSID* pClsid)
        = 0;
    virtual HRESULT __stdcall GetUserType(
        DWORD dwFormOfType,
        LPOLESTR* pszUserType)
        = 0;
    virtual HRESULT __stdcall SetExtent(
        DWORD dwDrawAspect,
        SIZEL* psizel)
        = 0;
    virtual HRESULT __stdcall GetExtent(
        DWORD dwDrawAspect,
        SIZEL* psizel)
        = 0;
    virtual HRESULT __stdcall Advise(
        IAdviseSink* pAdvSink,
        DWORD* pdwConnection)
        = 0;
    virtual HRESULT __stdcall Unadvise(
        DWORD dwConnection)
        = 0;
    virtual HRESULT __stdcall EnumAdvise(
        IEnumSTATDATA** ppenumAdvise)
        = 0;
    virtual HRESULT __stdcall GetMiscStatus(
        DWORD dwAspect,
        DWORD* pdwStatus)
        = 0;
    virtual HRESULT __stdcall SetColorScheme(
        LOGPALETTE* pLogpal)
        = 0;
};
typedef enum tagOLERENDER {
    OLERENDER_NONE = 0,
    OLERENDER_DRAW = 1,
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS = 3
} OLERENDER;
typedef OLERENDER* LPOLERENDER;
typedef struct tagOBJECTDESCRIPTOR {
    ULONG cbSize;
    CLSID clsid;
    DWORD dwDrawAspect;
    SIZEL sizel;
    POINTL pointl;
    DWORD dwStatus;
    DWORD dwFullUserTypeName;
    DWORD dwSrcOfCopy;
} OBJECTDESCRIPTOR;
typedef struct tagOBJECTDESCRIPTOR* POBJECTDESCRIPTOR;
typedef struct tagOBJECTDESCRIPTOR* LPOBJECTDESCRIPTOR;
typedef struct tagOBJECTDESCRIPTOR LINKSRCDESCRIPTOR;
typedef struct tagOBJECTDESCRIPTOR* PLINKSRCDESCRIPTOR;
typedef struct tagOBJECTDESCRIPTOR* LPLINKSRCDESCRIPTOR;
extern RPC_IF_HANDLE IOLETypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE IOLETypes_v0_0_s_ifspec;
typedef IOleWindow* LPOLEWINDOW;
extern "C" const IID IID_IOleWindow;
struct __declspec(uuid("00000114-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleWindow : public IUnknown {
public:
    virtual HRESULT __stdcall GetWindow(
        HWND* phwnd)
        = 0;
    virtual HRESULT __stdcall ContextSensitiveHelp(
        BOOL fEnterMode)
        = 0;
};
typedef IOleLink* LPOLELINK;
typedef enum tagOLEUPDATE {
    OLEUPDATE_ALWAYS = 1,
    OLEUPDATE_ONCALL = 3
} OLEUPDATE;
typedef OLEUPDATE* LPOLEUPDATE;
typedef OLEUPDATE* POLEUPDATE;
typedef enum tagOLELINKBIND {
    OLELINKBIND_EVENIFCLASSDIFF = 1
} OLELINKBIND;
extern "C" const IID IID_IOleLink;
struct __declspec(uuid("0000011d-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleLink : public IUnknown {
public:
    virtual HRESULT __stdcall SetUpdateOptions(
        DWORD dwUpdateOpt)
        = 0;
    virtual HRESULT __stdcall GetUpdateOptions(
        DWORD* pdwUpdateOpt)
        = 0;
    virtual HRESULT __stdcall SetSourceMoniker(
        IMoniker* pmk,
        const IID& rclsid)
        = 0;
    virtual HRESULT __stdcall GetSourceMoniker(
        IMoniker** ppmk)
        = 0;
    virtual HRESULT __stdcall SetSourceDisplayName(
        LPCOLESTR pszStatusText)
        = 0;
    virtual HRESULT __stdcall GetSourceDisplayName(
        LPOLESTR* ppszDisplayName)
        = 0;
    virtual HRESULT __stdcall BindToSource(
        DWORD bindflags,
        IBindCtx* pbc)
        = 0;
    virtual HRESULT __stdcall BindIfRunning(void) = 0;
    virtual HRESULT __stdcall GetBoundSource(
        IUnknown** ppunk)
        = 0;
    virtual HRESULT __stdcall UnbindSource(void) = 0;
    virtual HRESULT __stdcall Update(
        IBindCtx* pbc)
        = 0;
};
typedef IOleItemContainer* LPOLEITEMCONTAINER;
typedef enum tagBINDSPEED {
    BINDSPEED_INDEFINITE = 1,
    BINDSPEED_MODERATE = 2,
    BINDSPEED_IMMEDIATE = 3
} BINDSPEED;
typedef enum tagOLECONTF {
    OLECONTF_EMBEDDINGS = 1,
    OLECONTF_LINKS = 2,
    OLECONTF_OTHERS = 4,
    OLECONTF_ONLYUSER = 8,
    OLECONTF_ONLYIFRUNNING = 16
} OLECONTF;
extern "C" const IID IID_IOleItemContainer;
struct __declspec(uuid("0000011c-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleItemContainer : public IOleContainer {
public:
    virtual HRESULT __stdcall GetObjectW(
        LPOLESTR pszItem,
        DWORD dwSpeedNeeded,
        IBindCtx* pbc,
        const IID& riid,
        void** ppvObject)
        = 0;
    virtual HRESULT __stdcall GetObjectStorage(
        LPOLESTR pszItem,
        IBindCtx* pbc,
        const IID& riid,
        void** ppvStorage)
        = 0;
    virtual HRESULT __stdcall IsRunning(
        LPOLESTR pszItem)
        = 0;
};
typedef IOleInPlaceUIWindow* LPOLEINPLACEUIWINDOW;
typedef RECT BORDERWIDTHS;
typedef LPRECT LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;
extern "C" const IID IID_IOleInPlaceUIWindow;
struct __declspec(uuid("00000115-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleInPlaceUIWindow : public IOleWindow {
public:
    virtual HRESULT __stdcall GetBorder(
        LPRECT lprectBorder)
        = 0;
    virtual HRESULT __stdcall RequestBorderSpace(
        LPCBORDERWIDTHS pborderwidths)
        = 0;
    virtual HRESULT __stdcall SetBorderSpace(
        LPCBORDERWIDTHS pborderwidths)
        = 0;
    virtual HRESULT __stdcall SetActiveObject(
        IOleInPlaceActiveObject* pActiveObject,
        LPCOLESTR pszObjName)
        = 0;
};
typedef IOleInPlaceActiveObject* LPOLEINPLACEACTIVEOBJECT;
extern "C" const IID IID_IOleInPlaceActiveObject;
struct __declspec(uuid("00000117-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleInPlaceActiveObject : public IOleWindow {
public:
    virtual HRESULT __stdcall TranslateAcceleratorW(
        LPMSG lpmsg)
        = 0;
    virtual HRESULT __stdcall OnFrameWindowActivate(
        BOOL fActivate)
        = 0;
    virtual HRESULT __stdcall OnDocWindowActivate(
        BOOL fActivate)
        = 0;
    virtual HRESULT __stdcall ResizeBorder(
        LPCRECT prcBorder,
        IOleInPlaceUIWindow* pUIWindow,
        BOOL fFrameWindow)
        = 0;
    virtual HRESULT __stdcall EnableModeless(
        BOOL fEnable)
        = 0;
};
HRESULT __stdcall IOleInPlaceActiveObject_RemoteTranslateAccelerator_Proxy(
    IOleInPlaceActiveObject* This);
void __stdcall IOleInPlaceActiveObject_RemoteTranslateAccelerator_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(
    IOleInPlaceActiveObject* This,
    LPCRECT prcBorder,
    const IID& riid,
    IOleInPlaceUIWindow* pUIWindow,
    BOOL fFrameWindow);
void __stdcall IOleInPlaceActiveObject_RemoteResizeBorder_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IOleInPlaceFrame* LPOLEINPLACEFRAME;
typedef struct tagOIFI {
    UINT cb;
    BOOL fMDIApp;
    HWND hwndFrame;
    HACCEL haccel;
    UINT cAccelEntries;
} OLEINPLACEFRAMEINFO;
typedef struct tagOIFI* LPOLEINPLACEFRAMEINFO;
typedef struct tagOleMenuGroupWidths {
    LONG width[6];
} OLEMENUGROUPWIDTHS;
typedef struct tagOleMenuGroupWidths* LPOLEMENUGROUPWIDTHS;
typedef HGLOBAL HOLEMENU;
extern "C" const IID IID_IOleInPlaceFrame;
struct __declspec(uuid("00000116-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleInPlaceFrame : public IOleInPlaceUIWindow {
public:
    virtual HRESULT __stdcall InsertMenus(
        HMENU hmenuShared,
        LPOLEMENUGROUPWIDTHS lpMenuWidths)
        = 0;
    virtual HRESULT __stdcall SetMenu(
        HMENU hmenuShared,
        HOLEMENU holemenu,
        HWND hwndActiveObject)
        = 0;
    virtual HRESULT __stdcall RemoveMenus(
        HMENU hmenuShared)
        = 0;
    virtual HRESULT __stdcall SetStatusText(
        LPCOLESTR pszStatusText)
        = 0;
    virtual HRESULT __stdcall EnableModeless(
        BOOL fEnable)
        = 0;
    virtual HRESULT __stdcall TranslateAcceleratorW(
        LPMSG lpmsg,
        WORD wID)
        = 0;
};
typedef IOleInPlaceObject* LPOLEINPLACEOBJECT;
extern "C" const IID IID_IOleInPlaceObject;
struct __declspec(uuid("00000113-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleInPlaceObject : public IOleWindow {
public:
    virtual HRESULT __stdcall InPlaceDeactivate(void) = 0;
    virtual HRESULT __stdcall UIDeactivate(void) = 0;
    virtual HRESULT __stdcall SetObjectRects(
        LPCRECT lprcPosRect,
        LPCRECT lprcClipRect)
        = 0;
    virtual HRESULT __stdcall ReactivateAndUndo(void) = 0;
};
typedef IOleInPlaceSite* LPOLEINPLACESITE;
extern "C" const IID IID_IOleInPlaceSite;
struct __declspec(uuid("00000119-0000-0000-C000-000000000046")) __declspec(novtable)
    IOleInPlaceSite : public IOleWindow {
public:
    virtual HRESULT __stdcall CanInPlaceActivate(void) = 0;
    virtual HRESULT __stdcall OnInPlaceActivate(void) = 0;
    virtual HRESULT __stdcall OnUIActivate(void) = 0;
    virtual HRESULT __stdcall GetWindowContext(
        IOleInPlaceFrame** ppFrame,
        IOleInPlaceUIWindow** ppDoc,
        LPRECT lprcPosRect,
        LPRECT lprcClipRect,
        LPOLEINPLACEFRAMEINFO lpFrameInfo)
        = 0;
    virtual HRESULT __stdcall Scroll(
        SIZE scrollExtant)
        = 0;
    virtual HRESULT __stdcall OnUIDeactivate(
        BOOL fUndoable)
        = 0;
    virtual HRESULT __stdcall OnInPlaceDeactivate(void) = 0;
    virtual HRESULT __stdcall DiscardUndoState(void) = 0;
    virtual HRESULT __stdcall DeactivateAndUndo(void) = 0;
    virtual HRESULT __stdcall OnPosRectChange(
        LPCRECT lprcPosRect)
        = 0;
};
extern "C" const IID IID_IContinue;
struct __declspec(uuid("0000012a-0000-0000-C000-000000000046")) __declspec(novtable)
    IContinue : public IUnknown {
public:
    virtual HRESULT __stdcall FContinue(void) = 0;
};
typedef IViewObject* LPVIEWOBJECT;
extern "C" const IID IID_IViewObject;
struct __declspec(uuid("0000010d-0000-0000-C000-000000000046")) __declspec(novtable)
    IViewObject : public IUnknown {
public:
    virtual HRESULT __stdcall Draw(
        DWORD dwDrawAspect,
        LONG lindex,
        void* pvAspect,
        DVTARGETDEVICE* ptd,
        HDC hdcTargetDev,
        HDC hdcDraw,
        LPCRECTL lprcBounds,
        LPCRECTL lprcWBounds,
        BOOL(__stdcall* pfnContinue)(
            ULONG_PTR dwContinue),
        ULONG_PTR dwContinue)
        = 0;
    virtual HRESULT __stdcall GetColorSet(
        DWORD dwDrawAspect,
        LONG lindex,
        void* pvAspect,
        DVTARGETDEVICE* ptd,
        HDC hicTargetDev,
        LOGPALETTE** ppColorSet)
        = 0;
    virtual HRESULT __stdcall Freeze(
        DWORD dwDrawAspect,
        LONG lindex,
        void* pvAspect,
        DWORD* pdwFreeze)
        = 0;
    virtual HRESULT __stdcall Unfreeze(
        DWORD dwFreeze)
        = 0;
    virtual HRESULT __stdcall SetAdvise(
        DWORD aspects,
        DWORD advf,
        IAdviseSink* pAdvSink)
        = 0;
    virtual HRESULT __stdcall GetAdvise(
        DWORD* pAspects,
        DWORD* pAdvf,
        IAdviseSink** ppAdvSink)
        = 0;
};
HRESULT __stdcall IViewObject_RemoteDraw_Proxy(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE* ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    IContinue* pContinue);
void __stdcall IViewObject_RemoteDraw_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IViewObject_RemoteGetColorSet_Proxy(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE* ptd,
    ULONG_PTR hicTargetDev,
    LOGPALETTE** ppColorSet);
void __stdcall IViewObject_RemoteGetColorSet_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IViewObject_RemoteFreeze_Proxy(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DWORD* pdwFreeze);
void __stdcall IViewObject_RemoteFreeze_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IViewObject_RemoteGetAdvise_Proxy(
    IViewObject* This,
    DWORD* pAspects,
    DWORD* pAdvf,
    IAdviseSink** ppAdvSink);
void __stdcall IViewObject_RemoteGetAdvise_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IViewObject2* LPVIEWOBJECT2;
extern "C" const IID IID_IViewObject2;
struct __declspec(uuid("00000127-0000-0000-C000-000000000046")) __declspec(novtable)
    IViewObject2 : public IViewObject {
public:
    virtual HRESULT __stdcall GetExtent(
        DWORD dwDrawAspect,
        LONG lindex,
        DVTARGETDEVICE* ptd,
        LPSIZEL lpsizel)
        = 0;
};
typedef IDropSource* LPDROPSOURCE;
extern "C" const IID IID_IDropSource;
struct __declspec(uuid("00000121-0000-0000-C000-000000000046")) __declspec(novtable)
    IDropSource : public IUnknown {
public:
    virtual HRESULT __stdcall QueryContinueDrag(
        BOOL fEscapePressed,
        DWORD grfKeyState)
        = 0;
    virtual HRESULT __stdcall GiveFeedback(
        DWORD dwEffect)
        = 0;
};
typedef IDropTarget* LPDROPTARGET;
extern "C" const IID IID_IDropTarget;
struct __declspec(uuid("00000122-0000-0000-C000-000000000046")) __declspec(novtable)
    IDropTarget : public IUnknown {
public:
    virtual HRESULT __stdcall DragEnter(
        IDataObject* pDataObj,
        DWORD grfKeyState,
        POINTL pt,
        DWORD* pdwEffect)
        = 0;
    virtual HRESULT __stdcall DragOver(
        DWORD grfKeyState,
        POINTL pt,
        DWORD* pdwEffect)
        = 0;
    virtual HRESULT __stdcall DragLeave(void) = 0;
    virtual HRESULT __stdcall Drop(
        IDataObject* pDataObj,
        DWORD grfKeyState,
        POINTL pt,
        DWORD* pdwEffect)
        = 0;
};
extern "C" const IID IID_IDropSourceNotify;
struct __declspec(uuid("0000012B-0000-0000-C000-000000000046")) __declspec(novtable)
    IDropSourceNotify : public IUnknown {
public:
    virtual HRESULT __stdcall DragEnterTarget(
        HWND hwndTarget)
        = 0;
    virtual HRESULT __stdcall DragLeaveTarget(void) = 0;
};
extern "C" const IID IID_IEnterpriseDropTarget;
struct __declspec(uuid("390E3878-FD55-4E18-819D-4682081C0CFD")) __declspec(novtable)
    IEnterpriseDropTarget : public IUnknown {
public:
    virtual HRESULT __stdcall SetDropSourceEnterpriseId(
        LPCWSTR identity)
        = 0;
    virtual HRESULT __stdcall IsEvaluatingEdpPolicy(
        BOOL* value)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0024_v0_0_s_ifspec;
typedef IEnumOLEVERB* LPENUMOLEVERB;
typedef struct tagOLEVERB {
    LONG lVerb;
    LPOLESTR lpszVerbName;
    DWORD fuFlags;
    DWORD grfAttribs;
} OLEVERB;
typedef struct tagOLEVERB* LPOLEVERB;
typedef enum tagOLEVERBATTRIB {
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;
extern "C" const IID IID_IEnumOLEVERB;
struct __declspec(uuid("00000104-0000-0000-C000-000000000046")) __declspec(novtable)
    IEnumOLEVERB : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG celt,
        LPOLEVERB rgelt,
        ULONG* pceltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG celt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumOLEVERB** ppenum)
        = 0;
};
HRESULT __stdcall IEnumOLEVERB_RemoteNext_Proxy(
    IEnumOLEVERB* This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG* pceltFetched);
void __stdcall IEnumOLEVERB_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0025_v0_0_s_ifspec;
unsigned long __stdcall CLIPFORMAT_UserSize(unsigned long*, unsigned long, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserMarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserUnmarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
void __stdcall CLIPFORMAT_UserFree(unsigned long*, CLIPFORMAT*);
unsigned long __stdcall HACCEL_UserSize(unsigned long*, unsigned long, HACCEL*);
unsigned char* __stdcall HACCEL_UserMarshal(unsigned long*, unsigned char*, HACCEL*);
unsigned char* __stdcall HACCEL_UserUnmarshal(unsigned long*, unsigned char*, HACCEL*);
void __stdcall HACCEL_UserFree(unsigned long*, HACCEL*);
unsigned long __stdcall HDC_UserSize(unsigned long*, unsigned long, HDC*);
unsigned char* __stdcall HDC_UserMarshal(unsigned long*, unsigned char*, HDC*);
unsigned char* __stdcall HDC_UserUnmarshal(unsigned long*, unsigned char*, HDC*);
void __stdcall HDC_UserFree(unsigned long*, HDC*);
unsigned long __stdcall HGLOBAL_UserSize(unsigned long*, unsigned long, HGLOBAL*);
unsigned char* __stdcall HGLOBAL_UserMarshal(unsigned long*, unsigned char*, HGLOBAL*);
unsigned char* __stdcall HGLOBAL_UserUnmarshal(unsigned long*, unsigned char*, HGLOBAL*);
void __stdcall HGLOBAL_UserFree(unsigned long*, HGLOBAL*);
unsigned long __stdcall HMENU_UserSize(unsigned long*, unsigned long, HMENU*);
unsigned char* __stdcall HMENU_UserMarshal(unsigned long*, unsigned char*, HMENU*);
unsigned char* __stdcall HMENU_UserUnmarshal(unsigned long*, unsigned char*, HMENU*);
void __stdcall HMENU_UserFree(unsigned long*, HMENU*);
unsigned long __stdcall HWND_UserSize(unsigned long*, unsigned long, HWND*);
unsigned char* __stdcall HWND_UserMarshal(unsigned long*, unsigned char*, HWND*);
unsigned char* __stdcall HWND_UserUnmarshal(unsigned long*, unsigned char*, HWND*);
void __stdcall HWND_UserFree(unsigned long*, HWND*);
unsigned long __stdcall STGMEDIUM_UserSize(unsigned long*, unsigned long, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, STGMEDIUM*);
void __stdcall STGMEDIUM_UserFree(unsigned long*, STGMEDIUM*);
unsigned long __stdcall CLIPFORMAT_UserSize64(unsigned long*, unsigned long, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserMarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserUnmarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
void __stdcall CLIPFORMAT_UserFree64(unsigned long*, CLIPFORMAT*);
unsigned long __stdcall HACCEL_UserSize64(unsigned long*, unsigned long, HACCEL*);
unsigned char* __stdcall HACCEL_UserMarshal64(unsigned long*, unsigned char*, HACCEL*);
unsigned char* __stdcall HACCEL_UserUnmarshal64(unsigned long*, unsigned char*, HACCEL*);
void __stdcall HACCEL_UserFree64(unsigned long*, HACCEL*);
unsigned long __stdcall HDC_UserSize64(unsigned long*, unsigned long, HDC*);
unsigned char* __stdcall HDC_UserMarshal64(unsigned long*, unsigned char*, HDC*);
unsigned char* __stdcall HDC_UserUnmarshal64(unsigned long*, unsigned char*, HDC*);
void __stdcall HDC_UserFree64(unsigned long*, HDC*);
unsigned long __stdcall HGLOBAL_UserSize64(unsigned long*, unsigned long, HGLOBAL*);
unsigned char* __stdcall HGLOBAL_UserMarshal64(unsigned long*, unsigned char*, HGLOBAL*);
unsigned char* __stdcall HGLOBAL_UserUnmarshal64(unsigned long*, unsigned char*, HGLOBAL*);
void __stdcall HGLOBAL_UserFree64(unsigned long*, HGLOBAL*);
unsigned long __stdcall HMENU_UserSize64(unsigned long*, unsigned long, HMENU*);
unsigned char* __stdcall HMENU_UserMarshal64(unsigned long*, unsigned char*, HMENU*);
unsigned char* __stdcall HMENU_UserUnmarshal64(unsigned long*, unsigned char*, HMENU*);
void __stdcall HMENU_UserFree64(unsigned long*, HMENU*);
unsigned long __stdcall HWND_UserSize64(unsigned long*, unsigned long, HWND*);
unsigned char* __stdcall HWND_UserMarshal64(unsigned long*, unsigned char*, HWND*);
unsigned char* __stdcall HWND_UserUnmarshal64(unsigned long*, unsigned char*, HWND*);
void __stdcall HWND_UserFree64(unsigned long*, HWND*);
unsigned long __stdcall STGMEDIUM_UserSize64(unsigned long*, unsigned long, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
unsigned char* __stdcall STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
void __stdcall STGMEDIUM_UserFree64(unsigned long*, STGMEDIUM*);
HRESULT __stdcall IOleCache2_UpdateCache_Proxy(
    IOleCache2* This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LPVOID pReserved);
HRESULT __stdcall IOleCache2_UpdateCache_Stub(
    IOleCache2* This,
    LPDATAOBJECT pDataObject,
    DWORD grfUpdf,
    LONG_PTR pReserved);
HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Proxy(
    IOleInPlaceActiveObject* This,
    LPMSG lpmsg);
HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Stub(
    IOleInPlaceActiveObject* This);
HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Proxy(
    IOleInPlaceActiveObject* This,
    LPCRECT prcBorder,
    IOleInPlaceUIWindow* pUIWindow,
    BOOL fFrameWindow);
HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Stub(
    IOleInPlaceActiveObject* This,
    LPCRECT prcBorder,
    const IID& riid,
    IOleInPlaceUIWindow* pUIWindow,
    BOOL fFrameWindow);
HRESULT __stdcall IViewObject_Draw_Proxy(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    void* pvAspect,
    DVTARGETDEVICE* ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL(__stdcall* pfnContinue)(
        ULONG_PTR dwContinue),
    ULONG_PTR dwContinue);
HRESULT __stdcall IViewObject_Draw_Stub(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE* ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    IContinue* pContinue);
HRESULT __stdcall IViewObject_GetColorSet_Proxy(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    void* pvAspect,
    DVTARGETDEVICE* ptd,
    HDC hicTargetDev,
    LOGPALETTE** ppColorSet);
HRESULT __stdcall IViewObject_GetColorSet_Stub(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DVTARGETDEVICE* ptd,
    ULONG_PTR hicTargetDev,
    LOGPALETTE** ppColorSet);
HRESULT __stdcall IViewObject_Freeze_Proxy(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    void* pvAspect,
    DWORD* pdwFreeze);
HRESULT __stdcall IViewObject_Freeze_Stub(
    IViewObject* This,
    DWORD dwDrawAspect,
    LONG lindex,
    ULONG_PTR pvAspect,
    DWORD* pdwFreeze);
HRESULT __stdcall IViewObject_GetAdvise_Proxy(
    IViewObject* This,
    DWORD* pAspects,
    DWORD* pAdvf,
    IAdviseSink** ppAdvSink);
HRESULT __stdcall IViewObject_GetAdvise_Stub(
    IViewObject* This,
    DWORD* pAspects,
    DWORD* pAdvf,
    IAdviseSink** ppAdvSink);
HRESULT __stdcall IEnumOLEVERB_Next_Proxy(
    IEnumOLEVERB* This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumOLEVERB_Next_Stub(
    IEnumOLEVERB* This,
    ULONG celt,
    LPOLEVERB rgelt,
    ULONG* pceltFetched);
}
#pragma once
typedef struct IServiceProvider IServiceProvider;
extern "C" {
#pragma comment(lib, "uuid.lib")
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0000_v0_0_s_ifspec;
typedef IServiceProvider* LPSERVICEPROVIDER;
extern "C" const IID IID_IServiceProvider;
extern "C++" {
struct __declspec(uuid("6d5140c1-7436-11ce-8034-00aa006009fa")) __declspec(novtable)
    IServiceProvider : public IUnknown {
public:
    virtual HRESULT __stdcall QueryService(
        const GUID& guidService,
        const IID& riid,
        void** ppvObject)
        = 0;
    template <class Q>
    HRESULT __stdcall QueryService(const GUID& guidService, Q** pp)
    {
        return QueryService(guidService, __uuidof(Q), (void**)pp);
    }
};
}
HRESULT __stdcall IServiceProvider_RemoteQueryService_Proxy(
    IServiceProvider* This,
    const GUID& guidService,
    const IID& riid,
    IUnknown** ppvObject);
void __stdcall IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0001_v0_0_s_ifspec;
HRESULT __stdcall IServiceProvider_QueryService_Proxy(
    IServiceProvider* This,
    const GUID& guidService,
    const IID& riid,
    void** ppvObject);
HRESULT __stdcall IServiceProvider_QueryService_Stub(
    IServiceProvider* This,
    const GUID& guidService,
    const IID& riid,
    IUnknown** ppvObject);
}
#pragma once
typedef struct IXMLDOMImplementation IXMLDOMImplementation;
typedef struct IXMLDOMNode IXMLDOMNode;
typedef struct IXMLDOMDocumentFragment IXMLDOMDocumentFragment;
typedef struct IXMLDOMDocument IXMLDOMDocument;
typedef struct IXMLDOMNodeList IXMLDOMNodeList;
typedef struct IXMLDOMNamedNodeMap IXMLDOMNamedNodeMap;
typedef struct IXMLDOMCharacterData IXMLDOMCharacterData;
typedef struct IXMLDOMAttribute IXMLDOMAttribute;
typedef struct IXMLDOMElement IXMLDOMElement;
typedef struct IXMLDOMText IXMLDOMText;
typedef struct IXMLDOMComment IXMLDOMComment;
typedef struct IXMLDOMProcessingInstruction IXMLDOMProcessingInstruction;
typedef struct IXMLDOMCDATASection IXMLDOMCDATASection;
typedef struct IXMLDOMDocumentType IXMLDOMDocumentType;
typedef struct IXMLDOMNotation IXMLDOMNotation;
typedef struct IXMLDOMEntity IXMLDOMEntity;
typedef struct IXMLDOMEntityReference IXMLDOMEntityReference;
typedef struct IXMLDOMParseError IXMLDOMParseError;
typedef struct IXTLRuntime IXTLRuntime;
typedef struct XMLDOMDocumentEvents XMLDOMDocumentEvents;
typedef class DOMDocument DOMDocument;
typedef class DOMFreeThreadedDocument DOMFreeThreadedDocument;
typedef struct IXMLHttpRequest IXMLHttpRequest;
typedef class XMLHTTPRequest XMLHTTPRequest;
typedef struct IXMLDSOControl IXMLDSOControl;
typedef class XMLDSOControl XMLDSOControl;
typedef struct IXMLElementCollection IXMLElementCollection;
typedef struct IXMLDocument IXMLDocument;
typedef struct IXMLDocument2 IXMLDocument2;
typedef struct IXMLElement IXMLElement;
typedef struct IXMLElement2 IXMLElement2;
typedef struct IXMLAttribute IXMLAttribute;
typedef struct IXMLError IXMLError;
typedef class XMLDocument XMLDocument;
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(pop)
#pragma warning(pop)
#pragma region Desktop Family
#pragma endregion
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family
typedef struct _xml_error {
    unsigned int _nLine;
    BSTR _pchBuf;
    unsigned int _cchBuf;
    unsigned int _ich;
    BSTR _pszFound;
    BSTR _pszExpected;
    DWORD _reserved1;
    DWORD _reserved2;
} XML_ERROR;
extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0000_v0_0_s_ifspec;
#pragma region Desktop Family
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family
#pragma endregion
typedef enum tagDOMNodeType {
    NODE_INVALID = 0,
    NODE_ELEMENT = (NODE_INVALID + 1),
    NODE_ATTRIBUTE = (NODE_ELEMENT + 1),
    NODE_TEXT = (NODE_ATTRIBUTE + 1),
    NODE_CDATA_SECTION = (NODE_TEXT + 1),
    NODE_ENTITY_REFERENCE = (NODE_CDATA_SECTION + 1),
    NODE_ENTITY = (NODE_ENTITY_REFERENCE + 1),
    NODE_PROCESSING_INSTRUCTION = (NODE_ENTITY + 1),
    NODE_COMMENT = (NODE_PROCESSING_INSTRUCTION + 1),
    NODE_DOCUMENT = (NODE_COMMENT + 1),
    NODE_DOCUMENT_TYPE = (NODE_DOCUMENT + 1),
    NODE_DOCUMENT_FRAGMENT = (NODE_DOCUMENT_TYPE + 1),
    NODE_NOTATION = (NODE_DOCUMENT_FRAGMENT + 1)
} DOMNodeType;
#pragma endregion
#pragma region Desktop Family
#pragma region Desktop Family
#pragma endregion
#pragma region Desktop Family
#pragma endregion
#pragma endregion
typedef enum tagXMLEMEM_TYPE {
    XMLELEMTYPE_ELEMENT = 0,
    XMLELEMTYPE_TEXT = (XMLELEMTYPE_ELEMENT + 1),
    XMLELEMTYPE_COMMENT = (XMLELEMTYPE_TEXT + 1),
    XMLELEMTYPE_DOCUMENT = (XMLELEMTYPE_COMMENT + 1),
    XMLELEMTYPE_DTD = (XMLELEMTYPE_DOCUMENT + 1),
    XMLELEMTYPE_PI = (XMLELEMTYPE_DTD + 1),
    XMLELEMTYPE_OTHER = (XMLELEMTYPE_PI + 1)
} XMLELEM_TYPE;
extern "C" const IID LIBID_MSXML;
extern "C" const IID IID_IXMLDOMImplementation;
struct __declspec(uuid("2933BF8F-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMImplementation : public IDispatch {
public:
    virtual HRESULT __stdcall hasFeature(
        BSTR feature,
        BSTR version,
        VARIANT_BOOL* hasFeature)
        = 0;
};
extern "C" const IID IID_IXMLDOMNode;
struct __declspec(uuid("2933BF80-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMNode : public IDispatch {
public:
    virtual HRESULT __stdcall get_nodeName(
        BSTR* name)
        = 0;
    virtual HRESULT __stdcall get_nodeValue(
        VARIANT* value)
        = 0;
    virtual HRESULT __stdcall put_nodeValue(
        VARIANT value)
        = 0;
    virtual HRESULT __stdcall get_nodeType(
        DOMNodeType* type)
        = 0;
    virtual HRESULT __stdcall get_parentNode(
        IXMLDOMNode** parent)
        = 0;
    virtual HRESULT __stdcall get_childNodes(
        IXMLDOMNodeList** childList)
        = 0;
    virtual HRESULT __stdcall get_firstChild(
        IXMLDOMNode** firstChild)
        = 0;
    virtual HRESULT __stdcall get_lastChild(
        IXMLDOMNode** lastChild)
        = 0;
    virtual HRESULT __stdcall get_previousSibling(
        IXMLDOMNode** previousSibling)
        = 0;
    virtual HRESULT __stdcall get_nextSibling(
        IXMLDOMNode** nextSibling)
        = 0;
    virtual HRESULT __stdcall get_attributes(
        IXMLDOMNamedNodeMap** attributeMap)
        = 0;
    virtual HRESULT __stdcall insertBefore(
        IXMLDOMNode* newChild,
        VARIANT refChild,
        IXMLDOMNode** outNewChild)
        = 0;
    virtual HRESULT __stdcall replaceChild(
        IXMLDOMNode* newChild,
        IXMLDOMNode* oldChild,
        IXMLDOMNode** outOldChild)
        = 0;
    virtual HRESULT __stdcall removeChild(
        IXMLDOMNode* childNode,
        IXMLDOMNode** oldChild)
        = 0;
    virtual HRESULT __stdcall appendChild(
        IXMLDOMNode* newChild,
        IXMLDOMNode** outNewChild)
        = 0;
    virtual HRESULT __stdcall hasChildNodes(
        VARIANT_BOOL* hasChild)
        = 0;
    virtual HRESULT __stdcall get_ownerDocument(
        IXMLDOMDocument** XMLDOMDocument)
        = 0;
    virtual HRESULT __stdcall cloneNode(
        VARIANT_BOOL deep,
        IXMLDOMNode** cloneRoot)
        = 0;
    virtual HRESULT __stdcall get_nodeTypeString(
        BSTR* nodeType)
        = 0;
    virtual HRESULT __stdcall get_text(
        BSTR* text)
        = 0;
    virtual HRESULT __stdcall put_text(
        BSTR text)
        = 0;
    virtual HRESULT __stdcall get_specified(
        VARIANT_BOOL* isSpecified)
        = 0;
    virtual HRESULT __stdcall get_definition(
        IXMLDOMNode** definitionNode)
        = 0;
    virtual HRESULT __stdcall get_nodeTypedValue(
        VARIANT* typedValue)
        = 0;
    virtual HRESULT __stdcall put_nodeTypedValue(
        VARIANT typedValue)
        = 0;
    virtual HRESULT __stdcall get_dataType(
        VARIANT* dataTypeName)
        = 0;
    virtual HRESULT __stdcall put_dataType(
        BSTR dataTypeName)
        = 0;
    virtual HRESULT __stdcall get_xml(
        BSTR* xmlString)
        = 0;
    virtual HRESULT __stdcall transformNode(
        IXMLDOMNode* stylesheet,
        BSTR* xmlString)
        = 0;
    virtual HRESULT __stdcall selectNodes(
        BSTR queryString,
        IXMLDOMNodeList** resultList)
        = 0;
    virtual HRESULT __stdcall selectSingleNode(
        BSTR queryString,
        IXMLDOMNode** resultNode)
        = 0;
    virtual HRESULT __stdcall get_parsed(
        VARIANT_BOOL* isParsed)
        = 0;
    virtual HRESULT __stdcall get_namespaceURI(
        BSTR* namespaceURI)
        = 0;
    virtual HRESULT __stdcall get_prefix(
        BSTR* prefixString)
        = 0;
    virtual HRESULT __stdcall get_baseName(
        BSTR* nameString)
        = 0;
    virtual HRESULT __stdcall transformNodeToObject(
        IXMLDOMNode* stylesheet,
        VARIANT outputObject)
        = 0;
};
extern "C" const IID IID_IXMLDOMDocumentFragment;
struct __declspec(uuid("3efaa413-272f-11d2-836f-0000f87a7782")) __declspec(novtable)
    IXMLDOMDocumentFragment : public IXMLDOMNode {
public:
};
extern "C" const IID IID_IXMLDOMDocument;
struct __declspec(uuid("2933BF81-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMDocument : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_doctype(
        IXMLDOMDocumentType** documentType)
        = 0;
    virtual HRESULT __stdcall get_implementation(
        IXMLDOMImplementation** impl)
        = 0;
    virtual HRESULT __stdcall get_documentElement(
        IXMLDOMElement** DOMElement)
        = 0;
    virtual HRESULT __stdcall putref_documentElement(
        IXMLDOMElement* DOMElement)
        = 0;
    virtual HRESULT __stdcall createElement(
        BSTR tagName,
        IXMLDOMElement** element)
        = 0;
    virtual HRESULT __stdcall createDocumentFragment(
        IXMLDOMDocumentFragment** docFrag)
        = 0;
    virtual HRESULT __stdcall createTextNode(
        BSTR data,
        IXMLDOMText** text)
        = 0;
    virtual HRESULT __stdcall createComment(
        BSTR data,
        IXMLDOMComment** comment)
        = 0;
    virtual HRESULT __stdcall createCDATASection(
        BSTR data,
        IXMLDOMCDATASection** cdata)
        = 0;
    virtual HRESULT __stdcall createProcessingInstruction(
        BSTR target,
        BSTR data,
        IXMLDOMProcessingInstruction** pi)
        = 0;
    virtual HRESULT __stdcall createAttribute(
        BSTR name,
        IXMLDOMAttribute** attribute)
        = 0;
    virtual HRESULT __stdcall createEntityReference(
        BSTR name,
        IXMLDOMEntityReference** entityRef)
        = 0;
    virtual HRESULT __stdcall getElementsByTagName(
        BSTR tagName,
        IXMLDOMNodeList** resultList)
        = 0;
    virtual HRESULT __stdcall createNode(
        VARIANT Type,
        BSTR name,
        BSTR namespaceURI,
        IXMLDOMNode** node)
        = 0;
    virtual HRESULT __stdcall nodeFromID(
        BSTR idString,
        IXMLDOMNode** node)
        = 0;
    virtual HRESULT __stdcall load(
        VARIANT xmlSource,
        VARIANT_BOOL* isSuccessful)
        = 0;
    virtual HRESULT __stdcall get_readyState(
        long* value)
        = 0;
    virtual HRESULT __stdcall get_parseError(
        IXMLDOMParseError** errorObj)
        = 0;
    virtual HRESULT __stdcall get_url(
        BSTR* urlString)
        = 0;
    virtual HRESULT __stdcall get_async(
        VARIANT_BOOL* isAsync)
        = 0;
    virtual HRESULT __stdcall put_async(
        VARIANT_BOOL isAsync)
        = 0;
    virtual HRESULT __stdcall abort(void) = 0;
    virtual HRESULT __stdcall loadXML(
        BSTR bstrXML,
        VARIANT_BOOL* isSuccessful)
        = 0;
    virtual HRESULT __stdcall save(
        VARIANT destination)
        = 0;
    virtual HRESULT __stdcall get_validateOnParse(
        VARIANT_BOOL* isValidating)
        = 0;
    virtual HRESULT __stdcall put_validateOnParse(
        VARIANT_BOOL isValidating)
        = 0;
    virtual HRESULT __stdcall get_resolveExternals(
        VARIANT_BOOL* isResolving)
        = 0;
    virtual HRESULT __stdcall put_resolveExternals(
        VARIANT_BOOL isResolving)
        = 0;
    virtual HRESULT __stdcall get_preserveWhiteSpace(
        VARIANT_BOOL* isPreserving)
        = 0;
    virtual HRESULT __stdcall put_preserveWhiteSpace(
        VARIANT_BOOL isPreserving)
        = 0;
    virtual HRESULT __stdcall put_onreadystatechange(
        VARIANT readystatechangeSink)
        = 0;
    virtual HRESULT __stdcall put_ondataavailable(
        VARIANT ondataavailableSink)
        = 0;
    virtual HRESULT __stdcall put_ontransformnode(
        VARIANT ontransformnodeSink)
        = 0;
};
extern "C" const IID IID_IXMLDOMNodeList;
struct __declspec(uuid("2933BF82-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMNodeList : public IDispatch {
public:
    virtual HRESULT __stdcall get_item(
        long index,
        IXMLDOMNode** listItem)
        = 0;
    virtual HRESULT __stdcall get_length(
        long* listLength)
        = 0;
    virtual HRESULT __stdcall nextNode(
        IXMLDOMNode** nextItem)
        = 0;
    virtual HRESULT __stdcall reset(void) = 0;
    virtual HRESULT __stdcall get__newEnum(
        IUnknown** ppUnk)
        = 0;
};
extern "C" const IID IID_IXMLDOMNamedNodeMap;
struct __declspec(uuid("2933BF83-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMNamedNodeMap : public IDispatch {
public:
    virtual HRESULT __stdcall getNamedItem(
        BSTR name,
        IXMLDOMNode** namedItem)
        = 0;
    virtual HRESULT __stdcall setNamedItem(
        IXMLDOMNode* newItem,
        IXMLDOMNode** nameItem)
        = 0;
    virtual HRESULT __stdcall removeNamedItem(
        BSTR name,
        IXMLDOMNode** namedItem)
        = 0;
    virtual HRESULT __stdcall get_item(
        long index,
        IXMLDOMNode** listItem)
        = 0;
    virtual HRESULT __stdcall get_length(
        long* listLength)
        = 0;
    virtual HRESULT __stdcall getQualifiedItem(
        BSTR baseName,
        BSTR namespaceURI,
        IXMLDOMNode** qualifiedItem)
        = 0;
    virtual HRESULT __stdcall removeQualifiedItem(
        BSTR baseName,
        BSTR namespaceURI,
        IXMLDOMNode** qualifiedItem)
        = 0;
    virtual HRESULT __stdcall nextNode(
        IXMLDOMNode** nextItem)
        = 0;
    virtual HRESULT __stdcall reset(void) = 0;
    virtual HRESULT __stdcall get__newEnum(
        IUnknown** ppUnk)
        = 0;
};
extern "C" const IID IID_IXMLDOMCharacterData;
struct __declspec(uuid("2933BF84-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMCharacterData : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_data(
        BSTR* data)
        = 0;
    virtual HRESULT __stdcall put_data(
        BSTR data)
        = 0;
    virtual HRESULT __stdcall get_length(
        long* dataLength)
        = 0;
    virtual HRESULT __stdcall substringData(
        long offset,
        long count,
        BSTR* data)
        = 0;
    virtual HRESULT __stdcall appendData(
        BSTR data)
        = 0;
    virtual HRESULT __stdcall insertData(
        long offset,
        BSTR data)
        = 0;
    virtual HRESULT __stdcall deleteData(
        long offset,
        long count)
        = 0;
    virtual HRESULT __stdcall replaceData(
        long offset,
        long count,
        BSTR data)
        = 0;
};
extern "C" const IID IID_IXMLDOMAttribute;
struct __declspec(uuid("2933BF85-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMAttribute : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_name(
        BSTR* attributeName)
        = 0;
    virtual HRESULT __stdcall get_value(
        VARIANT* attributeValue)
        = 0;
    virtual HRESULT __stdcall put_value(
        VARIANT attributeValue)
        = 0;
};
extern "C" const IID IID_IXMLDOMElement;
struct __declspec(uuid("2933BF86-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMElement : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_tagName(
        BSTR* tagName)
        = 0;
    virtual HRESULT __stdcall getAttribute(
        BSTR name,
        VARIANT* value)
        = 0;
    virtual HRESULT __stdcall setAttribute(
        BSTR name,
        VARIANT value)
        = 0;
    virtual HRESULT __stdcall removeAttribute(
        BSTR name)
        = 0;
    virtual HRESULT __stdcall getAttributeNode(
        BSTR name,
        IXMLDOMAttribute** attributeNode)
        = 0;
    virtual HRESULT __stdcall setAttributeNode(
        IXMLDOMAttribute* DOMAttribute,
        IXMLDOMAttribute** attributeNode)
        = 0;
    virtual HRESULT __stdcall removeAttributeNode(
        IXMLDOMAttribute* DOMAttribute,
        IXMLDOMAttribute** attributeNode)
        = 0;
    virtual HRESULT __stdcall getElementsByTagName(
        BSTR tagName,
        IXMLDOMNodeList** resultList)
        = 0;
    virtual HRESULT __stdcall normalize(void) = 0;
};
extern "C" const IID IID_IXMLDOMText;
struct __declspec(uuid("2933BF87-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMText : public IXMLDOMCharacterData {
public:
    virtual HRESULT __stdcall splitText(
        long offset,
        IXMLDOMText** rightHandTextNode)
        = 0;
};
extern "C" const IID IID_IXMLDOMComment;
struct __declspec(uuid("2933BF88-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMComment : public IXMLDOMCharacterData {
public:
};
extern "C" const IID IID_IXMLDOMProcessingInstruction;
struct __declspec(uuid("2933BF89-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMProcessingInstruction : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_target(
        BSTR* name)
        = 0;
    virtual HRESULT __stdcall get_data(
        BSTR* value)
        = 0;
    virtual HRESULT __stdcall put_data(
        BSTR value)
        = 0;
};
extern "C" const IID IID_IXMLDOMCDATASection;
struct __declspec(uuid("2933BF8A-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMCDATASection : public IXMLDOMText {
public:
};
extern "C" const IID IID_IXMLDOMDocumentType;
struct __declspec(uuid("2933BF8B-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMDocumentType : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_name(
        BSTR* rootName)
        = 0;
    virtual HRESULT __stdcall get_entities(
        IXMLDOMNamedNodeMap** entityMap)
        = 0;
    virtual HRESULT __stdcall get_notations(
        IXMLDOMNamedNodeMap** notationMap)
        = 0;
};
extern "C" const IID IID_IXMLDOMNotation;
struct __declspec(uuid("2933BF8C-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMNotation : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_publicId(
        VARIANT* publicID)
        = 0;
    virtual HRESULT __stdcall get_systemId(
        VARIANT* systemID)
        = 0;
};
extern "C" const IID IID_IXMLDOMEntity;
struct __declspec(uuid("2933BF8D-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMEntity : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall get_publicId(
        VARIANT* publicID)
        = 0;
    virtual HRESULT __stdcall get_systemId(
        VARIANT* systemID)
        = 0;
    virtual HRESULT __stdcall get_notationName(
        BSTR* name)
        = 0;
};
extern "C" const IID IID_IXMLDOMEntityReference;
struct __declspec(uuid("2933BF8E-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable)
    IXMLDOMEntityReference : public IXMLDOMNode {
public:
};
extern "C" const IID IID_IXMLDOMParseError;
struct __declspec(uuid("3efaa426-272f-11d2-836f-0000f87a7782")) __declspec(novtable)
    IXMLDOMParseError : public IDispatch {
public:
    virtual HRESULT __stdcall get_errorCode(
        long* errorCode)
        = 0;
    virtual HRESULT __stdcall get_url(
        BSTR* urlString)
        = 0;
    virtual HRESULT __stdcall get_reason(
        BSTR* reasonString)
        = 0;
    virtual HRESULT __stdcall get_srcText(
        BSTR* sourceString)
        = 0;
    virtual HRESULT __stdcall get_line(
        long* lineNumber)
        = 0;
    virtual HRESULT __stdcall get_linepos(
        long* linePosition)
        = 0;
    virtual HRESULT __stdcall get_filepos(
        long* filePosition)
        = 0;
};
extern "C" const IID IID_IXTLRuntime;
struct __declspec(uuid("3efaa425-272f-11d2-836f-0000f87a7782")) __declspec(novtable)
    IXTLRuntime : public IXMLDOMNode {
public:
    virtual HRESULT __stdcall uniqueID(
        IXMLDOMNode* pNode,
        long* pID)
        = 0;
    virtual HRESULT __stdcall depth(
        IXMLDOMNode* pNode,
        long* pDepth)
        = 0;
    virtual HRESULT __stdcall childNumber(
        IXMLDOMNode* pNode,
        long* pNumber)
        = 0;
    virtual HRESULT __stdcall ancestorChildNumber(
        BSTR bstrNodeName,
        IXMLDOMNode* pNode,
        long* pNumber)
        = 0;
    virtual HRESULT __stdcall absoluteChildNumber(
        IXMLDOMNode* pNode,
        long* pNumber)
        = 0;
    virtual HRESULT __stdcall formatIndex(
        long lIndex,
        BSTR bstrFormat,
        BSTR* pbstrFormattedString)
        = 0;
    virtual HRESULT __stdcall formatNumber(
        double dblNumber,
        BSTR bstrFormat,
        BSTR* pbstrFormattedString)
        = 0;
    virtual HRESULT __stdcall formatDate(
        VARIANT varDate,
        BSTR bstrFormat,
        VARIANT varDestLocale,
        BSTR* pbstrFormattedString)
        = 0;
    virtual HRESULT __stdcall formatTime(
        VARIANT varTime,
        BSTR bstrFormat,
        VARIANT varDestLocale,
        BSTR* pbstrFormattedString)
        = 0;
};
extern "C" const IID DIID_XMLDOMDocumentEvents;
struct __declspec(uuid("3efaa427-272f-11d2-836f-0000f87a7782")) __declspec(novtable)
    XMLDOMDocumentEvents : public IDispatch {
};
extern "C" const CLSID CLSID_DOMDocument;
class __declspec(uuid("2933BF90-7B36-11d2-B20E-00C04F983E60"))
    DOMDocument;
extern "C" const CLSID CLSID_DOMFreeThreadedDocument;
class __declspec(uuid("2933BF91-7B36-11d2-B20E-00C04F983E60"))
    DOMFreeThreadedDocument;
extern "C" const IID IID_IXMLHttpRequest;
struct __declspec(uuid("ED8C108D-4349-11D2-91A4-00C04F7969E8")) __declspec(novtable)
    IXMLHttpRequest : public IDispatch {
public:
    virtual HRESULT __stdcall open(
        BSTR bstrMethod,
        BSTR bstrUrl,
        VARIANT varAsync,
        VARIANT bstrUser,
        VARIANT bstrPassword)
        = 0;
    virtual HRESULT __stdcall setRequestHeader(
        BSTR bstrHeader,
        BSTR bstrValue)
        = 0;
    virtual HRESULT __stdcall getResponseHeader(
        BSTR bstrHeader,
        BSTR* pbstrValue)
        = 0;
    virtual HRESULT __stdcall getAllResponseHeaders(
        BSTR* pbstrHeaders)
        = 0;
    virtual HRESULT __stdcall send(
        VARIANT varBody)
        = 0;
    virtual HRESULT __stdcall abort(void) = 0;
    virtual HRESULT __stdcall get_status(
        long* plStatus)
        = 0;
    virtual HRESULT __stdcall get_statusText(
        BSTR* pbstrStatus)
        = 0;
    virtual HRESULT __stdcall get_responseXML(
        IDispatch** ppBody)
        = 0;
    virtual HRESULT __stdcall get_responseText(
        BSTR* pbstrBody)
        = 0;
    virtual HRESULT __stdcall get_responseBody(
        VARIANT* pvarBody)
        = 0;
    virtual HRESULT __stdcall get_responseStream(
        VARIANT* pvarBody)
        = 0;
    virtual HRESULT __stdcall get_readyState(
        long* plState)
        = 0;
    virtual HRESULT __stdcall put_onreadystatechange(
        IDispatch* pReadyStateSink)
        = 0;
};
extern "C" const CLSID CLSID_XMLHTTPRequest;
class __declspec(uuid("ED8C108E-4349-11D2-91A4-00C04F7969E8"))
    XMLHTTPRequest;
extern "C" const IID IID_IXMLDSOControl;
struct __declspec(uuid("310afa62-0575-11d2-9ca9-0060b0ec3d39")) __declspec(novtable)
    IXMLDSOControl : public IDispatch {
public:
    virtual HRESULT __stdcall get_XMLDocument(
        IXMLDOMDocument** ppDoc)
        = 0;
    virtual HRESULT __stdcall put_XMLDocument(
        IXMLDOMDocument* ppDoc)
        = 0;
    virtual HRESULT __stdcall get_JavaDSOCompatible(
        BOOL* fJavaDSOCompatible)
        = 0;
    virtual HRESULT __stdcall put_JavaDSOCompatible(
        BOOL fJavaDSOCompatible)
        = 0;
    virtual HRESULT __stdcall get_readyState(
        long* state)
        = 0;
};
extern "C" const CLSID CLSID_XMLDSOControl;
class __declspec(uuid("550dda30-0541-11d2-9ca9-0060b0ec3d39"))
    XMLDSOControl;
extern "C" const IID IID_IXMLElementCollection;
struct __declspec(uuid("65725580-9B5D-11d0-9BFE-00C04FC99C8E")) __declspec(novtable)
    IXMLElementCollection : public IDispatch {
public:
    virtual HRESULT __stdcall put_length(
        long v)
        = 0;
    virtual HRESULT __stdcall get_length(
        long* p)
        = 0;
    virtual HRESULT __stdcall get__newEnum(
        IUnknown** ppUnk)
        = 0;
    virtual HRESULT __stdcall item(
        VARIANT var1,
        VARIANT var2,
        IDispatch** ppDisp)
        = 0;
};
extern "C" const IID IID_IXMLDocument;
struct __declspec(uuid("F52E2B61-18A1-11d1-B105-00805F49916B")) __declspec(novtable)
    IXMLDocument : public IDispatch {
public:
    virtual HRESULT __stdcall get_root(
        IXMLElement** p)
        = 0;
    virtual HRESULT __stdcall get_fileSize(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_fileModifiedDate(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_fileUpdatedDate(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_URL(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_URL(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall get_mimeType(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_readyState(
        long* pl)
        = 0;
    virtual HRESULT __stdcall get_charset(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_charset(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall get_version(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_doctype(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_dtdURL(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall createElement(
        VARIANT vType,
        VARIANT var1,
        IXMLElement** ppElem)
        = 0;
};
extern "C" const IID IID_IXMLDocument2;
struct __declspec(uuid("2B8DE2FE-8D2D-11d1-B2FC-00C04FD915A9")) __declspec(novtable)
    IXMLDocument2 : public IDispatch {
public:
    virtual HRESULT __stdcall get_root(
        IXMLElement2** p)
        = 0;
    virtual HRESULT __stdcall get_fileSize(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_fileModifiedDate(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_fileUpdatedDate(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_URL(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_URL(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall get_mimeType(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_readyState(
        long* pl)
        = 0;
    virtual HRESULT __stdcall get_charset(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_charset(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall get_version(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_doctype(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall get_dtdURL(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall createElement(
        VARIANT vType,
        VARIANT var1,
        IXMLElement2** ppElem)
        = 0;
    virtual HRESULT __stdcall get_async(
        VARIANT_BOOL* pf)
        = 0;
    virtual HRESULT __stdcall put_async(
        VARIANT_BOOL f)
        = 0;
};
extern "C" const IID IID_IXMLElement;
struct __declspec(uuid("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")) __declspec(novtable)
    IXMLElement : public IDispatch {
public:
    virtual HRESULT __stdcall get_tagName(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_tagName(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall get_parent(
        IXMLElement** ppParent)
        = 0;
    virtual HRESULT __stdcall setAttribute(
        BSTR strPropertyName,
        VARIANT PropertyValue)
        = 0;
    virtual HRESULT __stdcall getAttribute(
        BSTR strPropertyName,
        VARIANT* PropertyValue)
        = 0;
    virtual HRESULT __stdcall removeAttribute(
        BSTR strPropertyName)
        = 0;
    virtual HRESULT __stdcall get_children(
        IXMLElementCollection** pp)
        = 0;
    virtual HRESULT __stdcall get_type(
        long* plType)
        = 0;
    virtual HRESULT __stdcall get_text(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_text(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall addChild(
        IXMLElement* pChildElem,
        long lIndex,
        long lReserved)
        = 0;
    virtual HRESULT __stdcall removeChild(
        IXMLElement* pChildElem)
        = 0;
};
extern "C" const IID IID_IXMLElement2;
struct __declspec(uuid("2B8DE2FF-8D2D-11d1-B2FC-00C04FD915A9")) __declspec(novtable)
    IXMLElement2 : public IDispatch {
public:
    virtual HRESULT __stdcall get_tagName(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_tagName(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall get_parent(
        IXMLElement2** ppParent)
        = 0;
    virtual HRESULT __stdcall setAttribute(
        BSTR strPropertyName,
        VARIANT PropertyValue)
        = 0;
    virtual HRESULT __stdcall getAttribute(
        BSTR strPropertyName,
        VARIANT* PropertyValue)
        = 0;
    virtual HRESULT __stdcall removeAttribute(
        BSTR strPropertyName)
        = 0;
    virtual HRESULT __stdcall get_children(
        IXMLElementCollection** pp)
        = 0;
    virtual HRESULT __stdcall get_type(
        long* plType)
        = 0;
    virtual HRESULT __stdcall get_text(
        BSTR* p)
        = 0;
    virtual HRESULT __stdcall put_text(
        BSTR p)
        = 0;
    virtual HRESULT __stdcall addChild(
        IXMLElement2* pChildElem,
        long lIndex,
        long lReserved)
        = 0;
    virtual HRESULT __stdcall removeChild(
        IXMLElement2* pChildElem)
        = 0;
    virtual HRESULT __stdcall get_attributes(
        IXMLElementCollection** pp)
        = 0;
};
extern "C" const IID IID_IXMLAttribute;
struct __declspec(uuid("D4D4A0FC-3B73-11d1-B2B4-00C04FB92596")) __declspec(novtable)
    IXMLAttribute : public IDispatch {
public:
    virtual HRESULT __stdcall get_name(
        BSTR* n)
        = 0;
    virtual HRESULT __stdcall get_value(
        BSTR* v)
        = 0;
};
extern "C" const IID IID_IXMLError;
struct __declspec(uuid("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")) __declspec(novtable)
    IXMLError : public IUnknown {
public:
    virtual HRESULT __stdcall GetErrorInfo(
        XML_ERROR* pErrorReturn)
        = 0;
};
extern "C" const CLSID CLSID_XMLDocument;
class __declspec(uuid("CFC399AF-D876-11d0-9C10-00C04FC99C8E"))
    XMLDocument;
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0001_v0_0_s_ifspec;
}
extern "C" {
#pragma comment(lib, "uuid.lib")
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family
extern "C" const IID CLSID_SBS_StdURLMoniker;
extern "C" const IID CLSID_SBS_HttpProtocol;
extern "C" const IID CLSID_SBS_FtpProtocol;
extern "C" const IID CLSID_SBS_GopherProtocol;
extern "C" const IID CLSID_SBS_HttpSProtocol;
extern "C" const IID CLSID_SBS_FileProtocol;
extern "C" const IID CLSID_SBS_MkProtocol;
extern "C" const IID CLSID_SBS_UrlMkBindCtx;
extern "C" const IID CLSID_SBS_SoftDistExt;
extern "C" const IID CLSID_SBS_CdlProtocol;
extern "C" const IID CLSID_SBS_ClassInstallFilter;
extern "C" const IID CLSID_SBS_InternetSecurityManager;
extern "C" const IID CLSID_SBS_InternetZoneManager;
extern "C" const IID IID_IAsyncMoniker;
extern "C" const IID CLSID_StdURLMoniker;
extern "C" const IID CLSID_HttpProtocol;
extern "C" const IID CLSID_FtpProtocol;
extern "C" const IID CLSID_GopherProtocol;
extern "C" const IID CLSID_HttpSProtocol;
extern "C" const IID CLSID_FileProtocol;
extern "C" const IID CLSID_ResProtocol;
extern "C" const IID CLSID_AboutProtocol;
extern "C" const IID CLSID_JSProtocol;
extern "C" const IID CLSID_MailtoProtocol;
extern "C" const IID CLSID_IE4_PROTOCOLS;
extern "C" const IID CLSID_MkProtocol;
extern "C" const IID CLSID_StdURLProtocol;
extern "C" const IID CLSID_TBAuthProtocol;
extern "C" const IID CLSID_UrlMkBindCtx;
extern "C" const IID CLSID_CdlProtocol;
extern "C" const IID CLSID_ClassInstallFilter;
extern "C" const IID IID_IAsyncBindCtx;
extern "C" HRESULT __stdcall CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER* ppmk);
extern "C" HRESULT __stdcall CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER* ppmk, DWORD dwFlags);
extern "C" HRESULT __stdcall GetClassURL(LPCWSTR szURL, CLSID* pClsID);
extern "C" HRESULT __stdcall CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback* pBSCb,
    IEnumFORMATETC* pEFetc, IBindCtx** ppBC);
extern "C" HRESULT __stdcall CreateURLMonikerEx2(LPMONIKER pMkCtx, IUri* pUri, LPMONIKER* ppmk, DWORD dwFlags);
extern "C" HRESULT __stdcall CreateAsyncBindCtxEx(IBindCtx* pbc, DWORD dwOptions, IBindStatusCallback* pBSCb, IEnumFORMATETC* pEnum,
    IBindCtx** ppBC, DWORD reserved);
extern "C" HRESULT __stdcall MkParseDisplayNameEx(IBindCtx* pbc, LPCWSTR szDisplayName, ULONG* pchEaten,
    LPMONIKER* ppmk);
extern "C" HRESULT __stdcall RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback* pBSCb,
    IBindStatusCallback** ppBSCBPrev, DWORD dwReserved);
extern "C" HRESULT __stdcall RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback* pBSCb);
extern "C" HRESULT __stdcall GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID* pclsid);
extern "C" HRESULT __stdcall IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);
extern "C" HRESULT __stdcall CoGetClassObjectFromURL(const IID& rCLASSID,
    LPCWSTR szCODE, DWORD dwFileVersionMS,
    DWORD dwFileVersionLS, LPCWSTR szTYPE,
    LPBINDCTX pBindCtx, DWORD dwClsContext,
    LPVOID pvReserved, const IID& riid, LPVOID* ppv);
extern "C" HRESULT __stdcall IEInstallScope(LPDWORD pdwScope);
extern "C" HRESULT __stdcall FaultInIEFeature(HWND hWnd,
    uCLSSPEC* pClassSpec,
    QUERYCONTEXT* pQuery, DWORD dwFlags);
extern "C" HRESULT __stdcall GetComponentIDFromCLSSPEC(uCLSSPEC* pClassspec,
    LPSTR* ppszComponentID);
extern "C" HRESULT __stdcall IsAsyncMoniker(IMoniker* pmk);
extern "C" HRESULT __stdcall CreateURLBinding(LPCWSTR lpszUrl, IBindCtx* pbc, IBinding** ppBdg);
extern "C" HRESULT __stdcall RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);
extern "C" HRESULT __stdcall FindMediaType(LPCSTR rgszTypes, CLIPFORMAT* rgcfTypes);
extern "C" HRESULT __stdcall CreateFormatEnumerator(UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc);
extern "C" HRESULT __stdcall RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC* pEFetc, DWORD reserved);
extern "C" HRESULT __stdcall RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC* pEFetc);
extern "C" HRESULT __stdcall RegisterMediaTypeClass(LPBC pBC, UINT ctypes, const LPCSTR* rgszTypes, CLSID* rgclsID, DWORD reserved);
extern "C" HRESULT __stdcall FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID* pclsID, DWORD reserved);
#pragma endregion
#pragma region Application Family
extern "C" HRESULT __stdcall UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved);
extern "C" HRESULT __stdcall UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD* pdwBufferLengthOut, DWORD dwReserved);
#pragma endregion
#pragma region Desktop Family
extern "C" HRESULT __stdcall FindMimeFromData(
    LPBC pBC,
    LPCWSTR pwzUrl,
    LPVOID pBuffer,
    DWORD cbSize,
    LPCWSTR pwzMimeProposed,
    DWORD dwMimeFlags,
    LPWSTR* ppwzMimeOut,
    DWORD dwReserved);
extern "C" HRESULT __stdcall ObtainUserAgentString(
    DWORD dwOption,
    LPSTR pszUAOut,
    DWORD* cbSize);
extern "C" HRESULT __stdcall CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved);
extern "C" HRESULT __stdcall CompatFlagsFromClsid(CLSID* pclsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);
typedef enum IEObjectType {
    IE_EPM_OBJECT_EVENT,
    IE_EPM_OBJECT_MUTEX,
    IE_EPM_OBJECT_SEMAPHORE,
    IE_EPM_OBJECT_SHARED_MEMORY,
    IE_EPM_OBJECT_WAITABLE_TIMER,
    IE_EPM_OBJECT_FILE,
    IE_EPM_OBJECT_NAMED_PIPE,
    IE_EPM_OBJECT_REGISTRY,
} IEObjectType;
extern "C" HRESULT __stdcall SetAccessForIEAppContainer(
    HANDLE hObject,
    IEObjectType ieObjectType,
    DWORD dwAccessMask);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec;
typedef IPersistMoniker* LPPERSISTMONIKER;
extern "C" const IID IID_IPersistMoniker;
struct __declspec(uuid("79eac9c9-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IPersistMoniker : public IUnknown {
public:
    virtual HRESULT __stdcall GetClassID(
        CLSID* pClassID)
        = 0;
    virtual HRESULT __stdcall IsDirty(void) = 0;
    virtual HRESULT __stdcall Load(
        BOOL fFullyAvailable,
        IMoniker* pimkName,
        LPBC pibc,
        DWORD grfMode)
        = 0;
    virtual HRESULT __stdcall Save(
        IMoniker* pimkName,
        LPBC pbc,
        BOOL fRemember)
        = 0;
    virtual HRESULT __stdcall SaveCompleted(
        IMoniker* pimkName,
        LPBC pibc)
        = 0;
    virtual HRESULT __stdcall GetCurMoniker(
        IMoniker** ppimkName)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec;
typedef IMonikerProp* LPMONIKERPROP;
typedef enum __MIDL_IMonikerProp_0001 {
    MIMETYPEPROP = 0,
    USE_SRC_URL = 0x1,
    CLASSIDPROP = 0x2,
    TRUSTEDDOWNLOADPROP = 0x3,
    POPUPLEVELPROP = 0x4
} MONIKERPROPERTY;
extern "C" const IID IID_IMonikerProp;
struct __declspec(uuid("a5ca5f7f-1847-4d87-9c5b-918509f7511d")) __declspec(novtable)
    IMonikerProp : public IUnknown {
public:
    virtual HRESULT __stdcall PutProperty(
        MONIKERPROPERTY mkp,
        LPCWSTR val)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec;
typedef IBindProtocol* LPBINDPROTOCOL;
extern "C" const IID IID_IBindProtocol;
struct __declspec(uuid("79eac9cd-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IBindProtocol : public IUnknown {
public:
    virtual HRESULT __stdcall CreateBinding(
        LPCWSTR szUrl,
        IBindCtx* pbc,
        IBinding** ppb)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec;
typedef IBinding* LPBINDING;
extern "C" const IID IID_IBinding;
struct __declspec(uuid("79eac9c0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IBinding : public IUnknown {
public:
    virtual HRESULT __stdcall Abort(void) = 0;
    virtual HRESULT __stdcall Suspend(void) = 0;
    virtual HRESULT __stdcall Resume(void) = 0;
    virtual HRESULT __stdcall SetPriority(
        LONG nPriority)
        = 0;
    virtual HRESULT __stdcall GetPriority(
        LONG* pnPriority)
        = 0;
    virtual HRESULT __stdcall GetBindResult(
        CLSID* pclsidProtocol,
        DWORD* pdwResult,
        LPOLESTR* pszResult,
        DWORD* pdwReserved)
        = 0;
};
HRESULT __stdcall IBinding_RemoteGetBindResult_Proxy(
    IBinding* This,
    CLSID* pclsidProtocol,
    DWORD* pdwResult,
    LPOLESTR* pszResult,
    DWORD dwReserved);
void __stdcall IBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Application Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec;
typedef IBindStatusCallback* LPBINDSTATUSCALLBACK;
typedef enum __MIDL_IBindStatusCallback_0001 {
    BINDVERB_GET = 0,
    BINDVERB_POST = 0x1,
    BINDVERB_PUT = 0x2,
    BINDVERB_CUSTOM = 0x3,
    BINDVERB_RESERVED1 = 0x4
} BINDVERB;
typedef enum __MIDL_IBindStatusCallback_0002 {
    BINDINFOF_URLENCODESTGMEDDATA = 0x1,
    BINDINFOF_URLENCODEDEXTRAINFO = 0x2
} BINDINFOF;
typedef enum __MIDL_IBindStatusCallback_0003 {
    BINDF_ASYNCHRONOUS = 0x1,
    BINDF_ASYNCSTORAGE = 0x2,
    BINDF_NOPROGRESSIVERENDERING = 0x4,
    BINDF_OFFLINEOPERATION = 0x8,
    BINDF_GETNEWESTVERSION = 0x10,
    BINDF_NOWRITECACHE = 0x20,
    BINDF_NEEDFILE = 0x40,
    BINDF_PULLDATA = 0x80,
    BINDF_IGNORESECURITYPROBLEM = 0x100,
    BINDF_RESYNCHRONIZE = 0x200,
    BINDF_HYPERLINK = 0x400,
    BINDF_NO_UI = 0x800,
    BINDF_SILENTOPERATION = 0x1000,
    BINDF_PRAGMA_NO_CACHE = 0x2000,
    BINDF_GETCLASSOBJECT = 0x4000,
    BINDF_RESERVED_1 = 0x8000,
    BINDF_FREE_THREADED = 0x10000,
    BINDF_DIRECT_READ = 0x20000,
    BINDF_FORMS_SUBMIT = 0x40000,
    BINDF_GETFROMCACHE_IF_NET_FAIL = 0x80000,
    BINDF_FROMURLMON = 0x100000,
    BINDF_FWD_BACK = 0x200000,
    BINDF_PREFERDEFAULTHANDLER = 0x400000,
    BINDF_ENFORCERESTRICTED = 0x800000,
    BINDF_RESERVED_2 = 0x80000000,
    BINDF_RESERVED_3 = 0x1000000,
    BINDF_RESERVED_4 = 0x2000000,
    BINDF_RESERVED_5 = 0x4000000,
    BINDF_RESERVED_6 = 0x8000000,
    BINDF_RESERVED_7 = 0x40000000,
    BINDF_RESERVED_8 = 0x20000000
} BINDF;
typedef enum __MIDL_IBindStatusCallback_0004 {
    URL_ENCODING_NONE = 0,
    URL_ENCODING_ENABLE_UTF8 = 0x10000000,
    URL_ENCODING_DISABLE_UTF8 = 0x20000000
} URL_ENCODING;
typedef struct _tagBINDINFO {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown* pUnk;
    DWORD dwReserved;
} BINDINFO;
typedef struct _REMSECURITY_ATTRIBUTES {
    DWORD nLength;
    DWORD lpSecurityDescriptor;
    BOOL bInheritHandle;
} REMSECURITY_ATTRIBUTES;
typedef struct _REMSECURITY_ATTRIBUTES* PREMSECURITY_ATTRIBUTES;
typedef struct _REMSECURITY_ATTRIBUTES* LPREMSECURITY_ATTRIBUTES;
typedef struct _tagRemBINDINFO {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    REMSECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown* pUnk;
    DWORD dwReserved;
} RemBINDINFO;
typedef struct tagRemFORMATETC {
    DWORD cfFormat;
    DWORD ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
} RemFORMATETC;
typedef struct tagRemFORMATETC* LPREMFORMATETC;
typedef enum __MIDL_IBindStatusCallback_0005 {
    BINDINFO_OPTIONS_WININETFLAG = 0x10000,
    BINDINFO_OPTIONS_ENABLE_UTF8 = 0x20000,
    BINDINFO_OPTIONS_DISABLE_UTF8 = 0x40000,
    BINDINFO_OPTIONS_USE_IE_ENCODING = 0x80000,
    BINDINFO_OPTIONS_BINDTOOBJECT = 0x100000,
    BINDINFO_OPTIONS_SECURITYOPTOUT = 0x200000,
    BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = 0x400000,
    BINDINFO_OPTIONS_USEBINDSTRINGCREDS = 0x800000,
    BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 0x1000000,
    BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = 0x2000000,
    BINDINFO_WPC_DOWNLOADBLOCKED = 0x8000000,
    BINDINFO_WPC_LOGGING_ENABLED = 0x10000000,
    BINDINFO_OPTIONS_ALLOWCONNECTDATA = 0x20000000,
    BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = 0x40000000,
    BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = (int)0x80000000
} BINDINFO_OPTIONS;
typedef enum __MIDL_IBindStatusCallback_0006 {
    BSCF_FIRSTDATANOTIFICATION = 0x1,
    BSCF_INTERMEDIATEDATANOTIFICATION = 0x2,
    BSCF_LASTDATANOTIFICATION = 0x4,
    BSCF_DATAFULLYAVAILABLE = 0x8,
    BSCF_AVAILABLEDATASIZEUNKNOWN = 0x10,
    BSCF_SKIPDRAINDATAFORFILEURLS = 0x20,
    BSCF_64BITLENGTHDOWNLOAD = 0x40
} BSCF;
typedef enum tagBINDSTATUS {
    BINDSTATUS_FINDINGRESOURCE = 1,
    BINDSTATUS_CONNECTING = (BINDSTATUS_FINDINGRESOURCE + 1),
    BINDSTATUS_REDIRECTING = (BINDSTATUS_CONNECTING + 1),
    BINDSTATUS_BEGINDOWNLOADDATA = (BINDSTATUS_REDIRECTING + 1),
    BINDSTATUS_DOWNLOADINGDATA = (BINDSTATUS_BEGINDOWNLOADDATA + 1),
    BINDSTATUS_ENDDOWNLOADDATA = (BINDSTATUS_DOWNLOADINGDATA + 1),
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS = (BINDSTATUS_ENDDOWNLOADDATA + 1),
    BINDSTATUS_INSTALLINGCOMPONENTS = (BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1),
    BINDSTATUS_ENDDOWNLOADCOMPONENTS = (BINDSTATUS_INSTALLINGCOMPONENTS + 1),
    BINDSTATUS_USINGCACHEDCOPY = (BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1),
    BINDSTATUS_SENDINGREQUEST = (BINDSTATUS_USINGCACHEDCOPY + 1),
    BINDSTATUS_CLASSIDAVAILABLE = (BINDSTATUS_SENDINGREQUEST + 1),
    BINDSTATUS_MIMETYPEAVAILABLE = (BINDSTATUS_CLASSIDAVAILABLE + 1),
    BINDSTATUS_CACHEFILENAMEAVAILABLE = (BINDSTATUS_MIMETYPEAVAILABLE + 1),
    BINDSTATUS_BEGINSYNCOPERATION = (BINDSTATUS_CACHEFILENAMEAVAILABLE + 1),
    BINDSTATUS_ENDSYNCOPERATION = (BINDSTATUS_BEGINSYNCOPERATION + 1),
    BINDSTATUS_BEGINUPLOADDATA = (BINDSTATUS_ENDSYNCOPERATION + 1),
    BINDSTATUS_UPLOADINGDATA = (BINDSTATUS_BEGINUPLOADDATA + 1),
    BINDSTATUS_ENDUPLOADDATA = (BINDSTATUS_UPLOADINGDATA + 1),
    BINDSTATUS_PROTOCOLCLASSID = (BINDSTATUS_ENDUPLOADDATA + 1),
    BINDSTATUS_ENCODING = (BINDSTATUS_PROTOCOLCLASSID + 1),
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = (BINDSTATUS_ENCODING + 1),
    BINDSTATUS_CLASSINSTALLLOCATION = (BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE + 1),
    BINDSTATUS_DECODING = (BINDSTATUS_CLASSINSTALLLOCATION + 1),
    BINDSTATUS_LOADINGMIMEHANDLER = (BINDSTATUS_DECODING + 1),
    BINDSTATUS_CONTENTDISPOSITIONATTACH = (BINDSTATUS_LOADINGMIMEHANDLER + 1),
    BINDSTATUS_FILTERREPORTMIMETYPE = (BINDSTATUS_CONTENTDISPOSITIONATTACH + 1),
    BINDSTATUS_CLSIDCANINSTANTIATE = (BINDSTATUS_FILTERREPORTMIMETYPE + 1),
    BINDSTATUS_IUNKNOWNAVAILABLE = (BINDSTATUS_CLSIDCANINSTANTIATE + 1),
    BINDSTATUS_DIRECTBIND = (BINDSTATUS_IUNKNOWNAVAILABLE + 1),
    BINDSTATUS_RAWMIMETYPE = (BINDSTATUS_DIRECTBIND + 1),
    BINDSTATUS_PROXYDETECTING = (BINDSTATUS_RAWMIMETYPE + 1),
    BINDSTATUS_ACCEPTRANGES = (BINDSTATUS_PROXYDETECTING + 1),
    BINDSTATUS_COOKIE_SENT = (BINDSTATUS_ACCEPTRANGES + 1),
    BINDSTATUS_COMPACT_POLICY_RECEIVED = (BINDSTATUS_COOKIE_SENT + 1),
    BINDSTATUS_COOKIE_SUPPRESSED = (BINDSTATUS_COMPACT_POLICY_RECEIVED + 1),
    BINDSTATUS_COOKIE_STATE_UNKNOWN = (BINDSTATUS_COOKIE_SUPPRESSED + 1),
    BINDSTATUS_COOKIE_STATE_ACCEPT = (BINDSTATUS_COOKIE_STATE_UNKNOWN + 1),
    BINDSTATUS_COOKIE_STATE_REJECT = (BINDSTATUS_COOKIE_STATE_ACCEPT + 1),
    BINDSTATUS_COOKIE_STATE_PROMPT = (BINDSTATUS_COOKIE_STATE_REJECT + 1),
    BINDSTATUS_COOKIE_STATE_LEASH = (BINDSTATUS_COOKIE_STATE_PROMPT + 1),
    BINDSTATUS_COOKIE_STATE_DOWNGRADE = (BINDSTATUS_COOKIE_STATE_LEASH + 1),
    BINDSTATUS_POLICY_HREF = (BINDSTATUS_COOKIE_STATE_DOWNGRADE + 1),
    BINDSTATUS_P3P_HEADER = (BINDSTATUS_POLICY_HREF + 1),
    BINDSTATUS_SESSION_COOKIE_RECEIVED = (BINDSTATUS_P3P_HEADER + 1),
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = (BINDSTATUS_SESSION_COOKIE_RECEIVED + 1),
    BINDSTATUS_SESSION_COOKIES_ALLOWED = (BINDSTATUS_PERSISTENT_COOKIE_RECEIVED + 1),
    BINDSTATUS_CACHECONTROL = (BINDSTATUS_SESSION_COOKIES_ALLOWED + 1),
    BINDSTATUS_CONTENTDISPOSITIONFILENAME = (BINDSTATUS_CACHECONTROL + 1),
    BINDSTATUS_MIMETEXTPLAINMISMATCH = (BINDSTATUS_CONTENTDISPOSITIONFILENAME + 1),
    BINDSTATUS_PUBLISHERAVAILABLE = (BINDSTATUS_MIMETEXTPLAINMISMATCH + 1),
    BINDSTATUS_DISPLAYNAMEAVAILABLE = (BINDSTATUS_PUBLISHERAVAILABLE + 1),
    BINDSTATUS_SSLUX_NAVBLOCKED = (BINDSTATUS_DISPLAYNAMEAVAILABLE + 1),
    BINDSTATUS_SERVER_MIMETYPEAVAILABLE = (BINDSTATUS_SSLUX_NAVBLOCKED + 1),
    BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = (BINDSTATUS_SERVER_MIMETYPEAVAILABLE + 1),
    BINDSTATUS_64BIT_PROGRESS = (BINDSTATUS_SNIFFED_CLASSIDAVAILABLE + 1),
    BINDSTATUS_LAST = BINDSTATUS_64BIT_PROGRESS,
    BINDSTATUS_RESERVED_0 = (BINDSTATUS_LAST + 1),
    BINDSTATUS_RESERVED_1 = (BINDSTATUS_RESERVED_0 + 1),
    BINDSTATUS_RESERVED_2 = (BINDSTATUS_RESERVED_1 + 1),
    BINDSTATUS_RESERVED_3 = (BINDSTATUS_RESERVED_2 + 1),
    BINDSTATUS_RESERVED_4 = (BINDSTATUS_RESERVED_3 + 1),
    BINDSTATUS_RESERVED_5 = (BINDSTATUS_RESERVED_4 + 1),
    BINDSTATUS_RESERVED_6 = (BINDSTATUS_RESERVED_5 + 1),
    BINDSTATUS_RESERVED_7 = (BINDSTATUS_RESERVED_6 + 1),
    BINDSTATUS_RESERVED_8 = (BINDSTATUS_RESERVED_7 + 1),
    BINDSTATUS_RESERVED_9 = (BINDSTATUS_RESERVED_8 + 1),
    BINDSTATUS_RESERVED_A = (BINDSTATUS_RESERVED_9 + 1),
    BINDSTATUS_RESERVED_B = (BINDSTATUS_RESERVED_A + 1),
    BINDSTATUS_RESERVED_C = (BINDSTATUS_RESERVED_B + 1),
    BINDSTATUS_RESERVED_D = (BINDSTATUS_RESERVED_C + 1),
    BINDSTATUS_RESERVED_E = (BINDSTATUS_RESERVED_D + 1),
    BINDSTATUS_RESERVED_F = (BINDSTATUS_RESERVED_E + 1),
    BINDSTATUS_RESERVED_10 = (BINDSTATUS_RESERVED_F + 1),
    BINDSTATUS_RESERVED_11 = (BINDSTATUS_RESERVED_10 + 1),
    BINDSTATUS_RESERVED_12 = (BINDSTATUS_RESERVED_11 + 1),
    BINDSTATUS_RESERVED_13 = (BINDSTATUS_RESERVED_12 + 1),
    BINDSTATUS_RESERVED_14 = (BINDSTATUS_RESERVED_13 + 1),
    BINDSTATUS_LAST_PRIVATE = BINDSTATUS_RESERVED_14
} BINDSTATUS;
extern "C" const IID IID_IBindStatusCallback;
struct __declspec(uuid("79eac9c1-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IBindStatusCallback : public IUnknown {
public:
    virtual HRESULT __stdcall OnStartBinding(
        DWORD dwReserved,
        IBinding* pib)
        = 0;
    virtual HRESULT __stdcall GetPriority(
        LONG* pnPriority)
        = 0;
    virtual HRESULT __stdcall OnLowResource(
        DWORD reserved)
        = 0;
    virtual HRESULT __stdcall OnProgress(
        ULONG ulProgress,
        ULONG ulProgressMax,
        ULONG ulStatusCode,
        LPCWSTR szStatusText)
        = 0;
    virtual HRESULT __stdcall OnStopBinding(
        HRESULT hresult,
        LPCWSTR szError)
        = 0;
    virtual HRESULT __stdcall GetBindInfo(
        DWORD* grfBINDF,
        BINDINFO* pbindinfo)
        = 0;
    virtual HRESULT __stdcall OnDataAvailable(
        DWORD grfBSCF,
        DWORD dwSize,
        FORMATETC* pformatetc,
        STGMEDIUM* pstgmed)
        = 0;
    virtual HRESULT __stdcall OnObjectAvailable(
        const IID& riid,
        IUnknown* punk)
        = 0;
};
HRESULT __stdcall IBindStatusCallback_RemoteGetBindInfo_Proxy(
    IBindStatusCallback* This,
    DWORD* grfBINDF,
    RemBINDINFO* pbindinfo,
    RemSTGMEDIUM* pstgmed);
void __stdcall IBindStatusCallback_RemoteGetBindInfo_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IBindStatusCallback_RemoteOnDataAvailable_Proxy(
    IBindStatusCallback* This,
    DWORD grfBSCF,
    DWORD dwSize,
    RemFORMATETC* pformatetc,
    RemSTGMEDIUM* pstgmed);
void __stdcall IBindStatusCallback_RemoteOnDataAvailable_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec;
typedef IBindStatusCallbackEx* LPBINDSTATUSCALLBACKEX;
typedef enum __MIDL_IBindStatusCallbackEx_0001 {
    BINDF2_DISABLEBASICOVERHTTP = 0x1,
    BINDF2_DISABLEAUTOCOOKIEHANDLING = 0x2,
    BINDF2_READ_DATA_GREATER_THAN_4GB = 0x4,
    BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = 0x8,
    BINDF2_SETDOWNLOADMODE = 0x20,
    BINDF2_DISABLE_HTTP_REDIRECT_CACHING = 0x40,
    BINDF2_KEEP_CALLBACK_MODULE_LOADED = 0x80,
    BINDF2_ALLOW_PROXY_CRED_PROMPT = 0x100,
    BINDF2_RESERVED_17 = 0x200,
    BINDF2_RESERVED_16 = 0x400,
    BINDF2_RESERVED_15 = 0x800,
    BINDF2_RESERVED_14 = 0x1000,
    BINDF2_RESERVED_13 = 0x2000,
    BINDF2_RESERVED_12 = 0x4000,
    BINDF2_RESERVED_11 = 0x8000,
    BINDF2_RESERVED_10 = 0x10000,
    BINDF2_RESERVED_F = 0x20000,
    BINDF2_RESERVED_E = 0x40000,
    BINDF2_RESERVED_D = 0x80000,
    BINDF2_RESERVED_C = 0x100000,
    BINDF2_RESERVED_B = 0x200000,
    BINDF2_RESERVED_A = 0x400000,
    BINDF2_RESERVED_9 = 0x800000,
    BINDF2_RESERVED_8 = 0x1000000,
    BINDF2_RESERVED_7 = 0x2000000,
    BINDF2_RESERVED_6 = 0x4000000,
    BINDF2_RESERVED_5 = 0x8000000,
    BINDF2_RESERVED_4 = 0x10000000,
    BINDF2_RESERVED_3 = 0x20000000,
    BINDF2_RESERVED_2 = 0x40000000,
    BINDF2_RESERVED_1 = 0x80000000
} BINDF2;
extern "C" const IID IID_IBindStatusCallbackEx;
struct __declspec(uuid("aaa74ef9-8ee7-4659-88d9-f8c504da73cc")) __declspec(novtable)
    IBindStatusCallbackEx : public IBindStatusCallback {
public:
    virtual HRESULT __stdcall GetBindInfoEx(
        DWORD* grfBINDF,
        BINDINFO* pbindinfo,
        DWORD* grfBINDF2,
        DWORD* pdwReserved)
        = 0;
};
HRESULT __stdcall IBindStatusCallbackEx_RemoteGetBindInfoEx_Proxy(
    IBindStatusCallbackEx* This,
    DWORD* grfBINDF,
    RemBINDINFO* pbindinfo,
    RemSTGMEDIUM* pstgmed,
    DWORD* grfBINDF2,
    DWORD* pdwReserved);
void __stdcall IBindStatusCallbackEx_RemoteGetBindInfoEx_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec;
typedef IAuthenticate* LPAUTHENTICATION;
extern "C" const IID IID_IAuthenticate;
struct __declspec(uuid("79eac9d0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IAuthenticate : public IUnknown {
public:
    virtual HRESULT __stdcall Authenticate(
        HWND* phwnd,
        LPWSTR* pszUsername,
        LPWSTR* pszPassword)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec;
typedef IAuthenticateEx* LPAUTHENTICATIONEX;
typedef enum __MIDL_IAuthenticateEx_0001 {
    AUTHENTICATEF_PROXY = 0x1,
    AUTHENTICATEF_BASIC = 0x2,
    AUTHENTICATEF_HTTP = 0x4
} AUTHENTICATEF;
typedef struct _tagAUTHENTICATEINFO {
    DWORD dwFlags;
    DWORD dwReserved;
} AUTHENTICATEINFO;
extern "C" const IID IID_IAuthenticateEx;
struct __declspec(uuid("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd")) __declspec(novtable)
    IAuthenticateEx : public IAuthenticate {
public:
    virtual HRESULT __stdcall AuthenticateEx(
        HWND* phwnd,
        LPWSTR* pszUsername,
        LPWSTR* pszPassword,
        AUTHENTICATEINFO* pauthinfo)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec;
typedef IHttpNegotiate* LPHTTPNEGOTIATE;
extern "C" const IID IID_IHttpNegotiate;
struct __declspec(uuid("79eac9d2-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IHttpNegotiate : public IUnknown {
public:
    virtual HRESULT __stdcall BeginningTransaction(
        LPCWSTR szURL,
        LPCWSTR szHeaders,
        DWORD dwReserved,
        LPWSTR* pszAdditionalHeaders)
        = 0;
    virtual HRESULT __stdcall OnResponse(
        DWORD dwResponseCode,
        LPCWSTR szResponseHeaders,
        LPCWSTR szRequestHeaders,
        LPWSTR* pszAdditionalRequestHeaders)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec;
typedef IHttpNegotiate2* LPHTTPNEGOTIATE2;
extern "C" const IID IID_IHttpNegotiate2;
struct __declspec(uuid("4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4")) __declspec(novtable)
    IHttpNegotiate2 : public IHttpNegotiate {
public:
    virtual HRESULT __stdcall GetRootSecurityId(
        BYTE* pbSecurityId,
        DWORD* pcbSecurityId,
        DWORD_PTR dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec;
typedef IHttpNegotiate3* LPHTTPNEGOTIATE3;
extern "C" const IID IID_IHttpNegotiate3;
struct __declspec(uuid("57b6c80a-34c2-4602-bc26-66a02fc57153")) __declspec(novtable)
    IHttpNegotiate3 : public IHttpNegotiate2 {
public:
    virtual HRESULT __stdcall GetSerializedClientCertContext(
        BYTE** ppbCert,
        DWORD* pcbCert)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec;
typedef IWinInetFileStream* LPWININETFILESTREAM;
extern "C" const IID IID_IWinInetFileStream;
struct __declspec(uuid("F134C4B7-B1F8-4e75-B886-74B90943BECB")) __declspec(novtable)
    IWinInetFileStream : public IUnknown {
public:
    virtual HRESULT __stdcall SetHandleForUnlock(
        DWORD_PTR hWinInetLockHandle,
        DWORD_PTR dwReserved)
        = 0;
    virtual HRESULT __stdcall SetDeleteFile(
        DWORD_PTR dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec;
typedef IWindowForBindingUI* LPWINDOWFORBINDINGUI;
extern "C" const IID IID_IWindowForBindingUI;
struct __declspec(uuid("79eac9d5-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IWindowForBindingUI : public IUnknown {
public:
    virtual HRESULT __stdcall GetWindow(
        const GUID& rguidReason,
        HWND* phwnd)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec;
typedef ICodeInstall* LPCODEINSTALL;
typedef enum __MIDL_ICodeInstall_0001 {
    CIP_DISK_FULL = 0,
    CIP_ACCESS_DENIED = (CIP_DISK_FULL + 1),
    CIP_NEWER_VERSION_EXISTS = (CIP_ACCESS_DENIED + 1),
    CIP_OLDER_VERSION_EXISTS = (CIP_NEWER_VERSION_EXISTS + 1),
    CIP_NAME_CONFLICT = (CIP_OLDER_VERSION_EXISTS + 1),
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING = (CIP_NAME_CONFLICT + 1),
    CIP_EXE_SELF_REGISTERATION_TIMEOUT = (CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1),
    CIP_UNSAFE_TO_ABORT = (CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1),
    CIP_NEED_REBOOT = (CIP_UNSAFE_TO_ABORT + 1),
    CIP_NEED_REBOOT_UI_PERMISSION = (CIP_NEED_REBOOT + 1)
} CIP_STATUS;
extern "C" const IID IID_ICodeInstall;
struct __declspec(uuid("79eac9d1-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    ICodeInstall : public IWindowForBindingUI {
public:
    virtual HRESULT __stdcall OnCodeInstallProblem(
        ULONG ulStatusCode,
        LPCWSTR szDestination,
        LPCWSTR szSource,
        DWORD dwReserved)
        = 0;
};
#pragma endregion
#pragma region Application Family
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0014_v0_0_s_ifspec;
typedef enum __MIDL_IUri_0001 {
    Uri_PROPERTY_ABSOLUTE_URI = 0,
    Uri_PROPERTY_STRING_START = Uri_PROPERTY_ABSOLUTE_URI,
    Uri_PROPERTY_AUTHORITY = 1,
    Uri_PROPERTY_DISPLAY_URI = 2,
    Uri_PROPERTY_DOMAIN = 3,
    Uri_PROPERTY_EXTENSION = 4,
    Uri_PROPERTY_FRAGMENT = 5,
    Uri_PROPERTY_HOST = 6,
    Uri_PROPERTY_PASSWORD = 7,
    Uri_PROPERTY_PATH = 8,
    Uri_PROPERTY_PATH_AND_QUERY = 9,
    Uri_PROPERTY_QUERY = 10,
    Uri_PROPERTY_RAW_URI = 11,
    Uri_PROPERTY_SCHEME_NAME = 12,
    Uri_PROPERTY_USER_INFO = 13,
    Uri_PROPERTY_USER_NAME = 14,
    Uri_PROPERTY_STRING_LAST = Uri_PROPERTY_USER_NAME,
    Uri_PROPERTY_HOST_TYPE = 15,
    Uri_PROPERTY_DWORD_START = Uri_PROPERTY_HOST_TYPE,
    Uri_PROPERTY_PORT = 16,
    Uri_PROPERTY_SCHEME = 17,
    Uri_PROPERTY_ZONE = 18,
    Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY_ZONE
} Uri_PROPERTY;
typedef enum __MIDL_IUri_0002 {
    Uri_HOST_UNKNOWN = 0,
    Uri_HOST_DNS = (Uri_HOST_UNKNOWN + 1),
    Uri_HOST_IPV4 = (Uri_HOST_DNS + 1),
    Uri_HOST_IPV6 = (Uri_HOST_IPV4 + 1),
    Uri_HOST_IDN = (Uri_HOST_IPV6 + 1)
} Uri_HOST_TYPE;
extern "C" const IID IID_IUri;
struct __declspec(uuid("A39EE748-6A27-4817-A6F2-13914BEF5890")) __declspec(novtable)
    IUri : public IUnknown {
public:
    virtual HRESULT __stdcall GetPropertyBSTR(
        Uri_PROPERTY uriProp,
        BSTR* pbstrProperty,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetPropertyLength(
        Uri_PROPERTY uriProp,
        DWORD* pcchProperty,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetPropertyDWORD(
        Uri_PROPERTY uriProp,
        DWORD* pdwProperty,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall HasProperty(
        Uri_PROPERTY uriProp,
        BOOL* pfHasProperty)
        = 0;
    virtual HRESULT __stdcall GetAbsoluteUri(
        BSTR* pbstrAbsoluteUri)
        = 0;
    virtual HRESULT __stdcall GetAuthority(
        BSTR* pbstrAuthority)
        = 0;
    virtual HRESULT __stdcall GetDisplayUri(
        BSTR* pbstrDisplayString)
        = 0;
    virtual HRESULT __stdcall GetDomain(
        BSTR* pbstrDomain)
        = 0;
    virtual HRESULT __stdcall GetExtension(
        BSTR* pbstrExtension)
        = 0;
    virtual HRESULT __stdcall GetFragment(
        BSTR* pbstrFragment)
        = 0;
    virtual HRESULT __stdcall GetHost(
        BSTR* pbstrHost)
        = 0;
    virtual HRESULT __stdcall GetPassword(
        BSTR* pbstrPassword)
        = 0;
    virtual HRESULT __stdcall GetPath(
        BSTR* pbstrPath)
        = 0;
    virtual HRESULT __stdcall GetPathAndQuery(
        BSTR* pbstrPathAndQuery)
        = 0;
    virtual HRESULT __stdcall GetQuery(
        BSTR* pbstrQuery)
        = 0;
    virtual HRESULT __stdcall GetRawUri(
        BSTR* pbstrRawUri)
        = 0;
    virtual HRESULT __stdcall GetSchemeName(
        BSTR* pbstrSchemeName)
        = 0;
    virtual HRESULT __stdcall GetUserInfo(
        BSTR* pbstrUserInfo)
        = 0;
    virtual HRESULT __stdcall GetUserNameW(
        BSTR* pbstrUserName)
        = 0;
    virtual HRESULT __stdcall GetHostType(
        DWORD* pdwHostType)
        = 0;
    virtual HRESULT __stdcall GetPort(
        DWORD* pdwPort)
        = 0;
    virtual HRESULT __stdcall GetScheme(
        DWORD* pdwScheme)
        = 0;
    virtual HRESULT __stdcall GetZone(
        DWORD* pdwZone)
        = 0;
    virtual HRESULT __stdcall GetProperties(
        LPDWORD pdwFlags)
        = 0;
    virtual HRESULT __stdcall IsEqual(
        IUri* pUri,
        BOOL* pfEqual)
        = 0;
};
extern "C" HRESULT __stdcall CreateUri(LPCWSTR pwzURI,
    DWORD dwFlags,
    DWORD_PTR dwReserved,
    IUri** ppURI);
extern "C" HRESULT __stdcall CreateUriWithFragment(
    LPCWSTR pwzURI,
    LPCWSTR pwzFragment,
    DWORD dwFlags,
    DWORD_PTR dwReserved,
    IUri** ppURI);
#pragma endregion
#pragma region Desktop Family
extern "C" HRESULT __stdcall CreateUriFromMultiByteString(
    LPCSTR pszANSIInputUri,
    DWORD dwEncodingFlags,
    DWORD dwCodePage,
    DWORD dwCreateFlags,
    DWORD_PTR dwReserved,
    IUri** ppUri);
#pragma endregion
#pragma region Application Family
#pragma endregion
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec;
extern "C" const IID IID_IUriContainer;
struct __declspec(uuid("a158a630-ed6f-45fb-b987-f68676f57752")) __declspec(novtable)
    IUriContainer : public IUnknown {
public:
    virtual HRESULT __stdcall GetIUri(
        IUri** ppIUri)
        = 0;
};
extern "C" const IID IID_IUriBuilder;
struct __declspec(uuid("4221B2E1-8955-46c0-BD5B-DE9897565DE7")) __declspec(novtable)
    IUriBuilder : public IUnknown {
public:
    virtual HRESULT __stdcall CreateUriSimple(
        DWORD dwAllowEncodingPropertyMask,
        DWORD_PTR dwReserved,
        IUri** ppIUri)
        = 0;
    virtual HRESULT __stdcall CreateUri(
        DWORD dwCreateFlags,
        DWORD dwAllowEncodingPropertyMask,
        DWORD_PTR dwReserved,
        IUri** ppIUri)
        = 0;
    virtual HRESULT __stdcall CreateUriWithFlags(
        DWORD dwCreateFlags,
        DWORD dwUriBuilderFlags,
        DWORD dwAllowEncodingPropertyMask,
        DWORD_PTR dwReserved,
        IUri** ppIUri)
        = 0;
    virtual HRESULT __stdcall GetIUri(
        IUri** ppIUri)
        = 0;
    virtual HRESULT __stdcall SetIUri(
        IUri* pIUri)
        = 0;
    virtual HRESULT __stdcall GetFragment(
        DWORD* pcchFragment,
        LPCWSTR* ppwzFragment)
        = 0;
    virtual HRESULT __stdcall GetHost(
        DWORD* pcchHost,
        LPCWSTR* ppwzHost)
        = 0;
    virtual HRESULT __stdcall GetPassword(
        DWORD* pcchPassword,
        LPCWSTR* ppwzPassword)
        = 0;
    virtual HRESULT __stdcall GetPath(
        DWORD* pcchPath,
        LPCWSTR* ppwzPath)
        = 0;
    virtual HRESULT __stdcall GetPort(
        BOOL* pfHasPort,
        DWORD* pdwPort)
        = 0;
    virtual HRESULT __stdcall GetQuery(
        DWORD* pcchQuery,
        LPCWSTR* ppwzQuery)
        = 0;
    virtual HRESULT __stdcall GetSchemeName(
        DWORD* pcchSchemeName,
        LPCWSTR* ppwzSchemeName)
        = 0;
    virtual HRESULT __stdcall GetUserNameW(
        DWORD* pcchUserName,
        LPCWSTR* ppwzUserName)
        = 0;
    virtual HRESULT __stdcall SetFragment(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall SetHost(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall SetPassword(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall SetPath(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall SetPort(
        BOOL fHasPort,
        DWORD dwNewValue)
        = 0;
    virtual HRESULT __stdcall SetQuery(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall SetSchemeName(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall SetUserName(
        LPCWSTR pwzNewValue)
        = 0;
    virtual HRESULT __stdcall RemoveProperties(
        DWORD dwPropertyMask)
        = 0;
    virtual HRESULT __stdcall HasBeenModified(
        BOOL* pfModified)
        = 0;
};
extern "C" const IID IID_IUriBuilderFactory;
struct __declspec(uuid("E982CE48-0B96-440c-BC37-0C869B27A29E")) __declspec(novtable)
    IUriBuilderFactory : public IUnknown {
public:
    virtual HRESULT __stdcall CreateIUriBuilder(
        DWORD dwFlags,
        DWORD_PTR dwReserved,
        IUriBuilder** ppIUriBuilder)
        = 0;
    virtual HRESULT __stdcall CreateInitializedIUriBuilder(
        DWORD dwFlags,
        DWORD_PTR dwReserved,
        IUriBuilder** ppIUriBuilder)
        = 0;
};
extern "C" HRESULT __stdcall CreateIUriBuilder(
    IUri* pIUri,
    DWORD dwFlags,
    DWORD_PTR dwReserved,
    IUriBuilder** ppIUriBuilder);
#pragma endregion
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec;
typedef IWinInetInfo* LPWININETINFO;
extern "C" const IID IID_IWinInetInfo;
struct __declspec(uuid("79eac9d6-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IWinInetInfo : public IUnknown {
public:
    virtual HRESULT __stdcall QueryOption(
        DWORD dwOption,
        LPVOID pBuffer,
        DWORD* pcbBuf)
        = 0;
};
HRESULT __stdcall IWinInetInfo_RemoteQueryOption_Proxy(
    IWinInetInfo* This,
    DWORD dwOption,
    BYTE* pBuffer,
    DWORD* pcbBuf);
void __stdcall IWinInetInfo_RemoteQueryOption_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec;
typedef IHttpSecurity* LPHTTPSECURITY;
extern "C" const IID IID_IHttpSecurity;
struct __declspec(uuid("79eac9d7-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IHttpSecurity : public IWindowForBindingUI {
public:
    virtual HRESULT __stdcall OnSecurityProblem(
        DWORD dwProblem)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec;
typedef IWinInetHttpInfo* LPWININETHTTPINFO;
extern "C" const IID IID_IWinInetHttpInfo;
struct __declspec(uuid("79eac9d8-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IWinInetHttpInfo : public IWinInetInfo {
public:
    virtual HRESULT __stdcall QueryInfo(
        DWORD dwOption,
        LPVOID pBuffer,
        DWORD* pcbBuf,
        DWORD* pdwFlags,
        DWORD* pdwReserved)
        = 0;
};
HRESULT __stdcall IWinInetHttpInfo_RemoteQueryInfo_Proxy(
    IWinInetHttpInfo* This,
    DWORD dwOption,
    BYTE* pBuffer,
    DWORD* pcbBuf,
    DWORD* pdwFlags,
    DWORD* pdwReserved);
void __stdcall IWinInetHttpInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec;
extern "C" const IID IID_IWinInetHttpTimeouts;
struct __declspec(uuid("F286FA56-C1FD-4270-8E67-B3EB790A81E8")) __declspec(novtable)
    IWinInetHttpTimeouts : public IUnknown {
public:
    virtual HRESULT __stdcall GetRequestTimeouts(
        DWORD* pdwConnectTimeout,
        DWORD* pdwSendTimeout,
        DWORD* pdwReceiveTimeout)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec;
typedef IWinInetCacheHints* LPWININETCACHEHINTS;
extern "C" const IID IID_IWinInetCacheHints;
struct __declspec(uuid("DD1EC3B3-8391-4fdb-A9E6-347C3CAAA7DD")) __declspec(novtable)
    IWinInetCacheHints : public IUnknown {
public:
    virtual HRESULT __stdcall SetCacheExtension(
        LPCWSTR pwzExt,
        LPVOID pszCacheFile,
        DWORD* pcbCacheFile,
        DWORD* pdwWinInetError,
        DWORD* pdwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec;
typedef IWinInetCacheHints2* LPWININETCACHEHINTS2;
extern "C" const IID IID_IWinInetCacheHints2;
struct __declspec(uuid("7857AEAC-D31F-49bf-884E-DD46DF36780A")) __declspec(novtable)
    IWinInetCacheHints2 : public IWinInetCacheHints {
public:
    virtual HRESULT __stdcall SetCacheExtension2(
        LPCWSTR pwzExt,
        WCHAR* pwzCacheFile,
        DWORD* pcchCacheFile,
        DWORD* pdwWinInetError,
        DWORD* pdwReserved)
        = 0;
};
extern "C" const GUID SID_BindHost;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec;
typedef IBindHost* LPBINDHOST;
extern "C" const IID IID_IBindHost;
struct __declspec(uuid("fc4801a1-2ba9-11cf-a229-00aa003d7352")) __declspec(novtable)
    IBindHost : public IUnknown {
public:
    virtual HRESULT __stdcall CreateMoniker(
        LPOLESTR szName,
        IBindCtx* pBC,
        IMoniker** ppmk,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall MonikerBindToStorage(
        IMoniker* pMk,
        IBindCtx* pBC,
        IBindStatusCallback* pBSC,
        const IID& riid,
        void** ppvObj)
        = 0;
    virtual HRESULT __stdcall MonikerBindToObject(
        IMoniker* pMk,
        IBindCtx* pBC,
        IBindStatusCallback* pBSC,
        const IID& riid,
        void** ppvObj)
        = 0;
};
HRESULT __stdcall IBindHost_RemoteMonikerBindToStorage_Proxy(
    IBindHost* This,
    IMoniker* pMk,
    IBindCtx* pBC,
    IBindStatusCallback* pBSC,
    const IID& riid,
    IUnknown** ppvObj);
void __stdcall IBindHost_RemoteMonikerBindToStorage_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IBindHost_RemoteMonikerBindToObject_Proxy(
    IBindHost* This,
    IMoniker* pMk,
    IBindCtx* pBC,
    IBindStatusCallback* pBSC,
    const IID& riid,
    IUnknown** ppvObj);
void __stdcall IBindHost_RemoteMonikerBindToObject_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
struct IBindStatusCallback;
extern "C" HRESULT __stdcall HlinkSimpleNavigateToString(
    LPCWSTR szTarget,
    LPCWSTR szLocation,
    LPCWSTR szTargetFrameName,
    IUnknown* pUnk,
    IBindCtx* pbc,
    IBindStatusCallback*,
    DWORD grfHLNF,
    DWORD dwReserved);
extern "C" HRESULT __stdcall HlinkSimpleNavigateToMoniker(
    IMoniker* pmkTarget,
    LPCWSTR szLocation,
    LPCWSTR szTargetFrameName,
    IUnknown* pUnk,
    IBindCtx* pbc,
    IBindStatusCallback*,
    DWORD grfHLNF,
    DWORD dwReserved);
extern "C" HRESULT __stdcall URLOpenStreamA(LPUNKNOWN, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLOpenStreamW(LPUNKNOWN, LPCWSTR, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLOpenPullStreamA(LPUNKNOWN, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLOpenPullStreamW(LPUNKNOWN, LPCWSTR, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLDownloadToFileA(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLDownloadToFileW(LPUNKNOWN, LPCWSTR, LPCWSTR, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLDownloadToCacheFileA(LPUNKNOWN, LPCSTR, LPSTR, DWORD cchFileName, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLDownloadToCacheFileW(LPUNKNOWN, LPCWSTR, LPWSTR, DWORD cchFileName, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLOpenBlockingStreamA(LPUNKNOWN, LPCSTR, LPSTREAM*, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall URLOpenBlockingStreamW(LPUNKNOWN, LPCWSTR, LPSTREAM*, DWORD, LPBINDSTATUSCALLBACK);
extern "C" HRESULT __stdcall HlinkGoBack(IUnknown* pUnk);
extern "C" HRESULT __stdcall HlinkGoForward(IUnknown* pUnk);
extern "C" HRESULT __stdcall HlinkNavigateString(IUnknown* pUnk, LPCWSTR szTarget);
extern "C" HRESULT __stdcall HlinkNavigateMoniker(IUnknown* pUnk, IMoniker* pmkTarget);
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec;
typedef IInternet* LPIINTERNET;
extern "C" const IID IID_IInternet;
struct __declspec(uuid("79eac9e0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternet : public IUnknown {
public:
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec;
typedef IInternetBindInfo* LPIINTERNETBINDINFO;
typedef enum tagBINDSTRING {
    BINDSTRING_HEADERS = 1,
    BINDSTRING_ACCEPT_MIMES = (BINDSTRING_HEADERS + 1),
    BINDSTRING_EXTRA_URL = (BINDSTRING_ACCEPT_MIMES + 1),
    BINDSTRING_LANGUAGE = (BINDSTRING_EXTRA_URL + 1),
    BINDSTRING_USERNAME = (BINDSTRING_LANGUAGE + 1),
    BINDSTRING_PASSWORD = (BINDSTRING_USERNAME + 1),
    BINDSTRING_UA_PIXELS = (BINDSTRING_PASSWORD + 1),
    BINDSTRING_UA_COLOR = (BINDSTRING_UA_PIXELS + 1),
    BINDSTRING_OS = (BINDSTRING_UA_COLOR + 1),
    BINDSTRING_USER_AGENT = (BINDSTRING_OS + 1),
    BINDSTRING_ACCEPT_ENCODINGS = (BINDSTRING_USER_AGENT + 1),
    BINDSTRING_POST_COOKIE = (BINDSTRING_ACCEPT_ENCODINGS + 1),
    BINDSTRING_POST_DATA_MIME = (BINDSTRING_POST_COOKIE + 1),
    BINDSTRING_URL = (BINDSTRING_POST_DATA_MIME + 1),
    BINDSTRING_IID = (BINDSTRING_URL + 1),
    BINDSTRING_FLAG_BIND_TO_OBJECT = (BINDSTRING_IID + 1),
    BINDSTRING_PTR_BIND_CONTEXT = (BINDSTRING_FLAG_BIND_TO_OBJECT + 1),
    BINDSTRING_XDR_ORIGIN = (BINDSTRING_PTR_BIND_CONTEXT + 1),
    BINDSTRING_DOWNLOADPATH = (BINDSTRING_XDR_ORIGIN + 1),
    BINDSTRING_ROOTDOC_URL = (BINDSTRING_DOWNLOADPATH + 1),
    BINDSTRING_INITIAL_FILENAME = (BINDSTRING_ROOTDOC_URL + 1),
    BINDSTRING_PROXY_USERNAME = (BINDSTRING_INITIAL_FILENAME + 1),
    BINDSTRING_PROXY_PASSWORD = (BINDSTRING_PROXY_USERNAME + 1),
    BINDSTRING_ENTERPRISE_ID = (BINDSTRING_PROXY_PASSWORD + 1),
    BINDSTRING_DOC_URL = (BINDSTRING_ENTERPRISE_ID + 1),
    BINDSTRING_SAMESITE_COOKIE_LEVEL = (BINDSTRING_DOC_URL + 1)
} BINDSTRING;
extern "C" const IID IID_IInternetBindInfo;
struct __declspec(uuid("79eac9e1-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetBindInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetBindInfo(
        DWORD* grfBINDF,
        BINDINFO* pbindinfo)
        = 0;
    virtual HRESULT __stdcall GetBindString(
        ULONG ulStringType,
        LPOLESTR* ppwzStr,
        ULONG cEl,
        ULONG* pcElFetched)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec;
typedef IInternetBindInfoEx* LPIINTERNETBINDINFOEX;
extern "C" const IID IID_IInternetBindInfoEx;
struct __declspec(uuid("a3e015b7-a82c-4dcd-a150-569aeeed36ab")) __declspec(novtable)
    IInternetBindInfoEx : public IInternetBindInfo {
public:
    virtual HRESULT __stdcall GetBindInfoEx(
        DWORD* grfBINDF,
        BINDINFO* pbindinfo,
        DWORD* grfBINDF2,
        DWORD* pdwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec;
typedef IInternetProtocolRoot* LPIINTERNETPROTOCOLROOT;
typedef enum _tagPI_FLAGS {
    PI_PARSE_URL = 0x1,
    PI_FILTER_MODE = 0x2,
    PI_FORCE_ASYNC = 0x4,
    PI_USE_WORKERTHREAD = 0x8,
    PI_MIMEVERIFICATION = 0x10,
    PI_CLSIDLOOKUP = 0x20,
    PI_DATAPROGRESS = 0x40,
    PI_SYNCHRONOUS = 0x80,
    PI_APARTMENTTHREADED = 0x100,
    PI_CLASSINSTALL = 0x200,
    PI_PASSONBINDCTX = 0x2000,
    PI_NOMIMEHANDLER = 0x8000,
    PI_LOADAPPDIRECT = 0x4000,
    PD_FORCE_SWITCH = 0x10000,
    PI_PREFERDEFAULTHANDLER = 0x20000
} PI_FLAGS;
typedef struct _tagPROTOCOLDATA {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
} PROTOCOLDATA;
typedef struct _tagStartParam {
    IID iid;
    IBindCtx* pIBindCtx;
    IUnknown* pItf;
} StartParam;
extern "C" const IID IID_IInternetProtocolRoot;
struct __declspec(uuid("79eac9e3-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetProtocolRoot : public IUnknown {
public:
    virtual HRESULT __stdcall Start(
        LPCWSTR szUrl,
        IInternetProtocolSink* pOIProtSink,
        IInternetBindInfo* pOIBindInfo,
        DWORD grfPI,
        HANDLE_PTR dwReserved)
        = 0;
    virtual HRESULT __stdcall Continue(
        PROTOCOLDATA* pProtocolData)
        = 0;
    virtual HRESULT __stdcall Abort(
        HRESULT hrReason,
        DWORD dwOptions)
        = 0;
    virtual HRESULT __stdcall Terminate(
        DWORD dwOptions)
        = 0;
    virtual HRESULT __stdcall Suspend(void) = 0;
    virtual HRESULT __stdcall Resume(void) = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec;
typedef IInternetProtocol* LPIINTERNETPROTOCOL;
extern "C" const IID IID_IInternetProtocol;
struct __declspec(uuid("79eac9e4-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetProtocol : public IInternetProtocolRoot {
public:
    virtual HRESULT __stdcall Read(
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
        = 0;
    virtual HRESULT __stdcall Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER* plibNewPosition)
        = 0;
    virtual HRESULT __stdcall LockRequest(
        DWORD dwOptions)
        = 0;
    virtual HRESULT __stdcall UnlockRequest(void) = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec;
extern "C" const IID IID_IInternetProtocolEx;
struct __declspec(uuid("C7A98E66-1010-492c-A1C8-C809E1F75905")) __declspec(novtable)
    IInternetProtocolEx : public IInternetProtocol {
public:
    virtual HRESULT __stdcall StartEx(
        IUri* pUri,
        IInternetProtocolSink* pOIProtSink,
        IInternetBindInfo* pOIBindInfo,
        DWORD grfPI,
        HANDLE_PTR dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec;
typedef IInternetProtocolSink* LPIINTERNETPROTOCOLSINK;
extern "C" const IID IID_IInternetProtocolSink;
struct __declspec(uuid("79eac9e5-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetProtocolSink : public IUnknown {
public:
    virtual HRESULT __stdcall Switch(
        PROTOCOLDATA* pProtocolData)
        = 0;
    virtual HRESULT __stdcall ReportProgress(
        ULONG ulStatusCode,
        LPCWSTR szStatusText)
        = 0;
    virtual HRESULT __stdcall ReportData(
        DWORD grfBSCF,
        ULONG ulProgress,
        ULONG ulProgressMax)
        = 0;
    virtual HRESULT __stdcall ReportResult(
        HRESULT hrResult,
        DWORD dwError,
        LPCWSTR szResult)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec;
typedef IInternetProtocolSinkStackable* LPIINTERNETPROTOCOLSINKStackable;
extern "C" const IID IID_IInternetProtocolSinkStackable;
struct __declspec(uuid("79eac9f0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetProtocolSinkStackable : public IUnknown {
public:
    virtual HRESULT __stdcall SwitchSink(
        IInternetProtocolSink* pOIProtSink)
        = 0;
    virtual HRESULT __stdcall CommitSwitch(void) = 0;
    virtual HRESULT __stdcall RollbackSwitch(void) = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec;
typedef IInternetSession* LPIINTERNETSESSION;
typedef enum _tagOIBDG_FLAGS {
    OIBDG_APARTMENTTHREADED = 0x100,
    OIBDG_DATAONLY = 0x1000
} OIBDG_FLAGS;
extern "C" const IID IID_IInternetSession;
struct __declspec(uuid("79eac9e7-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetSession : public IUnknown {
public:
    virtual HRESULT __stdcall RegisterNameSpace(
        IClassFactory* pCF,
        const IID& rclsid,
        LPCWSTR pwzProtocol,
        ULONG cPatterns,
        const LPCWSTR* ppwzPatterns,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall UnregisterNameSpace(
        IClassFactory* pCF,
        LPCWSTR pszProtocol)
        = 0;
    virtual HRESULT __stdcall RegisterMimeFilter(
        IClassFactory* pCF,
        const IID& rclsid,
        LPCWSTR pwzType)
        = 0;
    virtual HRESULT __stdcall UnregisterMimeFilter(
        IClassFactory* pCF,
        LPCWSTR pwzType)
        = 0;
    virtual HRESULT __stdcall CreateBinding(
        LPBC pBC,
        LPCWSTR szUrl,
        IUnknown* pUnkOuter,
        IUnknown** ppUnk,
        IInternetProtocol** ppOInetProt,
        DWORD dwOption)
        = 0;
    virtual HRESULT __stdcall SetSessionOption(
        DWORD dwOption,
        LPVOID pBuffer,
        DWORD dwBufferLength,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall GetSessionOption(
        DWORD dwOption,
        LPVOID pBuffer,
        DWORD* pdwBufferLength,
        DWORD dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec;
typedef IInternetThreadSwitch* LPIINTERNETTHREADSWITCH;
extern "C" const IID IID_IInternetThreadSwitch;
struct __declspec(uuid("79eac9e8-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetThreadSwitch : public IUnknown {
public:
    virtual HRESULT __stdcall Prepare(void) = 0;
    virtual HRESULT __stdcall Continue(void) = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec;
typedef IInternetPriority* LPIINTERNETPRIORITY;
extern "C" const IID IID_IInternetPriority;
struct __declspec(uuid("79eac9eb-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetPriority : public IUnknown {
public:
    virtual HRESULT __stdcall SetPriority(
        LONG nPriority)
        = 0;
    virtual HRESULT __stdcall GetPriority(
        LONG* pnPriority)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec;
typedef IInternetProtocolInfo* LPIINTERNETPROTOCOLINFO;
typedef enum _tagPARSEACTION {
    PARSE_CANONICALIZE = 1,
    PARSE_FRIENDLY = (PARSE_CANONICALIZE + 1),
    PARSE_SECURITY_URL = (PARSE_FRIENDLY + 1),
    PARSE_ROOTDOCUMENT = (PARSE_SECURITY_URL + 1),
    PARSE_DOCUMENT = (PARSE_ROOTDOCUMENT + 1),
    PARSE_ANCHOR = (PARSE_DOCUMENT + 1),
    PARSE_ENCODE_IS_UNESCAPE = (PARSE_ANCHOR + 1),
    PARSE_DECODE_IS_ESCAPE = (PARSE_ENCODE_IS_UNESCAPE + 1),
    PARSE_PATH_FROM_URL = (PARSE_DECODE_IS_ESCAPE + 1),
    PARSE_URL_FROM_PATH = (PARSE_PATH_FROM_URL + 1),
    PARSE_MIME = (PARSE_URL_FROM_PATH + 1),
    PARSE_SERVER = (PARSE_MIME + 1),
    PARSE_SCHEMA = (PARSE_SERVER + 1),
    PARSE_SITE = (PARSE_SCHEMA + 1),
    PARSE_DOMAIN = (PARSE_SITE + 1),
    PARSE_LOCATION = (PARSE_DOMAIN + 1),
    PARSE_SECURITY_DOMAIN = (PARSE_LOCATION + 1),
    PARSE_ESCAPE = (PARSE_SECURITY_DOMAIN + 1),
    PARSE_UNESCAPE = (PARSE_ESCAPE + 1)
} PARSEACTION;
typedef enum _tagPSUACTION {
    PSU_DEFAULT = 1,
    PSU_SECURITY_URL_ONLY = (PSU_DEFAULT + 1)
} PSUACTION;
typedef enum _tagQUERYOPTION {
    QUERY_EXPIRATION_DATE = 1,
    QUERY_TIME_OF_LAST_CHANGE = (QUERY_EXPIRATION_DATE + 1),
    QUERY_CONTENT_ENCODING = (QUERY_TIME_OF_LAST_CHANGE + 1),
    QUERY_CONTENT_TYPE = (QUERY_CONTENT_ENCODING + 1),
    QUERY_REFRESH = (QUERY_CONTENT_TYPE + 1),
    QUERY_RECOMBINE = (QUERY_REFRESH + 1),
    QUERY_CAN_NAVIGATE = (QUERY_RECOMBINE + 1),
    QUERY_USES_NETWORK = (QUERY_CAN_NAVIGATE + 1),
    QUERY_IS_CACHED = (QUERY_USES_NETWORK + 1),
    QUERY_IS_INSTALLEDENTRY = (QUERY_IS_CACHED + 1),
    QUERY_IS_CACHED_OR_MAPPED = (QUERY_IS_INSTALLEDENTRY + 1),
    QUERY_USES_CACHE = (QUERY_IS_CACHED_OR_MAPPED + 1),
    QUERY_IS_SECURE = (QUERY_USES_CACHE + 1),
    QUERY_IS_SAFE = (QUERY_IS_SECURE + 1),
    QUERY_USES_HISTORYFOLDER = (QUERY_IS_SAFE + 1),
    QUERY_IS_CACHED_AND_USABLE_OFFLINE = (QUERY_USES_HISTORYFOLDER + 1)
} QUERYOPTION;
extern "C" const IID IID_IInternetProtocolInfo;
struct __declspec(uuid("79eac9ec-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetProtocolInfo : public IUnknown {
public:
    virtual HRESULT __stdcall ParseUrl(
        LPCWSTR pwzUrl,
        PARSEACTION ParseAction,
        DWORD dwParseFlags,
        LPWSTR pwzResult,
        DWORD cchResult,
        DWORD* pcchResult,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall CombineUrl(
        LPCWSTR pwzBaseUrl,
        LPCWSTR pwzRelativeUrl,
        DWORD dwCombineFlags,
        LPWSTR pwzResult,
        DWORD cchResult,
        DWORD* pcchResult,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall CompareUrl(
        LPCWSTR pwzUrl1,
        LPCWSTR pwzUrl2,
        DWORD dwCompareFlags)
        = 0;
    virtual HRESULT __stdcall QueryInfo(
        LPCWSTR pwzUrl,
        QUERYOPTION OueryOption,
        DWORD dwQueryFlags,
        LPVOID pBuffer,
        DWORD cbBuffer,
        DWORD* pcbBuf,
        DWORD dwReserved)
        = 0;
};
extern "C" HRESULT __stdcall CoInternetParseUrl(
    LPCWSTR pwzUrl,
    PARSEACTION ParseAction,
    DWORD dwFlags,
    LPWSTR pszResult,
    DWORD cchResult,
    DWORD* pcchResult,
    DWORD dwReserved);
extern "C" HRESULT __stdcall CoInternetParseIUri(
    IUri* pIUri,
    PARSEACTION ParseAction,
    DWORD dwFlags,
    LPWSTR pwzResult,
    DWORD cchResult,
    DWORD* pcchResult,
    DWORD_PTR dwReserved);
extern "C" HRESULT __stdcall CoInternetCombineUrl(
    LPCWSTR pwzBaseUrl,
    LPCWSTR pwzRelativeUrl,
    DWORD dwCombineFlags,
    LPWSTR pszResult,
    DWORD cchResult,
    DWORD* pcchResult,
    DWORD dwReserved);
extern "C" HRESULT __stdcall CoInternetCombineUrlEx(
    IUri* pBaseUri,
    LPCWSTR pwzRelativeUrl,
    DWORD dwCombineFlags,
    IUri** ppCombinedUri,
    DWORD_PTR dwReserved);
extern "C" HRESULT __stdcall CoInternetCombineIUri(
    IUri* pBaseUri,
    IUri* pRelativeUri,
    DWORD dwCombineFlags,
    IUri** ppCombinedUri,
    DWORD_PTR dwReserved);
extern "C" HRESULT __stdcall CoInternetCompareUrl(
    LPCWSTR pwzUrl1,
    LPCWSTR pwzUrl2,
    DWORD dwFlags);
extern "C" HRESULT __stdcall CoInternetGetProtocolFlags(
    LPCWSTR pwzUrl,
    DWORD* pdwFlags,
    DWORD dwReserved);
extern "C" HRESULT __stdcall CoInternetQueryInfo(
    LPCWSTR pwzUrl,
    QUERYOPTION QueryOptions,
    DWORD dwQueryFlags,
    LPVOID pvBuffer,
    DWORD cbBuffer,
    DWORD* pcbBuffer,
    DWORD dwReserved);
extern "C" HRESULT __stdcall CoInternetGetSession(
    DWORD dwSessionMode,
    IInternetSession** ppIInternetSession,
    DWORD dwReserved);
extern "C" HRESULT __stdcall CoInternetGetSecurityUrl(
    LPCWSTR pwszUrl,
    LPWSTR* ppwszSecUrl,
    PSUACTION psuAction,
    DWORD dwReserved);
extern "C" HRESULT __stdcall AsyncInstallDistributionUnit(
    LPCWSTR szDistUnit,
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    LPCWSTR szURL,
    IBindCtx* pbc,
    LPVOID pvReserved,
    DWORD flags);
extern "C" HRESULT __stdcall CoInternetGetSecurityUrlEx(
    IUri* pUri,
    IUri** ppSecUri,
    PSUACTION psuAction,
    DWORD_PTR dwReserved);
typedef enum _tagINTERNETFEATURELIST {
    FEATURE_OBJECT_CACHING = 0,
    FEATURE_ZONE_ELEVATION = (FEATURE_OBJECT_CACHING + 1),
    FEATURE_MIME_HANDLING = (FEATURE_ZONE_ELEVATION + 1),
    FEATURE_MIME_SNIFFING = (FEATURE_MIME_HANDLING + 1),
    FEATURE_WINDOW_RESTRICTIONS = (FEATURE_MIME_SNIFFING + 1),
    FEATURE_WEBOC_POPUPMANAGEMENT = (FEATURE_WINDOW_RESTRICTIONS + 1),
    FEATURE_BEHAVIORS = (FEATURE_WEBOC_POPUPMANAGEMENT + 1),
    FEATURE_DISABLE_MK_PROTOCOL = (FEATURE_BEHAVIORS + 1),
    FEATURE_LOCALMACHINE_LOCKDOWN = (FEATURE_DISABLE_MK_PROTOCOL + 1),
    FEATURE_SECURITYBAND = (FEATURE_LOCALMACHINE_LOCKDOWN + 1),
    FEATURE_RESTRICT_ACTIVEXINSTALL = (FEATURE_SECURITYBAND + 1),
    FEATURE_VALIDATE_NAVIGATE_URL = (FEATURE_RESTRICT_ACTIVEXINSTALL + 1),
    FEATURE_RESTRICT_FILEDOWNLOAD = (FEATURE_VALIDATE_NAVIGATE_URL + 1),
    FEATURE_ADDON_MANAGEMENT = (FEATURE_RESTRICT_FILEDOWNLOAD + 1),
    FEATURE_PROTOCOL_LOCKDOWN = (FEATURE_ADDON_MANAGEMENT + 1),
    FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = (FEATURE_PROTOCOL_LOCKDOWN + 1),
    FEATURE_SAFE_BINDTOOBJECT = (FEATURE_HTTP_USERNAME_PASSWORD_DISABLE + 1),
    FEATURE_UNC_SAVEDFILECHECK = (FEATURE_SAFE_BINDTOOBJECT + 1),
    FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = (FEATURE_UNC_SAVEDFILECHECK + 1),
    FEATURE_TABBED_BROWSING = (FEATURE_GET_URL_DOM_FILEPATH_UNENCODED + 1),
    FEATURE_SSLUX = (FEATURE_TABBED_BROWSING + 1),
    FEATURE_DISABLE_NAVIGATION_SOUNDS = (FEATURE_SSLUX + 1),
    FEATURE_DISABLE_LEGACY_COMPRESSION = (FEATURE_DISABLE_NAVIGATION_SOUNDS + 1),
    FEATURE_FORCE_ADDR_AND_STATUS = (FEATURE_DISABLE_LEGACY_COMPRESSION + 1),
    FEATURE_XMLHTTP = (FEATURE_FORCE_ADDR_AND_STATUS + 1),
    FEATURE_DISABLE_TELNET_PROTOCOL = (FEATURE_XMLHTTP + 1),
    FEATURE_FEEDS = (FEATURE_DISABLE_TELNET_PROTOCOL + 1),
    FEATURE_BLOCK_INPUT_PROMPTS = (FEATURE_FEEDS + 1),
    FEATURE_ENTRY_COUNT = (FEATURE_BLOCK_INPUT_PROMPTS + 1)
} INTERNETFEATURELIST;
extern "C" HRESULT __stdcall CoInternetSetFeatureEnabled(
    INTERNETFEATURELIST FeatureEntry,
    DWORD dwFlags,
    BOOL fEnable);
extern "C" HRESULT __stdcall CoInternetIsFeatureEnabled(
    INTERNETFEATURELIST FeatureEntry,
    DWORD dwFlags);
extern "C" HRESULT __stdcall CoInternetIsFeatureEnabledForUrl(
    INTERNETFEATURELIST FeatureEntry,
    DWORD dwFlags,
    LPCWSTR szURL,
    IInternetSecurityManager* pSecMgr);
extern "C" HRESULT __stdcall CoInternetIsFeatureEnabledForIUri(
    INTERNETFEATURELIST FeatureEntry,
    DWORD dwFlags,
    IUri* pIUri,
    IInternetSecurityManagerEx2* pSecMgr);
extern "C" HRESULT __stdcall CoInternetIsFeatureZoneElevationEnabled(
    LPCWSTR szFromURL,
    LPCWSTR szToURL,
    IInternetSecurityManager* pSecMgr,
    DWORD dwFlags);
extern "C" HRESULT __stdcall CopyStgMedium(const STGMEDIUM* pcstgmedSrc,
    STGMEDIUM* pstgmedDest);
extern "C" HRESULT __stdcall CopyBindInfo(const BINDINFO* pcbiSrc,
    BINDINFO* pbiDest);
extern "C" void __stdcall ReleaseBindInfo(BINDINFO* pbindinfo);
extern "C" PWSTR __stdcall IEGetUserPrivateNamespaceName(void);
extern "C" HRESULT __stdcall CoInternetCreateSecurityManager(IServiceProvider* pSP, IInternetSecurityManager** ppSM, DWORD dwReserved);
extern "C" HRESULT __stdcall CoInternetCreateZoneManager(IServiceProvider* pSP, IInternetZoneManager** ppZM, DWORD dwReserved);
extern "C" const IID CLSID_InternetSecurityManager;
extern "C" const IID CLSID_InternetZoneManager;
extern "C" const IID CLSID_PersistentZoneIdentifier;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec;
extern "C" const IID IID_IInternetSecurityMgrSite;
struct __declspec(uuid("79eac9ed-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetSecurityMgrSite : public IUnknown {
public:
    virtual HRESULT __stdcall GetWindow(
        HWND* phwnd)
        = 0;
    virtual HRESULT __stdcall EnableModeless(
        BOOL fEnable)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec;
typedef enum __MIDL_IInternetSecurityManager_0001 {
    PUAF_DEFAULT = 0,
    PUAF_NOUI = 0x1,
    PUAF_ISFILE = 0x2,
    PUAF_WARN_IF_DENIED = 0x4,
    PUAF_FORCEUI_FOREGROUND = 0x8,
    PUAF_CHECK_TIFS = 0x10,
    PUAF_DONTCHECKBOXINDIALOG = 0x20,
    PUAF_TRUSTED = 0x40,
    PUAF_ACCEPT_WILDCARD_SCHEME = 0x80,
    PUAF_ENFORCERESTRICTED = 0x100,
    PUAF_NOSAVEDFILECHECK = 0x200,
    PUAF_REQUIRESAVEDFILECHECK = 0x400,
    PUAF_DONT_USE_CACHE = 0x1000,
    PUAF_RESERVED1 = 0x2000,
    PUAF_RESERVED2 = 0x4000,
    PUAF_LMZ_UNLOCKED = 0x10000,
    PUAF_LMZ_LOCKED = 0x20000,
    PUAF_DEFAULTZONEPOL = 0x40000,
    PUAF_NPL_USE_LOCKED_IF_RESTRICTED = 0x80000,
    PUAF_NOUIIFLOCKED = 0x100000,
    PUAF_DRAGPROTOCOLCHECK = 0x200000
} PUAF;
typedef enum __MIDL_IInternetSecurityManager_0002 {
    PUAFOUT_DEFAULT = 0,
    PUAFOUT_ISLOCKZONEPOLICY = 0x1
} PUAFOUT;
typedef enum __MIDL_IInternetSecurityManager_0003 {
    SZM_CREATE = 0,
    SZM_DELETE = 0x1
} SZM_FLAGS;
extern "C" const IID IID_IInternetSecurityManager;
struct __declspec(uuid("79eac9ee-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetSecurityManager : public IUnknown {
public:
    virtual HRESULT __stdcall SetSecuritySite(
        IInternetSecurityMgrSite* pSite)
        = 0;
    virtual HRESULT __stdcall GetSecuritySite(
        IInternetSecurityMgrSite** ppSite)
        = 0;
    virtual HRESULT __stdcall MapUrlToZone(
        LPCWSTR pwszUrl,
        DWORD* pdwZone,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetSecurityId(
        LPCWSTR pwszUrl,
        BYTE* pbSecurityId,
        DWORD* pcbSecurityId,
        DWORD_PTR dwReserved)
        = 0;
    virtual HRESULT __stdcall ProcessUrlAction(
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall QueryCustomPolicy(
        LPCWSTR pwszUrl,
        const GUID& guidKey,
        BYTE** ppPolicy,
        DWORD* pcbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall SetZoneMapping(
        DWORD dwZone,
        LPCWSTR lpszPattern,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetZoneMappings(
        DWORD dwZone,
        IEnumString** ppenumString,
        DWORD dwFlags)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec;
extern "C" const IID IID_IInternetSecurityManagerEx;
struct __declspec(uuid("F164EDF1-CC7C-4f0d-9A94-34222625C393")) __declspec(novtable)
    IInternetSecurityManagerEx : public IInternetSecurityManager {
public:
    virtual HRESULT __stdcall ProcessUrlActionEx(
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved,
        DWORD* pdwOutFlags)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec;
extern "C" const IID IID_IInternetSecurityManagerEx2;
struct __declspec(uuid("F1E50292-A795-4117-8E09-2B560A72AC60")) __declspec(novtable)
    IInternetSecurityManagerEx2 : public IInternetSecurityManagerEx {
public:
    virtual HRESULT __stdcall MapUrlToZoneEx2(
        IUri* pUri,
        DWORD* pdwZone,
        DWORD dwFlags,
        LPWSTR* ppwszMappedUrl,
        DWORD* pdwOutFlags)
        = 0;
    virtual HRESULT __stdcall ProcessUrlActionEx2(
        IUri* pUri,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD_PTR dwReserved,
        DWORD* pdwOutFlags)
        = 0;
    virtual HRESULT __stdcall GetSecurityIdEx2(
        IUri* pUri,
        BYTE* pbSecurityId,
        DWORD* pcbSecurityId,
        DWORD_PTR dwReserved)
        = 0;
    virtual HRESULT __stdcall QueryCustomPolicyEx2(
        IUri* pUri,
        const GUID& guidKey,
        BYTE** ppPolicy,
        DWORD* pcbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD_PTR dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec;
extern "C" const IID IID_IZoneIdentifier;
struct __declspec(uuid("cd45f185-1b21-48e2-967b-ead743a8914e")) __declspec(novtable)
    IZoneIdentifier : public IUnknown {
public:
    virtual HRESULT __stdcall GetId(
        DWORD* pdwZone)
        = 0;
    virtual HRESULT __stdcall SetId(
        DWORD dwZone)
        = 0;
    virtual HRESULT __stdcall Remove(void) = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec;
extern "C" const IID IID_IZoneIdentifier2;
struct __declspec(uuid("EB5E760C-09EF-45C0-B510-70830CE31E6A")) __declspec(novtable)
    IZoneIdentifier2 : public IZoneIdentifier {
public:
    virtual HRESULT __stdcall GetLastWriterPackageFamilyName(
        LPWSTR* packageFamilyName)
        = 0;
    virtual HRESULT __stdcall SetLastWriterPackageFamilyName(
        LPCWSTR packageFamilyName)
        = 0;
    virtual HRESULT __stdcall RemoveLastWriterPackageFamilyName(void) = 0;
    virtual HRESULT __stdcall GetAppZoneId(
        DWORD* zone)
        = 0;
    virtual HRESULT __stdcall SetAppZoneId(
        DWORD zone)
        = 0;
    virtual HRESULT __stdcall RemoveAppZoneId(void) = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec;
extern "C" const IID IID_IInternetHostSecurityManager;
struct __declspec(uuid("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")) __declspec(novtable)
    IInternetHostSecurityManager : public IUnknown {
public:
    virtual HRESULT __stdcall GetSecurityId(
        BYTE* pbSecurityId,
        DWORD* pcbSecurityId,
        DWORD_PTR dwReserved)
        = 0;
    virtual HRESULT __stdcall ProcessUrlAction(
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall QueryCustomPolicy(
        const GUID& guidKey,
        BYTE** ppPolicy,
        DWORD* pcbPolicy,
        BYTE* pContext,
        DWORD cbContext,
        DWORD dwReserved)
        = 0;
};
extern "C" const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec;
typedef IInternetZoneManager* LPURLZONEMANAGER;
typedef enum tagURLZONE {
    URLZONE_INVALID = -1,
    URLZONE_PREDEFINED_MIN = 0,
    URLZONE_LOCAL_MACHINE = 0,
    URLZONE_INTRANET = (URLZONE_LOCAL_MACHINE + 1),
    URLZONE_TRUSTED = (URLZONE_INTRANET + 1),
    URLZONE_INTERNET = (URLZONE_TRUSTED + 1),
    URLZONE_UNTRUSTED = (URLZONE_INTERNET + 1),
    URLZONE_PREDEFINED_MAX = 999,
    URLZONE_USER_MIN = 1000,
    URLZONE_USER_MAX = 10000
} URLZONE;
typedef enum tagURLTEMPLATE {
    URLTEMPLATE_CUSTOM = 0,
    URLTEMPLATE_PREDEFINED_MIN = 0x10000,
    URLTEMPLATE_LOW = 0x10000,
    URLTEMPLATE_MEDLOW = 0x10500,
    URLTEMPLATE_MEDIUM = 0x11000,
    URLTEMPLATE_MEDHIGH = 0x11500,
    URLTEMPLATE_HIGH = 0x12000,
    URLTEMPLATE_PREDEFINED_MAX = 0x20000
} URLTEMPLATE;
enum __MIDL_IInternetZoneManager_0001 {
    MAX_ZONE_PATH = 260,
    MAX_ZONE_DESCRIPTION = 200
};
typedef enum __MIDL_IInternetZoneManager_0002 {
    ZAFLAGS_CUSTOM_EDIT = 0x1,
    ZAFLAGS_ADD_SITES = 0x2,
    ZAFLAGS_REQUIRE_VERIFICATION = 0x4,
    ZAFLAGS_INCLUDE_PROXY_OVERRIDE = 0x8,
    ZAFLAGS_INCLUDE_INTRANET_SITES = 0x10,
    ZAFLAGS_NO_UI = 0x20,
    ZAFLAGS_SUPPORTS_VERIFICATION = 0x40,
    ZAFLAGS_UNC_AS_INTRANET = 0x80,
    ZAFLAGS_DETECT_INTRANET = 0x100,
    ZAFLAGS_USE_LOCKED_ZONES = 0x10000,
    ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = 0x20000,
    ZAFLAGS_NO_CACHE = 0x40000
} ZAFLAGS;
typedef struct _ZONEATTRIBUTES {
    ULONG cbSize;
    WCHAR szDisplayName[260];
    WCHAR szDescription[200];
    WCHAR szIconPath[260];
    DWORD dwTemplateMinLevel;
    DWORD dwTemplateRecommended;
    DWORD dwTemplateCurrentLevel;
    DWORD dwFlags;
} ZONEATTRIBUTES;
typedef struct _ZONEATTRIBUTES* LPZONEATTRIBUTES;
typedef enum _URLZONEREG {
    URLZONEREG_DEFAULT = 0,
    URLZONEREG_HKLM = (URLZONEREG_DEFAULT + 1),
    URLZONEREG_HKCU = (URLZONEREG_HKLM + 1)
} URLZONEREG;
extern "C" const IID IID_IInternetZoneManager;
struct __declspec(uuid("79eac9ef-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable)
    IInternetZoneManager : public IUnknown {
public:
    virtual HRESULT __stdcall GetZoneAttributes(
        DWORD dwZone,
        ZONEATTRIBUTES* pZoneAttributes)
        = 0;
    virtual HRESULT __stdcall SetZoneAttributes(
        DWORD dwZone,
        ZONEATTRIBUTES* pZoneAttributes)
        = 0;
    virtual HRESULT __stdcall GetZoneCustomPolicy(
        DWORD dwZone,
        const GUID& guidKey,
        BYTE** ppPolicy,
        DWORD* pcbPolicy,
        URLZONEREG urlZoneReg)
        = 0;
    virtual HRESULT __stdcall SetZoneCustomPolicy(
        DWORD dwZone,
        const GUID& guidKey,
        BYTE* pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg)
        = 0;
    virtual HRESULT __stdcall GetZoneActionPolicy(
        DWORD dwZone,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg)
        = 0;
    virtual HRESULT __stdcall SetZoneActionPolicy(
        DWORD dwZone,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg)
        = 0;
    virtual HRESULT __stdcall PromptAction(
        DWORD dwAction,
        HWND hwndParent,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwPromptFlags)
        = 0;
    virtual HRESULT __stdcall LogAction(
        DWORD dwAction,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwLogFlags)
        = 0;
    virtual HRESULT __stdcall CreateZoneEnumerator(
        DWORD* pdwEnum,
        DWORD* pdwCount,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetZoneAt(
        DWORD dwEnum,
        DWORD dwIndex,
        DWORD* pdwZone)
        = 0;
    virtual HRESULT __stdcall DestroyZoneEnumerator(
        DWORD dwEnum)
        = 0;
    virtual HRESULT __stdcall CopyTemplatePoliciesToZone(
        DWORD dwTemplate,
        DWORD dwZone,
        DWORD dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec;
extern "C" const IID IID_IInternetZoneManagerEx;
struct __declspec(uuid("A4C23339-8E06-431e-9BF4-7E711C085648")) __declspec(novtable)
    IInternetZoneManagerEx : public IInternetZoneManager {
public:
    virtual HRESULT __stdcall GetZoneActionPolicyEx(
        DWORD dwZone,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall SetZoneActionPolicyEx(
        DWORD dwZone,
        DWORD dwAction,
        BYTE* pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec;
extern "C" const IID IID_IInternetZoneManagerEx2;
struct __declspec(uuid("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")) __declspec(novtable)
    IInternetZoneManagerEx2 : public IInternetZoneManagerEx {
public:
    virtual HRESULT __stdcall GetZoneAttributesEx(
        DWORD dwZone,
        ZONEATTRIBUTES* pZoneAttributes,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetZoneSecurityState(
        DWORD dwZoneIndex,
        BOOL fRespectPolicy,
        LPDWORD pdwState,
        BOOL* pfPolicyEncountered)
        = 0;
    virtual HRESULT __stdcall GetIESecurityState(
        BOOL fRespectPolicy,
        LPDWORD pdwState,
        BOOL* pfPolicyEncountered,
        BOOL fNoCache)
        = 0;
    virtual HRESULT __stdcall FixUnsecureSettings(void) = 0;
};
extern "C" const IID CLSID_SoftDistExt;
typedef struct _tagCODEBASEHOLD {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
} CODEBASEHOLD;
typedef struct _tagCODEBASEHOLD* LPCODEBASEHOLD;
typedef struct _tagSOFTDISTINFO {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
} SOFTDISTINFO;
typedef struct _tagSOFTDISTINFO* LPSOFTDISTINFO;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec;
extern "C" const IID IID_ISoftDistExt;
struct __declspec(uuid("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")) __declspec(novtable)
    ISoftDistExt : public IUnknown {
public:
    virtual HRESULT __stdcall ProcessSoftDist(
        LPCWSTR szCDFURL,
        IXMLElement* pSoftDistElement,
        LPSOFTDISTINFO lpsdi)
        = 0;
    virtual HRESULT __stdcall GetFirstCodeBase(
        LPWSTR* szCodeBase,
        LPDWORD dwMaxSize)
        = 0;
    virtual HRESULT __stdcall GetNextCodeBase(
        LPWSTR* szCodeBase,
        LPDWORD dwMaxSize)
        = 0;
    virtual HRESULT __stdcall AsyncInstallDistributionUnit(
        IBindCtx* pbc,
        LPVOID pvReserved,
        DWORD flags,
        LPCODEBASEHOLD lpcbh)
        = 0;
};
extern "C" HRESULT __stdcall GetSoftwareUpdateInfo(LPCWSTR szDistUnit, LPSOFTDISTINFO psdi);
extern "C" HRESULT __stdcall SetSoftwareUpdateAdvertisementState(LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS);
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec;
typedef ICatalogFileInfo* LPCATALOGFILEINFO;
extern "C" const IID IID_ICatalogFileInfo;
struct __declspec(uuid("711C7600-6B48-11d1-B403-00AA00B92AF1")) __declspec(novtable)
    ICatalogFileInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetCatalogFile(
        LPSTR* ppszCatalogFile)
        = 0;
    virtual HRESULT __stdcall GetJavaTrust(
        void** ppJavaTrust)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_s_ifspec;
typedef IDataFilter* LPDATAFILTER;
extern "C" const IID IID_IDataFilter;
struct __declspec(uuid("69d14c80-c18e-11d0-a9ce-006097942311")) __declspec(novtable)
    IDataFilter : public IUnknown {
public:
    virtual HRESULT __stdcall DoEncode(
        DWORD dwFlags,
        LONG lInBufferSize,
        BYTE* pbInBuffer,
        LONG lOutBufferSize,
        BYTE* pbOutBuffer,
        LONG lInBytesAvailable,
        LONG* plInBytesRead,
        LONG* plOutBytesWritten,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall DoDecode(
        DWORD dwFlags,
        LONG lInBufferSize,
        BYTE* pbInBuffer,
        LONG lOutBufferSize,
        BYTE* pbOutBuffer,
        LONG lInBytesAvailable,
        LONG* plInBytesRead,
        LONG* plOutBytesWritten,
        DWORD dwReserved)
        = 0;
    virtual HRESULT __stdcall SetEncodingLevel(
        DWORD dwEncLevel)
        = 0;
};
typedef struct _tagPROTOCOLFILTERDATA {
    DWORD cbSize;
    IInternetProtocolSink* pProtocolSink;
    IInternetProtocol* pProtocol;
    IUnknown* pUnk;
    DWORD dwFilterFlags;
} PROTOCOLFILTERDATA;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_s_ifspec;
typedef IEncodingFilterFactory* LPENCODINGFILTERFACTORY;
typedef struct _tagDATAINFO {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
} DATAINFO;
extern "C" const IID IID_IEncodingFilterFactory;
struct __declspec(uuid("70bdde00-c18e-11d0-a9ce-006097942311")) __declspec(novtable)
    IEncodingFilterFactory : public IUnknown {
public:
    virtual HRESULT __stdcall FindBestFilter(
        LPCWSTR pwzCodeIn,
        LPCWSTR pwzCodeOut,
        DATAINFO info,
        IDataFilter** ppDF)
        = 0;
    virtual HRESULT __stdcall GetDefaultFilter(
        LPCWSTR pwzCodeIn,
        LPCWSTR pwzCodeOut,
        IDataFilter** ppDF)
        = 0;
};
BOOL __stdcall IsLoggingEnabledA(LPCSTR pszUrl);
BOOL __stdcall IsLoggingEnabledW(LPCWSTR pwszUrl);
typedef struct _tagHIT_LOGGING_INFO {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
} HIT_LOGGING_INFO;
typedef struct _tagHIT_LOGGING_INFO* LPHIT_LOGGING_INFO;
BOOL __stdcall WriteHitLogging(LPHIT_LOGGING_INFO lpLogginginfo);
struct CONFIRMSAFETY {
    CLSID clsid;
    IUnknown* pUnk;
    DWORD dwFlags;
};
extern "C" const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0051_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0051_v0_0_s_ifspec;
typedef IWrappedProtocol* LPIWRAPPEDPROTOCOL;
extern "C" const IID IID_IWrappedProtocol;
struct __declspec(uuid("53c84785-8425-4dc5-971b-e58d9c19f9b6")) __declspec(novtable)
    IWrappedProtocol : public IUnknown {
public:
    virtual HRESULT __stdcall GetWrapperCode(
        LONG* pnCode,
        DWORD_PTR dwReserved)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0052_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0052_v0_0_s_ifspec;
typedef IGetBindHandle* LPGETBINDHANDLE;
typedef enum __MIDL_IGetBindHandle_0001 {
    BINDHANDLETYPES_APPCACHE = 0,
    BINDHANDLETYPES_DEPENDENCY = 0x1,
    BINDHANDLETYPES_COUNT = (BINDHANDLETYPES_DEPENDENCY + 1)
} BINDHANDLETYPES;
extern "C" const IID IID_IGetBindHandle;
struct __declspec(uuid("AF0FF408-129D-4b20-91F0-02BD23D88352")) __declspec(novtable)
    IGetBindHandle : public IUnknown {
public:
    virtual HRESULT __stdcall GetBindHandle(
        BINDHANDLETYPES enumRequestedHandle,
        HANDLE* pRetHandle)
        = 0;
};
typedef struct _tagPROTOCOL_ARGUMENT {
    LPCWSTR szMethod;
    LPCWSTR szTargetUrl;
} PROTOCOL_ARGUMENT;
typedef struct _tagPROTOCOL_ARGUMENT* LPPROTOCOL_ARGUMENT;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0053_v0_0_s_ifspec;
typedef IBindCallbackRedirect* LPBINDCALLBACKREDIRECT;
extern "C" const IID IID_IBindCallbackRedirect;
struct __declspec(uuid("11C81BC2-121E-4ed5-B9C4-B430BD54F2C0")) __declspec(novtable)
    IBindCallbackRedirect : public IUnknown {
public:
    virtual HRESULT __stdcall Redirect(
        LPCWSTR lpcUrl,
        VARIANT_BOOL* vbCancel)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0054_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0054_v0_0_s_ifspec;
extern "C" const IID IID_IBindHttpSecurity;
struct __declspec(uuid("a9eda967-f50e-4a33-b358-206f6ef3086d")) __declspec(novtable)
    IBindHttpSecurity : public IUnknown {
public:
    virtual HRESULT __stdcall GetIgnoreCertMask(
        DWORD* pdwIgnoreCertMask)
        = 0;
};
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0055_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0055_v0_0_s_ifspec;
unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree(unsigned long*, BSTR*);
unsigned long __stdcall HWND_UserSize(unsigned long*, unsigned long, HWND*);
unsigned char* __stdcall HWND_UserMarshal(unsigned long*, unsigned char*, HWND*);
unsigned char* __stdcall HWND_UserUnmarshal(unsigned long*, unsigned char*, HWND*);
void __stdcall HWND_UserFree(unsigned long*, HWND*);
unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);
unsigned long __stdcall HWND_UserSize64(unsigned long*, unsigned long, HWND*);
unsigned char* __stdcall HWND_UserMarshal64(unsigned long*, unsigned char*, HWND*);
unsigned char* __stdcall HWND_UserUnmarshal64(unsigned long*, unsigned char*, HWND*);
void __stdcall HWND_UserFree64(unsigned long*, HWND*);
HRESULT __stdcall IBinding_GetBindResult_Proxy(
    IBinding* This,
    CLSID* pclsidProtocol,
    DWORD* pdwResult,
    LPOLESTR* pszResult,
    DWORD* pdwReserved);
HRESULT __stdcall IBinding_GetBindResult_Stub(
    IBinding* This,
    CLSID* pclsidProtocol,
    DWORD* pdwResult,
    LPOLESTR* pszResult,
    DWORD dwReserved);
HRESULT __stdcall IBindStatusCallback_GetBindInfo_Proxy(
    IBindStatusCallback* This,
    DWORD* grfBINDF,
    BINDINFO* pbindinfo);
HRESULT __stdcall IBindStatusCallback_GetBindInfo_Stub(
    IBindStatusCallback* This,
    DWORD* grfBINDF,
    RemBINDINFO* pbindinfo,
    RemSTGMEDIUM* pstgmed);
HRESULT __stdcall IBindStatusCallback_OnDataAvailable_Proxy(
    IBindStatusCallback* This,
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pformatetc,
    STGMEDIUM* pstgmed);
HRESULT __stdcall IBindStatusCallback_OnDataAvailable_Stub(
    IBindStatusCallback* This,
    DWORD grfBSCF,
    DWORD dwSize,
    RemFORMATETC* pformatetc,
    RemSTGMEDIUM* pstgmed);
HRESULT __stdcall IBindStatusCallbackEx_GetBindInfoEx_Proxy(
    IBindStatusCallbackEx* This,
    DWORD* grfBINDF,
    BINDINFO* pbindinfo,
    DWORD* grfBINDF2,
    DWORD* pdwReserved);
HRESULT __stdcall IBindStatusCallbackEx_GetBindInfoEx_Stub(
    IBindStatusCallbackEx* This,
    DWORD* grfBINDF,
    RemBINDINFO* pbindinfo,
    RemSTGMEDIUM* pstgmed,
    DWORD* grfBINDF2,
    DWORD* pdwReserved);
HRESULT __stdcall IWinInetInfo_QueryOption_Proxy(
    IWinInetInfo* This,
    DWORD dwOption,
    LPVOID pBuffer,
    DWORD* pcbBuf);
HRESULT __stdcall IWinInetInfo_QueryOption_Stub(
    IWinInetInfo* This,
    DWORD dwOption,
    BYTE* pBuffer,
    DWORD* pcbBuf);
HRESULT __stdcall IWinInetHttpInfo_QueryInfo_Proxy(
    IWinInetHttpInfo* This,
    DWORD dwOption,
    LPVOID pBuffer,
    DWORD* pcbBuf,
    DWORD* pdwFlags,
    DWORD* pdwReserved);
HRESULT __stdcall IWinInetHttpInfo_QueryInfo_Stub(
    IWinInetHttpInfo* This,
    DWORD dwOption,
    BYTE* pBuffer,
    DWORD* pcbBuf,
    DWORD* pdwFlags,
    DWORD* pdwReserved);
HRESULT __stdcall IBindHost_MonikerBindToStorage_Proxy(
    IBindHost* This,
    IMoniker* pMk,
    IBindCtx* pBC,
    IBindStatusCallback* pBSC,
    const IID& riid,
    void** ppvObj);
HRESULT __stdcall IBindHost_MonikerBindToStorage_Stub(
    IBindHost* This,
    IMoniker* pMk,
    IBindCtx* pBC,
    IBindStatusCallback* pBSC,
    const IID& riid,
    IUnknown** ppvObj);
HRESULT __stdcall IBindHost_MonikerBindToObject_Proxy(
    IBindHost* This,
    IMoniker* pMk,
    IBindCtx* pBC,
    IBindStatusCallback* pBSC,
    const IID& riid,
    void** ppvObj);
HRESULT __stdcall IBindHost_MonikerBindToObject_Stub(
    IBindHost* This,
    IMoniker* pMk,
    IBindCtx* pBC,
    IBindStatusCallback* pBSC,
    const IID& riid,
    IUnknown** ppvObj);
}
#pragma once
extern "C" {
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma warning(disable : 4237)
#pragma once
#pragma region Desktop Family or OneCore Family
enum PIDMSI_STATUS_VALUE {
    PIDMSI_STATUS_NORMAL = 0,
    PIDMSI_STATUS_NEW = (PIDMSI_STATUS_NORMAL + 1),
    PIDMSI_STATUS_PRELIM = (PIDMSI_STATUS_NEW + 1),
    PIDMSI_STATUS_DRAFT = (PIDMSI_STATUS_PRELIM + 1),
    PIDMSI_STATUS_INPROGRESS = (PIDMSI_STATUS_DRAFT + 1),
    PIDMSI_STATUS_EDIT = (PIDMSI_STATUS_INPROGRESS + 1),
    PIDMSI_STATUS_REVIEW = (PIDMSI_STATUS_EDIT + 1),
    PIDMSI_STATUS_PROOF = (PIDMSI_STATUS_REVIEW + 1),
    PIDMSI_STATUS_FINAL = (PIDMSI_STATUS_PROOF + 1),
    PIDMSI_STATUS_OTHER = 0x7fff
};
#pragma endregion
#pragma region Application Family or OneCore or Games Family
extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantCopy(
    PROPVARIANT* pvarDest,
    const PROPVARIANT* pvarSrc);
extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantClear(PROPVARIANT* pvar);
extern "C" __declspec(dllimport) HRESULT __stdcall FreePropVariantArray(
    ULONG cVariants,
    PROPVARIANT* rgvars);
inline void PropVariantInit(PROPVARIANT* pvar)
{
    memset(pvar, 0, sizeof(PROPVARIANT));
}
#pragma endregion
#pragma region Desktop Family
typedef struct tagSERIALIZEDPROPERTYVALUE {
    DWORD dwType;
    BYTE rgb[1];
} SERIALIZEDPROPERTYVALUE;
extern "C" SERIALIZEDPROPERTYVALUE* __stdcall StgConvertVariantToProperty(
    const PROPVARIANT* pvar,
    USHORT CodePage,
    SERIALIZEDPROPERTYVALUE* pprop,
    ULONG* pcb,
    PROPID pid,
    BOOLEAN fReserved,
    ULONG* pcIndirect);
class PMemoryAllocator;
extern "C" BOOLEAN __stdcall StgConvertPropertyToVariant(
    const SERIALIZEDPROPERTYVALUE* pprop,
    USHORT CodePage,
    PROPVARIANT* pvar,
    PMemoryAllocator* pma);
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_s_ifspec;
unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree(unsigned long*, BSTR*);
unsigned long __stdcall LPSAFEARRAY_UserSize(unsigned long*, unsigned long, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserMarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
void __stdcall LPSAFEARRAY_UserFree(unsigned long*, LPSAFEARRAY*);
unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);
unsigned long __stdcall LPSAFEARRAY_UserSize64(unsigned long*, unsigned long, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserMarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
void __stdcall LPSAFEARRAY_UserFree64(unsigned long*, LPSAFEARRAY*);
HRESULT __stdcall IEnumSTATPROPSTG_Next_Proxy(
    IEnumSTATPROPSTG* This,
    ULONG celt,
    STATPROPSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATPROPSTG_Next_Stub(
    IEnumSTATPROPSTG* This,
    ULONG celt,
    STATPROPSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Proxy(
    IEnumSTATPROPSETSTG* This,
    ULONG celt,
    STATPROPSETSTG* rgelt,
    ULONG* pceltFetched);
HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Stub(
    IEnumSTATPROPSETSTG* This,
    ULONG celt,
    STATPROPSETSTG* rgelt,
    ULONG* pceltFetched);
}
#pragma region Desktop Partition
extern "C" __declspec(dllimport) HRESULT __stdcall CreateStdProgressIndicator(HWND hwndParent,
    LPCOLESTR pszTitle,
    IBindStatusCallback* pIbscCaller,
    IBindStatusCallback** ppIbsc);
#pragma endregion
#pragma warning(disable : 4103)
#pragma pack(pop)
extern "C" const GUID IID_IDirect3D9;
extern "C" const GUID IID_IDirect3DDevice9;
extern "C" const GUID IID_IDirect3DResource9;
extern "C" const GUID IID_IDirect3DBaseTexture9;
extern "C" const GUID IID_IDirect3DTexture9;
extern "C" const GUID IID_IDirect3DCubeTexture9;
extern "C" const GUID IID_IDirect3DVolumeTexture9;
extern "C" const GUID IID_IDirect3DVertexBuffer9;
extern "C" const GUID IID_IDirect3DIndexBuffer9;
extern "C" const GUID IID_IDirect3DSurface9;
extern "C" const GUID IID_IDirect3DVolume9;
extern "C" const GUID IID_IDirect3DSwapChain9;
extern "C" const GUID IID_IDirect3DVertexDeclaration9;
extern "C" const GUID IID_IDirect3DVertexShader9;
extern "C" const GUID IID_IDirect3DPixelShader9;
extern "C" const GUID IID_IDirect3DStateBlock9;
extern "C" const GUID IID_IDirect3DQuery9;
extern "C" const GUID IID_HelperName;
extern "C" const GUID IID_IDirect3D9Ex;
extern "C" const GUID IID_IDirect3DDevice9Ex;
extern "C" const GUID IID_IDirect3DSwapChain9Ex;
extern "C" const GUID IID_IDirect3D9ExOverlayExtension;
extern "C" const GUID IID_IDirect3DDevice9Video;
extern "C" const GUID IID_IDirect3DAuthenticatedChannel9;
extern "C" const GUID IID_IDirect3DCryptoSession9;
struct __declspec(uuid("81BDCBCA-64D4-426d-AE8D-AD0147F4275C")) IDirect3D9;
struct __declspec(uuid("D0223B96-BF7A-43fd-92BD-A43B0D82B9EB")) IDirect3DDevice9;
struct __declspec(uuid("B07C4FE5-310D-4ba8-A23C-4F0F206F218B")) IDirect3DStateBlock9;
struct __declspec(uuid("05EEC05D-8F7D-4362-B999-D1BAF357C704")) IDirect3DResource9;
struct __declspec(uuid("DD13C59C-36FA-4098-A8FB-C7ED39DC8546")) IDirect3DVertexDeclaration9;
struct __declspec(uuid("EFC5557E-6265-4613-8A94-43857889EB36")) IDirect3DVertexShader9;
struct __declspec(uuid("6D3BDBDC-5B02-4415-B852-CE5E8BCCB289")) IDirect3DPixelShader9;
struct __declspec(uuid("580CA87E-1D3C-4d54-991D-B7D3E3C298CE")) IDirect3DBaseTexture9;
struct __declspec(uuid("85C31227-3DE5-4f00-9B3A-F11AC38C18B5")) IDirect3DTexture9;
struct __declspec(uuid("2518526C-E789-4111-A7B9-47EF328D13E6")) IDirect3DVolumeTexture9;
struct __declspec(uuid("FFF32F81-D953-473a-9223-93D652ABA93F")) IDirect3DCubeTexture9;
struct __declspec(uuid("B64BB1B5-FD70-4df6-BF91-19D0A12455E3")) IDirect3DVertexBuffer9;
struct __declspec(uuid("7C9DD65E-D3F7-4529-ACEE-785830ACDE35")) IDirect3DIndexBuffer9;
struct __declspec(uuid("0CFBAF3A-9FF6-429a-99B3-A2796AF8B89B")) IDirect3DSurface9;
struct __declspec(uuid("24F416E6-1F67-4aa7-B88E-D33F6F3128A1")) IDirect3DVolume9;
struct __declspec(uuid("794950F2-ADFC-458a-905E-10A10B0B503B")) IDirect3DSwapChain9;
struct __declspec(uuid("d9771460-a695-4f26-bbd3-27b840b541cc")) IDirect3DQuery9;
struct __declspec(uuid("02177241-69FC-400C-8FF1-93A44DF6861D")) IDirect3D9Ex;
struct __declspec(uuid("B18B10CE-2649-405a-870F-95F777D4313A")) IDirect3DDevice9Ex;
struct __declspec(uuid("91886CAF-1C3D-4d2e-A0AB-3E4C7D8D3303")) IDirect3DSwapChain9Ex;
struct __declspec(uuid("187AEB13-AAF5-4C59-876D-E059088C0DF8")) IDirect3D9ExOverlayExtension;
struct __declspec(uuid("26DC4561-A1EE-4ae7-96DA-118A36C0EC95")) IDirect3DDevice9Video;
struct __declspec(uuid("FF24BEEE-DA21-4beb-98B5-D2F899F98AF9")) IDirect3DAuthenticatedChannel9;
struct __declspec(uuid("FA0AB799-7A9C-48CA-8C5B-237E71A54434")) IDirect3DCryptoSession9;
typedef struct IDirect3D9 IDirect3D9;
typedef struct IDirect3DDevice9 IDirect3DDevice9;
typedef struct IDirect3DStateBlock9 IDirect3DStateBlock9;
typedef struct IDirect3DVertexDeclaration9 IDirect3DVertexDeclaration9;
typedef struct IDirect3DVertexShader9 IDirect3DVertexShader9;
typedef struct IDirect3DPixelShader9 IDirect3DPixelShader9;
typedef struct IDirect3DResource9 IDirect3DResource9;
typedef struct IDirect3DBaseTexture9 IDirect3DBaseTexture9;
typedef struct IDirect3DTexture9 IDirect3DTexture9;
typedef struct IDirect3DVolumeTexture9 IDirect3DVolumeTexture9;
typedef struct IDirect3DCubeTexture9 IDirect3DCubeTexture9;
typedef struct IDirect3DVertexBuffer9 IDirect3DVertexBuffer9;
typedef struct IDirect3DIndexBuffer9 IDirect3DIndexBuffer9;
typedef struct IDirect3DSurface9 IDirect3DSurface9;
typedef struct IDirect3DVolume9 IDirect3DVolume9;
typedef struct IDirect3DSwapChain9 IDirect3DSwapChain9;
typedef struct IDirect3DQuery9 IDirect3DQuery9;
typedef struct IDirect3D9Ex IDirect3D9Ex;
typedef struct IDirect3DDevice9Ex IDirect3DDevice9Ex;
typedef struct IDirect3DSwapChain9Ex IDirect3DSwapChain9Ex;
typedef struct IDirect3D9ExOverlayExtension IDirect3D9ExOverlayExtension;
typedef struct IDirect3DDevice9Video IDirect3DDevice9Video;
typedef struct IDirect3DAuthenticatedChannel9 IDirect3DAuthenticatedChannel9;
typedef struct IDirect3DCryptoSession9 IDirect3DCryptoSession9;
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable : 4141)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_controlfp_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp(unsigned int _NewValue,
        unsigned int _Mask);
#pragma warning(pop)
    __declspec(dllimport) void __cdecl _set_controlfp(
        unsigned int _NewValue,
        unsigned int _Mask);
    __declspec(dllimport) errno_t __cdecl _controlfp_s(
        unsigned int* _CurrentState,
        unsigned int _NewValue,
        unsigned int _Mask);
    __declspec(dllimport) unsigned int __cdecl _statusfp(void);
    __declspec(dllimport) void __cdecl _fpreset(void);
    __declspec(dllimport) unsigned int __cdecl _control87(
        unsigned int _NewValue,
        unsigned int _Mask);
    __declspec(dllimport) int* __cdecl __fpecode(void);
    __declspec(dllimport) int __cdecl __fpe_flt_rounds(void);
    __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign);
    __declspec(dllimport) double __cdecl _chgsign(double _X);
    __declspec(dllimport) double __cdecl _scalb(double _X, long _Y);
    __declspec(dllimport) double __cdecl _logb(double _X);
    __declspec(dllimport) double __cdecl _nextafter(double _X, double _Y);
    __declspec(dllimport) int __cdecl _finite(double _X);
    __declspec(dllimport) int __cdecl _isnan(double _X);
    __declspec(dllimport) int __cdecl _fpclass(double _X);
    __declspec(dllimport) float __cdecl _scalbf(float _X, long _Y);
    __declspec(dllimport) void __cdecl fpreset(void);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4201)
#pragma region Desktop Family
    typedef DWORD D3DCOLOR;
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#pragma endregion
#pragma region App Family
typedef struct _D3DMATRIX {
    union {
        struct {
            float _11, _12, _13, _14;
            float _21, _22, _23, _24;
            float _31, _32, _33, _34;
            float _41, _42, _43, _44;
        };
        float m[4][4];
    };
} D3DMATRIX;
#pragma endregion
#pragma region Desktop Family
typedef struct _D3DVIEWPORT9 {
    DWORD X;
    DWORD Y;
    DWORD Width;
    DWORD Height;
    float MinZ;
    float MaxZ;
} D3DVIEWPORT9;
typedef struct _D3DCLIPSTATUS9 {
    DWORD ClipUnion;
    DWORD ClipIntersection;
} D3DCLIPSTATUS9;
typedef struct _D3DMATERIAL9 {
    D3DCOLORVALUE Diffuse;
    D3DCOLORVALUE Ambient;
    D3DCOLORVALUE Specular;
    D3DCOLORVALUE Emissive;
    float Power;
} D3DMATERIAL9;
typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT = 1,
    D3DLIGHT_SPOT = 2,
    D3DLIGHT_DIRECTIONAL = 3,
    D3DLIGHT_FORCE_DWORD = 0x7fffffff,
} D3DLIGHTTYPE;
typedef struct _D3DLIGHT9 {
    D3DLIGHTTYPE Type;
    D3DCOLORVALUE Diffuse;
    D3DCOLORVALUE Specular;
    D3DCOLORVALUE Ambient;
    D3DVECTOR Position;
    D3DVECTOR Direction;
    float Range;
    float Falloff;
    float Attenuation0;
    float Attenuation1;
    float Attenuation2;
    float Theta;
    float Phi;
} D3DLIGHT9;
typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT = 1,
    D3DSHADE_GOURAUD = 2,
    D3DSHADE_PHONG = 3,
    D3DSHADE_FORCE_DWORD = 0x7fffffff,
} D3DSHADEMODE;
typedef enum _D3DFILLMODE {
    D3DFILL_POINT = 1,
    D3DFILL_WIREFRAME = 2,
    D3DFILL_SOLID = 3,
    D3DFILL_FORCE_DWORD = 0x7fffffff,
} D3DFILLMODE;
typedef enum _D3DBLEND {
    D3DBLEND_ZERO = 1,
    D3DBLEND_ONE = 2,
    D3DBLEND_SRCCOLOR = 3,
    D3DBLEND_INVSRCCOLOR = 4,
    D3DBLEND_SRCALPHA = 5,
    D3DBLEND_INVSRCALPHA = 6,
    D3DBLEND_DESTALPHA = 7,
    D3DBLEND_INVDESTALPHA = 8,
    D3DBLEND_DESTCOLOR = 9,
    D3DBLEND_INVDESTCOLOR = 10,
    D3DBLEND_SRCALPHASAT = 11,
    D3DBLEND_BOTHSRCALPHA = 12,
    D3DBLEND_BOTHINVSRCALPHA = 13,
    D3DBLEND_BLENDFACTOR = 14,
    D3DBLEND_INVBLENDFACTOR = 15,
    D3DBLEND_SRCCOLOR2 = 16,
    D3DBLEND_INVSRCCOLOR2 = 17,
    D3DBLEND_FORCE_DWORD = 0x7fffffff,
} D3DBLEND;
typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD = 1,
    D3DBLENDOP_SUBTRACT = 2,
    D3DBLENDOP_REVSUBTRACT = 3,
    D3DBLENDOP_MIN = 4,
    D3DBLENDOP_MAX = 5,
    D3DBLENDOP_FORCE_DWORD = 0x7fffffff,
} D3DBLENDOP;
typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP = 1,
    D3DTADDRESS_MIRROR = 2,
    D3DTADDRESS_CLAMP = 3,
    D3DTADDRESS_BORDER = 4,
    D3DTADDRESS_MIRRORONCE = 5,
    D3DTADDRESS_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREADDRESS;
typedef enum _D3DCULL {
    D3DCULL_NONE = 1,
    D3DCULL_CW = 2,
    D3DCULL_CCW = 3,
    D3DCULL_FORCE_DWORD = 0x7fffffff,
} D3DCULL;
typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER = 1,
    D3DCMP_LESS = 2,
    D3DCMP_EQUAL = 3,
    D3DCMP_LESSEQUAL = 4,
    D3DCMP_GREATER = 5,
    D3DCMP_NOTEQUAL = 6,
    D3DCMP_GREATEREQUAL = 7,
    D3DCMP_ALWAYS = 8,
    D3DCMP_FORCE_DWORD = 0x7fffffff,
} D3DCMPFUNC;
typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP = 1,
    D3DSTENCILOP_ZERO = 2,
    D3DSTENCILOP_REPLACE = 3,
    D3DSTENCILOP_INCRSAT = 4,
    D3DSTENCILOP_DECRSAT = 5,
    D3DSTENCILOP_INVERT = 6,
    D3DSTENCILOP_INCR = 7,
    D3DSTENCILOP_DECR = 8,
    D3DSTENCILOP_FORCE_DWORD = 0x7fffffff,
} D3DSTENCILOP;
typedef enum _D3DFOGMODE {
    D3DFOG_NONE = 0,
    D3DFOG_EXP = 1,
    D3DFOG_EXP2 = 2,
    D3DFOG_LINEAR = 3,
    D3DFOG_FORCE_DWORD = 0x7fffffff,
} D3DFOGMODE;
typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE = 0,
    D3DZB_TRUE = 1,
    D3DZB_USEW = 2,
    D3DZB_FORCE_DWORD = 0x7fffffff,
} D3DZBUFFERTYPE;
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST = 1,
    D3DPT_LINELIST = 2,
    D3DPT_LINESTRIP = 3,
    D3DPT_TRIANGLELIST = 4,
    D3DPT_TRIANGLESTRIP = 5,
    D3DPT_TRIANGLEFAN = 6,
    D3DPT_FORCE_DWORD = 0x7fffffff,
} D3DPRIMITIVETYPE;
typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW = 2,
    D3DTS_PROJECTION = 3,
    D3DTS_TEXTURE0 = 16,
    D3DTS_TEXTURE1 = 17,
    D3DTS_TEXTURE2 = 18,
    D3DTS_TEXTURE3 = 19,
    D3DTS_TEXTURE4 = 20,
    D3DTS_TEXTURE5 = 21,
    D3DTS_TEXTURE6 = 22,
    D3DTS_TEXTURE7 = 23,
    D3DTS_FORCE_DWORD = 0x7fffffff,
} D3DTRANSFORMSTATETYPE;
typedef enum _D3DRENDERSTATETYPE {
    D3DRS_ZENABLE = 7,
    D3DRS_FILLMODE = 8,
    D3DRS_SHADEMODE = 9,
    D3DRS_ZWRITEENABLE = 14,
    D3DRS_ALPHATESTENABLE = 15,
    D3DRS_LASTPIXEL = 16,
    D3DRS_SRCBLEND = 19,
    D3DRS_DESTBLEND = 20,
    D3DRS_CULLMODE = 22,
    D3DRS_ZFUNC = 23,
    D3DRS_ALPHAREF = 24,
    D3DRS_ALPHAFUNC = 25,
    D3DRS_DITHERENABLE = 26,
    D3DRS_ALPHABLENDENABLE = 27,
    D3DRS_FOGENABLE = 28,
    D3DRS_SPECULARENABLE = 29,
    D3DRS_FOGCOLOR = 34,
    D3DRS_FOGTABLEMODE = 35,
    D3DRS_FOGSTART = 36,
    D3DRS_FOGEND = 37,
    D3DRS_FOGDENSITY = 38,
    D3DRS_RANGEFOGENABLE = 48,
    D3DRS_STENCILENABLE = 52,
    D3DRS_STENCILFAIL = 53,
    D3DRS_STENCILZFAIL = 54,
    D3DRS_STENCILPASS = 55,
    D3DRS_STENCILFUNC = 56,
    D3DRS_STENCILREF = 57,
    D3DRS_STENCILMASK = 58,
    D3DRS_STENCILWRITEMASK = 59,
    D3DRS_TEXTUREFACTOR = 60,
    D3DRS_WRAP0 = 128,
    D3DRS_WRAP1 = 129,
    D3DRS_WRAP2 = 130,
    D3DRS_WRAP3 = 131,
    D3DRS_WRAP4 = 132,
    D3DRS_WRAP5 = 133,
    D3DRS_WRAP6 = 134,
    D3DRS_WRAP7 = 135,
    D3DRS_CLIPPING = 136,
    D3DRS_LIGHTING = 137,
    D3DRS_AMBIENT = 139,
    D3DRS_FOGVERTEXMODE = 140,
    D3DRS_COLORVERTEX = 141,
    D3DRS_LOCALVIEWER = 142,
    D3DRS_NORMALIZENORMALS = 143,
    D3DRS_DIFFUSEMATERIALSOURCE = 145,
    D3DRS_SPECULARMATERIALSOURCE = 146,
    D3DRS_AMBIENTMATERIALSOURCE = 147,
    D3DRS_EMISSIVEMATERIALSOURCE = 148,
    D3DRS_VERTEXBLEND = 151,
    D3DRS_CLIPPLANEENABLE = 152,
    D3DRS_POINTSIZE = 154,
    D3DRS_POINTSIZE_MIN = 155,
    D3DRS_POINTSPRITEENABLE = 156,
    D3DRS_POINTSCALEENABLE = 157,
    D3DRS_POINTSCALE_A = 158,
    D3DRS_POINTSCALE_B = 159,
    D3DRS_POINTSCALE_C = 160,
    D3DRS_MULTISAMPLEANTIALIAS = 161,
    D3DRS_MULTISAMPLEMASK = 162,
    D3DRS_PATCHEDGESTYLE = 163,
    D3DRS_DEBUGMONITORTOKEN = 165,
    D3DRS_POINTSIZE_MAX = 166,
    D3DRS_INDEXEDVERTEXBLENDENABLE = 167,
    D3DRS_COLORWRITEENABLE = 168,
    D3DRS_TWEENFACTOR = 170,
    D3DRS_BLENDOP = 171,
    D3DRS_POSITIONDEGREE = 172,
    D3DRS_NORMALDEGREE = 173,
    D3DRS_SCISSORTESTENABLE = 174,
    D3DRS_SLOPESCALEDEPTHBIAS = 175,
    D3DRS_ANTIALIASEDLINEENABLE = 176,
    D3DRS_MINTESSELLATIONLEVEL = 178,
    D3DRS_MAXTESSELLATIONLEVEL = 179,
    D3DRS_ADAPTIVETESS_X = 180,
    D3DRS_ADAPTIVETESS_Y = 181,
    D3DRS_ADAPTIVETESS_Z = 182,
    D3DRS_ADAPTIVETESS_W = 183,
    D3DRS_ENABLEADAPTIVETESSELLATION = 184,
    D3DRS_TWOSIDEDSTENCILMODE = 185,
    D3DRS_CCW_STENCILFAIL = 186,
    D3DRS_CCW_STENCILZFAIL = 187,
    D3DRS_CCW_STENCILPASS = 188,
    D3DRS_CCW_STENCILFUNC = 189,
    D3DRS_COLORWRITEENABLE1 = 190,
    D3DRS_COLORWRITEENABLE2 = 191,
    D3DRS_COLORWRITEENABLE3 = 192,
    D3DRS_BLENDFACTOR = 193,
    D3DRS_SRGBWRITEENABLE = 194,
    D3DRS_DEPTHBIAS = 195,
    D3DRS_WRAP8 = 198,
    D3DRS_WRAP9 = 199,
    D3DRS_WRAP10 = 200,
    D3DRS_WRAP11 = 201,
    D3DRS_WRAP12 = 202,
    D3DRS_WRAP13 = 203,
    D3DRS_WRAP14 = 204,
    D3DRS_WRAP15 = 205,
    D3DRS_SEPARATEALPHABLENDENABLE = 206,
    D3DRS_SRCBLENDALPHA = 207,
    D3DRS_DESTBLENDALPHA = 208,
    D3DRS_BLENDOPALPHA = 209,
    D3DRS_FORCE_DWORD = 0x7fffffff,
} D3DRENDERSTATETYPE;
typedef enum _D3DMATERIALCOLORSOURCE {
    D3DMCS_MATERIAL = 0,
    D3DMCS_COLOR1 = 1,
    D3DMCS_COLOR2 = 2,
    D3DMCS_FORCE_DWORD = 0x7fffffff,
} D3DMATERIALCOLORSOURCE;
typedef enum _D3DTEXTURESTAGESTATETYPE {
    D3DTSS_COLOROP = 1,
    D3DTSS_COLORARG1 = 2,
    D3DTSS_COLORARG2 = 3,
    D3DTSS_ALPHAOP = 4,
    D3DTSS_ALPHAARG1 = 5,
    D3DTSS_ALPHAARG2 = 6,
    D3DTSS_BUMPENVMAT00 = 7,
    D3DTSS_BUMPENVMAT01 = 8,
    D3DTSS_BUMPENVMAT10 = 9,
    D3DTSS_BUMPENVMAT11 = 10,
    D3DTSS_TEXCOORDINDEX = 11,
    D3DTSS_BUMPENVLSCALE = 22,
    D3DTSS_BUMPENVLOFFSET = 23,
    D3DTSS_TEXTURETRANSFORMFLAGS = 24,
    D3DTSS_COLORARG0 = 26,
    D3DTSS_ALPHAARG0 = 27,
    D3DTSS_RESULTARG = 28,
    D3DTSS_CONSTANT = 32,
    D3DTSS_FORCE_DWORD = 0x7fffffff,
} D3DTEXTURESTAGESTATETYPE;
typedef enum _D3DSAMPLERSTATETYPE {
    D3DSAMP_ADDRESSU = 1,
    D3DSAMP_ADDRESSV = 2,
    D3DSAMP_ADDRESSW = 3,
    D3DSAMP_BORDERCOLOR = 4,
    D3DSAMP_MAGFILTER = 5,
    D3DSAMP_MINFILTER = 6,
    D3DSAMP_MIPFILTER = 7,
    D3DSAMP_MIPMAPLODBIAS = 8,
    D3DSAMP_MAXMIPLEVEL = 9,
    D3DSAMP_MAXANISOTROPY = 10,
    D3DSAMP_SRGBTEXTURE = 11,
    D3DSAMP_ELEMENTINDEX = 12,
    D3DSAMP_DMAPOFFSET = 13,
    D3DSAMP_FORCE_DWORD = 0x7fffffff,
} D3DSAMPLERSTATETYPE;
typedef enum _D3DTEXTUREOP {
    D3DTOP_DISABLE = 1,
    D3DTOP_SELECTARG1 = 2,
    D3DTOP_SELECTARG2 = 3,
    D3DTOP_MODULATE = 4,
    D3DTOP_MODULATE2X = 5,
    D3DTOP_MODULATE4X = 6,
    D3DTOP_ADD = 7,
    D3DTOP_ADDSIGNED = 8,
    D3DTOP_ADDSIGNED2X = 9,
    D3DTOP_SUBTRACT = 10,
    D3DTOP_ADDSMOOTH = 11,
    D3DTOP_BLENDDIFFUSEALPHA = 12,
    D3DTOP_BLENDTEXTUREALPHA = 13,
    D3DTOP_BLENDFACTORALPHA = 14,
    D3DTOP_BLENDTEXTUREALPHAPM = 15,
    D3DTOP_BLENDCURRENTALPHA = 16,
    D3DTOP_PREMODULATE = 17,
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,
    D3DTOP_BUMPENVMAP = 22,
    D3DTOP_BUMPENVMAPLUMINANCE = 23,
    D3DTOP_DOTPRODUCT3 = 24,
    D3DTOP_MULTIPLYADD = 25,
    D3DTOP_LERP = 26,
    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;
typedef enum _D3DTEXTUREFILTERTYPE {
    D3DTEXF_NONE = 0,
    D3DTEXF_POINT = 1,
    D3DTEXF_LINEAR = 2,
    D3DTEXF_ANISOTROPIC = 3,
    D3DTEXF_PYRAMIDALQUAD = 6,
    D3DTEXF_GAUSSIANQUAD = 7,
    D3DTEXF_CONVOLUTIONMONO = 8,
    D3DTEXF_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREFILTERTYPE;
typedef enum _D3DDECLUSAGE {
    D3DDECLUSAGE_POSITION = 0,
    D3DDECLUSAGE_BLENDWEIGHT,
    D3DDECLUSAGE_BLENDINDICES,
    D3DDECLUSAGE_NORMAL,
    D3DDECLUSAGE_PSIZE,
    D3DDECLUSAGE_TEXCOORD,
    D3DDECLUSAGE_TANGENT,
    D3DDECLUSAGE_BINORMAL,
    D3DDECLUSAGE_TESSFACTOR,
    D3DDECLUSAGE_POSITIONT,
    D3DDECLUSAGE_COLOR,
    D3DDECLUSAGE_FOG,
    D3DDECLUSAGE_DEPTH,
    D3DDECLUSAGE_SAMPLE,
} D3DDECLUSAGE;
typedef enum _D3DDECLMETHOD {
    D3DDECLMETHOD_DEFAULT = 0,
    D3DDECLMETHOD_PARTIALU,
    D3DDECLMETHOD_PARTIALV,
    D3DDECLMETHOD_CROSSUV,
    D3DDECLMETHOD_UV,
    D3DDECLMETHOD_LOOKUP,
    D3DDECLMETHOD_LOOKUPPRESAMPLED,
} D3DDECLMETHOD;
typedef enum _D3DDECLTYPE {
    D3DDECLTYPE_FLOAT1 = 0,
    D3DDECLTYPE_FLOAT2 = 1,
    D3DDECLTYPE_FLOAT3 = 2,
    D3DDECLTYPE_FLOAT4 = 3,
    D3DDECLTYPE_D3DCOLOR = 4,
    D3DDECLTYPE_UBYTE4 = 5,
    D3DDECLTYPE_SHORT2 = 6,
    D3DDECLTYPE_SHORT4 = 7,
    D3DDECLTYPE_UBYTE4N = 8,
    D3DDECLTYPE_SHORT2N = 9,
    D3DDECLTYPE_SHORT4N = 10,
    D3DDECLTYPE_USHORT2N = 11,
    D3DDECLTYPE_USHORT4N = 12,
    D3DDECLTYPE_UDEC3 = 13,
    D3DDECLTYPE_DEC3N = 14,
    D3DDECLTYPE_FLOAT16_2 = 15,
    D3DDECLTYPE_FLOAT16_4 = 16,
    D3DDECLTYPE_UNUSED = 17,
} D3DDECLTYPE;
typedef struct _D3DVERTEXELEMENT9 {
    WORD Stream;
    WORD Offset;
    BYTE Type;
    BYTE Method;
    BYTE Usage;
    BYTE UsageIndex;
} D3DVERTEXELEMENT9, *LPD3DVERTEXELEMENT9;
typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE {
    D3DSIO_NOP = 0,
    D3DSIO_MOV,
    D3DSIO_ADD,
    D3DSIO_SUB,
    D3DSIO_MAD,
    D3DSIO_MUL,
    D3DSIO_RCP,
    D3DSIO_RSQ,
    D3DSIO_DP3,
    D3DSIO_DP4,
    D3DSIO_MIN,
    D3DSIO_MAX,
    D3DSIO_SLT,
    D3DSIO_SGE,
    D3DSIO_EXP,
    D3DSIO_LOG,
    D3DSIO_LIT,
    D3DSIO_DST,
    D3DSIO_LRP,
    D3DSIO_FRC,
    D3DSIO_M4x4,
    D3DSIO_M4x3,
    D3DSIO_M3x4,
    D3DSIO_M3x3,
    D3DSIO_M3x2,
    D3DSIO_CALL,
    D3DSIO_CALLNZ,
    D3DSIO_LOOP,
    D3DSIO_RET,
    D3DSIO_ENDLOOP,
    D3DSIO_LABEL,
    D3DSIO_DCL,
    D3DSIO_POW,
    D3DSIO_CRS,
    D3DSIO_SGN,
    D3DSIO_ABS,
    D3DSIO_NRM,
    D3DSIO_SINCOS,
    D3DSIO_REP,
    D3DSIO_ENDREP,
    D3DSIO_IF,
    D3DSIO_IFC,
    D3DSIO_ELSE,
    D3DSIO_ENDIF,
    D3DSIO_BREAK,
    D3DSIO_BREAKC,
    D3DSIO_MOVA,
    D3DSIO_DEFB,
    D3DSIO_DEFI,
    D3DSIO_TEXCOORD = 64,
    D3DSIO_TEXKILL,
    D3DSIO_TEX,
    D3DSIO_TEXBEM,
    D3DSIO_TEXBEML,
    D3DSIO_TEXREG2AR,
    D3DSIO_TEXREG2GB,
    D3DSIO_TEXM3x2PAD,
    D3DSIO_TEXM3x2TEX,
    D3DSIO_TEXM3x3PAD,
    D3DSIO_TEXM3x3TEX,
    D3DSIO_RESERVED0,
    D3DSIO_TEXM3x3SPEC,
    D3DSIO_TEXM3x3VSPEC,
    D3DSIO_EXPP,
    D3DSIO_LOGP,
    D3DSIO_CND,
    D3DSIO_DEF,
    D3DSIO_TEXREG2RGB,
    D3DSIO_TEXDP3TEX,
    D3DSIO_TEXM3x2DEPTH,
    D3DSIO_TEXDP3,
    D3DSIO_TEXM3x3,
    D3DSIO_TEXDEPTH,
    D3DSIO_CMP,
    D3DSIO_BEM,
    D3DSIO_DP2ADD,
    D3DSIO_DSX,
    D3DSIO_DSY,
    D3DSIO_TEXLDD,
    D3DSIO_SETP,
    D3DSIO_TEXLDL,
    D3DSIO_BREAKP,
    D3DSIO_PHASE = 0xFFFD,
    D3DSIO_COMMENT = 0xFFFE,
    D3DSIO_END = 0xFFFF,
    D3DSIO_FORCE_DWORD = 0x7fffffff,
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;
typedef enum _D3DSHADER_COMPARISON {
    D3DSPC_RESERVED0 = 0,
    D3DSPC_GT = 1,
    D3DSPC_EQ = 2,
    D3DSPC_GE = 3,
    D3DSPC_LT = 4,
    D3DSPC_NE = 5,
    D3DSPC_LE = 6,
    D3DSPC_RESERVED1 = 7
} D3DSHADER_COMPARISON;
typedef enum _D3DSAMPLER_TEXTURE_TYPE {
    D3DSTT_UNKNOWN = 0 << 27,
    D3DSTT_2D = 2 << 27,
    D3DSTT_CUBE = 3 << 27,
    D3DSTT_VOLUME = 4 << 27,
    D3DSTT_FORCE_DWORD = 0x7fffffff,
} D3DSAMPLER_TEXTURE_TYPE;
typedef enum _D3DSHADER_PARAM_REGISTER_TYPE {
    D3DSPR_TEMP = 0,
    D3DSPR_INPUT = 1,
    D3DSPR_CONST = 2,
    D3DSPR_ADDR = 3,
    D3DSPR_TEXTURE = 3,
    D3DSPR_RASTOUT = 4,
    D3DSPR_ATTROUT = 5,
    D3DSPR_TEXCRDOUT = 6,
    D3DSPR_OUTPUT = 6,
    D3DSPR_CONSTINT = 7,
    D3DSPR_COLOROUT = 8,
    D3DSPR_DEPTHOUT = 9,
    D3DSPR_SAMPLER = 10,
    D3DSPR_CONST2 = 11,
    D3DSPR_CONST3 = 12,
    D3DSPR_CONST4 = 13,
    D3DSPR_CONSTBOOL = 14,
    D3DSPR_LOOP = 15,
    D3DSPR_TEMPFLOAT16 = 16,
    D3DSPR_MISCTYPE = 17,
    D3DSPR_LABEL = 18,
    D3DSPR_PREDICATE = 19,
    D3DSPR_FORCE_DWORD = 0x7fffffff,
} D3DSHADER_PARAM_REGISTER_TYPE;
typedef enum _D3DSHADER_MISCTYPE_OFFSETS {
    D3DSMO_POSITION = 0,
    D3DSMO_FACE = 1,
} D3DSHADER_MISCTYPE_OFFSETS;
typedef enum _D3DVS_RASTOUT_OFFSETS {
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD = 0x7fffffff,
} D3DVS_RASTOUT_OFFSETS;
typedef enum _D3DVS_ADDRESSMODE_TYPE {
    D3DVS_ADDRMODE_ABSOLUTE = (0 << 13),
    D3DVS_ADDRMODE_RELATIVE = (1 << 13),
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff,
} D3DVS_ADDRESSMODE_TYPE;
typedef enum _D3DSHADER_ADDRESSMODE_TYPE {
    D3DSHADER_ADDRMODE_ABSOLUTE = (0 << 13),
    D3DSHADER_ADDRMODE_RELATIVE = (1 << 13),
    D3DSHADER_ADDRMODE_FORCE_DWORD = 0x7fffffff,
} D3DSHADER_ADDRESSMODE_TYPE;
typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE {
    D3DSPSM_NONE = 0 << 24,
    D3DSPSM_NEG = 1 << 24,
    D3DSPSM_BIAS = 2 << 24,
    D3DSPSM_BIASNEG = 3 << 24,
    D3DSPSM_SIGN = 4 << 24,
    D3DSPSM_SIGNNEG = 5 << 24,
    D3DSPSM_COMP = 6 << 24,
    D3DSPSM_X2 = 7 << 24,
    D3DSPSM_X2NEG = 8 << 24,
    D3DSPSM_DZ = 9 << 24,
    D3DSPSM_DW = 10 << 24,
    D3DSPSM_ABS = 11 << 24,
    D3DSPSM_ABSNEG = 12 << 24,
    D3DSPSM_NOT = 13 << 24,
    D3DSPSM_FORCE_DWORD = 0x7fffffff,
} D3DSHADER_PARAM_SRCMOD_TYPE;
typedef enum _D3DSHADER_MIN_PRECISION {
    D3DMP_DEFAULT = 0,
    D3DMP_16 = 1,
    D3DMP_2_8 = 2,
} D3DSHADER_MIN_PRECISION;
typedef enum _D3DBASISTYPE {
    D3DBASIS_BEZIER = 0,
    D3DBASIS_BSPLINE = 1,
    D3DBASIS_CATMULL_ROM = 2,
    D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;
typedef enum _D3DDEGREETYPE {
    D3DDEGREE_LINEAR = 1,
    D3DDEGREE_QUADRATIC = 2,
    D3DDEGREE_CUBIC = 3,
    D3DDEGREE_QUINTIC = 5,
    D3DDEGREE_FORCE_DWORD = 0x7fffffff,
} D3DDEGREETYPE;
typedef enum _D3DPATCHEDGESTYLE {
    D3DPATCHEDGE_DISCRETE = 0,
    D3DPATCHEDGE_CONTINUOUS = 1,
    D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;
typedef enum _D3DSTATEBLOCKTYPE {
    D3DSBT_ALL = 1,
    D3DSBT_PIXELSTATE = 2,
    D3DSBT_VERTEXSTATE = 3,
    D3DSBT_FORCE_DWORD = 0x7fffffff,
} D3DSTATEBLOCKTYPE;
typedef enum _D3DVERTEXBLENDFLAGS {
    D3DVBF_DISABLE = 0,
    D3DVBF_1WEIGHTS = 1,
    D3DVBF_2WEIGHTS = 2,
    D3DVBF_3WEIGHTS = 3,
    D3DVBF_TWEENING = 255,
    D3DVBF_0WEIGHTS = 256,
    D3DVBF_FORCE_DWORD = 0x7fffffff,
} D3DVERTEXBLENDFLAGS;
typedef enum _D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE = 0,
    D3DTTFF_COUNT1 = 1,
    D3DTTFF_COUNT2 = 2,
    D3DTTFF_COUNT3 = 3,
    D3DTTFF_COUNT4 = 4,
    D3DTTFF_PROJECTED = 256,
    D3DTTFF_FORCE_DWORD = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;
typedef enum _D3DDEVTYPE {
    D3DDEVTYPE_HAL = 1,
    D3DDEVTYPE_REF = 2,
    D3DDEVTYPE_SW = 3,
    D3DDEVTYPE_NULLREF = 4,
    D3DDEVTYPE_FORCE_DWORD = 0x7fffffff
} D3DDEVTYPE;
typedef enum _D3DMULTISAMPLE_TYPE {
    D3DMULTISAMPLE_NONE = 0,
    D3DMULTISAMPLE_NONMASKABLE = 1,
    D3DMULTISAMPLE_2_SAMPLES = 2,
    D3DMULTISAMPLE_3_SAMPLES = 3,
    D3DMULTISAMPLE_4_SAMPLES = 4,
    D3DMULTISAMPLE_5_SAMPLES = 5,
    D3DMULTISAMPLE_6_SAMPLES = 6,
    D3DMULTISAMPLE_7_SAMPLES = 7,
    D3DMULTISAMPLE_8_SAMPLES = 8,
    D3DMULTISAMPLE_9_SAMPLES = 9,
    D3DMULTISAMPLE_10_SAMPLES = 10,
    D3DMULTISAMPLE_11_SAMPLES = 11,
    D3DMULTISAMPLE_12_SAMPLES = 12,
    D3DMULTISAMPLE_13_SAMPLES = 13,
    D3DMULTISAMPLE_14_SAMPLES = 14,
    D3DMULTISAMPLE_15_SAMPLES = 15,
    D3DMULTISAMPLE_16_SAMPLES = 16,
    D3DMULTISAMPLE_FORCE_DWORD = 0x7fffffff
} D3DMULTISAMPLE_TYPE;
typedef enum _D3DFORMAT {
    D3DFMT_UNKNOWN = 0,
    D3DFMT_R8G8B8 = 20,
    D3DFMT_A8R8G8B8 = 21,
    D3DFMT_X8R8G8B8 = 22,
    D3DFMT_R5G6B5 = 23,
    D3DFMT_X1R5G5B5 = 24,
    D3DFMT_A1R5G5B5 = 25,
    D3DFMT_A4R4G4B4 = 26,
    D3DFMT_R3G3B2 = 27,
    D3DFMT_A8 = 28,
    D3DFMT_A8R3G3B2 = 29,
    D3DFMT_X4R4G4B4 = 30,
    D3DFMT_A2B10G10R10 = 31,
    D3DFMT_A8B8G8R8 = 32,
    D3DFMT_X8B8G8R8 = 33,
    D3DFMT_G16R16 = 34,
    D3DFMT_A2R10G10B10 = 35,
    D3DFMT_A16B16G16R16 = 36,
    D3DFMT_A8P8 = 40,
    D3DFMT_P8 = 41,
    D3DFMT_L8 = 50,
    D3DFMT_A8L8 = 51,
    D3DFMT_A4L4 = 52,
    D3DFMT_V8U8 = 60,
    D3DFMT_L6V5U5 = 61,
    D3DFMT_X8L8V8U8 = 62,
    D3DFMT_Q8W8V8U8 = 63,
    D3DFMT_V16U16 = 64,
    D3DFMT_A2W10V10U10 = 67,
    D3DFMT_UYVY = ((DWORD)(BYTE)('U') | ((DWORD)(BYTE)('Y') << 8) | ((DWORD)(BYTE)('V') << 16) | ((DWORD)(BYTE)('Y') << 24)),
    D3DFMT_R8G8_B8G8 = ((DWORD)(BYTE)('R') | ((DWORD)(BYTE)('G') << 8) | ((DWORD)(BYTE)('B') << 16) | ((DWORD)(BYTE)('G') << 24)),
    D3DFMT_YUY2 = ((DWORD)(BYTE)('Y') | ((DWORD)(BYTE)('U') << 8) | ((DWORD)(BYTE)('Y') << 16) | ((DWORD)(BYTE)('2') << 24)),
    D3DFMT_G8R8_G8B8 = ((DWORD)(BYTE)('G') | ((DWORD)(BYTE)('R') << 8) | ((DWORD)(BYTE)('G') << 16) | ((DWORD)(BYTE)('B') << 24)),
    D3DFMT_DXT1 = ((DWORD)(BYTE)('D') | ((DWORD)(BYTE)('X') << 8) | ((DWORD)(BYTE)('T') << 16) | ((DWORD)(BYTE)('1') << 24)),
    D3DFMT_DXT2 = ((DWORD)(BYTE)('D') | ((DWORD)(BYTE)('X') << 8) | ((DWORD)(BYTE)('T') << 16) | ((DWORD)(BYTE)('2') << 24)),
    D3DFMT_DXT3 = ((DWORD)(BYTE)('D') | ((DWORD)(BYTE)('X') << 8) | ((DWORD)(BYTE)('T') << 16) | ((DWORD)(BYTE)('3') << 24)),
    D3DFMT_DXT4 = ((DWORD)(BYTE)('D') | ((DWORD)(BYTE)('X') << 8) | ((DWORD)(BYTE)('T') << 16) | ((DWORD)(BYTE)('4') << 24)),
    D3DFMT_DXT5 = ((DWORD)(BYTE)('D') | ((DWORD)(BYTE)('X') << 8) | ((DWORD)(BYTE)('T') << 16) | ((DWORD)(BYTE)('5') << 24)),
    D3DFMT_D16_LOCKABLE = 70,
    D3DFMT_D32 = 71,
    D3DFMT_D15S1 = 73,
    D3DFMT_D24S8 = 75,
    D3DFMT_D24X8 = 77,
    D3DFMT_D24X4S4 = 79,
    D3DFMT_D16 = 80,
    D3DFMT_D32F_LOCKABLE = 82,
    D3DFMT_D24FS8 = 83,
    D3DFMT_D32_LOCKABLE = 84,
    D3DFMT_S8_LOCKABLE = 85,
    D3DFMT_L16 = 81,
    D3DFMT_VERTEXDATA = 100,
    D3DFMT_INDEX16 = 101,
    D3DFMT_INDEX32 = 102,
    D3DFMT_Q16W16V16U16 = 110,
    D3DFMT_MULTI2_ARGB8 = ((DWORD)(BYTE)('M') | ((DWORD)(BYTE)('E') << 8) | ((DWORD)(BYTE)('T') << 16) | ((DWORD)(BYTE)('1') << 24)),
    D3DFMT_R16F = 111,
    D3DFMT_G16R16F = 112,
    D3DFMT_A16B16G16R16F = 113,
    D3DFMT_R32F = 114,
    D3DFMT_G32R32F = 115,
    D3DFMT_A32B32G32R32F = 116,
    D3DFMT_CxV8U8 = 117,
    D3DFMT_A1 = 118,
    D3DFMT_A2B10G10R10_XR_BIAS = 119,
    D3DFMT_BINARYBUFFER = 199,
    D3DFMT_FORCE_DWORD = 0x7fffffff
} D3DFORMAT;
typedef struct _D3DDISPLAYMODE {
    UINT Width;
    UINT Height;
    UINT RefreshRate;
    D3DFORMAT Format;
} D3DDISPLAYMODE;
typedef struct _D3DDEVICE_CREATION_PARAMETERS {
    UINT AdapterOrdinal;
    D3DDEVTYPE DeviceType;
    HWND hFocusWindow;
    DWORD BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;
typedef enum _D3DSWAPEFFECT {
    D3DSWAPEFFECT_DISCARD = 1,
    D3DSWAPEFFECT_FLIP = 2,
    D3DSWAPEFFECT_COPY = 3,
    D3DSWAPEFFECT_OVERLAY = 4,
    D3DSWAPEFFECT_FLIPEX = 5,
    D3DSWAPEFFECT_FORCE_DWORD = 0x7fffffff
} D3DSWAPEFFECT;
typedef enum _D3DPOOL {
    D3DPOOL_DEFAULT = 0,
    D3DPOOL_MANAGED = 1,
    D3DPOOL_SYSTEMMEM = 2,
    D3DPOOL_SCRATCH = 3,
    D3DPOOL_FORCE_DWORD = 0x7fffffff
} D3DPOOL;
typedef struct _D3DPRESENT_PARAMETERS_ {
    UINT BackBufferWidth;
    UINT BackBufferHeight;
    D3DFORMAT BackBufferFormat;
    UINT BackBufferCount;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD MultiSampleQuality;
    D3DSWAPEFFECT SwapEffect;
    HWND hDeviceWindow;
    BOOL Windowed;
    BOOL EnableAutoDepthStencil;
    D3DFORMAT AutoDepthStencilFormat;
    DWORD Flags;
    UINT FullScreen_RefreshRateInHz;
    UINT PresentationInterval;
} D3DPRESENT_PARAMETERS;
typedef struct _D3DGAMMARAMP {
    WORD red[256];
    WORD green[256];
    WORD blue[256];
} D3DGAMMARAMP;
typedef enum _D3DBACKBUFFER_TYPE {
    D3DBACKBUFFER_TYPE_MONO = 0,
    D3DBACKBUFFER_TYPE_LEFT = 1,
    D3DBACKBUFFER_TYPE_RIGHT = 2,
    D3DBACKBUFFER_TYPE_FORCE_DWORD = 0x7fffffff
} D3DBACKBUFFER_TYPE;
typedef enum _D3DRESOURCETYPE {
    D3DRTYPE_SURFACE = 1,
    D3DRTYPE_VOLUME = 2,
    D3DRTYPE_TEXTURE = 3,
    D3DRTYPE_VOLUMETEXTURE = 4,
    D3DRTYPE_CUBETEXTURE = 5,
    D3DRTYPE_VERTEXBUFFER = 6,
    D3DRTYPE_INDEXBUFFER = 7,
    D3DRTYPE_FORCE_DWORD = 0x7fffffff
} D3DRESOURCETYPE;
typedef enum _D3DCUBEMAP_FACES {
    D3DCUBEMAP_FACE_POSITIVE_X = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z = 5,
    D3DCUBEMAP_FACE_FORCE_DWORD = 0x7fffffff
} D3DCUBEMAP_FACES;
typedef struct _D3DVERTEXBUFFER_DESC {
    D3DFORMAT Format;
    D3DRESOURCETYPE Type;
    DWORD Usage;
    D3DPOOL Pool;
    UINT Size;
    DWORD FVF;
} D3DVERTEXBUFFER_DESC;
typedef struct _D3DINDEXBUFFER_DESC {
    D3DFORMAT Format;
    D3DRESOURCETYPE Type;
    DWORD Usage;
    D3DPOOL Pool;
    UINT Size;
} D3DINDEXBUFFER_DESC;
typedef struct _D3DSURFACE_DESC {
    D3DFORMAT Format;
    D3DRESOURCETYPE Type;
    DWORD Usage;
    D3DPOOL Pool;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD MultiSampleQuality;
    UINT Width;
    UINT Height;
} D3DSURFACE_DESC;
typedef struct _D3DVOLUME_DESC {
    D3DFORMAT Format;
    D3DRESOURCETYPE Type;
    DWORD Usage;
    D3DPOOL Pool;
    UINT Width;
    UINT Height;
    UINT Depth;
} D3DVOLUME_DESC;
typedef struct _D3DLOCKED_RECT {
    INT Pitch;
    void* pBits;
} D3DLOCKED_RECT;
typedef struct _D3DBOX {
    UINT Left;
    UINT Top;
    UINT Right;
    UINT Bottom;
    UINT Front;
    UINT Back;
} D3DBOX;
typedef struct _D3DLOCKED_BOX {
    INT RowPitch;
    INT SlicePitch;
    void* pBits;
} D3DLOCKED_BOX;
typedef struct _D3DRANGE {
    UINT Offset;
    UINT Size;
} D3DRANGE;
typedef struct _D3DRECTPATCH_INFO {
    UINT StartVertexOffsetWidth;
    UINT StartVertexOffsetHeight;
    UINT Width;
    UINT Height;
    UINT Stride;
    D3DBASISTYPE Basis;
    D3DDEGREETYPE Degree;
} D3DRECTPATCH_INFO;
typedef struct _D3DTRIPATCH_INFO {
    UINT StartVertexOffset;
    UINT NumVertices;
    D3DBASISTYPE Basis;
    D3DDEGREETYPE Degree;
} D3DTRIPATCH_INFO;
typedef struct _D3DADAPTER_IDENTIFIER9 {
    char Driver[512];
    char Description[512];
    char DeviceName[32];
    LARGE_INTEGER DriverVersion;
    DWORD VendorId;
    DWORD DeviceId;
    DWORD SubSysId;
    DWORD Revision;
    GUID DeviceIdentifier;
    DWORD WHQLLevel;
} D3DADAPTER_IDENTIFIER9;
typedef struct _D3DRASTER_STATUS {
    BOOL InVBlank;
    UINT ScanLine;
} D3DRASTER_STATUS;
typedef enum _D3DDEBUGMONITORTOKENS {
    D3DDMT_ENABLE = 0,
    D3DDMT_DISABLE = 1,
    D3DDMT_FORCE_DWORD = 0x7fffffff,
} D3DDEBUGMONITORTOKENS;
typedef enum _D3DQUERYTYPE {
    D3DQUERYTYPE_VCACHE = 4,
    D3DQUERYTYPE_RESOURCEMANAGER = 5,
    D3DQUERYTYPE_VERTEXSTATS = 6,
    D3DQUERYTYPE_EVENT = 8,
    D3DQUERYTYPE_OCCLUSION = 9,
    D3DQUERYTYPE_TIMESTAMP = 10,
    D3DQUERYTYPE_TIMESTAMPDISJOINT = 11,
    D3DQUERYTYPE_TIMESTAMPFREQ = 12,
    D3DQUERYTYPE_PIPELINETIMINGS = 13,
    D3DQUERYTYPE_INTERFACETIMINGS = 14,
    D3DQUERYTYPE_VERTEXTIMINGS = 15,
    D3DQUERYTYPE_PIXELTIMINGS = 16,
    D3DQUERYTYPE_BANDWIDTHTIMINGS = 17,
    D3DQUERYTYPE_CACHEUTILIZATION = 18,
    D3DQUERYTYPE_MEMORYPRESSURE = 19,
} D3DQUERYTYPE;
typedef struct _D3DRESOURCESTATS {
    BOOL bThrashing;
    DWORD ApproxBytesDownloaded;
    DWORD NumEvicts;
    DWORD NumVidCreates;
    DWORD LastPri;
    DWORD NumUsed;
    DWORD NumUsedInVidMem;
    DWORD WorkingSet;
    DWORD WorkingSetBytes;
    DWORD TotalManaged;
    DWORD TotalBytes;
} D3DRESOURCESTATS;
typedef struct _D3DDEVINFO_RESOURCEMANAGER {
    D3DRESOURCESTATS stats[(D3DRTYPE_INDEXBUFFER + 1)];
} D3DDEVINFO_RESOURCEMANAGER, *LPD3DDEVINFO_RESOURCEMANAGER;
typedef struct _D3DDEVINFO_D3DVERTEXSTATS {
    DWORD NumRenderedTriangles;
    DWORD NumExtraClippingTriangles;
} D3DDEVINFO_D3DVERTEXSTATS, *LPD3DDEVINFO_D3DVERTEXSTATS;
typedef struct _D3DDEVINFO_VCACHE {
    DWORD Pattern;
    DWORD OptMethod;
    DWORD CacheSize;
    DWORD MagicNumber;
} D3DDEVINFO_VCACHE, *LPD3DDEVINFO_VCACHE;
typedef struct _D3DDEVINFO_D3D9PIPELINETIMINGS {
    FLOAT VertexProcessingTimePercent;
    FLOAT PixelProcessingTimePercent;
    FLOAT OtherGPUProcessingTimePercent;
    FLOAT GPUIdleTimePercent;
} D3DDEVINFO_D3D9PIPELINETIMINGS;
typedef struct _D3DDEVINFO_D3D9INTERFACETIMINGS {
    FLOAT WaitingForGPUToUseApplicationResourceTimePercent;
    FLOAT WaitingForGPUToAcceptMoreCommandsTimePercent;
    FLOAT WaitingForGPUToStayWithinLatencyTimePercent;
    FLOAT WaitingForGPUExclusiveResourceTimePercent;
    FLOAT WaitingForGPUOtherTimePercent;
} D3DDEVINFO_D3D9INTERFACETIMINGS;
typedef struct _D3DDEVINFO_D3D9STAGETIMINGS {
    FLOAT MemoryProcessingPercent;
    FLOAT ComputationProcessingPercent;
} D3DDEVINFO_D3D9STAGETIMINGS;
typedef struct _D3DDEVINFO_D3D9BANDWIDTHTIMINGS {
    FLOAT MaxBandwidthUtilized;
    FLOAT FrontEndUploadMemoryUtilizedPercent;
    FLOAT VertexRateUtilizedPercent;
    FLOAT TriangleSetupRateUtilizedPercent;
    FLOAT FillRateUtilizedPercent;
} D3DDEVINFO_D3D9BANDWIDTHTIMINGS;
typedef struct _D3DDEVINFO_D3D9CACHEUTILIZATION {
    FLOAT TextureCacheHitRate;
    FLOAT PostTransformVertexCacheHitRate;
} D3DDEVINFO_D3D9CACHEUTILIZATION;
typedef struct _D3DMEMORYPRESSURE {
    UINT64 BytesEvictedFromProcess;
    UINT64 SizeOfInefficientAllocation;
    DWORD LevelOfEfficiency;
} D3DMEMORYPRESSURE;
typedef enum _D3DCOMPOSERECTSOP {
    D3DCOMPOSERECTS_COPY = 1,
    D3DCOMPOSERECTS_OR = 2,
    D3DCOMPOSERECTS_AND = 3,
    D3DCOMPOSERECTS_NEG = 4,
    D3DCOMPOSERECTS_FORCE_DWORD = 0x7fffffff,
} D3DCOMPOSERECTSOP;
typedef struct _D3DCOMPOSERECTDESC {
    USHORT X, Y;
    USHORT Width, Height;
} D3DCOMPOSERECTDESC;
typedef struct _D3DCOMPOSERECTDESTINATION {
    USHORT SrcRectIndex;
    USHORT Reserved;
    SHORT X, Y;
} D3DCOMPOSERECTDESTINATION;
typedef struct _D3DPRESENTSTATS {
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
} D3DPRESENTSTATS;
typedef enum D3DSCANLINEORDERING {
    D3DSCANLINEORDERING_UNKNOWN = 0,
    D3DSCANLINEORDERING_PROGRESSIVE = 1,
    D3DSCANLINEORDERING_INTERLACED = 2,
} D3DSCANLINEORDERING;
typedef struct D3DDISPLAYMODEEX {
    UINT Size;
    UINT Width;
    UINT Height;
    UINT RefreshRate;
    D3DFORMAT Format;
    D3DSCANLINEORDERING ScanLineOrdering;
} D3DDISPLAYMODEEX;
typedef struct D3DDISPLAYMODEFILTER {
    UINT Size;
    D3DFORMAT Format;
    D3DSCANLINEORDERING ScanLineOrdering;
} D3DDISPLAYMODEFILTER;
typedef enum D3DDISPLAYROTATION {
    D3DDISPLAYROTATION_IDENTITY = 1,
    D3DDISPLAYROTATION_90 = 2,
    D3DDISPLAYROTATION_180 = 3,
    D3DDISPLAYROTATION_270 = 4
} D3DDISPLAYROTATION;
typedef struct _D3D_OMAC {
    BYTE Omac[16];
} D3D_OMAC;
typedef enum _D3DAUTHENTICATEDCHANNELTYPE {
    D3DAUTHENTICATEDCHANNEL_D3D9 = 1,
    D3DAUTHENTICATEDCHANNEL_DRIVER_SOFTWARE = 2,
    D3DAUTHENTICATEDCHANNEL_DRIVER_HARDWARE = 3,
} D3DAUTHENTICATEDCHANNELTYPE;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERY_INPUT {
    GUID QueryType;
    HANDLE hChannel;
    UINT SequenceNumber;
} D3DAUTHENTICATEDCHANNEL_QUERY_INPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT {
    D3D_OMAC omac;
    GUID QueryType;
    HANDLE hChannel;
    UINT SequenceNumber;
    HRESULT ReturnCode;
} D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_PROTECTION;
typedef struct _D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS {
    union {
        struct
        {
            UINT ProtectionEnabled : 1;
            UINT OverlayOrFullscreenRequired : 1;
            UINT Reserved : 30;
        };
        UINT Value;
    };
} D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYPROTECTION_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS ProtectionFlags;
} D3DAUTHENTICATEDCHANNEL_QUERYPROTECTION_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_CHANNELTYPE;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYCHANNELTYPE_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    D3DAUTHENTICATEDCHANNELTYPE ChannelType;
} D3DAUTHENTICATEDCHANNEL_QUERYCHANNELTYPE_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_DEVICEHANDLE;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYDEVICEHANDLE_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    HANDLE DeviceHandle;
} D3DAUTHENTICATEDCHANNEL_QUERYDEVICEHANDLE_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_CRYPTOSESSION;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_INPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
    HANDLE DXVA2DecodeHandle;
} D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_INPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    HANDLE DXVA2DecodeHandle;
    HANDLE CryptoSessionHandle;
    HANDLE DeviceHandle;
} D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_RESTRICTEDSHAREDRESOURCEPROCESSCOUNT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESSCOUNT_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    UINT NumRestrictedSharedResourceProcesses;
} D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESSCOUNT_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_RESTRICTEDSHAREDRESOURCEPROCESS;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_INPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
    UINT ProcessIndex;
} D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_INPUT;
typedef enum _D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE {
    PROCESSIDTYPE_UNKNOWN = 0,
    PROCESSIDTYPE_DWM = 1,
    PROCESSIDTYPE_HANDLE = 2
} D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    UINT ProcessIndex;
    D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE ProcessIdentifer;
    HANDLE ProcessHandle;
} D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_UNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYUNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    UINT NumUnrestrictedProtectedSharedResources;
} D3DAUTHENTICATEDCHANNEL_QUERYUNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_OUTPUTIDCOUNT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_INPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_INPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
    UINT NumOutputIDs;
} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_OUTPUTID;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_INPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
    UINT OutputIDIndex;
} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_INPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
    UINT OutputIDIndex;
    UINT64 OutputID;
} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_ACCESSIBILITYATTRIBUTES;
typedef enum _D3DBUSTYPE {
    D3DBUSTYPE_OTHER = 0x00000000,
    D3DBUSTYPE_PCI = 0x00000001,
    D3DBUSTYPE_PCIX = 0x00000002,
    D3DBUSTYPE_PCIEXPRESS = 0x00000003,
    D3DBUSTYPE_AGP = 0x00000004,
    D3DBUSIMPL_MODIFIER_INSIDE_OF_CHIPSET = 0x00010000,
    D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = 0x00020000,
    D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 0x00030000,
    D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR = 0x00040000,
    D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 0x00050000,
    D3DBUSIMPL_MODIFIER_NON_STANDARD = 0x80000000,
} D3DBUSTYPE;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYINFOBUSTYPE_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    D3DBUSTYPE BusType;
    BOOL bAccessibleInContiguousBlocks;
    BOOL bAccessibleInNonContiguousBlocks;
} D3DAUTHENTICATEDCHANNEL_QUERYINFOBUSTYPE_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_ENCRYPTIONWHENACCESSIBLEGUIDCOUNT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUIDCOUNT_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    UINT NumEncryptionGuids;
} D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUIDCOUNT_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_ENCRYPTIONWHENACCESSIBLEGUID;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_INPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
    UINT EncryptionGuidIndex;
} D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_INPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    UINT EncryptionGuidIndex;
    GUID EncryptionGuid;
} D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDQUERY_CURRENTENCRYPTIONWHENACCESSIBLE;
typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYUNCOMPRESSEDENCRYPTIONLEVEL_OUTPUT {
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
    GUID EncryptionGuid;
} D3DAUTHENTICATEDCHANNEL_QUERYUNCOMPRESSEDENCRYPTIONLEVEL_OUTPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT {
    D3D_OMAC omac;
    GUID ConfigureType;
    HANDLE hChannel;
    UINT SequenceNumber;
} D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT {
    D3D_OMAC omac;
    GUID ConfigureType;
    HANDLE hChannel;
    UINT SequenceNumber;
    HRESULT ReturnCode;
} D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT;
extern "C" const GUID D3DAUTHENTICATEDCONFIGURE_INITIALIZE;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGUREINITIALIZE {
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT Parameters;
    UINT StartSequenceQuery;
    UINT StartSequenceConfigure;
} D3DAUTHENTICATEDCHANNEL_CONFIGUREINITIALIZE;
extern "C" const GUID D3DAUTHENTICATEDCONFIGURE_PROTECTION;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGUREPROTECTION {
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT Parameters;
    D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS Protections;
} D3DAUTHENTICATEDCHANNEL_CONFIGUREPROTECTION;
extern "C" const GUID D3DAUTHENTICATEDCONFIGURE_CRYPTOSESSION;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURECRYPTOSESSION {
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT Parameters;
    HANDLE DXVA2DecodeHandle;
    HANDLE CryptoSessionHandle;
    HANDLE DeviceHandle;
} D3DAUTHENTICATEDCHANNEL_CONFIGURECRYPTOSESSION;
extern "C" const GUID D3DAUTHENTICATEDCONFIGURE_SHAREDRESOURCE;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURESHAREDRESOURCE {
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT Parameters;
    D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE ProcessIdentiferType;
    HANDLE ProcessHandle;
    BOOL AllowAccess;
} D3DAUTHENTICATEDCHANNEL_CONFIGURESHAREDRESOURCE;
extern "C" const GUID D3DAUTHENTICATEDCONFIGURE_ENCRYPTIONWHENACCESSIBLE;
typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGUREUNCOMPRESSEDENCRYPTION {
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT Parameters;
    GUID EncryptionGuid;
} D3DAUTHENTICATEDCHANNEL_CONFIGUREUNCOMPRESSEDENCRYPTION;
typedef struct _D3DENCRYPTED_BLOCK_INFO {
    UINT NumEncryptedBytesAtBeginning;
    UINT NumBytesInSkipPattern;
    UINT NumBytesInEncryptPattern;
} D3DENCRYPTED_BLOCK_INFO;
typedef struct _D3DAES_CTR_IV {
    UINT64 IV;
    UINT64 Count;
} D3DAES_CTR_IV;
#pragma pack()
#pragma warning(pop)
#pragma endregion
#pragma region Desktop Family
typedef struct _D3DVSHADERCAPS2_0 {
    DWORD Caps;
    INT DynamicFlowControlDepth;
    INT NumTemps;
    INT StaticFlowControlDepth;
} D3DVSHADERCAPS2_0;
typedef struct _D3DPSHADERCAPS2_0 {
    DWORD Caps;
    INT DynamicFlowControlDepth;
    INT NumTemps;
    INT StaticFlowControlDepth;
    INT NumInstructionSlots;
} D3DPSHADERCAPS2_0;
typedef struct _D3DOVERLAYCAPS {
    UINT Caps;
    UINT MaxOverlayDisplayWidth;
    UINT MaxOverlayDisplayHeight;
} D3DOVERLAYCAPS;
typedef struct _D3DCONTENTPROTECTIONCAPS {
    DWORD Caps;
    GUID KeyExchangeType;
    UINT BufferAlignmentStart;
    UINT BlockAlignmentSize;
    ULONGLONG ProtectedMemorySize;
} D3DCONTENTPROTECTIONCAPS;
extern "C" const GUID D3DCRYPTOTYPE_AES128_CTR;
extern "C" const GUID D3DCRYPTOTYPE_PROPRIETARY;
extern "C" const GUID D3DKEYEXCHANGE_RSAES_OAEP;
extern "C" const GUID D3DKEYEXCHANGE_DXVA;
typedef struct _D3DCAPS9 {
    D3DDEVTYPE DeviceType;
    UINT AdapterOrdinal;
    DWORD Caps;
    DWORD Caps2;
    DWORD Caps3;
    DWORD PresentationIntervals;
    DWORD CursorCaps;
    DWORD DevCaps;
    DWORD PrimitiveMiscCaps;
    DWORD RasterCaps;
    DWORD ZCmpCaps;
    DWORD SrcBlendCaps;
    DWORD DestBlendCaps;
    DWORD AlphaCmpCaps;
    DWORD ShadeCaps;
    DWORD TextureCaps;
    DWORD TextureFilterCaps;
    DWORD CubeTextureFilterCaps;
    DWORD VolumeTextureFilterCaps;
    DWORD TextureAddressCaps;
    DWORD VolumeTextureAddressCaps;
    DWORD LineCaps;
    DWORD MaxTextureWidth;
        DWORD    MaxTextureHeight;
    DWORD MaxVolumeExtent;
    DWORD MaxTextureRepeat;
    DWORD MaxTextureAspectRatio;
    DWORD MaxAnisotropy;
    float MaxVertexW;
    float GuardBandLeft;
    float GuardBandTop;
    float GuardBandRight;
    float GuardBandBottom;
    float ExtentsAdjust;
    DWORD StencilCaps;
    DWORD FVFCaps;
    DWORD TextureOpCaps;
    DWORD MaxTextureBlendStages;
    DWORD MaxSimultaneousTextures;
    DWORD VertexProcessingCaps;
    DWORD MaxActiveLights;
    DWORD MaxUserClipPlanes;
    DWORD MaxVertexBlendMatrices;
    DWORD MaxVertexBlendMatrixIndex;
    float MaxPointSize;
    DWORD MaxPrimitiveCount;
    DWORD MaxVertexIndex;
    DWORD MaxStreams;
    DWORD MaxStreamStride;
    DWORD VertexShaderVersion;
    DWORD MaxVertexShaderConst;
    DWORD PixelShaderVersion;
    float PixelShader1xMaxValue;
    DWORD DevCaps2;
    float MaxNpatchTessellationLevel;
    DWORD Reserved5;
    UINT MasterAdapterOrdinal;
    UINT AdapterOrdinalInGroup;
    UINT NumberOfAdaptersInGroup;
    DWORD DeclTypes;
    DWORD NumSimultaneousRTs;
    DWORD StretchRectFilterCaps;
    D3DVSHADERCAPS2_0 VS20Caps;
    D3DPSHADERCAPS2_0 PS20Caps;
    DWORD VertexTextureFilterCaps;
    DWORD MaxVShaderInstructionsExecuted;
    DWORD MaxPShaderInstructionsExecuted;
    DWORD MaxVertexShader30InstructionSlots;
    DWORD MaxPixelShader30InstructionSlots;
} D3DCAPS9;
#pragma pack()
#pragma endregion
extern "C" {
IDirect3D9* __stdcall Direct3DCreate9(UINT SDKVersion);
int __stdcall D3DPERF_BeginEvent(D3DCOLOR col, LPCWSTR wszName);
int __stdcall D3DPERF_EndEvent(void);
void __stdcall D3DPERF_SetMarker(D3DCOLOR col, LPCWSTR wszName);
void __stdcall D3DPERF_SetRegion(D3DCOLOR col, LPCWSTR wszName);
BOOL __stdcall D3DPERF_QueryRepeatFrame(void);
void __stdcall D3DPERF_SetOptions(DWORD dwOptions);
DWORD __stdcall D3DPERF_GetStatus(void);
struct __declspec(novtable) IDirect3D9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterSoftwareDevice(void* pInitializeFunction) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAdapterCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER9* pIdentifier) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAdapterModeCount(UINT Adapter, D3DFORMAT Format) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EnumAdapterModes(UINT Adapter, D3DFORMAT Format, UINT Mode, D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceType(UINT Adapter, D3DDEVTYPE DevType, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, BOOL bWindowed) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD* pQualityLevels) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceFormatConversion(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SourceFormat, D3DFORMAT TargetFormat) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeviceCaps(UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS9* pCaps) = 0;
    virtual __declspec(nothrow) HMONITOR __stdcall GetAdapterMonitor(UINT Adapter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface) = 0;
};
typedef struct IDirect3D9 *LPDIRECT3D9, *PDIRECT3D9;
struct __declspec(novtable) IDirect3DDevice9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall TestCooperativeLevel(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAvailableTextureMem(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EvictManagedResources(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDirect3D(IDirect3D9** ppD3D9) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeviceCaps(D3DCAPS9* pCaps) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplayMode(UINT iSwapChain, D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS* pParameters) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetCursorProperties(UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap) = 0;
    virtual __declspec(nothrow) void __stdcall SetCursorPosition(int X, int Y, DWORD Flags) = 0;
    virtual __declspec(nothrow) BOOL __stdcall ShowCursor(BOOL bShow) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateAdditionalSwapChain(D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSwapChain(UINT iSwapChain, IDirect3DSwapChain9** pSwapChain) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumberOfSwapChains(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Reset(D3DPRESENT_PARAMETERS* pPresentationParameters) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Present(const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackBuffer(UINT iSwapChain, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRasterStatus(UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDialogBoxMode(BOOL bEnableDialogs) = 0;
    virtual __declspec(nothrow) void __stdcall SetGammaRamp(UINT iSwapChain, DWORD Flags, const D3DGAMMARAMP* pRamp) = 0;
    virtual __declspec(nothrow) void __stdcall GetGammaRamp(UINT iSwapChain, D3DGAMMARAMP* pRamp) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateSurface(IDirect3DSurface9* pSourceSurface, const RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, const POINT* pDestPoint) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateTexture(IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderTargetData(IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFrontBufferData(UINT iSwapChain, IDirect3DSurface9* pDestSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall StretchRect(IDirect3DSurface9* pSourceSurface, const RECT* pSourceRect, IDirect3DSurface9* pDestSurface, const RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ColorFill(IDirect3DSurface9* pSurface, const RECT* pRect, D3DCOLOR color) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateOffscreenPlainSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderTarget(DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderTarget(DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDepthStencilSurface(IDirect3DSurface9* pNewZStencil) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDepthStencilSurface(IDirect3DSurface9** ppZStencilSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginScene(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EndScene(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Clear(DWORD Count, const D3DRECT* pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTransform(D3DTRANSFORMSTATETYPE State, const D3DMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall MultiplyTransform(D3DTRANSFORMSTATETYPE, const D3DMATRIX*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetViewport(const D3DVIEWPORT9* pViewport) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetViewport(D3DVIEWPORT9* pViewport) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMaterial(const D3DMATERIAL9* pMaterial) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMaterial(D3DMATERIAL9* pMaterial) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetLight(DWORD Index, const D3DLIGHT9*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLight(DWORD Index, D3DLIGHT9*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LightEnable(DWORD Index, BOOL Enable) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLightEnable(DWORD Index, BOOL* pEnable) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetClipPlane(DWORD Index, const float* pPlane) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetClipPlane(DWORD Index, float* pPlane) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderState(D3DRENDERSTATETYPE State, DWORD* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateStateBlock(D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginStateBlock(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EndStateBlock(IDirect3DStateBlock9** ppSB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetClipStatus(const D3DCLIPSTATUS9* pClipStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetClipStatus(D3DCLIPSTATUS9* pClipStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTexture(DWORD Stage, IDirect3DBaseTexture9** ppTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexture(DWORD Stage, IDirect3DBaseTexture9* pTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSamplerState(DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetSamplerState(DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ValidateDevice(DWORD* pNumPasses) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPaletteEntries(UINT PaletteNumber, const PALETTEENTRY* pEntries) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY* pEntries) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetCurrentTexturePalette(UINT PaletteNumber) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCurrentTexturePalette(UINT* PaletteNumber) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetScissorRect(const RECT* pRect) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetScissorRect(RECT* pRect) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetSoftwareVertexProcessing(BOOL bSoftware) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetSoftwareVertexProcessing(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetNPatchMode(float nSegments) = 0;
    virtual __declspec(nothrow) float __stdcall GetNPatchMode(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawIndexedPrimitive(D3DPRIMITIVETYPE, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, const void* pVertexStreamZeroData, UINT VertexStreamZeroStride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertices, UINT PrimitiveCount, const void* pIndexData, D3DFORMAT IndexDataFormat, const void* pVertexStreamZeroData, UINT VertexStreamZeroStride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVertexDeclaration(const D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexDeclaration(IDirect3DVertexDeclaration9* pDecl) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexDeclaration(IDirect3DVertexDeclaration9** ppDecl) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFVF(DWORD FVF) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFVF(DWORD* pFVF) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVertexShader(const DWORD* pFunction, IDirect3DVertexShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShader(IDirect3DVertexShader9* pShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShader(IDirect3DVertexShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantF(UINT StartRegister, const float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderConstantF(UINT StartRegister, float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantI(UINT StartRegister, const int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderConstantI(UINT StartRegister, int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantB(UINT StartRegister, const BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderConstantB(UINT StartRegister, BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* pOffsetInBytes, UINT* pStride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetStreamSourceFreq(UINT StreamNumber, UINT Setting) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetStreamSourceFreq(UINT StreamNumber, UINT* pSetting) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIndices(IDirect3DIndexBuffer9* pIndexData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndices(IDirect3DIndexBuffer9** ppIndexData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreatePixelShader(const DWORD* pFunction, IDirect3DPixelShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShader(IDirect3DPixelShader9* pShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShader(IDirect3DPixelShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantF(UINT StartRegister, const float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderConstantF(UINT StartRegister, float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantI(UINT StartRegister, const int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderConstantI(UINT StartRegister, int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantB(UINT StartRegister, const BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderConstantB(UINT StartRegister, BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawRectPatch(UINT Handle, const float* pNumSegs, const D3DRECTPATCH_INFO* pRectPatchInfo) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawTriPatch(UINT Handle, const float* pNumSegs, const D3DTRIPATCH_INFO* pTriPatchInfo) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DeletePatch(UINT Handle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateQuery(D3DQUERYTYPE Type, IDirect3DQuery9** ppQuery) = 0;
};
typedef struct IDirect3DDevice9 *LPDIRECT3DDEVICE9, *PDIRECT3DDEVICE9;
struct __declspec(novtable) IDirect3DStateBlock9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Capture(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Apply(void) = 0;
};
typedef struct IDirect3DStateBlock9 *LPDIRECT3DSTATEBLOCK9, *PDIRECT3DSTATEBLOCK9;
struct __declspec(novtable) IDirect3DSwapChain9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Present(const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion, DWORD dwFlags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFrontBufferData(IDirect3DSurface9* pDestSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackBuffer(UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRasterStatus(D3DRASTER_STATUS* pRasterStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplayMode(D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPresentParameters(D3DPRESENT_PARAMETERS* pPresentationParameters) = 0;
};
typedef struct IDirect3DSwapChain9 *LPDIRECT3DSWAPCHAIN9, *PDIRECT3DSWAPCHAIN9;
struct __declspec(novtable) IDirect3DResource9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
};
typedef struct IDirect3DResource9 *LPDIRECT3DRESOURCE9, *PDIRECT3DRESOURCE9;
struct __declspec(novtable) IDirect3DVertexDeclaration9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9* pElement, UINT* pNumElements) = 0;
};
typedef struct IDirect3DVertexDeclaration9 *LPDIRECT3DVERTEXDECLARATION9, *PDIRECT3DVERTEXDECLARATION9;
struct __declspec(novtable) IDirect3DVertexShader9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFunction(void*, UINT* pSizeOfData) = 0;
};
typedef struct IDirect3DVertexShader9 *LPDIRECT3DVERTEXSHADER9, *PDIRECT3DVERTEXSHADER9;
struct __declspec(novtable) IDirect3DPixelShader9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFunction(void*, UINT* pSizeOfData) = 0;
};
typedef struct IDirect3DPixelShader9 *LPDIRECT3DPIXELSHADER9, *PDIRECT3DPIXELSHADER9;
struct __declspec(novtable) IDirect3DBaseTexture9 : public IDirect3DResource9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetLOD(DWORD LODNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLOD(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLevelCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAutoGenFilterType(D3DTEXTUREFILTERTYPE FilterType) = 0;
    virtual __declspec(nothrow) D3DTEXTUREFILTERTYPE __stdcall GetAutoGenFilterType(void) = 0;
    virtual __declspec(nothrow) void __stdcall GenerateMipSubLevels(void) = 0;
};
typedef struct IDirect3DBaseTexture9 *LPDIRECT3DBASETEXTURE9, *PDIRECT3DBASETEXTURE9;
struct __declspec(novtable) IDirect3DTexture9 : public IDirect3DBaseTexture9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetLOD(DWORD LODNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLOD(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLevelCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAutoGenFilterType(D3DTEXTUREFILTERTYPE FilterType) = 0;
    virtual __declspec(nothrow) D3DTEXTUREFILTERTYPE __stdcall GetAutoGenFilterType(void) = 0;
    virtual __declspec(nothrow) void __stdcall GenerateMipSubLevels(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLevelDesc(UINT Level, D3DSURFACE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSurfaceLevel(UINT Level, IDirect3DSurface9** ppSurfaceLevel) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockRect(UINT Level, D3DLOCKED_RECT* pLockedRect, const RECT* pRect, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockRect(UINT Level) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddDirtyRect(const RECT* pDirtyRect) = 0;
};
typedef struct IDirect3DTexture9 *LPDIRECT3DTEXTURE9, *PDIRECT3DTEXTURE9;
struct __declspec(novtable) IDirect3DVolumeTexture9 : public IDirect3DBaseTexture9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetLOD(DWORD LODNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLOD(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLevelCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAutoGenFilterType(D3DTEXTUREFILTERTYPE FilterType) = 0;
    virtual __declspec(nothrow) D3DTEXTUREFILTERTYPE __stdcall GetAutoGenFilterType(void) = 0;
    virtual __declspec(nothrow) void __stdcall GenerateMipSubLevels(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLevelDesc(UINT Level, D3DVOLUME_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVolumeLevel(UINT Level, IDirect3DVolume9** ppVolumeLevel) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockBox(UINT Level, D3DLOCKED_BOX* pLockedVolume, const D3DBOX* pBox, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockBox(UINT Level) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddDirtyBox(const D3DBOX* pDirtyBox) = 0;
};
typedef struct IDirect3DVolumeTexture9 *LPDIRECT3DVOLUMETEXTURE9, *PDIRECT3DVOLUMETEXTURE9;
struct __declspec(novtable) IDirect3DCubeTexture9 : public IDirect3DBaseTexture9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetLOD(DWORD LODNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLOD(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetLevelCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAutoGenFilterType(D3DTEXTUREFILTERTYPE FilterType) = 0;
    virtual __declspec(nothrow) D3DTEXTUREFILTERTYPE __stdcall GetAutoGenFilterType(void) = 0;
    virtual __declspec(nothrow) void __stdcall GenerateMipSubLevels(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLevelDesc(UINT Level, D3DSURFACE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, IDirect3DSurface9** ppCubeMapSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT* pLockedRect, const RECT* pRect, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddDirtyRect(D3DCUBEMAP_FACES FaceType, const RECT* pDirtyRect) = 0;
};
typedef struct IDirect3DCubeTexture9 *LPDIRECT3DCUBETEXTURE9, *PDIRECT3DCUBETEXTURE9;
struct __declspec(novtable) IDirect3DVertexBuffer9 : public IDirect3DResource9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Lock(UINT OffsetToLock, UINT SizeToLock, void** ppbData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Unlock(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DVERTEXBUFFER_DESC* pDesc) = 0;
};
typedef struct IDirect3DVertexBuffer9 *LPDIRECT3DVERTEXBUFFER9, *PDIRECT3DVERTEXBUFFER9;
struct __declspec(novtable) IDirect3DIndexBuffer9 : public IDirect3DResource9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Lock(UINT OffsetToLock, UINT SizeToLock, void** ppbData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Unlock(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DINDEXBUFFER_DESC* pDesc) = 0;
};
typedef struct IDirect3DIndexBuffer9 *LPDIRECT3DINDEXBUFFER9, *PDIRECT3DINDEXBUFFER9;
struct __declspec(novtable) IDirect3DSurface9 : public IDirect3DResource9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) DWORD __stdcall SetPriority(DWORD PriorityNew) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPriority(void) = 0;
    virtual __declspec(nothrow) void __stdcall PreLoad(void) = 0;
    virtual __declspec(nothrow) D3DRESOURCETYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetContainer(const IID& riid, void** ppContainer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DSURFACE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockRect(D3DLOCKED_RECT* pLockedRect, const RECT* pRect, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockRect(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDC(HDC* phdc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ReleaseDC(HDC hdc) = 0;
};
typedef struct IDirect3DSurface9 *LPDIRECT3DSURFACE9, *PDIRECT3DSURFACE9;
struct __declspec(novtable) IDirect3DVolume9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPrivateData(const GUID& refguid, const void* pData, DWORD SizeOfData, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPrivateData(const GUID& refguid, void* pData, DWORD* pSizeOfData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreePrivateData(const GUID& refguid) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetContainer(const IID& riid, void** ppContainer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DVOLUME_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockBox(D3DLOCKED_BOX* pLockedVolume, const D3DBOX* pBox, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockBox(void) = 0;
};
typedef struct IDirect3DVolume9 *LPDIRECT3DVOLUME9, *PDIRECT3DVOLUME9;
struct __declspec(novtable) IDirect3DQuery9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) D3DQUERYTYPE __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetDataSize(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Issue(DWORD dwIssueFlags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetData(void* pData, DWORD dwSize, DWORD dwGetDataFlags) = 0;
};
typedef struct IDirect3DQuery9 *LPDIRECT3DQUERY9, *PDIRECT3DQUERY9;
HRESULT __stdcall Direct3DCreate9Ex(UINT SDKVersion, IDirect3D9Ex**);
struct __declspec(novtable) IDirect3D9Ex : public IDirect3D9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterSoftwareDevice(void* pInitializeFunction) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAdapterCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER9* pIdentifier) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAdapterModeCount(UINT Adapter, D3DFORMAT Format) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EnumAdapterModes(UINT Adapter, D3DFORMAT Format, UINT Mode, D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceType(UINT Adapter, D3DDEVTYPE DevType, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, BOOL bWindowed) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD* pQualityLevels) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceFormatConversion(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SourceFormat, D3DFORMAT TargetFormat) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeviceCaps(UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS9* pCaps) = 0;
    virtual __declspec(nothrow) HMONITOR __stdcall GetAdapterMonitor(UINT Adapter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAdapterModeCountEx(UINT Adapter, const D3DDISPLAYMODEFILTER* pFilter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EnumAdapterModesEx(UINT Adapter, const D3DDISPLAYMODEFILTER* pFilter, UINT Mode, D3DDISPLAYMODEEX* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdapterDisplayModeEx(UINT Adapter, D3DDISPLAYMODEEX* pMode, D3DDISPLAYROTATION* pRotation) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDeviceEx(UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, D3DDISPLAYMODEEX* pFullscreenDisplayMode, IDirect3DDevice9Ex** ppReturnedDeviceInterface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdapterLUID(UINT Adapter, LUID* pLUID) = 0;
};
typedef struct IDirect3D9Ex *LPDIRECT3D9EX, *PDIRECT3D9EX;
struct __declspec(novtable) IDirect3DDevice9Ex : public IDirect3DDevice9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall TestCooperativeLevel(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetAvailableTextureMem(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EvictManagedResources(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDirect3D(IDirect3D9** ppD3D9) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeviceCaps(D3DCAPS9* pCaps) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplayMode(UINT iSwapChain, D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS* pParameters) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetCursorProperties(UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap) = 0;
    virtual __declspec(nothrow) void __stdcall SetCursorPosition(int X, int Y, DWORD Flags) = 0;
    virtual __declspec(nothrow) BOOL __stdcall ShowCursor(BOOL bShow) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateAdditionalSwapChain(D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSwapChain(UINT iSwapChain, IDirect3DSwapChain9** pSwapChain) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumberOfSwapChains(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Reset(D3DPRESENT_PARAMETERS* pPresentationParameters) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Present(const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackBuffer(UINT iSwapChain, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRasterStatus(UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDialogBoxMode(BOOL bEnableDialogs) = 0;
    virtual __declspec(nothrow) void __stdcall SetGammaRamp(UINT iSwapChain, DWORD Flags, const D3DGAMMARAMP* pRamp) = 0;
    virtual __declspec(nothrow) void __stdcall GetGammaRamp(UINT iSwapChain, D3DGAMMARAMP* pRamp) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateSurface(IDirect3DSurface9* pSourceSurface, const RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, const POINT* pDestPoint) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateTexture(IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderTargetData(IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFrontBufferData(UINT iSwapChain, IDirect3DSurface9* pDestSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall StretchRect(IDirect3DSurface9* pSourceSurface, const RECT* pSourceRect, IDirect3DSurface9* pDestSurface, const RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ColorFill(IDirect3DSurface9* pSurface, const RECT* pRect, D3DCOLOR color) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateOffscreenPlainSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderTarget(DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderTarget(DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDepthStencilSurface(IDirect3DSurface9* pNewZStencil) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDepthStencilSurface(IDirect3DSurface9** ppZStencilSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginScene(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EndScene(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Clear(DWORD Count, const D3DRECT* pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTransform(D3DTRANSFORMSTATETYPE State, const D3DMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall MultiplyTransform(D3DTRANSFORMSTATETYPE, const D3DMATRIX*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetViewport(const D3DVIEWPORT9* pViewport) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetViewport(D3DVIEWPORT9* pViewport) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMaterial(const D3DMATERIAL9* pMaterial) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMaterial(D3DMATERIAL9* pMaterial) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetLight(DWORD Index, const D3DLIGHT9*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLight(DWORD Index, D3DLIGHT9*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LightEnable(DWORD Index, BOOL Enable) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLightEnable(DWORD Index, BOOL* pEnable) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetClipPlane(DWORD Index, const float* pPlane) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetClipPlane(DWORD Index, float* pPlane) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderState(D3DRENDERSTATETYPE State, DWORD* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateStateBlock(D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginStateBlock(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EndStateBlock(IDirect3DStateBlock9** ppSB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetClipStatus(const D3DCLIPSTATUS9* pClipStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetClipStatus(D3DCLIPSTATUS9* pClipStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTexture(DWORD Stage, IDirect3DBaseTexture9** ppTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexture(DWORD Stage, IDirect3DBaseTexture9* pTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSamplerState(DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetSamplerState(DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ValidateDevice(DWORD* pNumPasses) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPaletteEntries(UINT PaletteNumber, const PALETTEENTRY* pEntries) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY* pEntries) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetCurrentTexturePalette(UINT PaletteNumber) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCurrentTexturePalette(UINT* PaletteNumber) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetScissorRect(const RECT* pRect) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetScissorRect(RECT* pRect) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetSoftwareVertexProcessing(BOOL bSoftware) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetSoftwareVertexProcessing(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetNPatchMode(float nSegments) = 0;
    virtual __declspec(nothrow) float __stdcall GetNPatchMode(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawIndexedPrimitive(D3DPRIMITIVETYPE, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, const void* pVertexStreamZeroData, UINT VertexStreamZeroStride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertices, UINT PrimitiveCount, const void* pIndexData, D3DFORMAT IndexDataFormat, const void* pVertexStreamZeroData, UINT VertexStreamZeroStride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVertexDeclaration(const D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexDeclaration(IDirect3DVertexDeclaration9* pDecl) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexDeclaration(IDirect3DVertexDeclaration9** ppDecl) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFVF(DWORD FVF) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFVF(DWORD* pFVF) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateVertexShader(const DWORD* pFunction, IDirect3DVertexShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShader(IDirect3DVertexShader9* pShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShader(IDirect3DVertexShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantF(UINT StartRegister, const float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderConstantF(UINT StartRegister, float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantI(UINT StartRegister, const int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderConstantI(UINT StartRegister, int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantB(UINT StartRegister, const BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderConstantB(UINT StartRegister, BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* pOffsetInBytes, UINT* pStride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetStreamSourceFreq(UINT StreamNumber, UINT Setting) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetStreamSourceFreq(UINT StreamNumber, UINT* pSetting) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIndices(IDirect3DIndexBuffer9* pIndexData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndices(IDirect3DIndexBuffer9** ppIndexData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreatePixelShader(const DWORD* pFunction, IDirect3DPixelShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShader(IDirect3DPixelShader9* pShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShader(IDirect3DPixelShader9** ppShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantF(UINT StartRegister, const float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderConstantF(UINT StartRegister, float* pConstantData, UINT Vector4fCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantI(UINT StartRegister, const int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderConstantI(UINT StartRegister, int* pConstantData, UINT Vector4iCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantB(UINT StartRegister, const BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderConstantB(UINT StartRegister, BOOL* pConstantData, UINT BoolCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawRectPatch(UINT Handle, const float* pNumSegs, const D3DRECTPATCH_INFO* pRectPatchInfo) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawTriPatch(UINT Handle, const float* pNumSegs, const D3DTRIPATCH_INFO* pTriPatchInfo) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DeletePatch(UINT Handle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateQuery(D3DQUERYTYPE Type, IDirect3DQuery9** ppQuery) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetConvolutionMonoKernel(UINT width, UINT height, float* rows, float* columns) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComposeRects(IDirect3DSurface9* pSrc, IDirect3DSurface9* pDst, IDirect3DVertexBuffer9* pSrcRectDescs, UINT NumRects, IDirect3DVertexBuffer9* pDstRectDescs, D3DCOMPOSERECTSOP Operation, int Xoffset, int Yoffset) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PresentEx(const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion, DWORD dwFlags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGPUThreadPriority(INT* pPriority) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetGPUThreadPriority(INT Priority) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall WaitForVBlank(UINT iSwapChain) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckResourceResidency(IDirect3DResource9** pResourceArray, UINT32 NumResources) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMaximumFrameLatency(UINT MaxLatency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMaximumFrameLatency(UINT* pMaxLatency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceState(HWND hDestinationWindow) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateRenderTargetEx(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle, DWORD Usage) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateOffscreenPlainSurfaceEx(UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle, DWORD Usage) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDepthStencilSurfaceEx(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle, DWORD Usage) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ResetEx(D3DPRESENT_PARAMETERS* pPresentationParameters, D3DDISPLAYMODEEX* pFullscreenDisplayMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplayModeEx(UINT iSwapChain, D3DDISPLAYMODEEX* pMode, D3DDISPLAYROTATION* pRotation) = 0;
};
typedef struct IDirect3DDevice9Ex *LPDIRECT3DDEVICE9EX, *PDIRECT3DDEVICE9EX;
struct __declspec(novtable) IDirect3DSwapChain9Ex : public IDirect3DSwapChain9 {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Present(const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion, DWORD dwFlags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFrontBufferData(IDirect3DSurface9* pDestSurface) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackBuffer(UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRasterStatus(D3DRASTER_STATUS* pRasterStatus) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplayMode(D3DDISPLAYMODE* pMode) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(IDirect3DDevice9** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPresentParameters(D3DPRESENT_PARAMETERS* pPresentationParameters) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLastPresentCount(UINT* pLastPresentCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPresentStats(D3DPRESENTSTATS* pPresentationStatistics) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplayModeEx(D3DDISPLAYMODEEX* pMode, D3DDISPLAYROTATION* pRotation) = 0;
};
typedef struct IDirect3DSwapChain9Ex *LPDIRECT3DSWAPCHAIN9EX, *PDIRECT3DSWAPCHAIN9EX;
struct __declspec(novtable) IDirect3D9ExOverlayExtension : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CheckDeviceOverlayType(UINT Adapter, D3DDEVTYPE DevType, UINT OverlayWidth, UINT OverlayHeight, D3DFORMAT OverlayFormat, D3DDISPLAYMODEEX* pDisplayMode, D3DDISPLAYROTATION DisplayRotation, D3DOVERLAYCAPS* pOverlayCaps) = 0;
};
typedef struct IDirect3D9ExOverlayExtension *LPDIRECT3D9EXOVERLAYEXTENSION, *PDIRECT3D9EXOVERLAYEXTENSION;
struct __declspec(novtable) IDirect3DDevice9Video : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetContentProtectionCaps(const GUID* pCryptoType, const GUID* pDecodeProfile, D3DCONTENTPROTECTIONCAPS* pCaps) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateAuthenticatedChannel(D3DAUTHENTICATEDCHANNELTYPE ChannelType, IDirect3DAuthenticatedChannel9** ppAuthenticatedChannel, HANDLE* pChannelHandle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateCryptoSession(const GUID* pCryptoType, const GUID* pDecodeProfile, IDirect3DCryptoSession9** ppCryptoSession, HANDLE* pCryptoHandle) = 0;
};
typedef struct IDirect3DDevice9Video *LPDIRECT3DDEVICE9VIDEO, *PDIRECT3DDEVICE9VIDEO;
struct __declspec(novtable) IDirect3DAuthenticatedChannel9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCertificateSize(UINT* pCertificateSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCertificate(UINT CertifacteSize, BYTE* ppCertificate) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall NegotiateKeyExchange(UINT DataSize, void* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Query(UINT InputSize, const void* pInput, UINT OutputSize, void* pOutput) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Configure(UINT InputSize, const void* pInput, D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT* pOutput) = 0;
};
typedef struct IDirect3DAuthenticatedChannel9 *LPDIRECT3DAUTHENTICATEDCHANNEL9, *PDIRECT3DAUTHENTICATEDCHANNEL9;
struct __declspec(novtable) IDirect3DCryptoSession9 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCertificateSize(UINT* pCertificateSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCertificate(UINT CertifacteSize, BYTE* ppCertificate) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall NegotiateKeyExchange(UINT DataSize, void* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EncryptionBlt(IDirect3DSurface9* pSrcSurface, IDirect3DSurface9* pDstSurface, UINT DstSurfaceSize, void* pIV) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DecryptionBlt(IDirect3DSurface9* pSrcSurface, IDirect3DSurface9* pDstSurface, UINT SrcSurfaceSize, D3DENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo, void* pContentKey, void* pIV) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSurfacePitch(IDirect3DSurface9* pSrcSurface, UINT* pSurfacePitch) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall StartSessionKeyRefresh(void* pRandomNumber, UINT RandomNumberSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FinishSessionKeyRefresh(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetEncryptionBltKey(void* pReadbackKey, UINT KeySize) = 0;
};
typedef struct IDirect3DCryptoSession9 *LPDIRECT3DCRYPTOSESSION9, *PDIRECT3DCRYPTOSESSION9;
};
#pragma endregion
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    struct _exception {
        int type;
        char* name;
        double arg1;
        double arg2;
        double retval;
    };
    struct _complex {
        double x, y;
    };
    typedef float float_t;
    typedef double double_t;
    extern double const _HUGE;
    void __cdecl _fperrraise(int _Except);
    __declspec(dllimport) short __cdecl _dclass(double _X);
    __declspec(dllimport) short __cdecl _ldclass(long double _X);
    __declspec(dllimport) short __cdecl _fdclass(float _X);
    __declspec(dllimport) int __cdecl _dsign(double _X);
    __declspec(dllimport) int __cdecl _ldsign(long double _X);
    __declspec(dllimport) int __cdecl _fdsign(float _X);
    __declspec(dllimport) int __cdecl _dpcomp(double _X, double _Y);
    __declspec(dllimport) int __cdecl _ldpcomp(long double _X, long double _Y);
    __declspec(dllimport) int __cdecl _fdpcomp(float _X, float _Y);
    __declspec(dllimport) short __cdecl _dtest(double* _Px);
    __declspec(dllimport) short __cdecl _ldtest(long double* _Px);
    __declspec(dllimport) short __cdecl _fdtest(float* _Px);
    __declspec(dllimport) short __cdecl _d_int(double* _Px, short _Xexp);
    __declspec(dllimport) short __cdecl _ld_int(long double* _Px, short _Xexp);
    __declspec(dllimport) short __cdecl _fd_int(float* _Px, short _Xexp);
    __declspec(dllimport) short __cdecl _dscale(double* _Px, long _Lexp);
    __declspec(dllimport) short __cdecl _ldscale(long double* _Px, long _Lexp);
    __declspec(dllimport) short __cdecl _fdscale(float* _Px, long _Lexp);
    __declspec(dllimport) short __cdecl _dunscale(short* _Pex, double* _Px);
    __declspec(dllimport) short __cdecl _ldunscale(short* _Pex, long double* _Px);
    __declspec(dllimport) short __cdecl _fdunscale(short* _Pex, float* _Px);
    __declspec(dllimport) short __cdecl _dexp(double* _Px, double _Y, long _Eoff);
    __declspec(dllimport) short __cdecl _ldexp(long double* _Px, long double _Y, long _Eoff);
    __declspec(dllimport) short __cdecl _fdexp(float* _Px, float _Y, long _Eoff);
    __declspec(dllimport) short __cdecl _dnorm(unsigned short* _Ps);
    __declspec(dllimport) short __cdecl _fdnorm(unsigned short* _Ps);
    __declspec(dllimport) double __cdecl _dpoly(double _X, double const* _Tab, int _N);
    __declspec(dllimport) long double __cdecl _ldpoly(long double _X, long double const* _Tab, int _N);
    __declspec(dllimport) float __cdecl _fdpoly(float _X, float const* _Tab, int _N);
    __declspec(dllimport) double __cdecl _dlog(double _X, int _Baseflag);
    __declspec(dllimport) long double __cdecl _ldlog(long double _X, int _Baseflag);
    __declspec(dllimport) float __cdecl _fdlog(float _X, int _Baseflag);
    __declspec(dllimport) double __cdecl _dsin(double _X, unsigned int _Qoff);
    __declspec(dllimport) long double __cdecl _ldsin(long double _X, unsigned int _Qoff);
    __declspec(dllimport) float __cdecl _fdsin(float _X, unsigned int _Qoff);
    typedef union {
        unsigned short _Sh[4];
        double _Val;
    } _double_val;
    typedef union {
        unsigned short _Sh[2];
        float _Val;
    } _float_val;
    typedef union {
        unsigned short _Sh[4];
        long double _Val;
    } _ldouble_val;
    typedef union {
        unsigned short _Word[4];
        float _Float;
        double _Double;
        long double _Long_double;
    } _float_const;
    extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
    extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
    extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;
    extern const _float_const _Eps_C, _Rteps_C;
    extern const _float_const _FEps_C, _FRteps_C;
    extern const _float_const _LEps_C, _LRteps_C;
    extern const double _Zero_C, _Xbig_C;
    extern const float _FZero_C, _FXbig_C;
    extern const long double _LZero_C, _LXbig_C;
    extern "C++" {
    inline int fpclassify(float _X) throw()
    {
        return _fdtest(&_X);
    }
    inline int fpclassify(double _X) throw()
    {
        return _dtest(&_X);
    }
    inline int fpclassify(long double _X) throw()
    {
        return _ldtest(&_X);
    }
    inline bool signbit(float _X) throw()
    {
        return _fdsign(_X) != 0;
    }
    inline bool signbit(double _X) throw()
    {
        return _dsign(_X) != 0;
    }
    inline bool signbit(long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }
    inline int _fpcomp(float _X, float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }
    inline int _fpcomp(double _X, double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }
    inline int _fpcomp(long double _X, long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }
    template <class _Trc, class _Tre>
    struct _Combined_type {
        typedef float _Type;
    };
    template <>
    struct _Combined_type<float, double> {
        typedef double _Type;
    };
    template <>
    struct _Combined_type<float, long double> {
        typedef long double _Type;
    };
    template <class _Ty, class _T2>
    struct _Real_widened {
        typedef long double _Type;
    };
    template <>
    struct _Real_widened<float, float> {
        typedef float _Type;
    };
    template <>
    struct _Real_widened<float, double> {
        typedef double _Type;
    };
    template <>
    struct _Real_widened<double, float> {
        typedef double _Type;
    };
    template <>
    struct _Real_widened<double, double> {
        typedef double _Type;
    };
    template <class _Ty>
    struct _Real_type {
        typedef double _Type;
    };
    template <>
    struct _Real_type<float> {
        typedef float _Type;
    };
    template <>
    struct _Real_type<long double> {
        typedef long double _Type;
    };
    template <class _T1, class _T2>
    inline int _fpcomp(_T1 _X, _T2 _Y) throw()
    {
        typedef typename _Combined_type<float,
            typename _Real_widened<
                typename _Real_type<_T1>::_Type,
                typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }
    template <class _Ty>
    inline bool isfinite(_Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }
    template <class _Ty>
    inline bool isinf(_Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }
    template <class _Ty>
    inline bool isnan(_Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }
    template <class _Ty>
    inline bool isnormal(_Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }
    template <class _Ty1, class _Ty2>
    inline bool isgreater(_Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }
    template <class _Ty1, class _Ty2>
    inline bool isgreaterequal(_Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }
    template <class _Ty1, class _Ty2>
    inline bool isless(_Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }
    template <class _Ty1, class _Ty2>
    inline bool islessequal(_Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }
    template <class _Ty1, class _Ty2>
    inline bool islessgreater(_Ty1 _X, _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }
    template <class _Ty1, class _Ty2>
    inline bool isunordered(_Ty1 _X, _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
    }
    int __cdecl abs(int _X);
    long __cdecl labs(long _X);
    long long __cdecl llabs(long long _X);
    double __cdecl acos(double _X);
    double __cdecl asin(double _X);
    double __cdecl atan(double _X);
    double __cdecl atan2(double _Y, double _X);
    double __cdecl cos(double _X);
    double __cdecl cosh(double _X);
    double __cdecl exp(double _X);
    double __cdecl fabs(double _X);
    double __cdecl fmod(double _X, double _Y);
    double __cdecl log(double _X);
    double __cdecl log10(double _X);
    double __cdecl pow(double _X, double _Y);
    double __cdecl sin(double _X);
    double __cdecl sinh(double _X);
    double __cdecl sqrt(double _X);
    double __cdecl tan(double _X);
    double __cdecl tanh(double _X);
    __declspec(dllimport) double __cdecl acosh(double _X);
    __declspec(dllimport) double __cdecl asinh(double _X);
    __declspec(dllimport) double __cdecl atanh(double _X);
    __declspec(dllimport) double __cdecl atof(char const* _String);
    __declspec(dllimport) double __cdecl _atof_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) double __cdecl _cabs(struct _complex _Complex_value);
    __declspec(dllimport) double __cdecl cbrt(double _X);
    __declspec(dllimport) double __cdecl ceil(double _X);
    __declspec(dllimport) double __cdecl _chgsign(double _X);
    __declspec(dllimport) double __cdecl copysign(double _Number, double _Sign);
    __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign);
    __declspec(dllimport) double __cdecl erf(double _X);
    __declspec(dllimport) double __cdecl erfc(double _X);
    __declspec(dllimport) double __cdecl exp2(double _X);
    __declspec(dllimport) double __cdecl expm1(double _X);
    __declspec(dllimport) double __cdecl fdim(double _X, double _Y);
    __declspec(dllimport) double __cdecl floor(double _X);
    __declspec(dllimport) double __cdecl fma(double _X, double _Y, double _Z);
    __declspec(dllimport) double __cdecl fmax(double _X, double _Y);
    __declspec(dllimport) double __cdecl fmin(double _X, double _Y);
    __declspec(dllimport) double __cdecl frexp(double _X, int* _Y);
    __declspec(dllimport) double __cdecl hypot(double _X, double _Y);
    __declspec(dllimport) double __cdecl _hypot(double _X, double _Y);
    __declspec(dllimport) int __cdecl ilogb(double _X);
    __declspec(dllimport) double __cdecl ldexp(double _X, int _Y);
    __declspec(dllimport) double __cdecl lgamma(double _X);
    __declspec(dllimport) long long __cdecl llrint(double _X);
    __declspec(dllimport) long long __cdecl llround(double _X);
    __declspec(dllimport) double __cdecl log1p(double _X);
    __declspec(dllimport) double __cdecl log2(double _X);
    __declspec(dllimport) double __cdecl logb(double _X);
    __declspec(dllimport) long __cdecl lrint(double _X);
    __declspec(dllimport) long __cdecl lround(double _X);
    int __cdecl _matherr(struct _exception * _Except);
    __declspec(dllimport) double __cdecl modf(double _X, double* _Y);
    __declspec(dllimport) double __cdecl nan(char const* _X);
    __declspec(dllimport) double __cdecl nearbyint(double _X);
    __declspec(dllimport) double __cdecl nextafter(double _X, double _Y);
    __declspec(dllimport) double __cdecl nexttoward(double _X, long double _Y);
    __declspec(dllimport) double __cdecl remainder(double _X, double _Y);
    __declspec(dllimport) double __cdecl remquo(double _X, double _Y, int* _Z);
    __declspec(dllimport) double __cdecl rint(double _X);
    __declspec(dllimport) double __cdecl round(double _X);
    __declspec(dllimport) double __cdecl scalbln(double _X, long _Y);
    __declspec(dllimport) double __cdecl scalbn(double _X, int _Y);
    __declspec(dllimport) double __cdecl tgamma(double _X);
    __declspec(dllimport) double __cdecl trunc(double _X);
    __declspec(dllimport) double __cdecl _j0(double _X);
    __declspec(dllimport) double __cdecl _j1(double _X);
    __declspec(dllimport) double __cdecl _jn(int _X, double _Y);
    __declspec(dllimport) double __cdecl _y0(double _X);
    __declspec(dllimport) double __cdecl _y1(double _X);
    __declspec(dllimport) double __cdecl _yn(int _X, double _Y);
    __declspec(dllimport) float __cdecl acoshf(float _X);
    __declspec(dllimport) float __cdecl asinhf(float _X);
    __declspec(dllimport) float __cdecl atanhf(float _X);
    __declspec(dllimport) float __cdecl cbrtf(float _X);
    __declspec(dllimport) float __cdecl _chgsignf(float _X);
    __declspec(dllimport) float __cdecl copysignf(float _Number, float _Sign);
    __declspec(dllimport) float __cdecl _copysignf(float _Number, float _Sign);
    __declspec(dllimport) float __cdecl erff(float _X);
    __declspec(dllimport) float __cdecl erfcf(float _X);
    __declspec(dllimport) float __cdecl expm1f(float _X);
    __declspec(dllimport) float __cdecl exp2f(float _X);
    __declspec(dllimport) float __cdecl fdimf(float _X, float _Y);
    __declspec(dllimport) float __cdecl fmaf(float _X, float _Y, float _Z);
    __declspec(dllimport) float __cdecl fmaxf(float _X, float _Y);
    __declspec(dllimport) float __cdecl fminf(float _X, float _Y);
    __declspec(dllimport) float __cdecl _hypotf(float _X, float _Y);
    __declspec(dllimport) int __cdecl ilogbf(float _X);
    __declspec(dllimport) float __cdecl lgammaf(float _X);
    __declspec(dllimport) long long __cdecl llrintf(float _X);
    __declspec(dllimport) long long __cdecl llroundf(float _X);
    __declspec(dllimport) float __cdecl log1pf(float _X);
    __declspec(dllimport) float __cdecl log2f(float _X);
    __declspec(dllimport) float __cdecl logbf(float _X);
    __declspec(dllimport) long __cdecl lrintf(float _X);
    __declspec(dllimport) long __cdecl lroundf(float _X);
    __declspec(dllimport) float __cdecl nanf(char const* _X);
    __declspec(dllimport) float __cdecl nearbyintf(float _X);
    __declspec(dllimport) float __cdecl nextafterf(float _X, float _Y);
    __declspec(dllimport) float __cdecl nexttowardf(float _X, long double _Y);
    __declspec(dllimport) float __cdecl remainderf(float _X, float _Y);
    __declspec(dllimport) float __cdecl remquof(float _X, float _Y, int* _Z);
    __declspec(dllimport) float __cdecl rintf(float _X);
    __declspec(dllimport) float __cdecl roundf(float _X);
    __declspec(dllimport) float __cdecl scalblnf(float _X, long _Y);
    __declspec(dllimport) float __cdecl scalbnf(float _X, int _Y);
    __declspec(dllimport) float __cdecl tgammaf(float _X);
    __declspec(dllimport) float __cdecl truncf(float _X);
    __declspec(dllimport) float __cdecl _logbf(float _X);
    __declspec(dllimport) float __cdecl _nextafterf(float _X, float _Y);
    __declspec(dllimport) int __cdecl _finitef(float _X);
    __declspec(dllimport) int __cdecl _isnanf(float _X);
    __declspec(dllimport) int __cdecl _fpclassf(float _X);
    __declspec(dllimport) int __cdecl _set_FMA3_enable(int _Flag);
    __declspec(dllimport) int __cdecl _get_FMA3_enable(void);
    __declspec(dllimport) float __cdecl acosf(float _X);
    __declspec(dllimport) float __cdecl asinf(float _X);
    __declspec(dllimport) float __cdecl atan2f(float _Y, float _X);
    __declspec(dllimport) float __cdecl atanf(float _X);
    __declspec(dllimport) float __cdecl ceilf(float _X);
    __declspec(dllimport) float __cdecl cosf(float _X);
    __declspec(dllimport) float __cdecl coshf(float _X);
    __declspec(dllimport) float __cdecl expf(float _X);
    __inline float __cdecl fabsf(float _X)
    {
        return (float)fabs(_X);
    }
    __declspec(dllimport) float __cdecl floorf(float _X);
    __declspec(dllimport) float __cdecl fmodf(float _X, float _Y);
    __inline float __cdecl frexpf(float _X, int* _Y)
    {
        return (float)frexp(_X, _Y);
    }
    __inline float __cdecl hypotf(float _X, float _Y)
    {
        return _hypotf(_X, _Y);
    }
    __inline float __cdecl ldexpf(float _X, int _Y)
    {
        return (float)ldexp(_X, _Y);
    }
    __declspec(dllimport) float __cdecl log10f(float _X);
    __declspec(dllimport) float __cdecl logf(float _X);
    __declspec(dllimport) float __cdecl modff(float _X, float* _Y);
    __declspec(dllimport) float __cdecl powf(float _X, float _Y);
    __declspec(dllimport) float __cdecl sinf(float _X);
    __declspec(dllimport) float __cdecl sinhf(float _X);
    __declspec(dllimport) float __cdecl sqrtf(float _X);
    __declspec(dllimport) float __cdecl tanf(float _X);
    __declspec(dllimport) float __cdecl tanhf(float _X);
    __declspec(dllimport) long double __cdecl acoshl(long double _X);
    __inline long double __cdecl acosl(long double _X)
    {
        return acos((double)_X);
    }
    __declspec(dllimport) long double __cdecl asinhl(long double _X);
    __inline long double __cdecl asinl(long double _X)
    {
        return asin((double)_X);
    }
    __inline long double __cdecl atan2l(long double _Y, long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }
    __declspec(dllimport) long double __cdecl atanhl(long double _X);
    __inline long double __cdecl atanl(long double _X)
    {
        return atan((double)_X);
    }
    __declspec(dllimport) long double __cdecl cbrtl(long double _X);
    __inline long double __cdecl ceill(long double _X)
    {
        return ceil((double)_X);
    }
    __inline long double __cdecl _chgsignl(long double _X)
    {
        return _chgsign((double)_X);
    }
    __declspec(dllimport) long double __cdecl copysignl(long double _Number, long double _Sign);
    __inline long double __cdecl _copysignl(long double _Number, long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }
    __inline long double __cdecl coshl(long double _X)
    {
        return cosh((double)_X);
    }
    __inline long double __cdecl cosl(long double _X)
    {
        return cos((double)_X);
    }
    __declspec(dllimport) long double __cdecl erfl(long double _X);
    __declspec(dllimport) long double __cdecl erfcl(long double _X);
    __inline long double __cdecl expl(long double _X)
    {
        return exp((double)_X);
    }
    __declspec(dllimport) long double __cdecl exp2l(long double _X);
    __declspec(dllimport) long double __cdecl expm1l(long double _X);
    __inline long double __cdecl fabsl(long double _X)
    {
        return fabs((double)_X);
    }
    __declspec(dllimport) long double __cdecl fdiml(long double _X, long double _Y);
    __inline long double __cdecl floorl(long double _X)
    {
        return floor((double)_X);
    }
    __declspec(dllimport) long double __cdecl fmal(long double _X, long double _Y, long double _Z);
    __declspec(dllimport) long double __cdecl fmaxl(long double _X, long double _Y);
    __declspec(dllimport) long double __cdecl fminl(long double _X, long double _Y);
    __inline long double __cdecl fmodl(long double _X, long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }
    __inline long double __cdecl frexpl(long double _X, int* _Y)
    {
        return frexp((double)_X, _Y);
    }
    __declspec(dllimport) int __cdecl ilogbl(long double _X);
    __inline long double __cdecl _hypotl(long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }
    __inline long double __cdecl hypotl(long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }
    __inline long double __cdecl ldexpl(long double _X, int _Y)
    {
        return ldexp((double)_X, _Y);
    }
    __declspec(dllimport) long double __cdecl lgammal(long double _X);
    __declspec(dllimport) long long __cdecl llrintl(long double _X);
    __declspec(dllimport) long long __cdecl llroundl(long double _X);
    __inline long double __cdecl logl(long double _X)
    {
        return log((double)_X);
    }
    __inline long double __cdecl log10l(long double _X)
    {
        return log10((double)_X);
    }
    __declspec(dllimport) long double __cdecl log1pl(long double _X);
    __declspec(dllimport) long double __cdecl log2l(long double _X);
    __declspec(dllimport) long double __cdecl logbl(long double _X);
    __declspec(dllimport) long __cdecl lrintl(long double _X);
    __declspec(dllimport) long __cdecl lroundl(long double _X);
    __inline long double __cdecl modfl(long double _X, long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }
    __declspec(dllimport) long double __cdecl nanl(char const* _X);
    __declspec(dllimport) long double __cdecl nearbyintl(long double _X);
    __declspec(dllimport) long double __cdecl nextafterl(long double _X, long double _Y);
    __declspec(dllimport) long double __cdecl nexttowardl(long double _X, long double _Y);
    __inline long double __cdecl powl(long double _X, long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }
    __declspec(dllimport) long double __cdecl remainderl(long double _X, long double _Y);
    __declspec(dllimport) long double __cdecl remquol(long double _X, long double _Y, int* _Z);
    __declspec(dllimport) long double __cdecl rintl(long double _X);
    __declspec(dllimport) long double __cdecl roundl(long double _X);
    __declspec(dllimport) long double __cdecl scalblnl(long double _X, long _Y);
    __declspec(dllimport) long double __cdecl scalbnl(long double _X, int _Y);
    __inline long double __cdecl sinhl(long double _X)
    {
        return sinh((double)_X);
    }
    __inline long double __cdecl sinl(long double _X)
    {
        return sin((double)_X);
    }
    __inline long double __cdecl sqrtl(long double _X)
    {
        return sqrt((double)_X);
    }
    __inline long double __cdecl tanhl(long double _X)
    {
        return tanh((double)_X);
    }
    __inline long double __cdecl tanl(long double _X)
    {
        return tan((double)_X);
    }
    __declspec(dllimport) long double __cdecl tgammal(long double _X);
    __declspec(dllimport) long double __cdecl truncl(long double _X);
    extern double HUGE;
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_j0"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl j0(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_j1"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl j1(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_jn"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl jn(int _X, double _Y);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_y0"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl y0(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_y1"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl y1(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_yn"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl yn(int _X, double _Y);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4201)
    typedef struct D3DXFLOAT16 {
public:
    D3DXFLOAT16() {};
    D3DXFLOAT16(FLOAT);
    D3DXFLOAT16(const D3DXFLOAT16&);
    operator FLOAT();
    BOOL operator==(const D3DXFLOAT16&) const;
    BOOL operator!=(const D3DXFLOAT16&) const;

protected:
    WORD value;
} D3DXFLOAT16, *LPD3DXFLOAT16;
typedef struct D3DXVECTOR2 {
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2(const FLOAT*);
    D3DXVECTOR2(const D3DXFLOAT16*);
    D3DXVECTOR2(FLOAT x, FLOAT y);
    operator FLOAT*();
    operator const FLOAT*() const;
    D3DXVECTOR2& operator+=(const D3DXVECTOR2&);
    D3DXVECTOR2& operator-=(const D3DXVECTOR2&);
    D3DXVECTOR2& operator*=(FLOAT);
    D3DXVECTOR2& operator/=(FLOAT);
    D3DXVECTOR2 operator+() const;
    D3DXVECTOR2 operator-() const;
    D3DXVECTOR2 operator+(const D3DXVECTOR2&) const;
    D3DXVECTOR2 operator-(const D3DXVECTOR2&) const;
    D3DXVECTOR2 operator*(FLOAT) const;
    D3DXVECTOR2 operator/(FLOAT) const;
    friend D3DXVECTOR2 operator*(FLOAT, const D3DXVECTOR2&);
    BOOL operator==(const D3DXVECTOR2&) const;
    BOOL operator!=(const D3DXVECTOR2&) const;

public:
    FLOAT x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;
typedef struct D3DXVECTOR2_16F {
public:
    D3DXVECTOR2_16F() {};
    D3DXVECTOR2_16F(const FLOAT*);
    D3DXVECTOR2_16F(const D3DXFLOAT16*);
    D3DXVECTOR2_16F(const D3DXFLOAT16& x, const D3DXFLOAT16& y);
    operator D3DXFLOAT16*();
    operator const D3DXFLOAT16*() const;
    BOOL operator==(const D3DXVECTOR2_16F&) const;
    BOOL operator!=(const D3DXVECTOR2_16F&) const;

public:
    D3DXFLOAT16 x, y;
} D3DXVECTOR2_16F, *LPD3DXVECTOR2_16F;
typedef struct D3DXVECTOR3 : public D3DVECTOR {
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3(const FLOAT*);
    D3DXVECTOR3(const D3DVECTOR&);
    D3DXVECTOR3(const D3DXFLOAT16*);
    D3DXVECTOR3(FLOAT x, FLOAT y, FLOAT z);
    operator FLOAT*();
    operator const FLOAT*() const;
    D3DXVECTOR3& operator+=(const D3DXVECTOR3&);
    D3DXVECTOR3& operator-=(const D3DXVECTOR3&);
    D3DXVECTOR3& operator*=(FLOAT);
    D3DXVECTOR3& operator/=(FLOAT);
    D3DXVECTOR3 operator+() const;
    D3DXVECTOR3 operator-() const;
    D3DXVECTOR3 operator+(const D3DXVECTOR3&) const;
    D3DXVECTOR3 operator-(const D3DXVECTOR3&) const;
    D3DXVECTOR3 operator*(FLOAT) const;
    D3DXVECTOR3 operator/(FLOAT) const;
    friend D3DXVECTOR3 operator*(FLOAT, const struct D3DXVECTOR3&);
    BOOL operator==(const D3DXVECTOR3&) const;
    BOOL operator!=(const D3DXVECTOR3&) const;
} D3DXVECTOR3, *LPD3DXVECTOR3;
typedef struct D3DXVECTOR3_16F {
public:
    D3DXVECTOR3_16F() {};
    D3DXVECTOR3_16F(const FLOAT*);
    D3DXVECTOR3_16F(const D3DVECTOR&);
    D3DXVECTOR3_16F(const D3DXFLOAT16*);
    D3DXVECTOR3_16F(const D3DXFLOAT16& x, const D3DXFLOAT16& y, const D3DXFLOAT16& z);
    operator D3DXFLOAT16*();
    operator const D3DXFLOAT16*() const;
    BOOL operator==(const D3DXVECTOR3_16F&) const;
    BOOL operator!=(const D3DXVECTOR3_16F&) const;

public:
    D3DXFLOAT16 x, y, z;
} D3DXVECTOR3_16F, *LPD3DXVECTOR3_16F;
typedef struct D3DXVECTOR4 {
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4(const FLOAT*);
    D3DXVECTOR4(const D3DXFLOAT16*);
    D3DXVECTOR4(const D3DVECTOR& xyz, FLOAT w);
    D3DXVECTOR4(FLOAT x, FLOAT y, FLOAT z, FLOAT w);
    operator FLOAT*();
    operator const FLOAT*() const;
    D3DXVECTOR4& operator+=(const D3DXVECTOR4&);
    D3DXVECTOR4& operator-=(const D3DXVECTOR4&);
    D3DXVECTOR4& operator*=(FLOAT);
    D3DXVECTOR4& operator/=(FLOAT);
    D3DXVECTOR4 operator+() const;
    D3DXVECTOR4 operator-() const;
    D3DXVECTOR4 operator+(const D3DXVECTOR4&) const;
    D3DXVECTOR4 operator-(const D3DXVECTOR4&) const;
    D3DXVECTOR4 operator*(FLOAT) const;
    D3DXVECTOR4 operator/(FLOAT) const;
    friend D3DXVECTOR4 operator*(FLOAT, const D3DXVECTOR4&);
    BOOL operator==(const D3DXVECTOR4&) const;
    BOOL operator!=(const D3DXVECTOR4&) const;

public:
    FLOAT x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;
typedef struct D3DXVECTOR4_16F {
public:
    D3DXVECTOR4_16F() {};
    D3DXVECTOR4_16F(const FLOAT*);
    D3DXVECTOR4_16F(const D3DXFLOAT16*);
    D3DXVECTOR4_16F(const D3DXVECTOR3_16F& xyz, const D3DXFLOAT16& w);
    D3DXVECTOR4_16F(const D3DXFLOAT16& x, const D3DXFLOAT16& y, const D3DXFLOAT16& z, const D3DXFLOAT16& w);
    operator D3DXFLOAT16*();
    operator const D3DXFLOAT16*() const;
    BOOL operator==(const D3DXVECTOR4_16F&) const;
    BOOL operator!=(const D3DXVECTOR4_16F&) const;

public:
    D3DXFLOAT16 x, y, z, w;
} D3DXVECTOR4_16F, *LPD3DXVECTOR4_16F;
typedef struct D3DXMATRIX : public D3DMATRIX {
public:
    D3DXMATRIX() {};
    D3DXMATRIX(const FLOAT*);
    D3DXMATRIX(const D3DMATRIX&);
    D3DXMATRIX(const D3DXFLOAT16*);
    D3DXMATRIX(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
        FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
        FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
        FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44);
    FLOAT& operator()(UINT Row, UINT Col);
    FLOAT operator()(UINT Row, UINT Col) const;
    operator FLOAT*();
    operator const FLOAT*() const;
    D3DXMATRIX& operator*=(const D3DXMATRIX&);
    D3DXMATRIX& operator+=(const D3DXMATRIX&);
    D3DXMATRIX& operator-=(const D3DXMATRIX&);
    D3DXMATRIX& operator*=(FLOAT);
    D3DXMATRIX& operator/=(FLOAT);
    D3DXMATRIX operator+() const;
    D3DXMATRIX operator-() const;
    D3DXMATRIX operator*(const D3DXMATRIX&) const;
    D3DXMATRIX operator+(const D3DXMATRIX&) const;
    D3DXMATRIX operator-(const D3DXMATRIX&) const;
    D3DXMATRIX operator*(FLOAT) const;
    D3DXMATRIX operator/(FLOAT) const;
    friend D3DXMATRIX operator*(FLOAT, const D3DXMATRIX&);
    BOOL operator==(const D3DXMATRIX&) const;
    BOOL operator!=(const D3DXMATRIX&) const;
} D3DXMATRIX, *LPD3DXMATRIX;
typedef struct _D3DXMATRIXA16 : public D3DXMATRIX {
    _D3DXMATRIXA16() { }
    _D3DXMATRIXA16(const FLOAT*);
    _D3DXMATRIXA16(const D3DMATRIX&);
    _D3DXMATRIXA16(const D3DXFLOAT16*);
    _D3DXMATRIXA16(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
        FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
        FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
        FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44);
    void* operator new(size_t);
    void* operator new[](size_t);
    void operator delete(void*);
    void operator delete[](void*);
    _D3DXMATRIXA16& operator=(const D3DXMATRIX&);
} _D3DXMATRIXA16;
typedef __declspec(align(16)) _D3DXMATRIXA16 D3DXMATRIXA16, *LPD3DXMATRIXA16;
typedef struct D3DXQUATERNION {
public:
    D3DXQUATERNION() { }
    D3DXQUATERNION(const FLOAT*);
    D3DXQUATERNION(const D3DXFLOAT16*);
    D3DXQUATERNION(FLOAT x, FLOAT y, FLOAT z, FLOAT w);
    operator FLOAT*();
    operator const FLOAT*() const;
    D3DXQUATERNION& operator+=(const D3DXQUATERNION&);
    D3DXQUATERNION& operator-=(const D3DXQUATERNION&);
    D3DXQUATERNION& operator*=(const D3DXQUATERNION&);
    D3DXQUATERNION& operator*=(FLOAT);
    D3DXQUATERNION& operator/=(FLOAT);
    D3DXQUATERNION operator+() const;
    D3DXQUATERNION operator-() const;
    D3DXQUATERNION operator+(const D3DXQUATERNION&) const;
    D3DXQUATERNION operator-(const D3DXQUATERNION&) const;
    D3DXQUATERNION operator*(const D3DXQUATERNION&) const;
    D3DXQUATERNION operator*(FLOAT) const;
    D3DXQUATERNION operator/(FLOAT) const;
    friend D3DXQUATERNION operator*(FLOAT, const D3DXQUATERNION&);
    BOOL operator==(const D3DXQUATERNION&) const;
    BOOL operator!=(const D3DXQUATERNION&) const;
    FLOAT x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;
typedef struct D3DXPLANE {
public:
    D3DXPLANE() { }
    D3DXPLANE(const FLOAT*);
    D3DXPLANE(const D3DXFLOAT16*);
    D3DXPLANE(FLOAT a, FLOAT b, FLOAT c, FLOAT d);
    operator FLOAT*();
    operator const FLOAT*() const;
    D3DXPLANE& operator*=(FLOAT);
    D3DXPLANE& operator/=(FLOAT);
    D3DXPLANE operator+() const;
    D3DXPLANE operator-() const;
    D3DXPLANE operator*(FLOAT) const;
    D3DXPLANE operator/(FLOAT) const;
    friend D3DXPLANE operator*(FLOAT, const D3DXPLANE&);
    BOOL operator==(const D3DXPLANE&) const;
    BOOL operator!=(const D3DXPLANE&) const;
    FLOAT a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;
typedef struct D3DXCOLOR {
public:
    D3DXCOLOR() { }
    D3DXCOLOR(DWORD argb);
    D3DXCOLOR(const FLOAT*);
    D3DXCOLOR(const D3DXFLOAT16*);
    D3DXCOLOR(const D3DCOLORVALUE&);
    D3DXCOLOR(FLOAT r, FLOAT g, FLOAT b, FLOAT a);
    operator DWORD() const;
    operator FLOAT*();
    operator const FLOAT*() const;
    operator D3DCOLORVALUE*();
    operator const D3DCOLORVALUE*() const;
    operator D3DCOLORVALUE&();
    operator const D3DCOLORVALUE&() const;
    D3DXCOLOR& operator+=(const D3DXCOLOR&);
    D3DXCOLOR& operator-=(const D3DXCOLOR&);
    D3DXCOLOR& operator*=(FLOAT);
    D3DXCOLOR& operator/=(FLOAT);
    D3DXCOLOR operator+() const;
    D3DXCOLOR operator-() const;
    D3DXCOLOR operator+(const D3DXCOLOR&) const;
    D3DXCOLOR operator-(const D3DXCOLOR&) const;
    D3DXCOLOR operator*(FLOAT) const;
    D3DXCOLOR operator/(FLOAT) const;
    friend D3DXCOLOR operator*(FLOAT, const D3DXCOLOR&);
    BOOL operator==(const D3DXCOLOR&) const;
    BOOL operator!=(const D3DXCOLOR&) const;
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;
extern "C" {
D3DXFLOAT16* __stdcall D3DXFloat32To16Array(D3DXFLOAT16* pOut, const FLOAT* pIn, UINT n);
FLOAT* __stdcall D3DXFloat16To32Array(FLOAT* pOut, const D3DXFLOAT16* pIn, UINT n);
}
FLOAT D3DXVec2Length(const D3DXVECTOR2* pV);
FLOAT D3DXVec2LengthSq(const D3DXVECTOR2* pV);
FLOAT D3DXVec2Dot(const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2);
FLOAT D3DXVec2CCW(const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2);
D3DXVECTOR2* D3DXVec2Add(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2);
D3DXVECTOR2* D3DXVec2Subtract(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2);
D3DXVECTOR2* D3DXVec2Minimize(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2);
D3DXVECTOR2* D3DXVec2Maximize(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2);
D3DXVECTOR2* D3DXVec2Scale(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV, FLOAT s);
D3DXVECTOR2* D3DXVec2Lerp(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2,
    FLOAT s);
extern "C" {
D3DXVECTOR2* __stdcall D3DXVec2Normalize(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV);
D3DXVECTOR2* __stdcall D3DXVec2Hermite(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pT1,
    const D3DXVECTOR2* pV2, const D3DXVECTOR2* pT2, FLOAT s);
D3DXVECTOR2* __stdcall D3DXVec2CatmullRom(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV0, const D3DXVECTOR2* pV1,
    const D3DXVECTOR2* pV2, const D3DXVECTOR2* pV3, FLOAT s);
D3DXVECTOR2* __stdcall D3DXVec2BaryCentric(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2,
    const D3DXVECTOR2* pV3, FLOAT f, FLOAT g);
D3DXVECTOR4* __stdcall D3DXVec2Transform(D3DXVECTOR4* pOut, const D3DXVECTOR2* pV, const D3DXMATRIX* pM);
D3DXVECTOR2* __stdcall D3DXVec2TransformCoord(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV, const D3DXMATRIX* pM);
D3DXVECTOR2* __stdcall D3DXVec2TransformNormal(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV, const D3DXMATRIX* pM);
D3DXVECTOR4* __stdcall D3DXVec2TransformArray(D3DXVECTOR4* pOut, UINT OutStride, const D3DXVECTOR2* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
D3DXVECTOR2* __stdcall D3DXVec2TransformCoordArray(D3DXVECTOR2* pOut, UINT OutStride, const D3DXVECTOR2* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
D3DXVECTOR2* __stdcall D3DXVec2TransformNormalArray(D3DXVECTOR2* pOut, UINT OutStride, const D3DXVECTOR2* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
}
FLOAT D3DXVec3Length(const D3DXVECTOR3* pV);
FLOAT D3DXVec3LengthSq(const D3DXVECTOR3* pV);
FLOAT D3DXVec3Dot(const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2);
D3DXVECTOR3* D3DXVec3Cross(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2);
D3DXVECTOR3* D3DXVec3Add(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2);
D3DXVECTOR3* D3DXVec3Subtract(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2);
D3DXVECTOR3* D3DXVec3Minimize(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2);
D3DXVECTOR3* D3DXVec3Maximize(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2);
D3DXVECTOR3* D3DXVec3Scale(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV, FLOAT s);
D3DXVECTOR3* D3DXVec3Lerp(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2,
    FLOAT s);
extern "C" {
D3DXVECTOR3* __stdcall D3DXVec3Normalize(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV);
D3DXVECTOR3* __stdcall D3DXVec3Hermite(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pT1,
    const D3DXVECTOR3* pV2, const D3DXVECTOR3* pT2, FLOAT s);
D3DXVECTOR3* __stdcall D3DXVec3CatmullRom(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV0, const D3DXVECTOR3* pV1,
    const D3DXVECTOR3* pV2, const D3DXVECTOR3* pV3, FLOAT s);
D3DXVECTOR3* __stdcall D3DXVec3BaryCentric(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2,
    const D3DXVECTOR3* pV3, FLOAT f, FLOAT g);
D3DXVECTOR4* __stdcall D3DXVec3Transform(D3DXVECTOR4* pOut, const D3DXVECTOR3* pV, const D3DXMATRIX* pM);
D3DXVECTOR3* __stdcall D3DXVec3TransformCoord(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV, const D3DXMATRIX* pM);
D3DXVECTOR3* __stdcall D3DXVec3TransformNormal(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV, const D3DXMATRIX* pM);
D3DXVECTOR4* __stdcall D3DXVec3TransformArray(D3DXVECTOR4* pOut, UINT OutStride, const D3DXVECTOR3* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
D3DXVECTOR3* __stdcall D3DXVec3TransformCoordArray(D3DXVECTOR3* pOut, UINT OutStride, const D3DXVECTOR3* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
D3DXVECTOR3* __stdcall D3DXVec3TransformNormalArray(D3DXVECTOR3* pOut, UINT OutStride, const D3DXVECTOR3* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
D3DXVECTOR3* __stdcall D3DXVec3Project(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV, const D3DVIEWPORT9* pViewport,
    const D3DXMATRIX* pProjection, const D3DXMATRIX* pView, const D3DXMATRIX* pWorld);
D3DXVECTOR3* __stdcall D3DXVec3Unproject(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV, const D3DVIEWPORT9* pViewport,
    const D3DXMATRIX* pProjection, const D3DXMATRIX* pView, const D3DXMATRIX* pWorld);
D3DXVECTOR3* __stdcall D3DXVec3ProjectArray(D3DXVECTOR3* pOut, UINT OutStride, const D3DXVECTOR3* pV, UINT VStride, const D3DVIEWPORT9* pViewport,
    const D3DXMATRIX* pProjection, const D3DXMATRIX* pView, const D3DXMATRIX* pWorld, UINT n);
D3DXVECTOR3* __stdcall D3DXVec3UnprojectArray(D3DXVECTOR3* pOut, UINT OutStride, const D3DXVECTOR3* pV, UINT VStride, const D3DVIEWPORT9* pViewport,
    const D3DXMATRIX* pProjection, const D3DXMATRIX* pView, const D3DXMATRIX* pWorld, UINT n);
}
FLOAT D3DXVec4Length(const D3DXVECTOR4* pV);
FLOAT D3DXVec4LengthSq(const D3DXVECTOR4* pV);
FLOAT D3DXVec4Dot(const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2);
D3DXVECTOR4* D3DXVec4Add(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2);
D3DXVECTOR4* D3DXVec4Subtract(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2);
D3DXVECTOR4* D3DXVec4Minimize(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2);
D3DXVECTOR4* D3DXVec4Maximize(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2);
D3DXVECTOR4* D3DXVec4Scale(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV, FLOAT s);
D3DXVECTOR4* D3DXVec4Lerp(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2,
    FLOAT s);
extern "C" {
D3DXVECTOR4* __stdcall D3DXVec4Cross(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2,
    const D3DXVECTOR4* pV3);
D3DXVECTOR4* __stdcall D3DXVec4Normalize(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV);
D3DXVECTOR4* __stdcall D3DXVec4Hermite(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pT1,
    const D3DXVECTOR4* pV2, const D3DXVECTOR4* pT2, FLOAT s);
D3DXVECTOR4* __stdcall D3DXVec4CatmullRom(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV0, const D3DXVECTOR4* pV1,
    const D3DXVECTOR4* pV2, const D3DXVECTOR4* pV3, FLOAT s);
D3DXVECTOR4* __stdcall D3DXVec4BaryCentric(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2,
    const D3DXVECTOR4* pV3, FLOAT f, FLOAT g);
D3DXVECTOR4* __stdcall D3DXVec4Transform(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV, const D3DXMATRIX* pM);
D3DXVECTOR4* __stdcall D3DXVec4TransformArray(D3DXVECTOR4* pOut, UINT OutStride, const D3DXVECTOR4* pV, UINT VStride, const D3DXMATRIX* pM, UINT n);
}
D3DXMATRIX* D3DXMatrixIdentity(D3DXMATRIX* pOut);
BOOL D3DXMatrixIsIdentity(const D3DXMATRIX* pM);
extern "C" {
FLOAT __stdcall D3DXMatrixDeterminant(const D3DXMATRIX* pM);
HRESULT __stdcall D3DXMatrixDecompose(D3DXVECTOR3* pOutScale, D3DXQUATERNION* pOutRotation,
    D3DXVECTOR3* pOutTranslation, const D3DXMATRIX* pM);
D3DXMATRIX* __stdcall D3DXMatrixTranspose(D3DXMATRIX* pOut, const D3DXMATRIX* pM);
D3DXMATRIX* __stdcall D3DXMatrixMultiply(D3DXMATRIX* pOut, const D3DXMATRIX* pM1, const D3DXMATRIX* pM2);
D3DXMATRIX* __stdcall D3DXMatrixMultiplyTranspose(D3DXMATRIX* pOut, const D3DXMATRIX* pM1, const D3DXMATRIX* pM2);
D3DXMATRIX* __stdcall D3DXMatrixInverse(D3DXMATRIX* pOut, FLOAT* pDeterminant, const D3DXMATRIX* pM);
D3DXMATRIX* __stdcall D3DXMatrixScaling(D3DXMATRIX* pOut, FLOAT sx, FLOAT sy, FLOAT sz);
D3DXMATRIX* __stdcall D3DXMatrixTranslation(D3DXMATRIX* pOut, FLOAT x, FLOAT y, FLOAT z);
D3DXMATRIX* __stdcall D3DXMatrixRotationX(D3DXMATRIX* pOut, FLOAT Angle);
D3DXMATRIX* __stdcall D3DXMatrixRotationY(D3DXMATRIX* pOut, FLOAT Angle);
D3DXMATRIX* __stdcall D3DXMatrixRotationZ(D3DXMATRIX* pOut, FLOAT Angle);
D3DXMATRIX* __stdcall D3DXMatrixRotationAxis(D3DXMATRIX* pOut, const D3DXVECTOR3* pV, FLOAT Angle);
D3DXMATRIX* __stdcall D3DXMatrixRotationQuaternion(D3DXMATRIX* pOut, const D3DXQUATERNION* pQ);
D3DXMATRIX* __stdcall D3DXMatrixRotationYawPitchRoll(D3DXMATRIX* pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll);
D3DXMATRIX* __stdcall D3DXMatrixTransformation(D3DXMATRIX* pOut, const D3DXVECTOR3* pScalingCenter,
    const D3DXQUATERNION* pScalingRotation, const D3DXVECTOR3* pScaling,
    const D3DXVECTOR3* pRotationCenter, const D3DXQUATERNION* pRotation,
    const D3DXVECTOR3* pTranslation);
D3DXMATRIX* __stdcall D3DXMatrixTransformation2D(D3DXMATRIX* pOut, const D3DXVECTOR2* pScalingCenter,
    FLOAT ScalingRotation, const D3DXVECTOR2* pScaling,
    const D3DXVECTOR2* pRotationCenter, FLOAT Rotation,
    const D3DXVECTOR2* pTranslation);
D3DXMATRIX* __stdcall D3DXMatrixAffineTransformation(D3DXMATRIX* pOut, FLOAT Scaling, const D3DXVECTOR3* pRotationCenter,
    const D3DXQUATERNION* pRotation, const D3DXVECTOR3* pTranslation);
D3DXMATRIX* __stdcall D3DXMatrixAffineTransformation2D(D3DXMATRIX* pOut, FLOAT Scaling, const D3DXVECTOR2* pRotationCenter,
    FLOAT Rotation, const D3DXVECTOR2* pTranslation);
D3DXMATRIX* __stdcall D3DXMatrixLookAtRH(D3DXMATRIX* pOut, const D3DXVECTOR3* pEye, const D3DXVECTOR3* pAt,
    const D3DXVECTOR3* pUp);
D3DXMATRIX* __stdcall D3DXMatrixLookAtLH(D3DXMATRIX* pOut, const D3DXVECTOR3* pEye, const D3DXVECTOR3* pAt,
    const D3DXVECTOR3* pUp);
D3DXMATRIX* __stdcall D3DXMatrixPerspectiveRH(D3DXMATRIX* pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixPerspectiveLH(D3DXMATRIX* pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixPerspectiveFovRH(D3DXMATRIX* pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixPerspectiveFovLH(D3DXMATRIX* pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixPerspectiveOffCenterRH(D3DXMATRIX* pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
    FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixPerspectiveOffCenterLH(D3DXMATRIX* pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
    FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixOrthoRH(D3DXMATRIX* pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixOrthoLH(D3DXMATRIX* pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixOrthoOffCenterRH(D3DXMATRIX* pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
    FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixOrthoOffCenterLH(D3DXMATRIX* pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
    FLOAT zf);
D3DXMATRIX* __stdcall D3DXMatrixShadow(D3DXMATRIX* pOut, const D3DXVECTOR4* pLight,
    const D3DXPLANE* pPlane);
D3DXMATRIX* __stdcall D3DXMatrixReflect(D3DXMATRIX* pOut, const D3DXPLANE* pPlane);
}
FLOAT D3DXQuaternionLength(const D3DXQUATERNION* pQ);
FLOAT D3DXQuaternionLengthSq(const D3DXQUATERNION* pQ);
FLOAT D3DXQuaternionDot(const D3DXQUATERNION* pQ1, const D3DXQUATERNION* pQ2);
D3DXQUATERNION* D3DXQuaternionIdentity(D3DXQUATERNION* pOut);
BOOL D3DXQuaternionIsIdentity(const D3DXQUATERNION* pQ);
D3DXQUATERNION* D3DXQuaternionConjugate(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ);
extern "C" {
void __stdcall D3DXQuaternionToAxisAngle(const D3DXQUATERNION* pQ, D3DXVECTOR3* pAxis, FLOAT* pAngle);
D3DXQUATERNION* __stdcall D3DXQuaternionRotationMatrix(D3DXQUATERNION* pOut, const D3DXMATRIX* pM);
D3DXQUATERNION* __stdcall D3DXQuaternionRotationAxis(D3DXQUATERNION* pOut, const D3DXVECTOR3* pV, FLOAT Angle);
D3DXQUATERNION* __stdcall D3DXQuaternionRotationYawPitchRoll(D3DXQUATERNION* pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll);
D3DXQUATERNION* __stdcall D3DXQuaternionMultiply(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ1,
    const D3DXQUATERNION* pQ2);
D3DXQUATERNION* __stdcall D3DXQuaternionNormalize(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ);
D3DXQUATERNION* __stdcall D3DXQuaternionInverse(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ);
D3DXQUATERNION* __stdcall D3DXQuaternionLn(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ);
D3DXQUATERNION* __stdcall D3DXQuaternionExp(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ);
D3DXQUATERNION* __stdcall D3DXQuaternionSlerp(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ1,
    const D3DXQUATERNION* pQ2, FLOAT t);
D3DXQUATERNION* __stdcall D3DXQuaternionSquad(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ1,
    const D3DXQUATERNION* pA, const D3DXQUATERNION* pB,
    const D3DXQUATERNION* pC, FLOAT t);
void __stdcall D3DXQuaternionSquadSetup(D3DXQUATERNION* pAOut, D3DXQUATERNION* pBOut, D3DXQUATERNION* pCOut,
    const D3DXQUATERNION* pQ0, const D3DXQUATERNION* pQ1,
    const D3DXQUATERNION* pQ2, const D3DXQUATERNION* pQ3);
D3DXQUATERNION* __stdcall D3DXQuaternionBaryCentric(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ1,
    const D3DXQUATERNION* pQ2, const D3DXQUATERNION* pQ3,
    FLOAT f, FLOAT g);
}
FLOAT D3DXPlaneDot(const D3DXPLANE* pP, const D3DXVECTOR4* pV);
FLOAT D3DXPlaneDotCoord(const D3DXPLANE* pP, const D3DXVECTOR3* pV);
FLOAT D3DXPlaneDotNormal(const D3DXPLANE* pP, const D3DXVECTOR3* pV);
D3DXPLANE* D3DXPlaneScale(D3DXPLANE* pOut, const D3DXPLANE* pP, FLOAT s);
extern "C" {
D3DXPLANE* __stdcall D3DXPlaneNormalize(D3DXPLANE* pOut, const D3DXPLANE* pP);
D3DXVECTOR3* __stdcall D3DXPlaneIntersectLine(D3DXVECTOR3* pOut, const D3DXPLANE* pP, const D3DXVECTOR3* pV1,
    const D3DXVECTOR3* pV2);
D3DXPLANE* __stdcall D3DXPlaneFromPointNormal(D3DXPLANE* pOut, const D3DXVECTOR3* pPoint, const D3DXVECTOR3* pNormal);
D3DXPLANE* __stdcall D3DXPlaneFromPoints(D3DXPLANE* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2,
    const D3DXVECTOR3* pV3);
D3DXPLANE* __stdcall D3DXPlaneTransform(D3DXPLANE* pOut, const D3DXPLANE* pP, const D3DXMATRIX* pM);
D3DXPLANE* __stdcall D3DXPlaneTransformArray(D3DXPLANE* pOut, UINT OutStride, const D3DXPLANE* pP, UINT PStride, const D3DXMATRIX* pM, UINT n);
}
D3DXCOLOR* D3DXColorNegative(D3DXCOLOR* pOut, const D3DXCOLOR* pC);
D3DXCOLOR* D3DXColorAdd(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2);
D3DXCOLOR* D3DXColorSubtract(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2);
D3DXCOLOR* D3DXColorScale(D3DXCOLOR* pOut, const D3DXCOLOR* pC, FLOAT s);
D3DXCOLOR* D3DXColorModulate(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2);
D3DXCOLOR* D3DXColorLerp(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2, FLOAT s);
extern "C" {
D3DXCOLOR* __stdcall D3DXColorAdjustSaturation(D3DXCOLOR* pOut, const D3DXCOLOR* pC, FLOAT s);
D3DXCOLOR* __stdcall D3DXColorAdjustContrast(D3DXCOLOR* pOut, const D3DXCOLOR* pC, FLOAT c);
}
extern "C" {
FLOAT __stdcall D3DXFresnelTerm(FLOAT CosTheta, FLOAT RefractionIndex);
}
typedef struct ID3DXMatrixStack ID3DXMatrixStack;
typedef struct ID3DXMatrixStack* LPD3DXMATRIXSTACK;
extern "C" const GUID IID_ID3DXMatrixStack;
struct __declspec(novtable) ID3DXMatrixStack : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, LPVOID* ppvObj) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Pop(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Push(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LoadIdentity(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LoadMatrix(const D3DXMATRIX* pM) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall MultMatrix(const D3DXMATRIX* pM) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall MultMatrixLocal(const D3DXMATRIX* pM) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RotateAxis(const D3DXVECTOR3* pV, FLOAT Angle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RotateAxisLocal(const D3DXVECTOR3* pV, FLOAT Angle) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RotateYawPitchRoll(FLOAT Yaw, FLOAT Pitch, FLOAT Roll) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RotateYawPitchRollLocal(FLOAT Yaw, FLOAT Pitch, FLOAT Roll) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Scale(FLOAT x, FLOAT y, FLOAT z) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ScaleLocal(FLOAT x, FLOAT y, FLOAT z) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Translate(FLOAT x, FLOAT y, FLOAT z) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall TranslateLocal(FLOAT x, FLOAT y, FLOAT z) = 0;
    virtual __declspec(nothrow) D3DXMATRIX* __stdcall GetTop(void) = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateMatrixStack(
    DWORD Flags,
    LPD3DXMATRIXSTACK* ppStack);
}
extern "C" {
FLOAT* __stdcall D3DXSHEvalDirection(FLOAT* pOut, UINT Order, const D3DXVECTOR3* pDir);
FLOAT* __stdcall D3DXSHRotate(FLOAT* pOut, UINT Order, const D3DXMATRIX* pMatrix, const FLOAT* pIn);
FLOAT* __stdcall D3DXSHRotateZ(FLOAT* pOut, UINT Order, FLOAT Angle, const FLOAT* pIn);
FLOAT* __stdcall D3DXSHAdd(FLOAT* pOut, UINT Order, const FLOAT* pA, const FLOAT* pB);
FLOAT* __stdcall D3DXSHScale(FLOAT* pOut, UINT Order, const FLOAT* pIn, const FLOAT Scale);
FLOAT __stdcall D3DXSHDot(UINT Order, const FLOAT* pA, const FLOAT* pB);
FLOAT* __stdcall D3DXSHMultiply2(FLOAT* pOut, const FLOAT* pF, const FLOAT* pG);
FLOAT* __stdcall D3DXSHMultiply3(FLOAT* pOut, const FLOAT* pF, const FLOAT* pG);
FLOAT* __stdcall D3DXSHMultiply4(FLOAT* pOut, const FLOAT* pF, const FLOAT* pG);
FLOAT* __stdcall D3DXSHMultiply5(FLOAT* pOut, const FLOAT* pF, const FLOAT* pG);
FLOAT* __stdcall D3DXSHMultiply6(FLOAT* pOut, const FLOAT* pF, const FLOAT* pG);
HRESULT __stdcall D3DXSHEvalDirectionalLight(UINT Order, const D3DXVECTOR3* pDir,
    FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
    FLOAT* pROut, FLOAT* pGOut, FLOAT* pBOut);
HRESULT __stdcall D3DXSHEvalSphericalLight(UINT Order, const D3DXVECTOR3* pPos, FLOAT Radius,
    FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
    FLOAT* pROut, FLOAT* pGOut, FLOAT* pBOut);
HRESULT __stdcall D3DXSHEvalConeLight(UINT Order, const D3DXVECTOR3* pDir, FLOAT Radius,
    FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
    FLOAT* pROut, FLOAT* pGOut, FLOAT* pBOut);
HRESULT __stdcall D3DXSHEvalHemisphereLight(UINT Order, const D3DXVECTOR3* pDir, D3DXCOLOR Top, D3DXCOLOR Bottom,
    FLOAT* pROut, FLOAT* pGOut, FLOAT* pBOut);
HRESULT __stdcall D3DXSHProjectCubeMap(UINT uOrder, LPDIRECT3DCUBETEXTURE9 pCubeMap,
    FLOAT* pROut, FLOAT* pGOut, FLOAT* pBOut);
}
#pragma external_header(push)
__forceinline D3DXFLOAT16::D3DXFLOAT16(FLOAT f)
{
    D3DXFloat32To16Array(this, &f, 1);
}
__forceinline D3DXFLOAT16::D3DXFLOAT16(const D3DXFLOAT16& f)
{
    value = f.value;
}
__forceinline D3DXFLOAT16::operator FLOAT()
{
    FLOAT f;
    D3DXFloat16To32Array(&f, this, 1);
    return f;
}
__forceinline BOOL
D3DXFLOAT16::operator==(const D3DXFLOAT16& f) const
{
    return value == f.value;
}
__forceinline BOOL
D3DXFLOAT16::operator!=(const D3DXFLOAT16& f) const
{
    return value != f.value;
}
__forceinline D3DXVECTOR2::D3DXVECTOR2(const FLOAT* pf)
{
    x = pf[0];
    y = pf[1];
}
__forceinline D3DXVECTOR2::D3DXVECTOR2(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&x, pf, 2);
}
__forceinline D3DXVECTOR2::D3DXVECTOR2(FLOAT fx, FLOAT fy)
{
    x = fx;
    y = fy;
}
__forceinline D3DXVECTOR2::operator FLOAT*()
{
    return (FLOAT*)&x;
}
__forceinline D3DXVECTOR2::operator const FLOAT*() const
{
    return (const FLOAT*)&x;
}
__forceinline D3DXVECTOR2&
D3DXVECTOR2::operator+=(const D3DXVECTOR2& v)
{
    x += v.x;
    y += v.y;
    return *this;
}
__forceinline D3DXVECTOR2&
D3DXVECTOR2::operator-=(const D3DXVECTOR2& v)
{
    x -= v.x;
    y -= v.y;
    return *this;
}
__forceinline D3DXVECTOR2&
D3DXVECTOR2::operator*=(FLOAT f)
{
    x *= f;
    y *= f;
    return *this;
}
__forceinline D3DXVECTOR2&
D3DXVECTOR2::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    return *this;
}
__forceinline D3DXVECTOR2
D3DXVECTOR2::operator+() const
{
    return *this;
}
__forceinline D3DXVECTOR2
D3DXVECTOR2::operator-() const
{
    return D3DXVECTOR2(-x, -y);
}
__forceinline D3DXVECTOR2
D3DXVECTOR2::operator+(const D3DXVECTOR2& v) const
{
    return D3DXVECTOR2(x + v.x, y + v.y);
}
__forceinline D3DXVECTOR2
D3DXVECTOR2::operator-(const D3DXVECTOR2& v) const
{
    return D3DXVECTOR2(x - v.x, y - v.y);
}
__forceinline D3DXVECTOR2
D3DXVECTOR2::operator*(FLOAT f) const
{
    return D3DXVECTOR2(x * f, y * f);
}
__forceinline D3DXVECTOR2
D3DXVECTOR2::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR2(x * fInv, y * fInv);
}
__forceinline D3DXVECTOR2
operator*(FLOAT f, const D3DXVECTOR2& v)
{
    return D3DXVECTOR2(f * v.x, f * v.y);
}
__forceinline BOOL
D3DXVECTOR2::operator==(const D3DXVECTOR2& v) const
{
    return x == v.x && y == v.y;
}
__forceinline BOOL
D3DXVECTOR2::operator!=(const D3DXVECTOR2& v) const
{
    return x != v.x || y != v.y;
}
__forceinline D3DXVECTOR2_16F::D3DXVECTOR2_16F(const FLOAT* pf)
{
    D3DXFloat32To16Array(&x, pf, 2);
}
__forceinline D3DXVECTOR2_16F::D3DXVECTOR2_16F(const D3DXFLOAT16* pf)
{
    *((DWORD*)&x) = *((DWORD*)&pf[0]);
}
__forceinline D3DXVECTOR2_16F::D3DXVECTOR2_16F(const D3DXFLOAT16& fx, const D3DXFLOAT16& fy)
{
    x = fx;
    y = fy;
}
__forceinline D3DXVECTOR2_16F::operator D3DXFLOAT16*()
{
    return (D3DXFLOAT16*)&x;
}
__forceinline D3DXVECTOR2_16F::operator const D3DXFLOAT16*() const
{
    return (const D3DXFLOAT16*)&x;
}
__forceinline BOOL
D3DXVECTOR2_16F::operator==(const D3DXVECTOR2_16F& v) const
{
    return *((DWORD*)&x) == *((DWORD*)&v.x);
}
__forceinline BOOL
D3DXVECTOR2_16F::operator!=(const D3DXVECTOR2_16F& v) const
{
    return *((DWORD*)&x) != *((DWORD*)&v.x);
}
__forceinline D3DXVECTOR3::D3DXVECTOR3(const FLOAT* pf)
{
    x = pf[0];
    y = pf[1];
    z = pf[2];
}
__forceinline D3DXVECTOR3::D3DXVECTOR3(const D3DVECTOR& v)
{
    x = v.x;
    y = v.y;
    z = v.z;
}
__forceinline D3DXVECTOR3::D3DXVECTOR3(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&x, pf, 3);
}
__forceinline D3DXVECTOR3::D3DXVECTOR3(FLOAT fx, FLOAT fy, FLOAT fz)
{
    x = fx;
    y = fy;
    z = fz;
}
__forceinline D3DXVECTOR3::operator FLOAT*()
{
    return (FLOAT*)&x;
}
__forceinline D3DXVECTOR3::operator const FLOAT*() const
{
    return (const FLOAT*)&x;
}
__forceinline D3DXVECTOR3&
D3DXVECTOR3::operator+=(const D3DXVECTOR3& v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}
__forceinline D3DXVECTOR3&
D3DXVECTOR3::operator-=(const D3DXVECTOR3& v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}
__forceinline D3DXVECTOR3&
D3DXVECTOR3::operator*=(FLOAT f)
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}
__forceinline D3DXVECTOR3&
D3DXVECTOR3::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}
__forceinline D3DXVECTOR3
D3DXVECTOR3::operator+() const
{
    return *this;
}
__forceinline D3DXVECTOR3
D3DXVECTOR3::operator-() const
{
    return D3DXVECTOR3(-x, -y, -z);
}
__forceinline D3DXVECTOR3
D3DXVECTOR3::operator+(const D3DXVECTOR3& v) const
{
    return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);
}
__forceinline D3DXVECTOR3
D3DXVECTOR3::operator-(const D3DXVECTOR3& v) const
{
    return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);
}
__forceinline D3DXVECTOR3
D3DXVECTOR3::operator*(FLOAT f) const
{
    return D3DXVECTOR3(x * f, y * f, z * f);
}
__forceinline D3DXVECTOR3
D3DXVECTOR3::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
}
__forceinline D3DXVECTOR3
operator*(FLOAT f, const struct D3DXVECTOR3& v)
{
    return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
}
__forceinline BOOL
D3DXVECTOR3::operator==(const D3DXVECTOR3& v) const
{
    return x == v.x && y == v.y && z == v.z;
}
__forceinline BOOL
D3DXVECTOR3::operator!=(const D3DXVECTOR3& v) const
{
    return x != v.x || y != v.y || z != v.z;
}
__forceinline D3DXVECTOR3_16F::D3DXVECTOR3_16F(const FLOAT* pf)
{
    D3DXFloat32To16Array(&x, pf, 3);
}
__forceinline D3DXVECTOR3_16F::D3DXVECTOR3_16F(const D3DVECTOR& v)
{
    D3DXFloat32To16Array(&x, &v.x, 1);
    D3DXFloat32To16Array(&y, &v.y, 1);
    D3DXFloat32To16Array(&z, &v.z, 1);
}
__forceinline D3DXVECTOR3_16F::D3DXVECTOR3_16F(const D3DXFLOAT16* pf)
{
    *((DWORD*)&x) = *((DWORD*)&pf[0]);
    *((WORD*)&z) = *((WORD*)&pf[2]);
}
__forceinline D3DXVECTOR3_16F::D3DXVECTOR3_16F(const D3DXFLOAT16& fx, const D3DXFLOAT16& fy, const D3DXFLOAT16& fz)
{
    x = fx;
    y = fy;
    z = fz;
}
__forceinline D3DXVECTOR3_16F::operator D3DXFLOAT16*()
{
    return (D3DXFLOAT16*)&x;
}
__forceinline D3DXVECTOR3_16F::operator const D3DXFLOAT16*() const
{
    return (const D3DXFLOAT16*)&x;
}
__forceinline BOOL
D3DXVECTOR3_16F::operator==(const D3DXVECTOR3_16F& v) const
{
    return *((DWORD*)&x) == *((DWORD*)&v.x) && *((WORD*)&z) == *((WORD*)&v.z);
}
__forceinline BOOL
D3DXVECTOR3_16F::operator!=(const D3DXVECTOR3_16F& v) const
{
    return *((DWORD*)&x) != *((DWORD*)&v.x) || *((WORD*)&z) != *((WORD*)&v.z);
}
__forceinline D3DXVECTOR4::D3DXVECTOR4(const FLOAT* pf)
{
    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}
__forceinline D3DXVECTOR4::D3DXVECTOR4(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&x, pf, 4);
}
__forceinline D3DXVECTOR4::D3DXVECTOR4(const D3DVECTOR& v, FLOAT f)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = f;
}
__forceinline D3DXVECTOR4::D3DXVECTOR4(FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw)
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}
__forceinline D3DXVECTOR4::operator FLOAT*()
{
    return (FLOAT*)&x;
}
__forceinline D3DXVECTOR4::operator const FLOAT*() const
{
    return (const FLOAT*)&x;
}
__forceinline D3DXVECTOR4&
D3DXVECTOR4::operator+=(const D3DXVECTOR4& v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}
__forceinline D3DXVECTOR4&
D3DXVECTOR4::operator-=(const D3DXVECTOR4& v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}
__forceinline D3DXVECTOR4&
D3DXVECTOR4::operator*=(FLOAT f)
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}
__forceinline D3DXVECTOR4&
D3DXVECTOR4::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}
__forceinline D3DXVECTOR4
D3DXVECTOR4::operator+() const
{
    return *this;
}
__forceinline D3DXVECTOR4
D3DXVECTOR4::operator-() const
{
    return D3DXVECTOR4(-x, -y, -z, -w);
}
__forceinline D3DXVECTOR4
D3DXVECTOR4::operator+(const D3DXVECTOR4& v) const
{
    return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
}
__forceinline D3DXVECTOR4
D3DXVECTOR4::operator-(const D3DXVECTOR4& v) const
{
    return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
}
__forceinline D3DXVECTOR4
D3DXVECTOR4::operator*(FLOAT f) const
{
    return D3DXVECTOR4(x * f, y * f, z * f, w * f);
}
__forceinline D3DXVECTOR4
D3DXVECTOR4::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
}
__forceinline D3DXVECTOR4
operator*(FLOAT f, const D3DXVECTOR4& v)
{
    return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
}
__forceinline BOOL
D3DXVECTOR4::operator==(const D3DXVECTOR4& v) const
{
    return x == v.x && y == v.y && z == v.z && w == v.w;
}
__forceinline BOOL
D3DXVECTOR4::operator!=(const D3DXVECTOR4& v) const
{
    return x != v.x || y != v.y || z != v.z || w != v.w;
}
__forceinline D3DXVECTOR4_16F::D3DXVECTOR4_16F(const FLOAT* pf)
{
    D3DXFloat32To16Array(&x, pf, 4);
}
__forceinline D3DXVECTOR4_16F::D3DXVECTOR4_16F(const D3DXFLOAT16* pf)
{
    *((DWORD*)&x) = *((DWORD*)&pf[0]);
    *((DWORD*)&z) = *((DWORD*)&pf[2]);
}
__forceinline D3DXVECTOR4_16F::D3DXVECTOR4_16F(const D3DXVECTOR3_16F& v, const D3DXFLOAT16& f)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = f;
}
__forceinline D3DXVECTOR4_16F::D3DXVECTOR4_16F(const D3DXFLOAT16& fx, const D3DXFLOAT16& fy, const D3DXFLOAT16& fz, const D3DXFLOAT16& fw)
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}
__forceinline D3DXVECTOR4_16F::operator D3DXFLOAT16*()
{
    return (D3DXFLOAT16*)&x;
}
__forceinline D3DXVECTOR4_16F::operator const D3DXFLOAT16*() const
{
    return (const D3DXFLOAT16*)&x;
}
__forceinline BOOL
D3DXVECTOR4_16F::operator==(const D3DXVECTOR4_16F& v) const
{
    return *((DWORD*)&x) == *((DWORD*)&v.x) && *((DWORD*)&z) == *((DWORD*)&v.z);
}
__forceinline BOOL
D3DXVECTOR4_16F::operator!=(const D3DXVECTOR4_16F& v) const
{
    return *((DWORD*)&x) != *((DWORD*)&v.x) || *((DWORD*)&z) != *((DWORD*)&v.z);
}
__forceinline D3DXMATRIX::D3DXMATRIX(const FLOAT* pf)
{
    memcpy(&_11, pf, sizeof(D3DXMATRIX));
}
__forceinline D3DXMATRIX::D3DXMATRIX(const D3DMATRIX& mat)
{
    memcpy(&_11, &mat, sizeof(D3DXMATRIX));
}
__forceinline D3DXMATRIX::D3DXMATRIX(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&_11, pf, 16);
}
__forceinline D3DXMATRIX::D3DXMATRIX(FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
    FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
    FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
    FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44)
{
    _11 = f11;
    _12 = f12;
    _13 = f13;
    _14 = f14;
    _21 = f21;
    _22 = f22;
    _23 = f23;
    _24 = f24;
    _31 = f31;
    _32 = f32;
    _33 = f33;
    _34 = f34;
    _41 = f41;
    _42 = f42;
    _43 = f43;
    _44 = f44;
}
__forceinline FLOAT&
D3DXMATRIX::operator()(UINT iRow, UINT iCol)
{
    return m[iRow][iCol];
}
__forceinline FLOAT
D3DXMATRIX::operator()(UINT iRow, UINT iCol) const
{
    return m[iRow][iCol];
}
__forceinline D3DXMATRIX::operator FLOAT*()
{
    return (FLOAT*)&_11;
}
__forceinline D3DXMATRIX::operator const FLOAT*() const
{
    return (const FLOAT*)&_11;
}
__forceinline D3DXMATRIX&
D3DXMATRIX::operator*=(const D3DXMATRIX& mat)
{
    D3DXMatrixMultiply(this, this, &mat);
    return *this;
}
__forceinline D3DXMATRIX&
D3DXMATRIX::operator+=(const D3DXMATRIX& mat)
{
    _11 += mat._11;
    _12 += mat._12;
    _13 += mat._13;
    _14 += mat._14;
    _21 += mat._21;
    _22 += mat._22;
    _23 += mat._23;
    _24 += mat._24;
    _31 += mat._31;
    _32 += mat._32;
    _33 += mat._33;
    _34 += mat._34;
    _41 += mat._41;
    _42 += mat._42;
    _43 += mat._43;
    _44 += mat._44;
    return *this;
}
__forceinline D3DXMATRIX&
D3DXMATRIX::operator-=(const D3DXMATRIX& mat)
{
    _11 -= mat._11;
    _12 -= mat._12;
    _13 -= mat._13;
    _14 -= mat._14;
    _21 -= mat._21;
    _22 -= mat._22;
    _23 -= mat._23;
    _24 -= mat._24;
    _31 -= mat._31;
    _32 -= mat._32;
    _33 -= mat._33;
    _34 -= mat._34;
    _41 -= mat._41;
    _42 -= mat._42;
    _43 -= mat._43;
    _44 -= mat._44;
    return *this;
}
__forceinline D3DXMATRIX&
D3DXMATRIX::operator*=(FLOAT f)
{
    _11 *= f;
    _12 *= f;
    _13 *= f;
    _14 *= f;
    _21 *= f;
    _22 *= f;
    _23 *= f;
    _24 *= f;
    _31 *= f;
    _32 *= f;
    _33 *= f;
    _34 *= f;
    _41 *= f;
    _42 *= f;
    _43 *= f;
    _44 *= f;
    return *this;
}
__forceinline D3DXMATRIX&
D3DXMATRIX::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    _11 *= fInv;
    _12 *= fInv;
    _13 *= fInv;
    _14 *= fInv;
    _21 *= fInv;
    _22 *= fInv;
    _23 *= fInv;
    _24 *= fInv;
    _31 *= fInv;
    _32 *= fInv;
    _33 *= fInv;
    _34 *= fInv;
    _41 *= fInv;
    _42 *= fInv;
    _43 *= fInv;
    _44 *= fInv;
    return *this;
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator+() const
{
    return *this;
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator-() const
{
    return D3DXMATRIX(-_11, -_12, -_13, -_14,
        -_21, -_22, -_23, -_24,
        -_31, -_32, -_33, -_34,
        -_41, -_42, -_43, -_44);
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator*(const D3DXMATRIX& mat) const
{
    D3DXMATRIX matT;
    D3DXMatrixMultiply(&matT, this, &mat);
    return matT;
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator+(const D3DXMATRIX& mat) const
{
    return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
        _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
        _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
        _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator-(const D3DXMATRIX& mat) const
{
    return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
        _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
        _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
        _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator*(FLOAT f) const
{
    return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
        _21 * f, _22 * f, _23 * f, _24 * f,
        _31 * f, _32 * f, _33 * f, _34 * f,
        _41 * f, _42 * f, _43 * f, _44 * f);
}
__forceinline D3DXMATRIX
D3DXMATRIX::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
        _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
        _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
        _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
}
__forceinline D3DXMATRIX
operator*(FLOAT f, const D3DXMATRIX& mat)
{
    return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
        f * mat._21, f * mat._22, f * mat._23, f * mat._24,
        f * mat._31, f * mat._32, f * mat._33, f * mat._34,
        f * mat._41, f * mat._42, f * mat._43, f * mat._44);
}
__forceinline BOOL
D3DXMATRIX::operator==(const D3DXMATRIX& mat) const
{
    return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
}
__forceinline BOOL
D3DXMATRIX::operator!=(const D3DXMATRIX& mat) const
{
    return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
}
__forceinline _D3DXMATRIXA16::_D3DXMATRIXA16(const FLOAT* f)
    : D3DXMATRIX(f)
{
}
__forceinline _D3DXMATRIXA16::_D3DXMATRIXA16(const D3DMATRIX& m)
    : D3DXMATRIX(m)
{
}
__forceinline _D3DXMATRIXA16::_D3DXMATRIXA16(const D3DXFLOAT16* f)
    : D3DXMATRIX(f)
{
}
__forceinline _D3DXMATRIXA16::_D3DXMATRIXA16(FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
    FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
    FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
    FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44)
    : D3DXMATRIX(_11, _12, _13, _14,
        _21, _22, _23, _24,
        _31, _32, _33, _34,
        _41, _42, _43, _44)
{
}
__forceinline void*
_D3DXMATRIXA16::operator new(size_t s)
{
    if (s > (0xffffffffffffffffui64 - 16))
        return 0;
    LPBYTE p = ::new BYTE[s + 16];
    if (p) {
        BYTE offset = (BYTE)(16 - ((UINT_PTR)p & 15));
        p += offset;
        p[-1] = offset;
    }
    return p;
}
__forceinline void*
_D3DXMATRIXA16::operator new[](size_t s)
{
    if (s > (0xffffffffffffffffui64 - 16))
        return 0;
    LPBYTE p = ::new BYTE[s + 16];
    if (p) {
        BYTE offset = (BYTE)(16 - ((UINT_PTR)p & 15));
        p += offset;
        p[-1] = offset;
    }
    return p;
}
__forceinline void
_D3DXMATRIXA16::operator delete(void* p)
{
    if (p) {
        BYTE* pb = static_cast<BYTE*>(p);
        pb -= pb[-1];
        ::delete[] pb;
    }
}
__forceinline void
_D3DXMATRIXA16::operator delete[](void* p)
{
    if (p) {
        BYTE* pb = static_cast<BYTE*>(p);
        pb -= pb[-1];
        ::delete[] pb;
    }
}
__forceinline _D3DXMATRIXA16&
_D3DXMATRIXA16::operator=(const D3DXMATRIX& rhs)
{
    memcpy(&_11, &rhs, sizeof(D3DXMATRIX));
    return *this;
}
__forceinline D3DXQUATERNION::D3DXQUATERNION(const FLOAT* pf)
{
    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}
__forceinline D3DXQUATERNION::D3DXQUATERNION(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&x, pf, 4);
}
__forceinline D3DXQUATERNION::D3DXQUATERNION(FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw)
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}
__forceinline D3DXQUATERNION::operator FLOAT*()
{
    return (FLOAT*)&x;
}
__forceinline D3DXQUATERNION::operator const FLOAT*() const
{
    return (const FLOAT*)&x;
}
__forceinline D3DXQUATERNION&
D3DXQUATERNION::operator+=(const D3DXQUATERNION& q)
{
    x += q.x;
    y += q.y;
    z += q.z;
    w += q.w;
    return *this;
}
__forceinline D3DXQUATERNION&
D3DXQUATERNION::operator-=(const D3DXQUATERNION& q)
{
    x -= q.x;
    y -= q.y;
    z -= q.z;
    w -= q.w;
    return *this;
}
__forceinline D3DXQUATERNION&
D3DXQUATERNION::operator*=(const D3DXQUATERNION& q)
{
    D3DXQuaternionMultiply(this, this, &q);
    return *this;
}
__forceinline D3DXQUATERNION&
D3DXQUATERNION::operator*=(FLOAT f)
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}
__forceinline D3DXQUATERNION&
D3DXQUATERNION::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator+() const
{
    return *this;
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator-() const
{
    return D3DXQUATERNION(-x, -y, -z, -w);
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator+(const D3DXQUATERNION& q) const
{
    return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator-(const D3DXQUATERNION& q) const
{
    return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator*(const D3DXQUATERNION& q) const
{
    D3DXQUATERNION qT;
    D3DXQuaternionMultiply(&qT, this, &q);
    return qT;
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator*(FLOAT f) const
{
    return D3DXQUATERNION(x * f, y * f, z * f, w * f);
}
__forceinline D3DXQUATERNION
D3DXQUATERNION::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
}
__forceinline D3DXQUATERNION
operator*(FLOAT f, const D3DXQUATERNION& q)
{
    return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
}
__forceinline BOOL
D3DXQUATERNION::operator==(const D3DXQUATERNION& q) const
{
    return x == q.x && y == q.y && z == q.z && w == q.w;
}
__forceinline BOOL
D3DXQUATERNION::operator!=(const D3DXQUATERNION& q) const
{
    return x != q.x || y != q.y || z != q.z || w != q.w;
}
__forceinline D3DXPLANE::D3DXPLANE(const FLOAT* pf)
{
    a = pf[0];
    b = pf[1];
    c = pf[2];
    d = pf[3];
}
__forceinline D3DXPLANE::D3DXPLANE(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&a, pf, 4);
}
__forceinline D3DXPLANE::D3DXPLANE(FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd)
{
    a = fa;
    b = fb;
    c = fc;
    d = fd;
}
__forceinline D3DXPLANE::operator FLOAT*()
{
    return (FLOAT*)&a;
}
__forceinline D3DXPLANE::operator const FLOAT*() const
{
    return (const FLOAT*)&a;
}
__forceinline D3DXPLANE&
D3DXPLANE::operator*=(FLOAT f)
{
    a *= f;
    b *= f;
    c *= f;
    d *= f;
    return *this;
}
__forceinline D3DXPLANE&
D3DXPLANE::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    a *= fInv;
    b *= fInv;
    c *= fInv;
    d *= fInv;
    return *this;
}
__forceinline D3DXPLANE
D3DXPLANE::operator+() const
{
    return *this;
}
__forceinline D3DXPLANE
D3DXPLANE::operator-() const
{
    return D3DXPLANE(-a, -b, -c, -d);
}
__forceinline D3DXPLANE
D3DXPLANE::operator*(FLOAT f) const
{
    return D3DXPLANE(a * f, b * f, c * f, d * f);
}
__forceinline D3DXPLANE
D3DXPLANE::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXPLANE(a * fInv, b * fInv, c * fInv, d * fInv);
}
__forceinline D3DXPLANE
operator*(FLOAT f, const D3DXPLANE& p)
{
    return D3DXPLANE(f * p.a, f * p.b, f * p.c, f * p.d);
}
__forceinline BOOL
D3DXPLANE::operator==(const D3DXPLANE& p) const
{
    return a == p.a && b == p.b && c == p.c && d == p.d;
}
__forceinline BOOL
D3DXPLANE::operator!=(const D3DXPLANE& p) const
{
    return a != p.a || b != p.b || c != p.c || d != p.d;
}
__forceinline D3DXCOLOR::D3DXCOLOR(DWORD dw)
{
    const FLOAT f = 1.0f / 255.0f;
    r = f * (FLOAT)(unsigned char)(dw >> 16);
    g = f * (FLOAT)(unsigned char)(dw >> 8);
    b = f * (FLOAT)(unsigned char)(dw >> 0);
    a = f * (FLOAT)(unsigned char)(dw >> 24);
}
__forceinline D3DXCOLOR::D3DXCOLOR(const FLOAT* pf)
{
    r = pf[0];
    g = pf[1];
    b = pf[2];
    a = pf[3];
}
__forceinline D3DXCOLOR::D3DXCOLOR(const D3DXFLOAT16* pf)
{
    D3DXFloat16To32Array(&r, pf, 4);
}
__forceinline D3DXCOLOR::D3DXCOLOR(const D3DCOLORVALUE& c)
{
    r = c.r;
    g = c.g;
    b = c.b;
    a = c.a;
}
__forceinline D3DXCOLOR::D3DXCOLOR(FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa)
{
    r = fr;
    g = fg;
    b = fb;
    a = fa;
}
__forceinline D3DXCOLOR::operator DWORD() const
{
    DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD)(r * 255.0f + 0.5f);
    DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD)(g * 255.0f + 0.5f);
    DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD)(b * 255.0f + 0.5f);
    DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD)(a * 255.0f + 0.5f);
    return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
}
__forceinline D3DXCOLOR::operator FLOAT*()
{
    return (FLOAT*)&r;
}
__forceinline D3DXCOLOR::operator const FLOAT*() const
{
    return (const FLOAT*)&r;
}
__forceinline D3DXCOLOR::operator D3DCOLORVALUE*()
{
    return (D3DCOLORVALUE*)&r;
}
__forceinline D3DXCOLOR::operator const D3DCOLORVALUE*() const
{
    return (const D3DCOLORVALUE*)&r;
}
__forceinline D3DXCOLOR::operator D3DCOLORVALUE&()
{
    return *((D3DCOLORVALUE*)&r);
}
__forceinline D3DXCOLOR::operator const D3DCOLORVALUE&() const
{
    return *((const D3DCOLORVALUE*)&r);
}
__forceinline D3DXCOLOR&
D3DXCOLOR::operator+=(const D3DXCOLOR& c)
{
    r += c.r;
    g += c.g;
    b += c.b;
    a += c.a;
    return *this;
}
__forceinline D3DXCOLOR&
D3DXCOLOR::operator-=(const D3DXCOLOR& c)
{
    r -= c.r;
    g -= c.g;
    b -= c.b;
    a -= c.a;
    return *this;
}
__forceinline D3DXCOLOR&
D3DXCOLOR::operator*=(FLOAT f)
{
    r *= f;
    g *= f;
    b *= f;
    a *= f;
    return *this;
}
__forceinline D3DXCOLOR&
D3DXCOLOR::operator/=(FLOAT f)
{
    FLOAT fInv = 1.0f / f;
    r *= fInv;
    g *= fInv;
    b *= fInv;
    a *= fInv;
    return *this;
}
__forceinline D3DXCOLOR
D3DXCOLOR::operator+() const
{
    return *this;
}
__forceinline D3DXCOLOR
D3DXCOLOR::operator-() const
{
    return D3DXCOLOR(-r, -g, -b, -a);
}
__forceinline D3DXCOLOR
D3DXCOLOR::operator+(const D3DXCOLOR& c) const
{
    return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
}
__forceinline D3DXCOLOR
D3DXCOLOR::operator-(const D3DXCOLOR& c) const
{
    return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
}
__forceinline D3DXCOLOR
D3DXCOLOR::operator*(FLOAT f) const
{
    return D3DXCOLOR(r * f, g * f, b * f, a * f);
}
__forceinline D3DXCOLOR
D3DXCOLOR::operator/(FLOAT f) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
}
__forceinline D3DXCOLOR
operator*(FLOAT f, const D3DXCOLOR& c)
{
    return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
}
__forceinline BOOL
D3DXCOLOR::operator==(const D3DXCOLOR& c) const
{
    return r == c.r && g == c.g && b == c.b && a == c.a;
}
__forceinline BOOL
D3DXCOLOR::operator!=(const D3DXCOLOR& c) const
{
    return r != c.r || g != c.g || b != c.b || a != c.a;
}
__forceinline FLOAT D3DXVec2Length(const D3DXVECTOR2* pV)
{
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
}
__forceinline FLOAT D3DXVec2LengthSq(const D3DXVECTOR2* pV)
{
    return pV->x * pV->x + pV->y * pV->y;
}
__forceinline FLOAT D3DXVec2Dot(const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2)
{
    return pV1->x * pV2->x + pV1->y * pV2->y;
}
__forceinline FLOAT D3DXVec2CCW(const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2)
{
    return pV1->x * pV2->y - pV1->y * pV2->x;
}
__forceinline D3DXVECTOR2* D3DXVec2Add(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2)
{
    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}
__forceinline D3DXVECTOR2* D3DXVec2Subtract(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2)
{
    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}
__forceinline D3DXVECTOR2* D3DXVec2Minimize(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2)
{
    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}
__forceinline D3DXVECTOR2* D3DXVec2Maximize(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2)
{
    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}
__forceinline D3DXVECTOR2* D3DXVec2Scale(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV, FLOAT s)
{
    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}
__forceinline D3DXVECTOR2* D3DXVec2Lerp(D3DXVECTOR2* pOut, const D3DXVECTOR2* pV1, const D3DXVECTOR2* pV2,
    FLOAT s)
{
    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}
__forceinline FLOAT D3DXVec3Length(const D3DXVECTOR3* pV)
{
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
}
__forceinline FLOAT D3DXVec3LengthSq(const D3DXVECTOR3* pV)
{
    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}
__forceinline FLOAT D3DXVec3Dot(const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2)
{
    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}
__forceinline D3DXVECTOR3* D3DXVec3Cross(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2)
{
    D3DXVECTOR3 v;
    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;
    *pOut = v;
    return pOut;
}
__forceinline D3DXVECTOR3* D3DXVec3Add(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2)
{
    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}
__forceinline D3DXVECTOR3* D3DXVec3Subtract(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2)
{
    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}
__forceinline D3DXVECTOR3* D3DXVec3Minimize(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2)
{
    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}
__forceinline D3DXVECTOR3* D3DXVec3Maximize(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2)
{
    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}
__forceinline D3DXVECTOR3* D3DXVec3Scale(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV, FLOAT s)
{
    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}
__forceinline D3DXVECTOR3* D3DXVec3Lerp(D3DXVECTOR3* pOut, const D3DXVECTOR3* pV1, const D3DXVECTOR3* pV2,
    FLOAT s)
{
    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}
__forceinline FLOAT D3DXVec4Length(const D3DXVECTOR4* pV)
{
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
}
__forceinline FLOAT D3DXVec4LengthSq(const D3DXVECTOR4* pV)
{
    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}
__forceinline FLOAT D3DXVec4Dot(const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2)
{
    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}
__forceinline D3DXVECTOR4* D3DXVec4Add(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2)
{
    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}
__forceinline D3DXVECTOR4* D3DXVec4Subtract(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2)
{
    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}
__forceinline D3DXVECTOR4* D3DXVec4Minimize(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2)
{
    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}
__forceinline D3DXVECTOR4* D3DXVec4Maximize(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2)
{
    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}
__forceinline D3DXVECTOR4* D3DXVec4Scale(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV, FLOAT s)
{
    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}
__forceinline D3DXVECTOR4* D3DXVec4Lerp(D3DXVECTOR4* pOut, const D3DXVECTOR4* pV1, const D3DXVECTOR4* pV2,
    FLOAT s)
{
    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}
__forceinline D3DXMATRIX* D3DXMatrixIdentity(D3DXMATRIX* pOut)
{
    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] = pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] = pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] = pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}
__forceinline BOOL D3DXMatrixIsIdentity(const D3DXMATRIX* pM)
{
    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f && pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f && pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f && pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}
__forceinline FLOAT D3DXQuaternionLength(const D3DXQUATERNION* pQ)
{
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
}
__forceinline FLOAT D3DXQuaternionLengthSq(const D3DXQUATERNION* pQ)
{
    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}
__forceinline FLOAT D3DXQuaternionDot(const D3DXQUATERNION* pQ1, const D3DXQUATERNION* pQ2)
{
    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}
__forceinline D3DXQUATERNION* D3DXQuaternionIdentity(D3DXQUATERNION* pOut)
{
    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}
__forceinline BOOL D3DXQuaternionIsIdentity(const D3DXQUATERNION* pQ)
{
    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}
__forceinline D3DXQUATERNION* D3DXQuaternionConjugate(D3DXQUATERNION* pOut, const D3DXQUATERNION* pQ)
{
    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w = pQ->w;
    return pOut;
}
__forceinline FLOAT D3DXPlaneDot(const D3DXPLANE* pP, const D3DXVECTOR4* pV)
{
    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}
__forceinline FLOAT D3DXPlaneDotCoord(const D3DXPLANE* pP, const D3DXVECTOR3* pV)
{
    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}
__forceinline FLOAT D3DXPlaneDotNormal(const D3DXPLANE* pP, const D3DXVECTOR3* pV)
{
    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}
__forceinline D3DXPLANE* D3DXPlaneScale(D3DXPLANE* pOut, const D3DXPLANE* pP, FLOAT s)
{
    pOut->a = pP->a * s;
    pOut->b = pP->b * s;
    pOut->c = pP->c * s;
    pOut->d = pP->d * s;
    return pOut;
}
__forceinline D3DXCOLOR* D3DXColorNegative(D3DXCOLOR* pOut, const D3DXCOLOR* pC)
{
    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}
__forceinline D3DXCOLOR* D3DXColorAdd(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2)
{
    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}
__forceinline D3DXCOLOR* D3DXColorSubtract(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2)
{
    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}
__forceinline D3DXCOLOR* D3DXColorScale(D3DXCOLOR* pOut, const D3DXCOLOR* pC, FLOAT s)
{
    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
}
__forceinline D3DXCOLOR* D3DXColorModulate(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2)
{
    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}
__forceinline D3DXCOLOR* D3DXColorLerp(D3DXCOLOR* pOut, const D3DXCOLOR* pC1, const D3DXCOLOR* pC2, FLOAT s)
{
    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}
#pragma external_header(pop)
#pragma warning(pop)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
BOOL __stdcall D3DXCheckVersion(UINT D3DSdkVersion, UINT D3DXSdkVersion);
}
extern "C" {
BOOL __stdcall D3DXDebugMute(BOOL Mute);
}
extern "C" {
UINT __stdcall D3DXGetDriverLevel(LPDIRECT3DDEVICE9 pDevice);
}
typedef struct ID3DXBuffer ID3DXBuffer;
typedef struct ID3DXBuffer* LPD3DXBUFFER;
extern "C" const GUID IID_ID3DXBuffer;
struct __declspec(novtable) ID3DXBuffer : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) LPVOID __stdcall GetBufferPointer(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetBufferSize(void) = 0;
};
typedef struct ID3DXSprite ID3DXSprite;
typedef struct ID3DXSprite* LPD3DXSPRITE;
extern "C" const GUID IID_ID3DXSprite;
struct __declspec(novtable) ID3DXSprite : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTransform(D3DXMATRIX* pTransform) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTransform(const D3DXMATRIX* pTransform) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetWorldViewRH(const D3DXMATRIX* pWorld, const D3DXMATRIX* pView) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetWorldViewLH(const D3DXMATRIX* pWorld, const D3DXMATRIX* pView) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Begin(DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Draw(LPDIRECT3DTEXTURE9 pTexture, const RECT* pSrcRect, const D3DXVECTOR3* pCenter, const D3DXVECTOR3* pPosition, D3DCOLOR Color) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Flush(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall End(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnLostDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnResetDevice(void) = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateSprite(
    LPDIRECT3DDEVICE9 pDevice,
    LPD3DXSPRITE* ppSprite);
}
typedef struct _D3DXFONT_DESCA {
    INT Height;
    UINT Width;
    UINT Weight;
    UINT MipLevels;
    BOOL Italic;
    BYTE CharSet;
    BYTE OutputPrecision;
    BYTE Quality;
    BYTE PitchAndFamily;
    CHAR FaceName[32];
} D3DXFONT_DESCA, *LPD3DXFONT_DESCA;
typedef struct _D3DXFONT_DESCW {
    INT Height;
    UINT Width;
    UINT Weight;
    UINT MipLevels;
    BOOL Italic;
    BYTE CharSet;
    BYTE OutputPrecision;
    BYTE Quality;
    BYTE PitchAndFamily;
    WCHAR FaceName[32];
} D3DXFONT_DESCW, *LPD3DXFONT_DESCW;
typedef D3DXFONT_DESCW D3DXFONT_DESC;
typedef LPD3DXFONT_DESCW LPD3DXFONT_DESC;
typedef struct ID3DXFont ID3DXFont;
typedef struct ID3DXFont* LPD3DXFONT;
extern "C" const GUID IID_ID3DXFont;
struct __declspec(novtable) ID3DXFont : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDescA(D3DXFONT_DESCA* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDescW(D3DXFONT_DESCW* pDesc) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetTextMetricsA(TEXTMETRICA* pTextMetrics) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetTextMetricsW(TEXTMETRICW* pTextMetrics) = 0;
    virtual __declspec(nothrow) HDC __stdcall GetDC(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGlyphData(UINT Glyph, LPDIRECT3DTEXTURE9* ppTexture, RECT* pBlackBox, POINT* pCellInc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadCharacters(UINT First, UINT Last) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadGlyphs(UINT First, UINT Last) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadTextA(LPCSTR pString, INT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadTextW(LPCWSTR pString, INT Count) = 0;
    virtual __declspec(nothrow) INT __stdcall DrawTextA(LPD3DXSPRITE pSprite, LPCSTR pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color) = 0;
    virtual __declspec(nothrow) INT __stdcall DrawTextW(LPD3DXSPRITE pSprite, LPCWSTR pString, INT Count, LPRECT pRect, DWORD Format, D3DCOLOR Color) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnLostDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnResetDevice(void) = 0;
    HRESULT GetDesc(D3DXFONT_DESCW* pDesc) { return GetDescW(pDesc); }
    HRESULT PreloadText(LPCWSTR pString, INT Count) { return PreloadTextW(pString, Count); }
};
extern "C" {
HRESULT __stdcall D3DXCreateFontA(
    LPDIRECT3DDEVICE9 pDevice,
    INT Height,
    UINT Width,
    UINT Weight,
    UINT MipLevels,
    BOOL Italic,
    DWORD CharSet,
    DWORD OutputPrecision,
    DWORD Quality,
    DWORD PitchAndFamily,
    LPCSTR pFaceName,
    LPD3DXFONT* ppFont);
HRESULT __stdcall D3DXCreateFontW(
    LPDIRECT3DDEVICE9 pDevice,
    INT Height,
    UINT Width,
    UINT Weight,
    UINT MipLevels,
    BOOL Italic,
    DWORD CharSet,
    DWORD OutputPrecision,
    DWORD Quality,
    DWORD PitchAndFamily,
    LPCWSTR pFaceName,
    LPD3DXFONT* ppFont);
HRESULT __stdcall D3DXCreateFontIndirectA(
    LPDIRECT3DDEVICE9 pDevice,
    const D3DXFONT_DESCA* pDesc,
    LPD3DXFONT* ppFont);
HRESULT __stdcall D3DXCreateFontIndirectW(
    LPDIRECT3DDEVICE9 pDevice,
    const D3DXFONT_DESCW* pDesc,
    LPD3DXFONT* ppFont);
}
typedef struct _D3DXRTS_DESC {
    UINT Width;
    UINT Height;
    D3DFORMAT Format;
    BOOL DepthStencil;
    D3DFORMAT DepthStencilFormat;
} D3DXRTS_DESC, *LPD3DXRTS_DESC;
typedef struct ID3DXRenderToSurface ID3DXRenderToSurface;
typedef struct ID3DXRenderToSurface* LPD3DXRENDERTOSURFACE;
extern "C" const GUID IID_ID3DXRenderToSurface;
struct __declspec(novtable) ID3DXRenderToSurface : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXRTS_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginScene(LPDIRECT3DSURFACE9 pSurface, const D3DVIEWPORT9* pViewport) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EndScene(DWORD MipFilter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnLostDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnResetDevice(void) = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateRenderToSurface(
    LPDIRECT3DDEVICE9 pDevice,
    UINT Width,
    UINT Height,
    D3DFORMAT Format,
    BOOL DepthStencil,
    D3DFORMAT DepthStencilFormat,
    LPD3DXRENDERTOSURFACE* ppRenderToSurface);
}
typedef struct _D3DXRTE_DESC {
    UINT Size;
    UINT MipLevels;
    D3DFORMAT Format;
    BOOL DepthStencil;
    D3DFORMAT DepthStencilFormat;
} D3DXRTE_DESC, *LPD3DXRTE_DESC;
typedef struct ID3DXRenderToEnvMap ID3DXRenderToEnvMap;
typedef struct ID3DXRenderToEnvMap* LPD3DXRenderToEnvMap;
extern "C" const GUID IID_ID3DXRenderToEnvMap;
struct __declspec(novtable) ID3DXRenderToEnvMap : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXRTE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginCube(
        LPDIRECT3DCUBETEXTURE9 pCubeTex)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginSphere(
        LPDIRECT3DTEXTURE9 pTex)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginHemisphere(
        LPDIRECT3DTEXTURE9 pTexZPos,
        LPDIRECT3DTEXTURE9 pTexZNeg)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginParabolic(
        LPDIRECT3DTEXTURE9 pTexZPos,
        LPDIRECT3DTEXTURE9 pTexZNeg)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Face(D3DCUBEMAP_FACES Face, DWORD MipFilter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall End(DWORD MipFilter) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnLostDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnResetDevice(void) = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateRenderToEnvMap(
    LPDIRECT3DDEVICE9 pDevice,
    UINT Size,
    UINT MipLevels,
    D3DFORMAT Format,
    BOOL DepthStencil,
    D3DFORMAT DepthStencilFormat,
    LPD3DXRenderToEnvMap* ppRenderToEnvMap);
}
typedef struct ID3DXLine ID3DXLine;
typedef struct ID3DXLine* LPD3DXLINE;
extern "C" const GUID IID_ID3DXLine;
struct __declspec(novtable) ID3DXLine : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Begin(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Draw(const D3DXVECTOR2* pVertexList,
        DWORD dwVertexListCount, D3DCOLOR Color)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawTransform(const D3DXVECTOR3* pVertexList,
        DWORD dwVertexListCount, const D3DXMATRIX* pTransform,
        D3DCOLOR Color)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPattern(DWORD dwPattern) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetPattern(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPatternScale(FLOAT fPatternScale) = 0;
    virtual __declspec(nothrow) FLOAT __stdcall GetPatternScale(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetWidth(FLOAT fWidth) = 0;
    virtual __declspec(nothrow) FLOAT __stdcall GetWidth(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAntialias(BOOL bAntialias) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetAntialias(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetGLLines(BOOL bGLLines) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetGLLines(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall End(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnLostDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnResetDevice(void) = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateLine(
    LPDIRECT3DDEVICE9 pDevice,
    LPD3DXLINE* ppLine);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
typedef DWORD D3DXF_FILEFORMAT;
typedef DWORD D3DXF_FILESAVEOPTIONS;
typedef DWORD D3DXF_FILELOADOPTIONS;
typedef struct _D3DXF_FILELOADRESOURCE {
    HMODULE hModule;
    LPCSTR lpName;
    LPCSTR lpType;
} D3DXF_FILELOADRESOURCE;
typedef struct _D3DXF_FILELOADMEMORY {
    LPCVOID lpMemory;
    SIZE_T dSize;
} D3DXF_FILELOADMEMORY;
extern "C" const GUID IID_ID3DXFile;
extern "C" const GUID IID_ID3DXFileSaveObject;
extern "C" const GUID IID_ID3DXFileSaveData;
extern "C" const GUID IID_ID3DXFileEnumObject;
extern "C" const GUID IID_ID3DXFileData;
struct __declspec(uuid("cef08cf9-7b4f-4429-9624-2a690a933201"))
    ID3DXFile;
struct __declspec(uuid("cef08cfa-7b4f-4429-9624-2a690a933201"))
    ID3DXFileSaveObject;
struct __declspec(uuid("cef08cfb-7b4f-4429-9624-2a690a933201"))
    ID3DXFileSaveData;
struct __declspec(uuid("cef08cfc-7b4f-4429-9624-2a690a933201"))
    ID3DXFileEnumObject;
struct __declspec(uuid("cef08cfd-7b4f-4429-9624-2a690a933201"))
    ID3DXFileData;
typedef struct ID3DXFile ID3DXFile;
typedef struct ID3DXFileSaveObject ID3DXFileSaveObject;
typedef struct ID3DXFileSaveData ID3DXFileSaveData;
typedef struct ID3DXFileEnumObject ID3DXFileEnumObject;
typedef struct ID3DXFileData ID3DXFileData;
struct __declspec(novtable) ID3DXFile : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID&, LPVOID*) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateEnumObject(LPCVOID, D3DXF_FILELOADOPTIONS,
        ID3DXFileEnumObject**)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateSaveObject(LPCVOID, D3DXF_FILESAVEOPTIONS,
        D3DXF_FILEFORMAT, ID3DXFileSaveObject**)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterTemplates(LPCVOID, SIZE_T) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterEnumTemplates(ID3DXFileEnumObject*) = 0;
};
struct __declspec(novtable) ID3DXFileSaveObject : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID&, LPVOID*) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFile(ID3DXFile**) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddDataObject(const GUID&, LPCSTR, const GUID*,
        SIZE_T, LPCVOID, ID3DXFileSaveData**)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Save(void) = 0;
};
struct __declspec(novtable) ID3DXFileSaveData : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID&, LPVOID*) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSave(ID3DXFileSaveObject**) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetName(LPSTR, SIZE_T*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetId(LPGUID) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetType(GUID*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddDataObject(const GUID&, LPCSTR, const GUID*,
        SIZE_T, LPCVOID, ID3DXFileSaveData**)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddDataReference(LPCSTR, const GUID*) = 0;
};
struct __declspec(novtable) ID3DXFileEnumObject : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID&, LPVOID*) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFile(ID3DXFile**) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetChildren(SIZE_T*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetChild(SIZE_T, ID3DXFileData**) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDataObjectById(const GUID&, ID3DXFileData**) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDataObjectByName(LPCSTR, ID3DXFileData**) = 0;
};
struct __declspec(novtable) ID3DXFileData : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID&, LPVOID*) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetEnum(ID3DXFileEnumObject**) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetName(LPSTR, SIZE_T*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetId(LPGUID) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Lock(SIZE_T*, LPCVOID*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Unlock(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetType(GUID*) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsReference(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetChildren(SIZE_T*) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetChild(SIZE_T, ID3DXFileData**) = 0;
};
extern "C" HRESULT __stdcall D3DXFileCreate(ID3DXFile** lplpDirectXFile);
typedef struct ID3DXFile *LPD3DXFILE, **LPLPD3DXFILE;
typedef struct ID3DXFileEnumObject *LPD3DXFILEENUMOBJECT, **LPLPD3DXFILEENUMOBJECT;
typedef struct ID3DXFileSaveObject *LPD3DXFILESAVEOBJECT, **LPLPD3DXFILESAVEOBJECT;
typedef struct ID3DXFileData *LPD3DXFILEDATA, **LPLPD3DXFILEDATA;
typedef struct ID3DXFileSaveData *LPD3DXFILESAVEDATA, **LPLPD3DXFILESAVEDATA;
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" const GUID IID_ID3DXBaseMesh;
extern "C" const GUID IID_ID3DXMesh;
extern "C" const GUID IID_ID3DXPMesh;
extern "C" const GUID IID_ID3DXSPMesh;
extern "C" const GUID IID_ID3DXSkinInfo;
extern "C" const GUID IID_ID3DXPatchMesh;
typedef enum _D3DXPATCHMESHTYPE {
    D3DXPATCHMESH_RECT = 0x001,
    D3DXPATCHMESH_TRI = 0x002,
    D3DXPATCHMESH_NPATCH = 0x003,
    D3DXPATCHMESH_FORCE_DWORD = 0x7fffffff,
} D3DXPATCHMESHTYPE;
enum _D3DXMESH {
    D3DXMESH_32BIT = 0x001,
    D3DXMESH_DONOTCLIP = 0x002,
    D3DXMESH_POINTS = 0x004,
    D3DXMESH_RTPATCHES = 0x008,
    D3DXMESH_NPATCHES = 0x4000,
    D3DXMESH_VB_SYSTEMMEM = 0x010,
    D3DXMESH_VB_MANAGED = 0x020,
    D3DXMESH_VB_WRITEONLY = 0x040,
    D3DXMESH_VB_DYNAMIC = 0x080,
    D3DXMESH_VB_SOFTWAREPROCESSING = 0x8000,
    D3DXMESH_IB_SYSTEMMEM = 0x100,
    D3DXMESH_IB_MANAGED = 0x200,
    D3DXMESH_IB_WRITEONLY = 0x400,
    D3DXMESH_IB_DYNAMIC = 0x800,
    D3DXMESH_IB_SOFTWAREPROCESSING = 0x10000,
    D3DXMESH_VB_SHARE = 0x1000,
    D3DXMESH_USEHWONLY = 0x2000,
    D3DXMESH_SYSTEMMEM = 0x110,
    D3DXMESH_MANAGED = 0x220,
    D3DXMESH_WRITEONLY = 0x440,
    D3DXMESH_DYNAMIC = 0x880,
    D3DXMESH_SOFTWAREPROCESSING = 0x18000,
};
enum _D3DXPATCHMESH {
    D3DXPATCHMESH_DEFAULT = 000,
};
enum _D3DXMESHSIMP {
    D3DXMESHSIMP_VERTEX = 0x1,
    D3DXMESHSIMP_FACE = 0x2,
};
typedef enum _D3DXCLEANTYPE {
    D3DXCLEAN_BACKFACING = 0x00000001,
    D3DXCLEAN_BOWTIES = 0x00000002,
    D3DXCLEAN_SKINNING = D3DXCLEAN_BACKFACING,
    D3DXCLEAN_OPTIMIZATION = D3DXCLEAN_BACKFACING,
    D3DXCLEAN_SIMPLIFICATION = D3DXCLEAN_BACKFACING | D3DXCLEAN_BOWTIES,
} D3DXCLEANTYPE;
enum _MAX_FVF_DECL_SIZE {
    MAX_FVF_DECL_SIZE = 64 + 1
};
typedef enum _D3DXTANGENT {
    D3DXTANGENT_WRAP_U = 0x01,
    D3DXTANGENT_WRAP_V = 0x02,
    D3DXTANGENT_WRAP_UV = 0x03,
    D3DXTANGENT_DONT_NORMALIZE_PARTIALS = 0x04,
    D3DXTANGENT_DONT_ORTHOGONALIZE = 0x08,
    D3DXTANGENT_ORTHOGONALIZE_FROM_V = 0x010,
    D3DXTANGENT_ORTHOGONALIZE_FROM_U = 0x020,
    D3DXTANGENT_WEIGHT_BY_AREA = 0x040,
    D3DXTANGENT_WEIGHT_EQUAL = 0x080,
    D3DXTANGENT_WIND_CW = 0x0100,
    D3DXTANGENT_CALCULATE_NORMALS = 0x0200,
    D3DXTANGENT_GENERATE_IN_PLACE = 0x0400,
} D3DXTANGENT;
typedef enum _D3DXIMT {
    D3DXIMT_WRAP_U = 0x01,
    D3DXIMT_WRAP_V = 0x02,
    D3DXIMT_WRAP_UV = 0x03,
} D3DXIMT;
typedef enum _D3DXUVATLAS {
    D3DXUVATLAS_DEFAULT = 0x00,
    D3DXUVATLAS_GEODESIC_FAST = 0x01,
    D3DXUVATLAS_GEODESIC_QUALITY = 0x02,
} D3DXUVATLAS;
typedef struct ID3DXBaseMesh* LPD3DXBASEMESH;
typedef struct ID3DXMesh* LPD3DXMESH;
typedef struct ID3DXPMesh* LPD3DXPMESH;
typedef struct ID3DXSPMesh* LPD3DXSPMESH;
typedef struct ID3DXSkinInfo* LPD3DXSKININFO;
typedef struct ID3DXPatchMesh* LPD3DXPATCHMESH;
typedef struct ID3DXTextureGutterHelper* LPD3DXTEXTUREGUTTERHELPER;
typedef struct ID3DXPRTBuffer* LPD3DXPRTBUFFER;
typedef struct _D3DXATTRIBUTERANGE {
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
} D3DXATTRIBUTERANGE;
typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;
typedef struct _D3DXMATERIAL {
    D3DMATERIAL9 MatD3D;
    LPSTR pTextureFilename;
} D3DXMATERIAL;
typedef D3DXMATERIAL* LPD3DXMATERIAL;
typedef enum _D3DXEFFECTDEFAULTTYPE {
    D3DXEDT_STRING = 0x1,
    D3DXEDT_FLOATS = 0x2,
    D3DXEDT_DWORD = 0x3,
    D3DXEDT_FORCEDWORD = 0x7fffffff
} D3DXEFFECTDEFAULTTYPE;
typedef struct _D3DXEFFECTDEFAULT {
    LPSTR pParamName;
    D3DXEFFECTDEFAULTTYPE Type;
    DWORD NumBytes;
    LPVOID pValue;
} D3DXEFFECTDEFAULT, *LPD3DXEFFECTDEFAULT;
typedef struct _D3DXEFFECTINSTANCE {
    LPSTR pEffectFilename;
    DWORD NumDefaults;
    LPD3DXEFFECTDEFAULT pDefaults;
} D3DXEFFECTINSTANCE, *LPD3DXEFFECTINSTANCE;
typedef struct _D3DXATTRIBUTEWEIGHTS {
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Texcoord[8];
    FLOAT Tangent;
    FLOAT Binormal;
} D3DXATTRIBUTEWEIGHTS, *LPD3DXATTRIBUTEWEIGHTS;
enum _D3DXWELDEPSILONSFLAGS {
    D3DXWELDEPSILONS_WELDALL = 0x1,
    D3DXWELDEPSILONS_WELDPARTIALMATCHES = 0x2,
    D3DXWELDEPSILONS_DONOTREMOVEVERTICES = 0x4,
    D3DXWELDEPSILONS_DONOTSPLIT = 0x8,
};
typedef struct _D3DXWELDEPSILONS {
    FLOAT Position;
    FLOAT BlendWeights;
    FLOAT Normal;
    FLOAT PSize;
    FLOAT Specular;
    FLOAT Diffuse;
    FLOAT Texcoord[8];
    FLOAT Tangent;
    FLOAT Binormal;
    FLOAT TessFactor;
} D3DXWELDEPSILONS;
typedef D3DXWELDEPSILONS* LPD3DXWELDEPSILONS;
struct __declspec(novtable) ID3DXBaseMesh : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSubset(DWORD AttribId) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumVertices(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetFVF(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumBytesPerVertex(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetOptions(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMeshFVF(DWORD Options,
        DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMesh(DWORD Options,
        const D3DVERTEXELEMENT9* pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9* ppVB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndexBuffer(LPDIRECT3DINDEXBUFFER9* ppIB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockVertexBuffer(DWORD Flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockVertexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockIndexBuffer(DWORD Flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockIndexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAttributeTable(
        D3DXATTRIBUTERANGE* pAttribTable, DWORD* pAttribTableSize)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertPointRepsToAdjacency(const DWORD* pPRep, DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertAdjacencyToPointReps(const DWORD* pAdjacency, DWORD* pPRep) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateAdjacency(FLOAT Epsilon, DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateSemantics(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
};
struct __declspec(novtable) ID3DXMesh : public ID3DXBaseMesh {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSubset(DWORD AttribId) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumVertices(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetFVF(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumBytesPerVertex(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetOptions(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMeshFVF(DWORD Options,
        DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMesh(DWORD Options,
        const D3DVERTEXELEMENT9* pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9* ppVB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndexBuffer(LPDIRECT3DINDEXBUFFER9* ppIB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockVertexBuffer(DWORD Flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockVertexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockIndexBuffer(DWORD Flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockIndexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAttributeTable(
        D3DXATTRIBUTERANGE* pAttribTable, DWORD* pAttribTableSize)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertPointRepsToAdjacency(const DWORD* pPRep, DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertAdjacencyToPointReps(const DWORD* pAdjacency, DWORD* pPRep) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateAdjacency(FLOAT Epsilon, DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateSemantics(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockAttributeBuffer(DWORD Flags, DWORD** ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockAttributeBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Optimize(DWORD Flags, const DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
        DWORD* pFaceRemap, LPD3DXBUFFER* ppVertexRemap,
        LPD3DXMESH* ppOptMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OptimizeInplace(DWORD Flags, const DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
        DWORD* pFaceRemap, LPD3DXBUFFER* ppVertexRemap)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAttributeTable(const D3DXATTRIBUTERANGE* pAttribTable, DWORD cAttribTableSize) = 0;
};
struct __declspec(novtable) ID3DXPMesh : public ID3DXBaseMesh {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSubset(DWORD AttribId) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumVertices(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetFVF(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumBytesPerVertex(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetOptions(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMeshFVF(DWORD Options,
        DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMesh(DWORD Options,
        const D3DVERTEXELEMENT9* pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9* ppVB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndexBuffer(LPDIRECT3DINDEXBUFFER9* ppIB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockVertexBuffer(DWORD Flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockVertexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockIndexBuffer(DWORD Flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockIndexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAttributeTable(
        D3DXATTRIBUTERANGE* pAttribTable, DWORD* pAttribTableSize)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertPointRepsToAdjacency(const DWORD* pPRep, DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertAdjacencyToPointReps(const DWORD* pAdjacency, DWORD* pPRep) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateAdjacency(FLOAT Epsilon, DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateSemantics(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ClonePMeshFVF(DWORD Options,
        DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXPMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ClonePMesh(DWORD Options,
        const D3DVERTEXELEMENT9* pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXPMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetNumFaces(DWORD Faces) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetNumVertices(DWORD Vertices) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetMaxFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetMinFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetMaxVertices(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetMinVertices(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Save(IStream* pStream, const D3DXMATERIAL* pMaterials, const D3DXEFFECTINSTANCE* pEffectInstances, DWORD NumMaterials) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Optimize(DWORD Flags, DWORD* pAdjacencyOut,
        DWORD* pFaceRemap, LPD3DXBUFFER* ppVertexRemap,
        LPD3DXMESH* ppOptMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OptimizeBaseLOD(DWORD Flags, DWORD* pFaceRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall TrimByFaces(DWORD NewFacesMin, DWORD NewFacesMax, DWORD* rgiFaceRemap, DWORD* rgiVertRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall TrimByVertices(DWORD NewVerticesMin, DWORD NewVerticesMax, DWORD* rgiFaceRemap, DWORD* rgiVertRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdjacency(DWORD* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateVertexHistory(DWORD* pVertexHistory) = 0;
};
struct __declspec(novtable) ID3DXSPMesh : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumVertices(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetFVF(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetOptions(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMeshFVF(DWORD Options,
        DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, DWORD* pAdjacencyOut, DWORD* pVertexRemapOut, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMesh(DWORD Options,
        const D3DVERTEXELEMENT9* pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, DWORD* pAdjacencyOut, DWORD* pVertexRemapOut, LPD3DXMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ClonePMeshFVF(DWORD Options,
        DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, DWORD* pVertexRemapOut, FLOAT* pErrorsByFace, LPD3DXPMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ClonePMesh(DWORD Options,
        const D3DVERTEXELEMENT9* pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, DWORD* pVertexRemapOut, FLOAT* pErrorsbyFace, LPD3DXPMESH* ppCloneMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ReduceFaces(DWORD Faces) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ReduceVertices(DWORD Vertices) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetMaxFaces(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetMaxVertices(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexAttributeWeights(LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexWeights(FLOAT* pVertexWeights) = 0;
};
enum _D3DXMESHOPT {
    D3DXMESHOPT_COMPACT = 0x01000000,
    D3DXMESHOPT_ATTRSORT = 0x02000000,
    D3DXMESHOPT_VERTEXCACHE = 0x04000000,
    D3DXMESHOPT_STRIPREORDER = 0x08000000,
    D3DXMESHOPT_IGNOREVERTS = 0x10000000,
    D3DXMESHOPT_DONOTSPLIT = 0x20000000,
    D3DXMESHOPT_DEVICEINDEPENDENT = 0x00400000,
};
typedef struct _D3DXBONECOMBINATION {
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
    DWORD* BoneId;
} D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;
typedef struct _D3DXPATCHINFO {
    D3DXPATCHMESHTYPE PatchType;
    D3DDEGREETYPE Degree;
    D3DBASISTYPE Basis;
} D3DXPATCHINFO, *LPD3DXPATCHINFO;
struct __declspec(novtable) ID3DXPatchMesh : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumPatches(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumVertices(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetControlVerticesPerPatch(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetOptions(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPatchInfo(LPD3DXPATCHINFO PatchInfo) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9* ppVB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndexBuffer(LPDIRECT3DINDEXBUFFER9* ppIB) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockVertexBuffer(DWORD flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockVertexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockIndexBuffer(DWORD flags, LPVOID* ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockIndexBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockAttributeBuffer(DWORD flags, DWORD** ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockAttributeBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTessSize(FLOAT fTessLevel, DWORD Adaptive, DWORD* NumTriangles, DWORD* NumVertices) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateAdjacency(FLOAT Tolerance) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMesh(DWORD Options, const D3DVERTEXELEMENT9* pDecl, LPD3DXPATCHMESH* pMesh) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Optimize(DWORD flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDisplaceParam(LPDIRECT3DBASETEXTURE9 Texture,
        D3DTEXTUREFILTERTYPE MinFilter,
        D3DTEXTUREFILTERTYPE MagFilter,
        D3DTEXTUREFILTERTYPE MipFilter,
        D3DTEXTUREADDRESS Wrap,
        DWORD dwLODBias)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDisplaceParam(LPDIRECT3DBASETEXTURE9* Texture,
        D3DTEXTUREFILTERTYPE* MinFilter,
        D3DTEXTUREFILTERTYPE* MagFilter,
        D3DTEXTUREFILTERTYPE* MipFilter,
        D3DTEXTUREADDRESS* Wrap,
        DWORD* dwLODBias)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Tessellate(FLOAT fTessLevel, LPD3DXMESH pMesh) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall TessellateAdaptive(
        const D3DXVECTOR4* pTrans,
        DWORD dwMaxTessLevel,
        DWORD dwMinTessLevel,
        LPD3DXMESH pMesh)
        = 0;
};
struct __declspec(novtable) ID3DXSkinInfo : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoneInfluence(DWORD bone, DWORD numInfluences, const DWORD* vertices, const FLOAT* weights) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoneVertexInfluence(DWORD boneNum, DWORD influenceNum, float weight) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumBoneInfluences(DWORD bone) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoneInfluence(DWORD bone, DWORD* vertices, FLOAT* weights) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoneVertexInfluence(DWORD boneNum, DWORD influenceNum, float* pWeight, DWORD* pVertexNum) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMaxVertexInfluences(DWORD* maxVertexInfluences) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetNumBones(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FindBoneVertexInfluenceIndex(DWORD boneNum, DWORD vertexNum, DWORD* pInfluenceIndex) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMaxFaceInfluences(LPDIRECT3DINDEXBUFFER9 pIB, DWORD NumFaces, DWORD* maxFaceInfluences) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMinBoneInfluence(FLOAT MinInfl) = 0;
    virtual __declspec(nothrow) FLOAT __stdcall GetMinBoneInfluence(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoneName(DWORD Bone, LPCSTR pName) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetBoneName(DWORD Bone) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoneOffsetMatrix(DWORD Bone, const D3DXMATRIX* pBoneTransform) = 0;
    virtual __declspec(nothrow) LPD3DXMATRIX __stdcall GetBoneOffsetMatrix(DWORD Bone) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Clone(LPD3DXSKININFO* ppSkinInfo) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Remap(DWORD NumVertices, DWORD* pVertexRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFVF(DWORD FVF) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDeclaration(const D3DVERTEXELEMENT9* pDeclaration) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetFVF(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeclaration(D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UpdateSkinnedMesh(
        const D3DXMATRIX* pBoneTransforms,
        const D3DXMATRIX* pBoneInvTransposeTransforms,
        LPCVOID pVerticesSrc,
        PVOID pVerticesDst)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertToBlendedMesh(
        LPD3DXMESH pMesh,
        DWORD Options,
        const DWORD* pAdjacencyIn,
        LPDWORD pAdjacencyOut,
        DWORD* pFaceRemap,
        LPD3DXBUFFER* ppVertexRemap,
        DWORD* pMaxFaceInfl,
        DWORD* pNumBoneCombinations,
        LPD3DXBUFFER* ppBoneCombinationTable,
        LPD3DXMESH* ppMesh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ConvertToIndexedBlendedMesh(
        LPD3DXMESH pMesh,
        DWORD Options,
        DWORD paletteSize,
        const DWORD* pAdjacencyIn,
        LPDWORD pAdjacencyOut,
        DWORD* pFaceRemap,
        LPD3DXBUFFER* ppVertexRemap,
        DWORD* pMaxVertexInfl,
        DWORD* pNumBoneCombinations,
        LPD3DXBUFFER* ppBoneCombinationTable,
        LPD3DXMESH* ppMesh)
        = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateMesh(
    DWORD NumFaces,
    DWORD NumVertices,
    DWORD Options,
    const D3DVERTEXELEMENT9* pDeclaration,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXCreateMeshFVF(
    DWORD NumFaces,
    DWORD NumVertices,
    DWORD Options,
    DWORD FVF,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXCreateSPMesh(
    LPD3DXMESH pMesh,
    const DWORD* pAdjacency,
    const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,
    const FLOAT* pVertexWeights,
    LPD3DXSPMESH* ppSMesh);
HRESULT __stdcall D3DXCleanMesh(
    D3DXCLEANTYPE CleanType,
    LPD3DXMESH pMeshIn,
    const DWORD* pAdjacencyIn,
    LPD3DXMESH* ppMeshOut,
    DWORD* pAdjacencyOut,
    LPD3DXBUFFER* ppErrorsAndWarnings);
HRESULT __stdcall D3DXValidMesh(
    LPD3DXMESH pMeshIn,
    const DWORD* pAdjacency,
    LPD3DXBUFFER* ppErrorsAndWarnings);
HRESULT __stdcall D3DXGeneratePMesh(
    LPD3DXMESH pMesh,
    const DWORD* pAdjacency,
    const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,
    const FLOAT* pVertexWeights,
    DWORD MinValue,
    DWORD Options,
    LPD3DXPMESH* ppPMesh);
HRESULT __stdcall D3DXSimplifyMesh(
    LPD3DXMESH pMesh,
    const DWORD* pAdjacency,
    const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,
    const FLOAT* pVertexWeights,
    DWORD MinValue,
    DWORD Options,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXComputeBoundingSphere(
    const D3DXVECTOR3* pFirstPosition,
    DWORD NumVertices,
    DWORD dwStride,
    D3DXVECTOR3* pCenter,
    FLOAT* pRadius);
HRESULT __stdcall D3DXComputeBoundingBox(
    const D3DXVECTOR3* pFirstPosition,
    DWORD NumVertices,
    DWORD dwStride,
    D3DXVECTOR3* pMin,
    D3DXVECTOR3* pMax);
HRESULT __stdcall D3DXComputeNormals(
    LPD3DXBASEMESH pMesh,
    const DWORD* pAdjacency);
HRESULT __stdcall D3DXCreateBuffer(
    DWORD NumBytes,
    LPD3DXBUFFER* ppBuffer);
HRESULT __stdcall D3DXLoadMeshFromXA(
    LPCSTR pFilename,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pNumMaterials,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXLoadMeshFromXW(
    LPCWSTR pFilename,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pNumMaterials,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXLoadMeshFromXInMemory(
    LPCVOID Memory,
    DWORD SizeOfMemory,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pNumMaterials,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXLoadMeshFromXResource(
    HMODULE Module,
    LPCSTR Name,
    LPCSTR Type,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pNumMaterials,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXSaveMeshToXA(
    LPCSTR pFilename,
    LPD3DXMESH pMesh,
    const DWORD* pAdjacency,
    const D3DXMATERIAL* pMaterials,
    const D3DXEFFECTINSTANCE* pEffectInstances,
    DWORD NumMaterials,
    DWORD Format);
HRESULT __stdcall D3DXSaveMeshToXW(
    LPCWSTR pFilename,
    LPD3DXMESH pMesh,
    const DWORD* pAdjacency,
    const D3DXMATERIAL* pMaterials,
    const D3DXEFFECTINSTANCE* pEffectInstances,
    DWORD NumMaterials,
    DWORD Format);
HRESULT __stdcall D3DXCreatePMeshFromStream(
    IStream* pStream,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pNumMaterials,
    LPD3DXPMESH* ppPMesh);
HRESULT __stdcall D3DXCreateSkinInfo(
    DWORD NumVertices,
    const D3DVERTEXELEMENT9* pDeclaration,
    DWORD NumBones,
    LPD3DXSKININFO* ppSkinInfo);
HRESULT __stdcall D3DXCreateSkinInfoFVF(
    DWORD NumVertices,
    DWORD FVF,
    DWORD NumBones,
    LPD3DXSKININFO* ppSkinInfo);
}
extern "C" {
HRESULT __stdcall D3DXLoadMeshFromXof(
    LPD3DXFILEDATA pxofMesh,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pNumMaterials,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXLoadSkinMeshFromXof(
    LPD3DXFILEDATA pxofMesh,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    DWORD* pMatOut,
    LPD3DXSKININFO* ppSkinInfo,
    LPD3DXMESH* ppMesh);
HRESULT __stdcall D3DXCreateSkinInfoFromBlendedMesh(
    LPD3DXBASEMESH pMesh,
    DWORD NumBones,
    const D3DXBONECOMBINATION* pBoneCombinationTable,
    LPD3DXSKININFO* ppSkinInfo);
HRESULT __stdcall D3DXTessellateNPatches(
    LPD3DXMESH pMeshIn,
    const DWORD* pAdjacencyIn,
    FLOAT NumSegs,
    BOOL QuadraticInterpNormals,
    LPD3DXMESH* ppMeshOut,
    LPD3DXBUFFER* ppAdjacencyOut);
HRESULT __stdcall D3DXGenerateOutputDecl(
    D3DVERTEXELEMENT9* pOutput,
    const D3DVERTEXELEMENT9* pInput);
HRESULT __stdcall D3DXLoadPatchMeshFromXof(
    LPD3DXFILEDATA pXofObjMesh,
    DWORD Options,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXBUFFER* ppMaterials,
    LPD3DXBUFFER* ppEffectInstances,
    PDWORD pNumMaterials,
    LPD3DXPATCHMESH* ppMesh);
HRESULT __stdcall D3DXRectPatchSize(
    const FLOAT* pfNumSegs,
    DWORD* pdwTriangles,
    DWORD* pdwVertices);
HRESULT __stdcall D3DXTriPatchSize(
    const FLOAT* pfNumSegs,
    DWORD* pdwTriangles,
    DWORD* pdwVertices);
HRESULT __stdcall D3DXTessellateRectPatch(
    LPDIRECT3DVERTEXBUFFER9 pVB,
    const FLOAT* pNumSegs,
    const D3DVERTEXELEMENT9* pdwInDecl,
    const D3DRECTPATCH_INFO* pRectPatchInfo,
    LPD3DXMESH pMesh);
HRESULT __stdcall D3DXTessellateTriPatch(
    LPDIRECT3DVERTEXBUFFER9 pVB,
    const FLOAT* pNumSegs,
    const D3DVERTEXELEMENT9* pInDecl,
    const D3DTRIPATCH_INFO* pTriPatchInfo,
    LPD3DXMESH pMesh);
HRESULT __stdcall D3DXCreateNPatchMesh(
    LPD3DXMESH pMeshSysMem,
    LPD3DXPATCHMESH* pPatchMesh);
HRESULT __stdcall D3DXCreatePatchMesh(
    const D3DXPATCHINFO* pInfo,
    DWORD dwNumPatches,
    DWORD dwNumVertices,
    DWORD dwOptions,
    const D3DVERTEXELEMENT9* pDecl,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXPATCHMESH* pPatchMesh);
HRESULT __stdcall D3DXValidPatchMesh(LPD3DXPATCHMESH pMesh,
    DWORD* dwcDegenerateVertices,
    DWORD* dwcDegeneratePatches,
    LPD3DXBUFFER* ppErrorsAndWarnings);
UINT __stdcall D3DXGetFVFVertexSize(DWORD FVF);
UINT __stdcall D3DXGetDeclVertexSize(const D3DVERTEXELEMENT9* pDecl, DWORD Stream);
UINT __stdcall D3DXGetDeclLength(const D3DVERTEXELEMENT9* pDecl);
HRESULT __stdcall D3DXDeclaratorFromFVF(
    DWORD FVF,
    D3DVERTEXELEMENT9 pDeclarator[MAX_FVF_DECL_SIZE]);
HRESULT __stdcall D3DXFVFFromDeclarator(
    const D3DVERTEXELEMENT9* pDeclarator,
    DWORD* pFVF);
HRESULT __stdcall D3DXWeldVertices(
    LPD3DXMESH pMesh,
    DWORD Flags,
    const D3DXWELDEPSILONS* pEpsilons,
    const DWORD* pAdjacencyIn,
    DWORD* pAdjacencyOut,
    DWORD* pFaceRemap,
    LPD3DXBUFFER* ppVertexRemap);
typedef struct _D3DXINTERSECTINFO {
    DWORD FaceIndex;
    FLOAT U;
    FLOAT V;
    FLOAT Dist;
} D3DXINTERSECTINFO, *LPD3DXINTERSECTINFO;
HRESULT __stdcall D3DXIntersect(
    LPD3DXBASEMESH pMesh,
    const D3DXVECTOR3* pRayPos,
    const D3DXVECTOR3* pRayDir,
    BOOL* pHit,
    DWORD* pFaceIndex,
    FLOAT* pU,
    FLOAT* pV,
    FLOAT* pDist,
    LPD3DXBUFFER* ppAllHits,
    DWORD* pCountOfHits);
HRESULT __stdcall D3DXIntersectSubset(
    LPD3DXBASEMESH pMesh,
    DWORD AttribId,
    const D3DXVECTOR3* pRayPos,
    const D3DXVECTOR3* pRayDir,
    BOOL* pHit,
    DWORD* pFaceIndex,
    FLOAT* pU,
    FLOAT* pV,
    FLOAT* pDist,
    LPD3DXBUFFER* ppAllHits,
    DWORD* pCountOfHits);
HRESULT __stdcall D3DXSplitMesh(
    LPD3DXMESH pMeshIn,
    const DWORD* pAdjacencyIn,
    const DWORD MaxSize,
    const DWORD Options,
    DWORD* pMeshesOut,
    LPD3DXBUFFER* ppMeshArrayOut,
    LPD3DXBUFFER* ppAdjacencyArrayOut,
    LPD3DXBUFFER* ppFaceRemapArrayOut,
    LPD3DXBUFFER* ppVertRemapArrayOut);
BOOL __stdcall D3DXIntersectTri(
    const D3DXVECTOR3* p0,
    const D3DXVECTOR3* p1,
    const D3DXVECTOR3* p2,
    const D3DXVECTOR3* pRayPos,
    const D3DXVECTOR3* pRayDir,
    FLOAT* pU,
    FLOAT* pV,
    FLOAT* pDist);
BOOL __stdcall D3DXSphereBoundProbe(
    const D3DXVECTOR3* pCenter,
    FLOAT Radius,
    const D3DXVECTOR3* pRayPosition,
    const D3DXVECTOR3* pRayDirection);
BOOL __stdcall D3DXBoxBoundProbe(
    const D3DXVECTOR3* pMin,
    const D3DXVECTOR3* pMax,
    const D3DXVECTOR3* pRayPosition,
    const D3DXVECTOR3* pRayDirection);
HRESULT __stdcall D3DXComputeTangentFrame(ID3DXMesh* pMesh,
    DWORD dwOptions);
HRESULT __stdcall D3DXComputeTangentFrameEx(ID3DXMesh* pMesh,
    DWORD dwTextureInSemantic,
    DWORD dwTextureInIndex,
    DWORD dwUPartialOutSemantic,
    DWORD dwUPartialOutIndex,
    DWORD dwVPartialOutSemantic,
    DWORD dwVPartialOutIndex,
    DWORD dwNormalOutSemantic,
    DWORD dwNormalOutIndex,
    DWORD dwOptions,
    const DWORD* pdwAdjacency,
    FLOAT fPartialEdgeThreshold,
    FLOAT fSingularPointThreshold,
    FLOAT fNormalEdgeThreshold,
    ID3DXMesh** ppMeshOut,
    ID3DXBuffer** ppVertexMapping);
HRESULT __stdcall D3DXComputeTangent(LPD3DXMESH Mesh,
    DWORD TexStage,
    DWORD TangentIndex,
    DWORD BinormIndex,
    DWORD Wrap,
    const DWORD* pAdjacency);
typedef HRESULT(__stdcall* LPD3DXUVATLASCB)(FLOAT fPercentDone, LPVOID lpUserContext);
HRESULT __stdcall D3DXUVAtlasCreate(LPD3DXMESH pMesh,
    UINT uMaxChartNumber,
    FLOAT fMaxStretch,
    UINT uWidth,
    UINT uHeight,
    FLOAT fGutter,
    DWORD dwTextureIndex,
    const DWORD* pdwAdjacency,
    const DWORD* pdwFalseEdgeAdjacency,
    const FLOAT* pfIMTArray,
    LPD3DXUVATLASCB pStatusCallback,
    FLOAT fCallbackFrequency,
    LPVOID pUserContext,
    DWORD dwOptions,
    LPD3DXMESH* ppMeshOut,
    LPD3DXBUFFER* ppFacePartitioning,
    LPD3DXBUFFER* ppVertexRemapArray,
    FLOAT* pfMaxStretchOut,
    UINT* puNumChartsOut);
HRESULT __stdcall D3DXUVAtlasPartition(LPD3DXMESH pMesh,
    UINT uMaxChartNumber,
    FLOAT fMaxStretch,
    DWORD dwTextureIndex,
    const DWORD* pdwAdjacency,
    const DWORD* pdwFalseEdgeAdjacency,
    const FLOAT* pfIMTArray,
    LPD3DXUVATLASCB pStatusCallback,
    FLOAT fCallbackFrequency,
    LPVOID pUserContext,
    DWORD dwOptions,
    LPD3DXMESH* ppMeshOut,
    LPD3DXBUFFER* ppFacePartitioning,
    LPD3DXBUFFER* ppVertexRemapArray,
    LPD3DXBUFFER* ppPartitionResultAdjacency,
    FLOAT* pfMaxStretchOut,
    UINT* puNumChartsOut);
HRESULT __stdcall D3DXUVAtlasPack(ID3DXMesh* pMesh,
    UINT uWidth,
    UINT uHeight,
    FLOAT fGutter,
    DWORD dwTextureIndex,
    const DWORD* pdwPartitionResultAdjacency,
    LPD3DXUVATLASCB pStatusCallback,
    FLOAT fCallbackFrequency,
    LPVOID pUserContext,
    DWORD dwOptions,
    LPD3DXBUFFER pFacePartitioning);
typedef HRESULT(__stdcall* LPD3DXIMTSIGNALCALLBACK)(const D3DXVECTOR2* uv,
    UINT uPrimitiveID,
    UINT uSignalDimension,
    void* pUserData,
    FLOAT* pfSignalOut);
HRESULT __stdcall D3DXComputeIMTFromPerVertexSignal(
    LPD3DXMESH pMesh,
    const FLOAT* pfVertexSignal,
    UINT uSignalDimension,
    UINT uSignalStride,
    DWORD dwOptions,
    LPD3DXUVATLASCB pStatusCallback,
    LPVOID pUserContext,
    LPD3DXBUFFER* ppIMTData);
HRESULT __stdcall D3DXComputeIMTFromSignal(
    LPD3DXMESH pMesh,
    DWORD dwTextureIndex,
    UINT uSignalDimension,
    FLOAT fMaxUVDistance,
    DWORD dwOptions,
    LPD3DXIMTSIGNALCALLBACK pSignalCallback,
    void* pUserData,
    LPD3DXUVATLASCB pStatusCallback,
    LPVOID pUserContext,
    LPD3DXBUFFER* ppIMTData);
HRESULT __stdcall D3DXComputeIMTFromTexture(
    LPD3DXMESH pMesh,
    LPDIRECT3DTEXTURE9 pTexture,
    DWORD dwTextureIndex,
    DWORD dwOptions,
    LPD3DXUVATLASCB pStatusCallback,
    LPVOID pUserContext,
    LPD3DXBUFFER* ppIMTData);
HRESULT __stdcall D3DXComputeIMTFromPerTexelSignal(
    LPD3DXMESH pMesh,
    DWORD dwTextureIndex,
    FLOAT* pfTexelSignal,
    UINT uWidth,
    UINT uHeight,
    UINT uSignalDimension,
    UINT uComponents,
    DWORD dwOptions,
    LPD3DXUVATLASCB pStatusCallback,
    LPVOID pUserContext,
    LPD3DXBUFFER* ppIMTData);
HRESULT __stdcall D3DXConvertMeshSubsetToSingleStrip(
    LPD3DXBASEMESH MeshIn,
    DWORD AttribId,
    DWORD IBOptions,
    LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,
    DWORD* pNumIndices);
HRESULT __stdcall D3DXConvertMeshSubsetToStrips(
    LPD3DXBASEMESH MeshIn,
    DWORD AttribId,
    DWORD IBOptions,
    LPDIRECT3DINDEXBUFFER9* ppIndexBuffer,
    DWORD* pNumIndices,
    LPD3DXBUFFER* ppStripLengths,
    DWORD* pNumStrips);
HRESULT __stdcall D3DXOptimizeFaces(
    LPCVOID pbIndices,
    UINT cFaces,
    UINT cVertices,
    BOOL b32BitIndices,
    DWORD* pFaceRemap);
HRESULT __stdcall D3DXOptimizeVertices(
    LPCVOID pbIndices,
    UINT cFaces,
    UINT cVertices,
    BOOL b32BitIndices,
    DWORD* pVertexRemap);
}
typedef enum _D3DXSHCOMPRESSQUALITYTYPE {
    D3DXSHCQUAL_FASTLOWQUALITY = 1,
    D3DXSHCQUAL_SLOWHIGHQUALITY = 2,
    D3DXSHCQUAL_FORCE_DWORD = 0x7fffffff
} D3DXSHCOMPRESSQUALITYTYPE;
typedef enum _D3DXSHGPUSIMOPT {
    D3DXSHGPUSIMOPT_SHADOWRES256 = 1,
    D3DXSHGPUSIMOPT_SHADOWRES512 = 0,
    D3DXSHGPUSIMOPT_SHADOWRES1024 = 2,
    D3DXSHGPUSIMOPT_SHADOWRES2048 = 3,
    D3DXSHGPUSIMOPT_HIGHQUALITY = 4,
    D3DXSHGPUSIMOPT_FORCE_DWORD = 0x7fffffff
} D3DXSHGPUSIMOPT;
typedef struct _D3DXSHMATERIAL {
    D3DCOLORVALUE Diffuse;
    BOOL bMirror;
    BOOL bSubSurf;
    FLOAT RelativeIndexOfRefraction;
    D3DCOLORVALUE Absorption;
    D3DCOLORVALUE ReducedScattering;
} D3DXSHMATERIAL;
typedef struct _D3DXSHPRTSPLITMESHVERTDATA {
    UINT uVertRemap;
    UINT uSubCluster;
    UCHAR ucVertStatus;
} D3DXSHPRTSPLITMESHVERTDATA;
typedef struct _D3DXSHPRTSPLITMESHCLUSTERDATA {
    UINT uVertStart;
    UINT uVertLength;
    UINT uFaceStart;
    UINT uFaceLength;
    UINT uClusterStart;
    UINT uClusterLength;
} D3DXSHPRTSPLITMESHCLUSTERDATA;
typedef HRESULT(__stdcall* LPD3DXSHPRTSIMCB)(float fPercentDone, LPVOID lpUserContext);
extern "C" const GUID IID_ID3DXPRTBuffer;
extern "C" const GUID IID_ID3DXPRTCompBuffer;
extern "C" const GUID IID_ID3DXTextureGutterHelper;
extern "C" const GUID IID_ID3DXPRTEngine;
typedef struct ID3DXTextureGutterHelper ID3DXTextureGutterHelper;
typedef struct ID3DXPRTBuffer ID3DXPRTBuffer;
struct __declspec(novtable) ID3DXPRTBuffer : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumSamples(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumCoeffs(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumChannels(void) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsTexture(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetWidth(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetHeight(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Resize(UINT NewSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LockBuffer(UINT Start, UINT NumSamples, FLOAT** ppData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnlockBuffer(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ScaleBuffer(FLOAT Scale) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddBuffer(LPD3DXPRTBUFFER pBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AttachGH(LPD3DXTEXTUREGUTTERHELPER) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ReleaseGH(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EvalGH(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractTexture(UINT Channel, UINT StartCoefficient,
        UINT NumCoefficients, LPDIRECT3DTEXTURE9 pTexture)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractToMesh(UINT NumCoefficients, D3DDECLUSAGE Usage, UINT UsageIndexStart,
        LPD3DXMESH pScene)
        = 0;
};
typedef struct ID3DXPRTCompBuffer ID3DXPRTCompBuffer;
typedef struct ID3DXPRTCompBuffer* LPD3DXPRTCOMPBUFFER;
struct __declspec(novtable) ID3DXPRTCompBuffer : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumSamples(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumCoeffs(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumChannels(void) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsTexture(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetWidth(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetHeight(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumClusters(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumPCA(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall NormalizeData(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractBasis(UINT Cluster, FLOAT* pClusterBasis) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractClusterIDs(UINT* pClusterIDs) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractPCA(UINT StartPCA, UINT NumExtract, FLOAT* pPCACoefficients) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractTexture(UINT StartPCA, UINT NumpPCA,
        LPDIRECT3DTEXTURE9 pTexture)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractToMesh(UINT NumPCA, D3DDECLUSAGE Usage, UINT UsageIndexStart,
        LPD3DXMESH pScene)
        = 0;
};
struct __declspec(novtable) ID3DXTextureGutterHelper : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetWidth(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetHeight(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ApplyGuttersFloat(FLOAT* pDataIn, UINT NumCoeffs, UINT Width, UINT Height);
    virtual __declspec(nothrow) HRESULT __stdcall ApplyGuttersTex(LPDIRECT3DTEXTURE9 pTexture);
    virtual __declspec(nothrow) HRESULT __stdcall ApplyGuttersPRT(LPD3DXPRTBUFFER pBuffer);
    virtual __declspec(nothrow) HRESULT __stdcall ResampleTex(LPDIRECT3DTEXTURE9 pTextureIn,
        LPD3DXMESH pMeshIn,
        D3DDECLUSAGE Usage, UINT UsageIndex,
        LPDIRECT3DTEXTURE9 pTextureOut);
    virtual __declspec(nothrow) HRESULT __stdcall GetFaceMap(UINT* pFaceData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBaryMap(D3DXVECTOR2* pBaryData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTexelMap(D3DXVECTOR2* pTexelData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGutterMap(BYTE* pGutterData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFaceMap(UINT* pFaceData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBaryMap(D3DXVECTOR2* pBaryData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexelMap(D3DXVECTOR2* pTexelData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetGutterMap(BYTE* pGutterData) = 0;
};
typedef struct ID3DXPRTEngine ID3DXPRTEngine;
typedef struct ID3DXPRTEngine* LPD3DXPRTENGINE;
struct __declspec(novtable) ID3DXPRTEngine : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMeshMaterials(const D3DXSHMATERIAL** ppMaterials, UINT NumMeshes,
        UINT NumChannels, BOOL bSetAlbedo, FLOAT fLengthScale)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPerVertexAlbedo(const void* pDataIn, UINT NumChannels, UINT Stride) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPerTexelAlbedo(LPDIRECT3DTEXTURE9 pAlbedoTexture,
        UINT NumChannels,
        LPD3DXTEXTUREGUTTERHELPER pGH)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexAlbedo(D3DXCOLOR* pVertColors, UINT NumVerts) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPerTexelNormal(LPDIRECT3DTEXTURE9 pNormalTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ExtractPerVertexAlbedo(LPD3DXMESH pMesh,
        D3DDECLUSAGE Usage,
        UINT NumChannels)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ResampleBuffer(LPD3DXPRTBUFFER pBufferIn, LPD3DXPRTBUFFER pBufferOut) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdaptedMesh(LPDIRECT3DDEVICE9 pD3DDevice, UINT* pFaceRemap, UINT* pVertRemap, FLOAT* pfVertWeights, LPD3DXMESH* ppMesh) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumVerts(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumFaces(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMinMaxIntersection(FLOAT fMin, FLOAT fMax) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RobustMeshRefine(FLOAT MinEdgeLength, UINT MaxSubdiv) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetSamplingInfo(UINT NumRays,
        BOOL UseSphere,
        BOOL UseCosine,
        BOOL Adaptive,
        FLOAT AdaptiveThresh)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeDirectLightingSH(UINT SHOrder,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeDirectLightingSHAdaptive(UINT SHOrder,
        FLOAT AdaptiveThresh,
        FLOAT MinEdgeLength,
        UINT MaxSubdiv,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeDirectLightingSHGPU(LPDIRECT3DDEVICE9 pD3DDevice,
        UINT Flags,
        UINT SHOrder,
        FLOAT ZBias,
        FLOAT ZAngleBias,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeSS(LPD3DXPRTBUFFER pDataIn,
        LPD3DXPRTBUFFER pDataOut, LPD3DXPRTBUFFER pDataTotal)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeSSAdaptive(LPD3DXPRTBUFFER pDataIn,
        FLOAT AdaptiveThresh,
        FLOAT MinEdgeLength,
        UINT MaxSubdiv,
        LPD3DXPRTBUFFER pDataOut, LPD3DXPRTBUFFER pDataTotal)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeBounce(LPD3DXPRTBUFFER pDataIn,
        LPD3DXPRTBUFFER pDataOut,
        LPD3DXPRTBUFFER pDataTotal)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeBounceAdaptive(LPD3DXPRTBUFFER pDataIn,
        FLOAT AdaptiveThresh,
        FLOAT MinEdgeLength,
        UINT MaxSubdiv,
        LPD3DXPRTBUFFER pDataOut,
        LPD3DXPRTBUFFER pDataTotal)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeVolumeSamplesDirectSH(UINT SHOrderIn,
        UINT SHOrderOut,
        UINT NumVolSamples,
        const D3DXVECTOR3* pSampleLocs,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeVolumeSamples(LPD3DXPRTBUFFER pSurfDataIn,
        UINT SHOrder,
        UINT NumVolSamples,
        const D3DXVECTOR3* pSampleLocs,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeSurfSamplesDirectSH(UINT SHOrder,
        UINT NumSamples,
        const D3DXVECTOR3* pSampleLocs,
        const D3DXVECTOR3* pSampleNorms,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeSurfSamplesBounce(LPD3DXPRTBUFFER pSurfDataIn,
        UINT NumSamples,
        const D3DXVECTOR3* pSampleLocs,
        const D3DXVECTOR3* pSampleNorms,
        LPD3DXPRTBUFFER pDataOut,
        LPD3DXPRTBUFFER pDataTotal)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreeSSData(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FreeBounceData(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeLDPRTCoeffs(LPD3DXPRTBUFFER pDataIn,
        UINT SHOrder,
        D3DXVECTOR3* pNormOut,
        LPD3DXPRTBUFFER pDataOut)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ScaleMeshChunk(UINT uMeshChunk, FLOAT fScale, LPD3DXPRTBUFFER pDataOut) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall MultiplyAlbedo(LPD3DXPRTBUFFER pDataOut) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetCallBack(LPD3DXSHPRTSIMCB pCB, FLOAT Frequency, LPVOID lpUserContext) = 0;
    virtual __declspec(nothrow) BOOL __stdcall ShadowRayIntersects(const D3DXVECTOR3* pRayPos, const D3DXVECTOR3* pRayDir) = 0;
    virtual __declspec(nothrow) BOOL __stdcall ClosestRayIntersects(const D3DXVECTOR3* pRayPos, const D3DXVECTOR3* pRayDir,
        DWORD* pFaceIndex, FLOAT* pU, FLOAT* pV, FLOAT* pDist)
        = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreatePRTBuffer(
    UINT NumSamples,
    UINT NumCoeffs,
    UINT NumChannels,
    LPD3DXPRTBUFFER* ppBuffer);
HRESULT __stdcall D3DXCreatePRTBufferTex(
    UINT Width,
    UINT Height,
    UINT NumCoeffs,
    UINT NumChannels,
    LPD3DXPRTBUFFER* ppBuffer);
HRESULT __stdcall D3DXLoadPRTBufferFromFileA(
    LPCSTR pFilename,
    LPD3DXPRTBUFFER* ppBuffer);
HRESULT __stdcall D3DXLoadPRTBufferFromFileW(
    LPCWSTR pFilename,
    LPD3DXPRTBUFFER* ppBuffer);
HRESULT __stdcall D3DXSavePRTBufferToFileA(
    LPCSTR pFileName,
    LPD3DXPRTBUFFER pBuffer);
HRESULT __stdcall D3DXSavePRTBufferToFileW(
    LPCWSTR pFileName,
    LPD3DXPRTBUFFER pBuffer);
HRESULT __stdcall D3DXLoadPRTCompBufferFromFileA(
    LPCSTR pFilename,
    LPD3DXPRTCOMPBUFFER* ppBuffer);
HRESULT __stdcall D3DXLoadPRTCompBufferFromFileW(
    LPCWSTR pFilename,
    LPD3DXPRTCOMPBUFFER* ppBuffer);
HRESULT __stdcall D3DXSavePRTCompBufferToFileA(
    LPCSTR pFileName,
    LPD3DXPRTCOMPBUFFER pBuffer);
HRESULT __stdcall D3DXSavePRTCompBufferToFileW(
    LPCWSTR pFileName,
    LPD3DXPRTCOMPBUFFER pBuffer);
HRESULT __stdcall D3DXCreatePRTCompBuffer(
    D3DXSHCOMPRESSQUALITYTYPE Quality,
    UINT NumClusters,
    UINT NumPCA,
    LPD3DXSHPRTSIMCB pCB,
    LPVOID lpUserContext,
    LPD3DXPRTBUFFER pBufferIn,
    LPD3DXPRTCOMPBUFFER* ppBufferOut);
HRESULT __stdcall D3DXCreateTextureGutterHelper(
    UINT Width,
    UINT Height,
    LPD3DXMESH pMesh,
    FLOAT GutterSize,
    LPD3DXTEXTUREGUTTERHELPER* ppBuffer);
HRESULT __stdcall D3DXCreatePRTEngine(
    LPD3DXMESH pMesh,
    DWORD* pAdjacency,
    BOOL ExtractUVs,
    LPD3DXMESH pBlockerMesh,
    LPD3DXPRTENGINE* ppEngine);
HRESULT __stdcall D3DXConcatenateMeshes(
    LPD3DXMESH* ppMeshes,
    UINT NumMeshes,
    DWORD Options,
    const D3DXMATRIX* pGeomXForms,
    const D3DXMATRIX* pTextureXForms,
    const D3DVERTEXELEMENT9* pDecl,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXMESH* ppMeshOut);
HRESULT __stdcall D3DXSHPRTCompSuperCluster(
    UINT* pClusterIDs,
    LPD3DXMESH pScene,
    UINT MaxNumClusters,
    UINT NumClusters,
    UINT* pSuperClusterIDs,
    UINT* pNumSuperClusters);
HRESULT __stdcall D3DXSHPRTCompSplitMeshSC(
    UINT* pClusterIDs,
    UINT NumVertices,
    UINT NumClusters,
    UINT* pSuperClusterIDs,
    UINT NumSuperClusters,
    LPVOID pInputIB,
    BOOL InputIBIs32Bit,
    UINT NumFaces,
    LPD3DXBUFFER* ppIBData,
    UINT* pIBDataLength,
    BOOL OutputIBIs32Bit,
    LPD3DXBUFFER* ppFaceRemap,
    LPD3DXBUFFER* ppVertData,
    UINT* pVertDataLength,
    UINT* pSCClusterList,
    D3DXSHPRTSPLITMESHCLUSTERDATA* pSCData);
}
extern "C" const GUID DXFILEOBJ_XSkinMeshHeader;
extern "C" const GUID DXFILEOBJ_VertexDuplicationIndices;
extern "C" const GUID DXFILEOBJ_FaceAdjacency;
extern "C" const GUID DXFILEOBJ_SkinWeights;
extern "C" const GUID DXFILEOBJ_Patch;
extern "C" const GUID DXFILEOBJ_PatchMesh;
extern "C" const GUID DXFILEOBJ_PatchMesh9;
extern "C" const GUID DXFILEOBJ_PMInfo;
extern "C" const GUID DXFILEOBJ_PMAttributeRange;
extern "C" const GUID DXFILEOBJ_PMVSplitRecord;
extern "C" const GUID DXFILEOBJ_FVFData;
extern "C" const GUID DXFILEOBJ_VertexElement;
extern "C" const GUID DXFILEOBJ_DeclData;
extern "C" const GUID DXFILEOBJ_EffectFloats;
extern "C" const GUID DXFILEOBJ_EffectString;
extern "C" const GUID DXFILEOBJ_EffectDWord;
extern "C" const GUID DXFILEOBJ_EffectParamFloats;
extern "C" const GUID DXFILEOBJ_EffectParamString;
extern "C" const GUID DXFILEOBJ_EffectParamDWord;
extern "C" const GUID DXFILEOBJ_EffectInstance;
extern "C" const GUID DXFILEOBJ_AnimTicksPerSecond;
extern "C" const GUID DXFILEOBJ_CompressedAnimationSet;
#pragma pack(push, 1)
typedef struct _XFILECOMPRESSEDANIMATIONSET {
    DWORD CompressedBlockSize;
    FLOAT TicksPerSec;
    DWORD PlaybackType;
    DWORD BufferLength;
} XFILECOMPRESSEDANIMATIONSET;
#pragma pack(pop)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
typedef LPCSTR D3DXHANDLE;
typedef D3DXHANDLE* LPD3DXHANDLE;
typedef struct _D3DXMACRO {
    LPCSTR Name;
    LPCSTR Definition;
} D3DXMACRO, *LPD3DXMACRO;
typedef struct _D3DXSEMANTIC {
    UINT Usage;
    UINT UsageIndex;
} D3DXSEMANTIC, *LPD3DXSEMANTIC;
typedef enum _D3DXREGISTER_SET {
    D3DXRS_BOOL,
    D3DXRS_INT4,
    D3DXRS_FLOAT4,
    D3DXRS_SAMPLER,
    D3DXRS_FORCE_DWORD = 0x7fffffff
} D3DXREGISTER_SET,
    *LPD3DXREGISTER_SET;
typedef enum _D3DXPARAMETER_CLASS {
    D3DXPC_SCALAR,
    D3DXPC_VECTOR,
    D3DXPC_MATRIX_ROWS,
    D3DXPC_MATRIX_COLUMNS,
    D3DXPC_OBJECT,
    D3DXPC_STRUCT,
    D3DXPC_FORCE_DWORD = 0x7fffffff
} D3DXPARAMETER_CLASS,
    *LPD3DXPARAMETER_CLASS;
typedef enum _D3DXPARAMETER_TYPE {
    D3DXPT_VOID,
    D3DXPT_BOOL,
    D3DXPT_INT,
    D3DXPT_FLOAT,
    D3DXPT_STRING,
    D3DXPT_TEXTURE,
    D3DXPT_TEXTURE1D,
    D3DXPT_TEXTURE2D,
    D3DXPT_TEXTURE3D,
    D3DXPT_TEXTURECUBE,
    D3DXPT_SAMPLER,
    D3DXPT_SAMPLER1D,
    D3DXPT_SAMPLER2D,
    D3DXPT_SAMPLER3D,
    D3DXPT_SAMPLERCUBE,
    D3DXPT_PIXELSHADER,
    D3DXPT_VERTEXSHADER,
    D3DXPT_PIXELFRAGMENT,
    D3DXPT_VERTEXFRAGMENT,
    D3DXPT_UNSUPPORTED,
    D3DXPT_FORCE_DWORD = 0x7fffffff
} D3DXPARAMETER_TYPE,
    *LPD3DXPARAMETER_TYPE;
typedef struct _D3DXCONSTANTTABLE_DESC {
    LPCSTR Creator;
    DWORD Version;
    UINT Constants;
} D3DXCONSTANTTABLE_DESC, *LPD3DXCONSTANTTABLE_DESC;
typedef struct _D3DXCONSTANT_DESC {
    LPCSTR Name;
    D3DXREGISTER_SET RegisterSet;
    UINT RegisterIndex;
    UINT RegisterCount;
    D3DXPARAMETER_CLASS Class;
    D3DXPARAMETER_TYPE Type;
    UINT Rows;
    UINT Columns;
    UINT Elements;
    UINT StructMembers;
    UINT Bytes;
    LPCVOID DefaultValue;
} D3DXCONSTANT_DESC, *LPD3DXCONSTANT_DESC;
typedef struct ID3DXConstantTable ID3DXConstantTable;
typedef struct ID3DXConstantTable* LPD3DXCONSTANTTABLE;
extern "C" const GUID IID_ID3DXConstantTable;
struct __declspec(novtable) ID3DXConstantTable : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) LPVOID __stdcall GetBufferPointer(void) = 0;
    virtual __declspec(nothrow) DWORD __stdcall GetBufferSize(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXCONSTANTTABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetConstantDesc(D3DXHANDLE hConstant, D3DXCONSTANT_DESC* pConstantDesc, UINT* pCount) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetSamplerIndex(D3DXHANDLE hConstant) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetConstant(D3DXHANDLE hConstant, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetConstantByName(D3DXHANDLE hConstant, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetConstantElement(D3DXHANDLE hConstant, UINT Index) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDefaults(LPDIRECT3DDEVICE9 pDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetValue(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, LPCVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBool(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, BOOL b) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetInt(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, INT n) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloat(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, FLOAT f) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVector(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVectorArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrix(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixPointerArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTranspose(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposeArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposePointerArray(LPDIRECT3DDEVICE9 pDevice, D3DXHANDLE hConstant, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
};
typedef struct ID3DXTextureShader ID3DXTextureShader;
typedef struct ID3DXTextureShader* LPD3DXTEXTURESHADER;
extern "C" const GUID IID_ID3DXTextureShader;
struct __declspec(novtable) ID3DXTextureShader : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFunction(LPD3DXBUFFER* ppFunction) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetConstantBuffer(LPD3DXBUFFER* ppConstantBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXCONSTANTTABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetConstantDesc(D3DXHANDLE hConstant, D3DXCONSTANT_DESC* pConstantDesc, UINT* pCount) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetConstant(D3DXHANDLE hConstant, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetConstantByName(D3DXHANDLE hConstant, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetConstantElement(D3DXHANDLE hConstant, UINT Index) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDefaults(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetValue(D3DXHANDLE hConstant, LPCVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBool(D3DXHANDLE hConstant, BOOL b) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolArray(D3DXHANDLE hConstant, const BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetInt(D3DXHANDLE hConstant, INT n) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntArray(D3DXHANDLE hConstant, const INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloat(D3DXHANDLE hConstant, FLOAT f) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatArray(D3DXHANDLE hConstant, const FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVector(D3DXHANDLE hConstant, const D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVectorArray(D3DXHANDLE hConstant, const D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrix(D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixArray(D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixPointerArray(D3DXHANDLE hConstant, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTranspose(D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposeArray(D3DXHANDLE hConstant, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposePointerArray(D3DXHANDLE hConstant, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
};
typedef enum _D3DXINCLUDE_TYPE {
    D3DXINC_LOCAL,
    D3DXINC_SYSTEM,
    D3DXINC_FORCE_DWORD = 0x7fffffff
} D3DXINCLUDE_TYPE,
    *LPD3DXINCLUDE_TYPE;
typedef struct ID3DXInclude ID3DXInclude;
typedef struct ID3DXInclude* LPD3DXINCLUDE;
struct __declspec(novtable) ID3DXInclude {
    virtual __declspec(nothrow) HRESULT __stdcall Open(D3DXINCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID* ppData, UINT* pBytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Close(LPCVOID pData) = 0;
};
extern "C" {
HRESULT __stdcall D3DXAssembleShaderFromFileA(
    LPCSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXAssembleShaderFromFileW(
    LPCWSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXAssembleShaderFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXAssembleShaderFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXAssembleShader(
    LPCSTR pSrcData,
    UINT SrcDataLen,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXCompileShaderFromFileA(
    LPCSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pFunctionName,
    LPCSTR pProfile,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXCompileShaderFromFileW(
    LPCWSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pFunctionName,
    LPCSTR pProfile,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXCompileShaderFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pFunctionName,
    LPCSTR pProfile,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXCompileShaderFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pFunctionName,
    LPCSTR pProfile,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXCompileShader(
    LPCSTR pSrcData,
    UINT SrcDataLen,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pFunctionName,
    LPCSTR pProfile,
    DWORD Flags,
    LPD3DXBUFFER* ppShader,
    LPD3DXBUFFER* ppErrorMsgs,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXDisassembleShader(
    const DWORD* pShader,
    BOOL EnableColorCode,
    LPCSTR pComments,
    LPD3DXBUFFER* ppDisassembly);
LPCSTR __stdcall D3DXGetPixelShaderProfile(
    LPDIRECT3DDEVICE9 pDevice);
LPCSTR __stdcall D3DXGetVertexShaderProfile(
    LPDIRECT3DDEVICE9 pDevice);
HRESULT __stdcall D3DXFindShaderComment(
    const DWORD* pFunction,
    DWORD FourCC,
    LPCVOID* ppData,
    UINT* pSizeInBytes);
UINT __stdcall D3DXGetShaderSize(
    const DWORD* pFunction);
DWORD __stdcall D3DXGetShaderVersion(
    const DWORD* pFunction);
HRESULT __stdcall D3DXGetShaderInputSemantics(
    const DWORD* pFunction,
    D3DXSEMANTIC* pSemantics,
    UINT* pCount);
HRESULT __stdcall D3DXGetShaderOutputSemantics(
    const DWORD* pFunction,
    D3DXSEMANTIC* pSemantics,
    UINT* pCount);
HRESULT __stdcall D3DXGetShaderSamplers(
    const DWORD* pFunction,
    LPCSTR* pSamplers,
    UINT* pCount);
HRESULT __stdcall D3DXGetShaderConstantTable(
    const DWORD* pFunction,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXGetShaderConstantTableEx(
    const DWORD* pFunction,
    DWORD Flags,
    LPD3DXCONSTANTTABLE* ppConstantTable);
HRESULT __stdcall D3DXCreateTextureShader(
    const DWORD* pFunction,
    LPD3DXTEXTURESHADER* ppTextureShader);
HRESULT __stdcall D3DXPreprocessShaderFromFileA(
    LPCSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPD3DXBUFFER* ppShaderText,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXPreprocessShaderFromFileW(
    LPCWSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPD3DXBUFFER* ppShaderText,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXPreprocessShaderFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPD3DXBUFFER* ppShaderText,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXPreprocessShaderFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPD3DXBUFFER* ppShaderText,
    LPD3DXBUFFER* ppErrorMsgs);
HRESULT __stdcall D3DXPreprocessShader(
    LPCSTR pSrcData,
    UINT SrcDataSize,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPD3DXBUFFER* ppShaderText,
    LPD3DXBUFFER* ppErrorMsgs);
}
typedef struct _D3DXSHADER_CONSTANTTABLE {
    DWORD Size;
    DWORD Creator;
    DWORD Version;
    DWORD Constants;
    DWORD ConstantInfo;
    DWORD Flags;
    DWORD Target;
} D3DXSHADER_CONSTANTTABLE, *LPD3DXSHADER_CONSTANTTABLE;
typedef struct _D3DXSHADER_CONSTANTINFO {
    DWORD Name;
    WORD RegisterSet;
    WORD RegisterIndex;
    WORD RegisterCount;
    WORD Reserved;
    DWORD TypeInfo;
    DWORD DefaultValue;
} D3DXSHADER_CONSTANTINFO, *LPD3DXSHADER_CONSTANTINFO;
typedef struct _D3DXSHADER_TYPEINFO {
    WORD Class;
    WORD Type;
    WORD Rows;
    WORD Columns;
    WORD Elements;
    WORD StructMembers;
    DWORD StructMemberInfo;
} D3DXSHADER_TYPEINFO, *LPD3DXSHADER_TYPEINFO;
typedef struct _D3DXSHADER_STRUCTMEMBERINFO {
    DWORD Name;
    DWORD TypeInfo;
} D3DXSHADER_STRUCTMEMBERINFO, *LPD3DXSHADER_STRUCTMEMBERINFO;
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
typedef struct _D3DXEFFECT_DESC {
    LPCSTR Creator;
    UINT Parameters;
    UINT Techniques;
    UINT Functions;
} D3DXEFFECT_DESC;
typedef struct _D3DXPARAMETER_DESC {
    LPCSTR Name;
    LPCSTR Semantic;
    D3DXPARAMETER_CLASS Class;
    D3DXPARAMETER_TYPE Type;
    UINT Rows;
    UINT Columns;
    UINT Elements;
    UINT Annotations;
    UINT StructMembers;
    DWORD Flags;
    UINT Bytes;
} D3DXPARAMETER_DESC;
typedef struct _D3DXTECHNIQUE_DESC {
    LPCSTR Name;
    UINT Passes;
    UINT Annotations;
} D3DXTECHNIQUE_DESC;
typedef struct _D3DXPASS_DESC {
    LPCSTR Name;
    UINT Annotations;
    const DWORD* pVertexShaderFunction;
    const DWORD* pPixelShaderFunction;
} D3DXPASS_DESC;
typedef struct _D3DXFUNCTION_DESC {
    LPCSTR Name;
    UINT Annotations;
} D3DXFUNCTION_DESC;
typedef struct ID3DXEffectPool ID3DXEffectPool;
typedef struct ID3DXEffectPool* LPD3DXEFFECTPOOL;
extern "C" const GUID IID_ID3DXEffectPool;
struct __declspec(novtable) ID3DXEffectPool : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
};
typedef struct ID3DXBaseEffect ID3DXBaseEffect;
typedef struct ID3DXBaseEffect* LPD3DXBASEEFFECT;
extern "C" const GUID IID_ID3DXBaseEffect;
struct __declspec(novtable) ID3DXBaseEffect : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXEFFECT_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetParameterDesc(D3DXHANDLE hParameter, D3DXPARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTechniqueDesc(D3DXHANDLE hTechnique, D3DXTECHNIQUE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPassDesc(D3DXHANDLE hPass, D3DXPASS_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFunctionDesc(D3DXHANDLE hShader, D3DXFUNCTION_DESC* pDesc) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameter(D3DXHANDLE hParameter, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterByName(D3DXHANDLE hParameter, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterBySemantic(D3DXHANDLE hParameter, LPCSTR pSemantic) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterElement(D3DXHANDLE hParameter, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetTechnique(UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetTechniqueByName(LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetPass(D3DXHANDLE hTechnique, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetPassByName(D3DXHANDLE hTechnique, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetFunction(UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetFunctionByName(LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetAnnotation(D3DXHANDLE hObject, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetAnnotationByName(D3DXHANDLE hObject, LPCSTR pName) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetValue(D3DXHANDLE hParameter, LPCVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetValue(D3DXHANDLE hParameter, LPVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBool(D3DXHANDLE hParameter, BOOL b) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBool(D3DXHANDLE hParameter, BOOL* pb) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolArray(D3DXHANDLE hParameter, const BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoolArray(D3DXHANDLE hParameter, BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetInt(D3DXHANDLE hParameter, INT n) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInt(D3DXHANDLE hParameter, INT* pn) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntArray(D3DXHANDLE hParameter, const INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIntArray(D3DXHANDLE hParameter, INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloat(D3DXHANDLE hParameter, FLOAT f) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloat(D3DXHANDLE hParameter, FLOAT* pf) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatArray(D3DXHANDLE hParameter, const FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloatArray(D3DXHANDLE hParameter, FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVector(D3DXHANDLE hParameter, const D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVector(D3DXHANDLE hParameter, D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVectorArray(D3DXHANDLE hParameter, const D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVectorArray(D3DXHANDLE hParameter, D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrix(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrix(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixArray(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixArray(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixPointerArray(D3DXHANDLE hParameter, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixPointerArray(D3DXHANDLE hParameter, D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTranspose(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTranspose(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposeArray(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposeArray(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposePointerArray(D3DXHANDLE hParameter, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposePointerArray(D3DXHANDLE hParameter, D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetString(D3DXHANDLE hParameter, LPCSTR pString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetString(D3DXHANDLE hParameter, LPCSTR* ppString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexture(D3DXHANDLE hParameter, LPDIRECT3DBASETEXTURE9 pTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTexture(D3DXHANDLE hParameter, LPDIRECT3DBASETEXTURE9* ppTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShader(D3DXHANDLE hParameter, LPDIRECT3DPIXELSHADER9* ppPShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShader(D3DXHANDLE hParameter, LPDIRECT3DVERTEXSHADER9* ppVShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetArrayRange(D3DXHANDLE hParameter, UINT uStart, UINT uEnd) = 0;
};
typedef struct ID3DXEffectStateManager ID3DXEffectStateManager;
typedef struct ID3DXEffectStateManager* LPD3DXEFFECTSTATEMANAGER;
extern "C" const GUID IID_ID3DXEffectStateManager;
struct __declspec(novtable) ID3DXEffectStateManager : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTransform(D3DTRANSFORMSTATETYPE State, const D3DMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMaterial(const D3DMATERIAL9* pMaterial) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetLight(DWORD Index, const D3DLIGHT9* pLight) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LightEnable(DWORD Index, BOOL Enable) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexture(DWORD Stage, LPDIRECT3DBASETEXTURE9 pTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetSamplerState(DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetNPatchMode(FLOAT NumSegments) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFVF(DWORD FVF) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShader(LPDIRECT3DVERTEXSHADER9 pShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantF(UINT RegisterIndex, const FLOAT* pConstantData, UINT RegisterCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantI(UINT RegisterIndex, const INT* pConstantData, UINT RegisterCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexShaderConstantB(UINT RegisterIndex, const BOOL* pConstantData, UINT RegisterCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShader(LPDIRECT3DPIXELSHADER9 pShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantF(UINT RegisterIndex, const FLOAT* pConstantData, UINT RegisterCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantI(UINT RegisterIndex, const INT* pConstantData, UINT RegisterCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPixelShaderConstantB(UINT RegisterIndex, const BOOL* pConstantData, UINT RegisterCount) = 0;
};
typedef struct ID3DXEffect ID3DXEffect;
typedef struct ID3DXEffect* LPD3DXEFFECT;
extern "C" const GUID IID_ID3DXEffect;
struct __declspec(novtable) ID3DXEffect : public ID3DXBaseEffect {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXEFFECT_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetParameterDesc(D3DXHANDLE hParameter, D3DXPARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTechniqueDesc(D3DXHANDLE hTechnique, D3DXTECHNIQUE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPassDesc(D3DXHANDLE hPass, D3DXPASS_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFunctionDesc(D3DXHANDLE hShader, D3DXFUNCTION_DESC* pDesc) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameter(D3DXHANDLE hParameter, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterByName(D3DXHANDLE hParameter, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterBySemantic(D3DXHANDLE hParameter, LPCSTR pSemantic) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterElement(D3DXHANDLE hParameter, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetTechnique(UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetTechniqueByName(LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetPass(D3DXHANDLE hTechnique, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetPassByName(D3DXHANDLE hTechnique, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetFunction(UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetFunctionByName(LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetAnnotation(D3DXHANDLE hObject, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetAnnotationByName(D3DXHANDLE hObject, LPCSTR pName) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetValue(D3DXHANDLE hParameter, LPCVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetValue(D3DXHANDLE hParameter, LPVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBool(D3DXHANDLE hParameter, BOOL b) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBool(D3DXHANDLE hParameter, BOOL* pb) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolArray(D3DXHANDLE hParameter, const BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoolArray(D3DXHANDLE hParameter, BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetInt(D3DXHANDLE hParameter, INT n) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInt(D3DXHANDLE hParameter, INT* pn) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntArray(D3DXHANDLE hParameter, const INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIntArray(D3DXHANDLE hParameter, INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloat(D3DXHANDLE hParameter, FLOAT f) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloat(D3DXHANDLE hParameter, FLOAT* pf) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatArray(D3DXHANDLE hParameter, const FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloatArray(D3DXHANDLE hParameter, FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVector(D3DXHANDLE hParameter, const D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVector(D3DXHANDLE hParameter, D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVectorArray(D3DXHANDLE hParameter, const D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVectorArray(D3DXHANDLE hParameter, D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrix(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrix(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixArray(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixArray(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixPointerArray(D3DXHANDLE hParameter, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixPointerArray(D3DXHANDLE hParameter, D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTranspose(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTranspose(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposeArray(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposeArray(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposePointerArray(D3DXHANDLE hParameter, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposePointerArray(D3DXHANDLE hParameter, D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetString(D3DXHANDLE hParameter, LPCSTR pString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetString(D3DXHANDLE hParameter, LPCSTR* ppString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexture(D3DXHANDLE hParameter, LPDIRECT3DBASETEXTURE9 pTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTexture(D3DXHANDLE hParameter, LPDIRECT3DBASETEXTURE9* ppTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShader(D3DXHANDLE hParameter, LPDIRECT3DPIXELSHADER9* ppPShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShader(D3DXHANDLE hParameter, LPDIRECT3DVERTEXSHADER9* ppVShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetArrayRange(D3DXHANDLE hParameter, UINT uStart, UINT uEnd) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPool(LPD3DXEFFECTPOOL* ppPool) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTechnique(D3DXHANDLE hTechnique) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetCurrentTechnique(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ValidateTechnique(D3DXHANDLE hTechnique) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FindNextValidTechnique(D3DXHANDLE hTechnique, D3DXHANDLE* pTechnique) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsParameterUsed(D3DXHANDLE hParameter, D3DXHANDLE hTechnique) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Begin(UINT* pPasses, DWORD Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginPass(UINT Pass) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CommitChanges(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall EndPass(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall End(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(LPDIRECT3DDEVICE9* ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnLostDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall OnResetDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetStateManager(LPD3DXEFFECTSTATEMANAGER pManager) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetStateManager(LPD3DXEFFECTSTATEMANAGER* ppManager) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall BeginParameterBlock(void) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall EndParameterBlock(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ApplyParameterBlock(D3DXHANDLE hParameterBlock) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DeleteParameterBlock(D3DXHANDLE hParameterBlock) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneEffect(LPDIRECT3DDEVICE9 pDevice, LPD3DXEFFECT* ppEffect) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(D3DXHANDLE hParameter, LPCVOID pData, UINT ByteOffset, UINT Bytes) = 0;
};
typedef struct ID3DXEffectCompiler ID3DXEffectCompiler;
typedef struct ID3DXEffectCompiler* LPD3DXEFFECTCOMPILER;
extern "C" const GUID IID_ID3DXEffectCompiler;
struct __declspec(novtable) ID3DXEffectCompiler : public ID3DXBaseEffect {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3DXEFFECT_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetParameterDesc(D3DXHANDLE hParameter, D3DXPARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTechniqueDesc(D3DXHANDLE hTechnique, D3DXTECHNIQUE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPassDesc(D3DXHANDLE hPass, D3DXPASS_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFunctionDesc(D3DXHANDLE hShader, D3DXFUNCTION_DESC* pDesc) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameter(D3DXHANDLE hParameter, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterByName(D3DXHANDLE hParameter, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterBySemantic(D3DXHANDLE hParameter, LPCSTR pSemantic) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetParameterElement(D3DXHANDLE hParameter, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetTechnique(UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetTechniqueByName(LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetPass(D3DXHANDLE hTechnique, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetPassByName(D3DXHANDLE hTechnique, LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetFunction(UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetFunctionByName(LPCSTR pName) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetAnnotation(D3DXHANDLE hObject, UINT Index) = 0;
    virtual __declspec(nothrow) D3DXHANDLE __stdcall GetAnnotationByName(D3DXHANDLE hObject, LPCSTR pName) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetValue(D3DXHANDLE hParameter, LPCVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetValue(D3DXHANDLE hParameter, LPVOID pData, UINT Bytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBool(D3DXHANDLE hParameter, BOOL b) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBool(D3DXHANDLE hParameter, BOOL* pb) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolArray(D3DXHANDLE hParameter, const BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoolArray(D3DXHANDLE hParameter, BOOL* pb, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetInt(D3DXHANDLE hParameter, INT n) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInt(D3DXHANDLE hParameter, INT* pn) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntArray(D3DXHANDLE hParameter, const INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIntArray(D3DXHANDLE hParameter, INT* pn, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloat(D3DXHANDLE hParameter, FLOAT f) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloat(D3DXHANDLE hParameter, FLOAT* pf) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatArray(D3DXHANDLE hParameter, const FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloatArray(D3DXHANDLE hParameter, FLOAT* pf, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVector(D3DXHANDLE hParameter, const D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVector(D3DXHANDLE hParameter, D3DXVECTOR4* pVector) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVectorArray(D3DXHANDLE hParameter, const D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVectorArray(D3DXHANDLE hParameter, D3DXVECTOR4* pVector, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrix(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrix(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixArray(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixArray(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixPointerArray(D3DXHANDLE hParameter, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixPointerArray(D3DXHANDLE hParameter, D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTranspose(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTranspose(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposeArray(D3DXHANDLE hParameter, const D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposeArray(D3DXHANDLE hParameter, D3DXMATRIX* pMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposePointerArray(D3DXHANDLE hParameter, const D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposePointerArray(D3DXHANDLE hParameter, D3DXMATRIX** ppMatrix, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetString(D3DXHANDLE hParameter, LPCSTR pString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetString(D3DXHANDLE hParameter, LPCSTR* ppString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTexture(D3DXHANDLE hParameter, LPDIRECT3DBASETEXTURE9 pTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTexture(D3DXHANDLE hParameter, LPDIRECT3DBASETEXTURE9* ppTexture) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShader(D3DXHANDLE hParameter, LPDIRECT3DPIXELSHADER9* ppPShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShader(D3DXHANDLE hParameter, LPDIRECT3DVERTEXSHADER9* ppVShader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetArrayRange(D3DXHANDLE hParameter, UINT uStart, UINT uEnd) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetLiteral(D3DXHANDLE hParameter, BOOL Literal) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetLiteral(D3DXHANDLE hParameter, BOOL* pLiteral) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CompileEffect(DWORD Flags,
        LPD3DXBUFFER* ppEffect, LPD3DXBUFFER* ppErrorMsgs)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CompileShader(D3DXHANDLE hFunction, LPCSTR pTarget, DWORD Flags,
        LPD3DXBUFFER* ppShader, LPD3DXBUFFER* ppErrorMsgs, LPD3DXCONSTANTTABLE* ppConstantTable)
        = 0;
};
extern "C" {
HRESULT __stdcall D3DXCreateEffectPool(
    LPD3DXEFFECTPOOL* ppPool);
HRESULT __stdcall D3DXCreateEffectFromFileA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromFileW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromResourceA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromResourceW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffect(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataLen,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromFileExA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pSkipConstants,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromFileExW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pSkipConstants,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromResourceExA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pSkipConstants,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectFromResourceExW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pSkipConstants,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectEx(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataLen,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    LPCSTR pSkipConstants,
    DWORD Flags,
    LPD3DXEFFECTPOOL pPool,
    LPD3DXEFFECT* ppEffect,
    LPD3DXBUFFER* ppCompilationErrors);
HRESULT __stdcall D3DXCreateEffectCompilerFromFileA(
    LPCSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTCOMPILER* ppCompiler,
    LPD3DXBUFFER* ppParseErrors);
HRESULT __stdcall D3DXCreateEffectCompilerFromFileW(
    LPCWSTR pSrcFile,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTCOMPILER* ppCompiler,
    LPD3DXBUFFER* ppParseErrors);
HRESULT __stdcall D3DXCreateEffectCompilerFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTCOMPILER* ppCompiler,
    LPD3DXBUFFER* ppParseErrors);
HRESULT __stdcall D3DXCreateEffectCompilerFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTCOMPILER* ppCompiler,
    LPD3DXBUFFER* ppParseErrors);
HRESULT __stdcall D3DXCreateEffectCompiler(
    LPCSTR pSrcData,
    UINT SrcDataLen,
    const D3DXMACRO* pDefines,
    LPD3DXINCLUDE pInclude,
    DWORD Flags,
    LPD3DXEFFECTCOMPILER* ppCompiler,
    LPD3DXBUFFER* ppParseErrors);
HRESULT __stdcall D3DXDisassembleEffect(
    LPD3DXEFFECT pEffect,
    BOOL EnableColorCode,
    LPD3DXBUFFER* ppDisassembly);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
typedef enum _D3DXIMAGE_FILEFORMAT {
    D3DXIFF_BMP = 0,
    D3DXIFF_JPG = 1,
    D3DXIFF_TGA = 2,
    D3DXIFF_PNG = 3,
    D3DXIFF_DDS = 4,
    D3DXIFF_PPM = 5,
    D3DXIFF_DIB = 6,
    D3DXIFF_HDR = 7,
    D3DXIFF_PFM = 8,
    D3DXIFF_FORCE_DWORD = 0x7fffffff
} D3DXIMAGE_FILEFORMAT;
typedef void(__stdcall* LPD3DXFILL2D)(D3DXVECTOR4* pOut,
    const D3DXVECTOR2* pTexCoord, const D3DXVECTOR2* pTexelSize, LPVOID pData);
typedef void(__stdcall* LPD3DXFILL3D)(D3DXVECTOR4* pOut,
    const D3DXVECTOR3* pTexCoord, const D3DXVECTOR3* pTexelSize, LPVOID pData);
typedef struct _D3DXIMAGE_INFO {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    D3DFORMAT Format;
    D3DRESOURCETYPE ResourceType;
    D3DXIMAGE_FILEFORMAT ImageFileFormat;
} D3DXIMAGE_INFO;
extern "C" {
;
HRESULT __stdcall D3DXGetImageInfoFromFileA(
    LPCSTR pSrcFile,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXGetImageInfoFromFileW(
    LPCWSTR pSrcFile,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXGetImageInfoFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXGetImageInfoFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXGetImageInfoFromFileInMemory(
    LPCVOID pSrcData,
    UINT SrcDataSize,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadSurfaceFromFileA(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    LPCSTR pSrcFile,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadSurfaceFromFileW(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    LPCWSTR pSrcFile,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadSurfaceFromResourceA(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadSurfaceFromResourceW(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadSurfaceFromFileInMemory(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadSurfaceFromSurface(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    LPDIRECT3DSURFACE9 pSrcSurface,
    const PALETTEENTRY* pSrcPalette,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey);
HRESULT __stdcall D3DXLoadSurfaceFromMemory(
    LPDIRECT3DSURFACE9 pDestSurface,
    const PALETTEENTRY* pDestPalette,
    const RECT* pDestRect,
    LPCVOID pSrcMemory,
    D3DFORMAT SrcFormat,
    UINT SrcPitch,
    const PALETTEENTRY* pSrcPalette,
    const RECT* pSrcRect,
    DWORD Filter,
    D3DCOLOR ColorKey);
HRESULT __stdcall D3DXSaveSurfaceToFileA(
    LPCSTR pDestFile,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DSURFACE9 pSrcSurface,
    const PALETTEENTRY* pSrcPalette,
    const RECT* pSrcRect);
HRESULT __stdcall D3DXSaveSurfaceToFileW(
    LPCWSTR pDestFile,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DSURFACE9 pSrcSurface,
    const PALETTEENTRY* pSrcPalette,
    const RECT* pSrcRect);
HRESULT __stdcall D3DXSaveSurfaceToFileInMemory(
    LPD3DXBUFFER* ppDestBuf,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DSURFACE9 pSrcSurface,
    const PALETTEENTRY* pSrcPalette,
    const RECT* pSrcRect);
HRESULT __stdcall D3DXLoadVolumeFromFileA(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    LPCSTR pSrcFile,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadVolumeFromFileW(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    LPCWSTR pSrcFile,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadVolumeFromResourceA(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadVolumeFromResourceW(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadVolumeFromFileInMemory(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo);
HRESULT __stdcall D3DXLoadVolumeFromVolume(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    LPDIRECT3DVOLUME9 pSrcVolume,
    const PALETTEENTRY* pSrcPalette,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey);
HRESULT __stdcall D3DXLoadVolumeFromMemory(
    LPDIRECT3DVOLUME9 pDestVolume,
    const PALETTEENTRY* pDestPalette,
    const D3DBOX* pDestBox,
    LPCVOID pSrcMemory,
    D3DFORMAT SrcFormat,
    UINT SrcRowPitch,
    UINT SrcSlicePitch,
    const PALETTEENTRY* pSrcPalette,
    const D3DBOX* pSrcBox,
    DWORD Filter,
    D3DCOLOR ColorKey);
HRESULT __stdcall D3DXSaveVolumeToFileA(
    LPCSTR pDestFile,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DVOLUME9 pSrcVolume,
    const PALETTEENTRY* pSrcPalette,
    const D3DBOX* pSrcBox);
HRESULT __stdcall D3DXSaveVolumeToFileW(
    LPCWSTR pDestFile,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DVOLUME9 pSrcVolume,
    const PALETTEENTRY* pSrcPalette,
    const D3DBOX* pSrcBox);
HRESULT __stdcall D3DXSaveVolumeToFileInMemory(
    LPD3DXBUFFER* ppDestBuf,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DVOLUME9 pSrcVolume,
    const PALETTEENTRY* pSrcPalette,
    const D3DBOX* pSrcBox);
HRESULT __stdcall D3DXCheckTextureRequirements(
    LPDIRECT3DDEVICE9 pDevice,
    UINT* pWidth,
    UINT* pHeight,
    UINT* pNumMipLevels,
    DWORD Usage,
    D3DFORMAT* pFormat,
    D3DPOOL Pool);
HRESULT __stdcall D3DXCheckCubeTextureRequirements(
    LPDIRECT3DDEVICE9 pDevice,
    UINT* pSize,
    UINT* pNumMipLevels,
    DWORD Usage,
    D3DFORMAT* pFormat,
    D3DPOOL Pool);
HRESULT __stdcall D3DXCheckVolumeTextureRequirements(
    LPDIRECT3DDEVICE9 pDevice,
    UINT* pWidth,
    UINT* pHeight,
    UINT* pDepth,
    UINT* pNumMipLevels,
    DWORD Usage,
    D3DFORMAT* pFormat,
    D3DPOOL Pool);
HRESULT __stdcall D3DXCreateTexture(
    LPDIRECT3DDEVICE9 pDevice,
    UINT Width,
    UINT Height,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTexture(
    LPDIRECT3DDEVICE9 pDevice,
    UINT Size,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTexture(
    LPDIRECT3DDEVICE9 pDevice,
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateTextureFromFileA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateTextureFromFileW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromFileA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromFileW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromFileA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromFileW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateTextureFromResourceA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateTextureFromResourceW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromResourceA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromResourceW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromResourceA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromResourceW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateTextureFromFileExA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    UINT Width,
    UINT Height,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateTextureFromFileExW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    UINT Width,
    UINT Height,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromFileExA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    UINT Size,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromFileExW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    UINT Size,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromFileExA(
    LPDIRECT3DDEVICE9 pDevice,
    LPCSTR pSrcFile,
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromFileExW(
    LPDIRECT3DDEVICE9 pDevice,
    LPCWSTR pSrcFile,
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateTextureFromResourceExA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    UINT Width,
    UINT Height,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateTextureFromResourceExW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    UINT Width,
    UINT Height,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromResourceExA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    UINT Size,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromResourceExW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    UINT Size,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromResourceExA(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromResourceExW(
    LPDIRECT3DDEVICE9 pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateTextureFromFileInMemory(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromFileInMemory(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromFileInMemory(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXCreateTextureFromFileInMemoryEx(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    UINT Width,
    UINT Height,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DTEXTURE9* ppTexture);
HRESULT __stdcall D3DXCreateCubeTextureFromFileInMemoryEx(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    UINT Size,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DCUBETEXTURE9* ppCubeTexture);
HRESULT __stdcall D3DXCreateVolumeTextureFromFileInMemoryEx(
    LPDIRECT3DDEVICE9 pDevice,
    LPCVOID pSrcData,
    UINT SrcDataSize,
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT MipLevels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    DWORD Filter,
    DWORD MipFilter,
    D3DCOLOR ColorKey,
    D3DXIMAGE_INFO* pSrcInfo,
    PALETTEENTRY* pPalette,
    LPDIRECT3DVOLUMETEXTURE9* ppVolumeTexture);
HRESULT __stdcall D3DXSaveTextureToFileA(
    LPCSTR pDestFile,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DBASETEXTURE9 pSrcTexture,
    const PALETTEENTRY* pSrcPalette);
HRESULT __stdcall D3DXSaveTextureToFileW(
    LPCWSTR pDestFile,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DBASETEXTURE9 pSrcTexture,
    const PALETTEENTRY* pSrcPalette);
HRESULT __stdcall D3DXSaveTextureToFileInMemory(
    LPD3DXBUFFER* ppDestBuf,
    D3DXIMAGE_FILEFORMAT DestFormat,
    LPDIRECT3DBASETEXTURE9 pSrcTexture,
    const PALETTEENTRY* pSrcPalette);
HRESULT __stdcall D3DXFilterTexture(
    LPDIRECT3DBASETEXTURE9 pBaseTexture,
    const PALETTEENTRY* pPalette,
    UINT SrcLevel,
    DWORD Filter);
HRESULT __stdcall D3DXFillTexture(
    LPDIRECT3DTEXTURE9 pTexture,
    LPD3DXFILL2D pFunction,
    LPVOID pData);
HRESULT __stdcall D3DXFillCubeTexture(
    LPDIRECT3DCUBETEXTURE9 pCubeTexture,
    LPD3DXFILL3D pFunction,
    LPVOID pData);
HRESULT __stdcall D3DXFillVolumeTexture(
    LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,
    LPD3DXFILL3D pFunction,
    LPVOID pData);
HRESULT __stdcall D3DXFillTextureTX(
    LPDIRECT3DTEXTURE9 pTexture,
    LPD3DXTEXTURESHADER pTextureShader);
HRESULT __stdcall D3DXFillCubeTextureTX(
    LPDIRECT3DCUBETEXTURE9 pCubeTexture,
    LPD3DXTEXTURESHADER pTextureShader);
HRESULT __stdcall D3DXFillVolumeTextureTX(
    LPDIRECT3DVOLUMETEXTURE9 pVolumeTexture,
    LPD3DXTEXTURESHADER pTextureShader);
HRESULT __stdcall D3DXComputeNormalMap(
    LPDIRECT3DTEXTURE9 pTexture,
    LPDIRECT3DTEXTURE9 pSrcTexture,
    const PALETTEENTRY* pSrcPalette,
    DWORD Flags,
    DWORD Channel,
    FLOAT Amplitude);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
HRESULT __stdcall D3DXCreatePolygon(
    LPDIRECT3DDEVICE9 pDevice,
    FLOAT Length,
    UINT Sides,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency);
HRESULT __stdcall D3DXCreateBox(
    LPDIRECT3DDEVICE9 pDevice,
    FLOAT Width,
    FLOAT Height,
    FLOAT Depth,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency);
HRESULT __stdcall D3DXCreateCylinder(
    LPDIRECT3DDEVICE9 pDevice,
    FLOAT Radius1,
    FLOAT Radius2,
    FLOAT Length,
    UINT Slices,
    UINT Stacks,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency);
HRESULT __stdcall D3DXCreateSphere(
    LPDIRECT3DDEVICE9 pDevice,
    FLOAT Radius,
    UINT Slices,
    UINT Stacks,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency);
HRESULT __stdcall D3DXCreateTorus(
    LPDIRECT3DDEVICE9 pDevice,
    FLOAT InnerRadius,
    FLOAT OuterRadius,
    UINT Sides,
    UINT Rings,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency);
HRESULT __stdcall D3DXCreateTeapot(
    LPDIRECT3DDEVICE9 pDevice,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency);
HRESULT __stdcall D3DXCreateTextA(
    LPDIRECT3DDEVICE9 pDevice,
    HDC hDC,
    LPCSTR pText,
    FLOAT Deviation,
    FLOAT Extrusion,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency,
    LPGLYPHMETRICSFLOAT pGlyphMetrics);
HRESULT __stdcall D3DXCreateTextW(
    LPDIRECT3DDEVICE9 pDevice,
    HDC hDC,
    LPCWSTR pText,
    FLOAT Deviation,
    FLOAT Extrusion,
    LPD3DXMESH* ppMesh,
    LPD3DXBUFFER* ppAdjacency,
    LPGLYPHMETRICSFLOAT pGlyphMetrics);
}
#pragma external_header(pop)
#pragma external_header(push)
extern "C" const GUID IID_ID3DXAnimationSet;
extern "C" const GUID IID_ID3DXKeyframedAnimationSet;
extern "C" const GUID IID_ID3DXCompressedAnimationSet;
extern "C" const GUID IID_ID3DXAnimationController;
typedef enum _D3DXMESHDATATYPE {
    D3DXMESHTYPE_MESH = 0x001,
    D3DXMESHTYPE_PMESH = 0x002,
    D3DXMESHTYPE_PATCHMESH = 0x003,
    D3DXMESHTYPE_FORCE_DWORD = 0x7fffffff,
} D3DXMESHDATATYPE;
typedef struct _D3DXMESHDATA {
    D3DXMESHDATATYPE Type;
    union {
        LPD3DXMESH pMesh;
        LPD3DXPMESH pPMesh;
        LPD3DXPATCHMESH pPatchMesh;
    };
} D3DXMESHDATA, *LPD3DXMESHDATA;
typedef struct _D3DXMESHCONTAINER {
    LPSTR Name;
    D3DXMESHDATA MeshData;
    LPD3DXMATERIAL pMaterials;
    LPD3DXEFFECTINSTANCE pEffects;
    DWORD NumMaterials;
    DWORD* pAdjacency;
    LPD3DXSKININFO pSkinInfo;
    struct _D3DXMESHCONTAINER* pNextMeshContainer;
} D3DXMESHCONTAINER, *LPD3DXMESHCONTAINER;
typedef struct _D3DXFRAME {
    LPSTR Name;
    D3DXMATRIX TransformationMatrix;
    LPD3DXMESHCONTAINER pMeshContainer;
    struct _D3DXFRAME* pFrameSibling;
    struct _D3DXFRAME* pFrameFirstChild;
} D3DXFRAME, *LPD3DXFRAME;
typedef struct ID3DXAllocateHierarchy ID3DXAllocateHierarchy;
typedef struct ID3DXAllocateHierarchy* LPD3DXALLOCATEHIERARCHY;
struct __declspec(novtable) ID3DXAllocateHierarchy {
    virtual __declspec(nothrow) HRESULT __stdcall CreateFrame(LPCSTR Name,
        LPD3DXFRAME* ppNewFrame)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateMeshContainer(
        LPCSTR Name,
        const D3DXMESHDATA* pMeshData,
        const D3DXMATERIAL* pMaterials,
        const D3DXEFFECTINSTANCE* pEffectInstances,
        DWORD NumMaterials,
        const DWORD* pAdjacency,
        LPD3DXSKININFO pSkinInfo,
        LPD3DXMESHCONTAINER* ppNewMeshContainer)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DestroyFrame(LPD3DXFRAME pFrameToFree) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DestroyMeshContainer(LPD3DXMESHCONTAINER pMeshContainerToFree) = 0;
};
typedef struct ID3DXLoadUserData ID3DXLoadUserData;
typedef struct ID3DXLoadUserData* LPD3DXLOADUSERDATA;
struct __declspec(novtable) ID3DXLoadUserData {
    virtual __declspec(nothrow) HRESULT __stdcall LoadTopLevelData(LPD3DXFILEDATA pXofChildData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LoadFrameChildData(LPD3DXFRAME pFrame,
        LPD3DXFILEDATA pXofChildData)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall LoadMeshChildData(LPD3DXMESHCONTAINER pMeshContainer,
        LPD3DXFILEDATA pXofChildData)
        = 0;
};
typedef struct ID3DXSaveUserData ID3DXSaveUserData;
typedef struct ID3DXSaveUserData* LPD3DXSAVEUSERDATA;
struct __declspec(novtable) ID3DXSaveUserData {
    virtual __declspec(nothrow) HRESULT __stdcall AddFrameChildData(const D3DXFRAME* pFrame,
        LPD3DXFILESAVEOBJECT pXofSave,
        LPD3DXFILESAVEDATA pXofFrameData)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddMeshChildData(const D3DXMESHCONTAINER* pMeshContainer,
        LPD3DXFILESAVEOBJECT pXofSave,
        LPD3DXFILESAVEDATA pXofMeshData)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddTopLevelDataObjectsPre(LPD3DXFILESAVEOBJECT pXofSave) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddTopLevelDataObjectsPost(LPD3DXFILESAVEOBJECT pXofSave) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterTemplates(LPD3DXFILE pXFileApi) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SaveTemplates(LPD3DXFILESAVEOBJECT pXofSave) = 0;
};
typedef enum _D3DXCALLBACK_SEARCH_FLAGS {
    D3DXCALLBACK_SEARCH_EXCLUDING_INITIAL_POSITION = 0x01,
    D3DXCALLBACK_SEARCH_BEHIND_INITIAL_POSITION = 0x02,
    D3DXCALLBACK_SEARCH_FORCE_DWORD = 0x7fffffff,
} D3DXCALLBACK_SEARCH_FLAGS;
typedef struct ID3DXAnimationSet ID3DXAnimationSet;
typedef struct ID3DXAnimationSet* LPD3DXANIMATIONSET;
struct __declspec(novtable) ID3DXAnimationSet : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetName(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetPeriod(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetPeriodicPosition(DOUBLE Position) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumAnimations(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationNameByIndex(UINT Index, LPCSTR* ppName) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationIndexByName(LPCSTR pName, UINT* pIndex) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSRT(
        DOUBLE PeriodicPosition,
        UINT Animation,
        D3DXVECTOR3* pScale,
        D3DXQUATERNION* pRotation,
        D3DXVECTOR3* pTranslation)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCallback(
        DOUBLE Position,
        DWORD Flags,
        DOUBLE* pCallbackPosition,
        LPVOID* ppCallbackData)
        = 0;
};
typedef enum _D3DXPLAYBACK_TYPE {
    D3DXPLAY_LOOP = 0,
    D3DXPLAY_ONCE = 1,
    D3DXPLAY_PINGPONG = 2,
    D3DXPLAY_FORCE_DWORD = 0x7fffffff,
} D3DXPLAYBACK_TYPE;
typedef struct _D3DXKEY_VECTOR3 {
    FLOAT Time;
    D3DXVECTOR3 Value;
} D3DXKEY_VECTOR3, *LPD3DXKEY_VECTOR3;
typedef struct _D3DXKEY_QUATERNION {
    FLOAT Time;
    D3DXQUATERNION Value;
} D3DXKEY_QUATERNION, *LPD3DXKEY_QUATERNION;
typedef struct _D3DXKEY_CALLBACK {
    FLOAT Time;
    LPVOID pCallbackData;
} D3DXKEY_CALLBACK, *LPD3DXKEY_CALLBACK;
typedef enum _D3DXCOMPRESSION_FLAGS {
    D3DXCOMPRESS_DEFAULT = 0x00,
    D3DXCOMPRESS_FORCE_DWORD = 0x7fffffff,
} D3DXCOMPRESSION_FLAGS;
typedef struct ID3DXKeyframedAnimationSet ID3DXKeyframedAnimationSet;
typedef struct ID3DXKeyframedAnimationSet* LPD3DXKEYFRAMEDANIMATIONSET;
struct __declspec(novtable) ID3DXKeyframedAnimationSet : public ID3DXAnimationSet {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetName(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetPeriod(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetPeriodicPosition(DOUBLE Position) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumAnimations(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationNameByIndex(UINT Index, LPCSTR* ppName) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationIndexByName(LPCSTR pName, UINT* pIndex) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSRT(
        DOUBLE PeriodicPosition,
        UINT Animation,
        D3DXVECTOR3* pScale,
        D3DXQUATERNION* pRotation,
        D3DXVECTOR3* pTranslation)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCallback(
        DOUBLE Position,
        DWORD Flags,
        DOUBLE* pCallbackPosition,
        LPVOID* ppCallbackData)
        = 0;
    virtual __declspec(nothrow) D3DXPLAYBACK_TYPE __stdcall GetPlaybackType(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetSourceTicksPerSecond(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumScaleKeys(UINT Animation) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetScaleKeys(UINT Animation, LPD3DXKEY_VECTOR3 pScaleKeys) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetScaleKey(UINT Animation, UINT Key, LPD3DXKEY_VECTOR3 pScaleKey) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetScaleKey(UINT Animation, UINT Key, LPD3DXKEY_VECTOR3 pScaleKey) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumRotationKeys(UINT Animation) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRotationKeys(UINT Animation, LPD3DXKEY_QUATERNION pRotationKeys) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRotationKey(UINT Animation, UINT Key, LPD3DXKEY_QUATERNION pRotationKey) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRotationKey(UINT Animation, UINT Key, LPD3DXKEY_QUATERNION pRotationKey) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumTranslationKeys(UINT Animation) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTranslationKeys(UINT Animation, LPD3DXKEY_VECTOR3 pTranslationKeys) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTranslationKey(UINT Animation, UINT Key, LPD3DXKEY_VECTOR3 pTranslationKey) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTranslationKey(UINT Animation, UINT Key, LPD3DXKEY_VECTOR3 pTranslationKey) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumCallbackKeys(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCallbackKeys(LPD3DXKEY_CALLBACK pCallbackKeys) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCallbackKey(UINT Key, LPD3DXKEY_CALLBACK pCallbackKey) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetCallbackKey(UINT Key, LPD3DXKEY_CALLBACK pCallbackKey) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnregisterScaleKey(UINT Animation, UINT Key) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnregisterRotationKey(UINT Animation, UINT Key) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnregisterTranslationKey(UINT Animation, UINT Key) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterAnimationSRTKeys(
        LPCSTR pName,
        UINT NumScaleKeys,
        UINT NumRotationKeys,
        UINT NumTranslationKeys,
        const D3DXKEY_VECTOR3* pScaleKeys,
        const D3DXKEY_QUATERNION* pRotationKeys,
        const D3DXKEY_VECTOR3* pTranslationKeys,
        DWORD* pAnimationIndex)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Compress(
        DWORD Flags,
        FLOAT Lossiness,
        LPD3DXFRAME pHierarchy,
        LPD3DXBUFFER* ppCompressedData)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnregisterAnimation(UINT Index) = 0;
};
typedef struct ID3DXCompressedAnimationSet ID3DXCompressedAnimationSet;
typedef struct ID3DXCompressedAnimationSet* LPD3DXCOMPRESSEDANIMATIONSET;
struct __declspec(novtable) ID3DXCompressedAnimationSet : public ID3DXAnimationSet {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetName(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetPeriod(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetPeriodicPosition(DOUBLE Position) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumAnimations(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationNameByIndex(UINT Index, LPCSTR* ppName) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationIndexByName(LPCSTR pName, UINT* pIndex) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSRT(
        DOUBLE PeriodicPosition,
        UINT Animation,
        D3DXVECTOR3* pScale,
        D3DXQUATERNION* pRotation,
        D3DXVECTOR3* pTranslation)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCallback(
        DOUBLE Position,
        DWORD Flags,
        DOUBLE* pCallbackPosition,
        LPVOID* ppCallbackData)
        = 0;
    virtual __declspec(nothrow) D3DXPLAYBACK_TYPE __stdcall GetPlaybackType(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetSourceTicksPerSecond(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCompressedData(LPD3DXBUFFER* ppCompressedData) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumCallbackKeys(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetCallbackKeys(LPD3DXKEY_CALLBACK pCallbackKeys) = 0;
};
typedef enum _D3DXPRIORITY_TYPE {
    D3DXPRIORITY_LOW = 0,
    D3DXPRIORITY_HIGH = 1,
    D3DXPRIORITY_FORCE_DWORD = 0x7fffffff,
} D3DXPRIORITY_TYPE;
typedef struct _D3DXTRACK_DESC {
    D3DXPRIORITY_TYPE Priority;
    FLOAT Weight;
    FLOAT Speed;
    DOUBLE Position;
    BOOL Enable;
} D3DXTRACK_DESC, *LPD3DXTRACK_DESC;
typedef enum _D3DXEVENT_TYPE {
    D3DXEVENT_TRACKSPEED = 0,
    D3DXEVENT_TRACKWEIGHT = 1,
    D3DXEVENT_TRACKPOSITION = 2,
    D3DXEVENT_TRACKENABLE = 3,
    D3DXEVENT_PRIORITYBLEND = 4,
    D3DXEVENT_FORCE_DWORD = 0x7fffffff,
} D3DXEVENT_TYPE;
typedef enum _D3DXTRANSITION_TYPE {
    D3DXTRANSITION_LINEAR = 0x000,
    D3DXTRANSITION_EASEINEASEOUT = 0x001,
    D3DXTRANSITION_FORCE_DWORD = 0x7fffffff,
} D3DXTRANSITION_TYPE;
typedef struct _D3DXEVENT_DESC {
    D3DXEVENT_TYPE Type;
    UINT Track;
    DOUBLE StartTime;
    DOUBLE Duration;
    D3DXTRANSITION_TYPE Transition;
    union {
        FLOAT Weight;
        FLOAT Speed;
        DOUBLE Position;
        BOOL Enable;
    };
} D3DXEVENT_DESC, *LPD3DXEVENT_DESC;
typedef DWORD D3DXEVENTHANDLE;
typedef D3DXEVENTHANDLE* LPD3DXEVENTHANDLE;
typedef struct ID3DXAnimationCallbackHandler ID3DXAnimationCallbackHandler;
typedef struct ID3DXAnimationCallbackHandler* LPD3DXANIMATIONCALLBACKHANDLER;
struct __declspec(novtable) ID3DXAnimationCallbackHandler {
    virtual __declspec(nothrow) HRESULT __stdcall HandleCallback(UINT Track, LPVOID pCallbackData) = 0;
};
typedef struct ID3DXAnimationController ID3DXAnimationController;
typedef struct ID3DXAnimationController* LPD3DXANIMATIONCONTROLLER;
struct __declspec(novtable) ID3DXAnimationController : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetMaxNumAnimationOutputs(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetMaxNumAnimationSets(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetMaxNumTracks(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetMaxNumEvents(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterAnimationOutput(
        LPCSTR pName,
        D3DXMATRIX* pMatrix,
        D3DXVECTOR3* pScale,
        D3DXQUATERNION* pRotation,
        D3DXVECTOR3* pTranslation)
        = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RegisterAnimationSet(LPD3DXANIMATIONSET pAnimSet) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnregisterAnimationSet(LPD3DXANIMATIONSET pAnimSet) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumAnimationSets(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationSet(UINT Index, LPD3DXANIMATIONSET* ppAnimationSet) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAnimationSetByName(LPCSTR szName, LPD3DXANIMATIONSET* ppAnimationSet) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AdvanceTime(DOUBLE TimeDelta, LPD3DXANIMATIONCALLBACKHANDLER pCallbackHandler) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ResetTime(void) = 0;
    virtual __declspec(nothrow) DOUBLE __stdcall GetTime(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackAnimationSet(UINT Track, LPD3DXANIMATIONSET pAnimSet) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTrackAnimationSet(UINT Track, LPD3DXANIMATIONSET* ppAnimSet) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackPriority(UINT Track, D3DXPRIORITY_TYPE Priority) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackSpeed(UINT Track, FLOAT Speed) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackWeight(UINT Track, FLOAT Weight) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackPosition(UINT Track, DOUBLE Position) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackEnable(UINT Track, BOOL Enable) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTrackDesc(UINT Track, LPD3DXTRACK_DESC pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTrackDesc(UINT Track, LPD3DXTRACK_DESC pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPriorityBlend(FLOAT BlendWeight) = 0;
    virtual __declspec(nothrow) FLOAT __stdcall GetPriorityBlend(void) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall KeyTrackSpeed(UINT Track, FLOAT NewSpeed, DOUBLE StartTime, DOUBLE Duration, D3DXTRANSITION_TYPE Transition) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall KeyTrackWeight(UINT Track, FLOAT NewWeight, DOUBLE StartTime, DOUBLE Duration, D3DXTRANSITION_TYPE Transition) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall KeyTrackPosition(UINT Track, DOUBLE NewPosition, DOUBLE StartTime) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall KeyTrackEnable(UINT Track, BOOL NewEnable, DOUBLE StartTime) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall KeyPriorityBlend(FLOAT NewBlendWeight, DOUBLE StartTime, DOUBLE Duration, D3DXTRANSITION_TYPE Transition) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnkeyEvent(D3DXEVENTHANDLE hEvent) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnkeyAllTrackEvents(UINT Track) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall UnkeyAllPriorityBlends(void) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall GetCurrentTrackEvent(UINT Track, D3DXEVENT_TYPE EventType) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall GetCurrentPriorityBlend(void) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall GetUpcomingTrackEvent(UINT Track, D3DXEVENTHANDLE hEvent) = 0;
    virtual __declspec(nothrow) D3DXEVENTHANDLE __stdcall GetUpcomingPriorityBlend(D3DXEVENTHANDLE hEvent) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ValidateEvent(D3DXEVENTHANDLE hEvent) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetEventDesc(D3DXEVENTHANDLE hEvent, LPD3DXEVENT_DESC pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneAnimationController(
        UINT MaxNumAnimationOutputs,
        UINT MaxNumAnimationSets,
        UINT MaxNumTracks,
        UINT MaxNumEvents,
        LPD3DXANIMATIONCONTROLLER* ppAnimController)
        = 0;
};
extern "C" {
HRESULT __stdcall D3DXLoadMeshHierarchyFromXA(
    LPCSTR Filename,
    DWORD MeshOptions,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXALLOCATEHIERARCHY pAlloc,
    LPD3DXLOADUSERDATA pUserDataLoader,
    LPD3DXFRAME* ppFrameHierarchy,
    LPD3DXANIMATIONCONTROLLER* ppAnimController);
HRESULT __stdcall D3DXLoadMeshHierarchyFromXW(
    LPCWSTR Filename,
    DWORD MeshOptions,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXALLOCATEHIERARCHY pAlloc,
    LPD3DXLOADUSERDATA pUserDataLoader,
    LPD3DXFRAME* ppFrameHierarchy,
    LPD3DXANIMATIONCONTROLLER* ppAnimController);
HRESULT __stdcall D3DXLoadMeshHierarchyFromXInMemory(
    LPCVOID Memory,
    DWORD SizeOfMemory,
    DWORD MeshOptions,
    LPDIRECT3DDEVICE9 pD3DDevice,
    LPD3DXALLOCATEHIERARCHY pAlloc,
    LPD3DXLOADUSERDATA pUserDataLoader,
    LPD3DXFRAME* ppFrameHierarchy,
    LPD3DXANIMATIONCONTROLLER* ppAnimController);
HRESULT __stdcall D3DXSaveMeshHierarchyToFileA(
    LPCSTR Filename,
    DWORD XFormat,
    const D3DXFRAME* pFrameRoot,
    LPD3DXANIMATIONCONTROLLER pAnimcontroller,
    LPD3DXSAVEUSERDATA pUserDataSaver);
HRESULT __stdcall D3DXSaveMeshHierarchyToFileW(
    LPCWSTR Filename,
    DWORD XFormat,
    const D3DXFRAME* pFrameRoot,
    LPD3DXANIMATIONCONTROLLER pAnimController,
    LPD3DXSAVEUSERDATA pUserDataSaver);
HRESULT __stdcall D3DXFrameDestroy(
    LPD3DXFRAME pFrameRoot,
    LPD3DXALLOCATEHIERARCHY pAlloc);
HRESULT __stdcall D3DXFrameAppendChild(
    LPD3DXFRAME pFrameParent,
    const D3DXFRAME* pFrameChild);
LPD3DXFRAME __stdcall D3DXFrameFind(
    const D3DXFRAME* pFrameRoot,
    LPCSTR Name);
HRESULT __stdcall D3DXFrameRegisterNamedMatrices(
    LPD3DXFRAME pFrameRoot,
    LPD3DXANIMATIONCONTROLLER pAnimController);
UINT __stdcall D3DXFrameNumNamedMatrices(
    const D3DXFRAME* pFrameRoot);
HRESULT __stdcall D3DXFrameCalculateBoundingSphere(
    const D3DXFRAME* pFrameRoot,
    LPD3DXVECTOR3 pObjectCenter,
    FLOAT* pObjectRadius);
HRESULT __stdcall D3DXCreateKeyframedAnimationSet(
    LPCSTR pName,
    DOUBLE TicksPerSecond,
    D3DXPLAYBACK_TYPE Playback,
    UINT NumAnimations,
    UINT NumCallbackKeys,
    const D3DXKEY_CALLBACK* pCallbackKeys,
    LPD3DXKEYFRAMEDANIMATIONSET* ppAnimationSet);
HRESULT __stdcall D3DXCreateCompressedAnimationSet(
    LPCSTR pName,
    DOUBLE TicksPerSecond,
    D3DXPLAYBACK_TYPE Playback,
    LPD3DXBUFFER pCompressedData,
    UINT NumCallbackKeys,
    const D3DXKEY_CALLBACK* pCallbackKeys,
    LPD3DXCOMPRESSEDANIMATIONSET* ppAnimationSet);
HRESULT __stdcall D3DXCreateAnimationController(
    UINT MaxNumMatrices,
    UINT MaxNumAnimationSets,
    UINT MaxNumTracks,
    UINT MaxNumEvents,
    LPD3DXANIMATIONCONTROLLER* ppAnimController);
}
#pragma external_header(pop)
enum _D3DXERR {
    D3DXERR_CANNOTMODIFYINDEXBUFFER = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2900)))),
    D3DXERR_INVALIDMESH = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2901)))),
    D3DXERR_CANNOTATTRSORT = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2902)))),
    D3DXERR_SKINNINGNOTSUPPORTED = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2903)))),
    D3DXERR_TOOMANYINFLUENCES = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2904)))),
    D3DXERR_INVALIDDATA = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2905)))),
    D3DXERR_LOADEDMESHASNODATA = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2906)))),
    D3DXERR_DUPLICATENAMEDFRAGMENT = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2907)))),
    D3DXERR_CANNOTREMOVELASTITEM = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2908)))),
};
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
#pragma once
typedef struct ID3D11DeviceChild ID3D11DeviceChild;
typedef struct ID3D11DepthStencilState ID3D11DepthStencilState;
typedef struct ID3D11BlendState ID3D11BlendState;
typedef struct ID3D11RasterizerState ID3D11RasterizerState;
typedef struct ID3D11Resource ID3D11Resource;
typedef struct ID3D11Buffer ID3D11Buffer;
typedef struct ID3D11Texture1D ID3D11Texture1D;
typedef struct ID3D11Texture2D ID3D11Texture2D;
typedef struct ID3D11Texture3D ID3D11Texture3D;
typedef struct ID3D11View ID3D11View;
typedef struct ID3D11ShaderResourceView ID3D11ShaderResourceView;
typedef struct ID3D11RenderTargetView ID3D11RenderTargetView;
typedef struct ID3D11DepthStencilView ID3D11DepthStencilView;
typedef struct ID3D11UnorderedAccessView ID3D11UnorderedAccessView;
typedef struct ID3D11VertexShader ID3D11VertexShader;
typedef struct ID3D11HullShader ID3D11HullShader;
typedef struct ID3D11DomainShader ID3D11DomainShader;
typedef struct ID3D11GeometryShader ID3D11GeometryShader;
typedef struct ID3D11PixelShader ID3D11PixelShader;
typedef struct ID3D11ComputeShader ID3D11ComputeShader;
typedef struct ID3D11InputLayout ID3D11InputLayout;
typedef struct ID3D11SamplerState ID3D11SamplerState;
typedef struct ID3D11Asynchronous ID3D11Asynchronous;
typedef struct ID3D11Query ID3D11Query;
typedef struct ID3D11Predicate ID3D11Predicate;
typedef struct ID3D11Counter ID3D11Counter;
typedef struct ID3D11ClassInstance ID3D11ClassInstance;
typedef struct ID3D11ClassLinkage ID3D11ClassLinkage;
typedef struct ID3D11CommandList ID3D11CommandList;
typedef struct ID3D11DeviceContext ID3D11DeviceContext;
typedef struct ID3D11VideoDecoder ID3D11VideoDecoder;
typedef struct ID3D11VideoProcessorEnumerator ID3D11VideoProcessorEnumerator;
typedef struct ID3D11VideoProcessor ID3D11VideoProcessor;
typedef struct ID3D11AuthenticatedChannel ID3D11AuthenticatedChannel;
typedef struct ID3D11CryptoSession ID3D11CryptoSession;
typedef struct ID3D11VideoDecoderOutputView ID3D11VideoDecoderOutputView;
typedef struct ID3D11VideoProcessorInputView ID3D11VideoProcessorInputView;
typedef struct ID3D11VideoProcessorOutputView ID3D11VideoProcessorOutputView;
typedef struct ID3D11VideoContext ID3D11VideoContext;
typedef struct ID3D11VideoDevice ID3D11VideoDevice;
typedef struct ID3D11Device ID3D11Device;
#pragma once
typedef struct IEnumConnections IEnumConnections;
typedef struct IConnectionPoint IConnectionPoint;
typedef struct IEnumConnectionPoints IEnumConnectionPoints;
typedef struct IConnectionPointContainer IConnectionPointContainer;
typedef struct IClassFactory2 IClassFactory2;
typedef struct IProvideClassInfo IProvideClassInfo;
typedef struct IProvideClassInfo2 IProvideClassInfo2;
typedef struct IProvideMultipleClassInfo IProvideMultipleClassInfo;
typedef struct IOleControl IOleControl;
typedef struct IOleControlSite IOleControlSite;
typedef struct IPropertyPage IPropertyPage;
typedef struct IPropertyPage2 IPropertyPage2;
typedef struct IPropertyPageSite IPropertyPageSite;
typedef struct IPropertyNotifySink IPropertyNotifySink;
typedef struct ISpecifyPropertyPages ISpecifyPropertyPages;
typedef struct IPersistMemory IPersistMemory;
typedef struct IPersistStreamInit IPersistStreamInit;
typedef struct IPersistPropertyBag IPersistPropertyBag;
typedef struct ISimpleFrameSite ISimpleFrameSite;
typedef struct IFont IFont;
typedef struct IPicture IPicture;
typedef struct IPicture2 IPicture2;
typedef struct IFontEventsDisp IFontEventsDisp;
typedef struct IFontDisp IFontDisp;
typedef struct IPictureDisp IPictureDisp;
typedef struct IOleInPlaceObjectWindowless IOleInPlaceObjectWindowless;
typedef struct IOleInPlaceSiteEx IOleInPlaceSiteEx;
typedef struct IOleInPlaceSiteWindowless IOleInPlaceSiteWindowless;
typedef struct IViewObjectEx IViewObjectEx;
typedef struct IOleUndoUnit IOleUndoUnit;
typedef struct IOleParentUndoUnit IOleParentUndoUnit;
typedef struct IEnumOleUndoUnits IEnumOleUndoUnits;
typedef struct IOleUndoManager IOleUndoManager;
typedef struct IPointerInactive IPointerInactive;
typedef struct IObjectWithSite IObjectWithSite;
typedef struct IPerPropertyBrowsing IPerPropertyBrowsing;
typedef struct IPropertyBag2 IPropertyBag2;
typedef struct IPersistPropertyBag2 IPersistPropertyBag2;
typedef struct IAdviseSinkEx IAdviseSinkEx;
typedef struct IQuickActivate IQuickActivate;
extern "C" {
#pragma once
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4917)
#pragma region Application Family or OneCore Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0000_v0_0_s_ifspec;
typedef enum tagUASFLAGS {
    UAS_NORMAL = 0,
    UAS_BLOCKED = 0x1,
    UAS_NOPARENTENABLE = 0x2,
    UAS_MASK = 0x3
} UASFLAGS;
typedef enum tagREADYSTATE {
    READYSTATE_UNINITIALIZED = 0,
    READYSTATE_LOADING = 1,
    READYSTATE_LOADED = 2,
    READYSTATE_INTERACTIVE = 3,
    READYSTATE_COMPLETE = 4
} READYSTATE;
extern RPC_IF_HANDLE IOleControlTypes_v1_0_c_ifspec;
extern RPC_IF_HANDLE IOleControlTypes_v1_0_s_ifspec;
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0001_v0_0_s_ifspec;
typedef IEnumConnections* PENUMCONNECTIONS;
typedef IEnumConnections* LPENUMCONNECTIONS;
typedef struct tagCONNECTDATA {
    IUnknown* pUnk;
    DWORD dwCookie;
} CONNECTDATA;
typedef struct tagCONNECTDATA* PCONNECTDATA;
typedef struct tagCONNECTDATA* LPCONNECTDATA;
extern "C" const IID IID_IEnumConnections;
struct __declspec(uuid("B196B287-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IEnumConnections : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG cConnections,
        LPCONNECTDATA rgcd,
        ULONG* pcFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG cConnections)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumConnections** ppEnum)
        = 0;
};
HRESULT __stdcall IEnumConnections_RemoteNext_Proxy(
    IEnumConnections* This,
    ULONG cConnections,
    LPCONNECTDATA rgcd,
    ULONG* pcFetched);
void __stdcall IEnumConnections_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IConnectionPoint* PCONNECTIONPOINT;
typedef IConnectionPoint* LPCONNECTIONPOINT;
extern "C" const IID IID_IConnectionPoint;
struct __declspec(uuid("B196B286-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IConnectionPoint : public IUnknown {
public:
    virtual HRESULT __stdcall GetConnectionInterface(
        IID* pIID)
        = 0;
    virtual HRESULT __stdcall GetConnectionPointContainer(
        IConnectionPointContainer** ppCPC)
        = 0;
    virtual HRESULT __stdcall Advise(
        IUnknown* pUnkSink,
        DWORD* pdwCookie)
        = 0;
    virtual HRESULT __stdcall Unadvise(
        DWORD dwCookie)
        = 0;
    virtual HRESULT __stdcall EnumConnections(
        IEnumConnections** ppEnum)
        = 0;
};
typedef IEnumConnectionPoints* PENUMCONNECTIONPOINTS;
typedef IEnumConnectionPoints* LPENUMCONNECTIONPOINTS;
extern "C" const IID IID_IEnumConnectionPoints;
struct __declspec(uuid("B196B285-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IEnumConnectionPoints : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG cConnections,
        LPCONNECTIONPOINT* ppCP,
        ULONG* pcFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG cConnections)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumConnectionPoints** ppEnum)
        = 0;
};
HRESULT __stdcall IEnumConnectionPoints_RemoteNext_Proxy(
    IEnumConnectionPoints* This,
    ULONG cConnections,
    LPCONNECTIONPOINT* ppCP,
    ULONG* pcFetched);
void __stdcall IEnumConnectionPoints_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IConnectionPointContainer* PCONNECTIONPOINTCONTAINER;
typedef IConnectionPointContainer* LPCONNECTIONPOINTCONTAINER;
extern "C" const IID IID_IConnectionPointContainer;
struct __declspec(uuid("B196B284-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IConnectionPointContainer : public IUnknown {
public:
    virtual HRESULT __stdcall EnumConnectionPoints(
        IEnumConnectionPoints** ppEnum)
        = 0;
    virtual HRESULT __stdcall FindConnectionPoint(
        const IID& riid,
        IConnectionPoint** ppCP)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0005_v0_0_s_ifspec;
typedef IClassFactory2* LPCLASSFACTORY2;
typedef struct tagLICINFO {
    LONG cbLicInfo;
    BOOL fRuntimeKeyAvail;
    BOOL fLicVerified;
} LICINFO;
typedef struct tagLICINFO* LPLICINFO;
extern "C" const IID IID_IClassFactory2;
struct __declspec(uuid("B196B28F-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IClassFactory2 : public IClassFactory {
public:
    virtual HRESULT __stdcall GetLicInfo(
        LICINFO* pLicInfo)
        = 0;
    virtual HRESULT __stdcall RequestLicKey(
        DWORD dwReserved,
        BSTR* pBstrKey)
        = 0;
    virtual HRESULT __stdcall CreateInstanceLic(
        IUnknown* pUnkOuter,
        IUnknown* pUnkReserved,
        const IID& riid,
        BSTR bstrKey,
        PVOID* ppvObj)
        = 0;
};
HRESULT __stdcall IClassFactory2_RemoteCreateInstanceLic_Proxy(
    IClassFactory2* This,
    const IID& riid,
    BSTR bstrKey,
    IUnknown** ppvObj);
void __stdcall IClassFactory2_RemoteCreateInstanceLic_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IProvideClassInfo* LPPROVIDECLASSINFO;
extern "C" const IID IID_IProvideClassInfo;
struct __declspec(uuid("B196B283-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IProvideClassInfo : public IUnknown {
public:
    virtual HRESULT __stdcall GetClassInfoW(
        ITypeInfo** ppTI)
        = 0;
};
typedef IProvideClassInfo2* LPPROVIDECLASSINFO2;
typedef enum tagGUIDKIND {
    GUIDKIND_DEFAULT_SOURCE_DISP_IID = 1
} GUIDKIND;
extern "C" const IID IID_IProvideClassInfo2;
struct __declspec(uuid("A6BC3AC0-DBAA-11CE-9DE3-00AA004BB851")) __declspec(novtable)
    IProvideClassInfo2 : public IProvideClassInfo {
public:
    virtual HRESULT __stdcall GetGUID(
        DWORD dwGuidKind,
        GUID* pGUID)
        = 0;
};
typedef IProvideMultipleClassInfo* LPPROVIDEMULTIPLECLASSINFO;
extern "C" const IID IID_IProvideMultipleClassInfo;
struct __declspec(uuid("A7ABA9C1-8983-11cf-8F20-00805F2CD064")) __declspec(novtable)
    IProvideMultipleClassInfo : public IProvideClassInfo2 {
public:
    virtual HRESULT __stdcall GetMultiTypeInfoCount(
        ULONG* pcti)
        = 0;
    virtual HRESULT __stdcall GetInfoOfIndex(
        ULONG iti,
        DWORD dwFlags,
        ITypeInfo** pptiCoClass,
        DWORD* pdwTIFlags,
        ULONG* pcdispidReserved,
        IID* piidPrimary,
        IID* piidSource)
        = 0;
};
typedef IOleControl* LPOLECONTROL;
typedef struct tagCONTROLINFO {
    ULONG cb;
    HACCEL hAccel;
    USHORT cAccel;
    DWORD dwFlags;
} CONTROLINFO;
typedef struct tagCONTROLINFO* LPCONTROLINFO;
typedef enum tagCTRLINFO {
    CTRLINFO_EATS_RETURN = 1,
    CTRLINFO_EATS_ESCAPE = 2
} CTRLINFO;
extern "C" const IID IID_IOleControl;
struct __declspec(uuid("B196B288-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IOleControl : public IUnknown {
public:
    virtual HRESULT __stdcall GetControlInfo(
        CONTROLINFO* pCI)
        = 0;
    virtual HRESULT __stdcall OnMnemonic(
        MSG* pMsg)
        = 0;
    virtual HRESULT __stdcall OnAmbientPropertyChange(
        DISPID dispID)
        = 0;
    virtual HRESULT __stdcall FreezeEvents(
        BOOL bFreeze)
        = 0;
};
typedef IOleControlSite* LPOLECONTROLSITE;
typedef struct tagPOINTF {
    FLOAT x;
    FLOAT y;
} POINTF;
typedef struct tagPOINTF* LPPOINTF;
typedef enum tagXFORMCOORDS {
    XFORMCOORDS_POSITION = 0x1,
    XFORMCOORDS_SIZE = 0x2,
    XFORMCOORDS_HIMETRICTOCONTAINER = 0x4,
    XFORMCOORDS_CONTAINERTOHIMETRIC = 0x8,
    XFORMCOORDS_EVENTCOMPAT = 0x10
} XFORMCOORDS;
extern "C" const IID IID_IOleControlSite;
struct __declspec(uuid("B196B289-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IOleControlSite : public IUnknown {
public:
    virtual HRESULT __stdcall OnControlInfoChanged(void) = 0;
    virtual HRESULT __stdcall LockInPlaceActive(
        BOOL fLock)
        = 0;
    virtual HRESULT __stdcall GetExtendedControl(
        IDispatch** ppDisp)
        = 0;
    virtual HRESULT __stdcall TransformCoords(
        POINTL* pPtlHimetric,
        POINTF* pPtfContainer,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall TranslateAcceleratorW(
        MSG* pMsg,
        DWORD grfModifiers)
        = 0;
    virtual HRESULT __stdcall OnFocus(
        BOOL fGotFocus)
        = 0;
    virtual HRESULT __stdcall ShowPropertyFrame(void) = 0;
};
typedef IPropertyPage* LPPROPERTYPAGE;
typedef struct tagPROPPAGEINFO {
    ULONG cb;
    LPOLESTR pszTitle;
    SIZE size;
    LPOLESTR pszDocString;
    LPOLESTR pszHelpFile;
    DWORD dwHelpContext;
} PROPPAGEINFO;
typedef struct tagPROPPAGEINFO* LPPROPPAGEINFO;
extern "C" const IID IID_IPropertyPage;
struct __declspec(uuid("B196B28D-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IPropertyPage : public IUnknown {
public:
    virtual HRESULT __stdcall SetPageSite(
        IPropertyPageSite* pPageSite)
        = 0;
    virtual HRESULT __stdcall Activate(
        HWND hWndParent,
        LPCRECT pRect,
        BOOL bModal)
        = 0;
    virtual HRESULT __stdcall Deactivate(void) = 0;
    virtual HRESULT __stdcall GetPageInfo(
        PROPPAGEINFO* pPageInfo)
        = 0;
    virtual HRESULT __stdcall SetObjects(
        ULONG cObjects,
        IUnknown** ppUnk)
        = 0;
    virtual HRESULT __stdcall Show(
        UINT nCmdShow)
        = 0;
    virtual HRESULT __stdcall Move(
        LPCRECT pRect)
        = 0;
    virtual HRESULT __stdcall IsPageDirty(void) = 0;
    virtual HRESULT __stdcall Apply(void) = 0;
    virtual HRESULT __stdcall Help(
        LPCOLESTR pszHelpDir)
        = 0;
    virtual HRESULT __stdcall TranslateAcceleratorW(
        MSG* pMsg)
        = 0;
};
typedef IPropertyPage2* LPPROPERTYPAGE2;
extern "C" const IID IID_IPropertyPage2;
struct __declspec(uuid("01E44665-24AC-101B-84ED-08002B2EC713")) __declspec(novtable)
    IPropertyPage2 : public IPropertyPage {
public:
    virtual HRESULT __stdcall EditProperty(
        DISPID dispID)
        = 0;
};
typedef IPropertyPageSite* LPPROPERTYPAGESITE;
typedef enum tagPROPPAGESTATUS {
    PROPPAGESTATUS_DIRTY = 0x1,
    PROPPAGESTATUS_VALIDATE = 0x2,
    PROPPAGESTATUS_CLEAN = 0x4
} PROPPAGESTATUS;
extern "C" const IID IID_IPropertyPageSite;
struct __declspec(uuid("B196B28C-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    IPropertyPageSite : public IUnknown {
public:
    virtual HRESULT __stdcall OnStatusChange(
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall GetLocaleID(
        LCID* pLocaleID)
        = 0;
    virtual HRESULT __stdcall GetPageContainer(
        IUnknown** ppUnk)
        = 0;
    virtual HRESULT __stdcall TranslateAcceleratorW(
        MSG* pMsg)
        = 0;
};
typedef IPropertyNotifySink* LPPROPERTYNOTIFYSINK;
extern "C" const IID IID_IPropertyNotifySink;
struct __declspec(uuid("9BFBBC02-EFF1-101A-84ED-00AA00341D07")) __declspec(novtable)
    IPropertyNotifySink : public IUnknown {
public:
    virtual HRESULT __stdcall OnChanged(
        DISPID dispID)
        = 0;
    virtual HRESULT __stdcall OnRequestEdit(
        DISPID dispID)
        = 0;
};
typedef ISpecifyPropertyPages* LPSPECIFYPROPERTYPAGES;
typedef struct tagCAUUID {
    ULONG cElems;
    GUID* pElems;
} CAUUID;
typedef struct tagCAUUID* LPCAUUID;
extern "C" const IID IID_ISpecifyPropertyPages;
struct __declspec(uuid("B196B28B-BAB4-101A-B69C-00AA00341D07")) __declspec(novtable)
    ISpecifyPropertyPages : public IUnknown {
public:
    virtual HRESULT __stdcall GetPages(
        CAUUID* pPages)
        = 0;
};
typedef IPersistMemory* LPPERSISTMEMORY;
extern "C" const IID IID_IPersistMemory;
struct __declspec(uuid("BD1AE5E0-A6AE-11CE-BD37-504200C10000")) __declspec(novtable)
    IPersistMemory : public IPersist {
public:
    virtual HRESULT __stdcall IsDirty(void) = 0;
    virtual HRESULT __stdcall Load(
        LPVOID pMem,
        ULONG cbSize)
        = 0;
    virtual HRESULT __stdcall Save(
        LPVOID pMem,
        BOOL fClearDirty,
        ULONG cbSize)
        = 0;
    virtual HRESULT __stdcall GetSizeMax(
        ULONG* pCbSize)
        = 0;
    virtual HRESULT __stdcall InitNew(void) = 0;
};
HRESULT __stdcall IPersistMemory_RemoteLoad_Proxy(
    IPersistMemory* This,
    BYTE* pMem,
    ULONG cbSize);
void __stdcall IPersistMemory_RemoteLoad_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
HRESULT __stdcall IPersistMemory_RemoteSave_Proxy(
    IPersistMemory* This,
    BYTE* pMem,
    BOOL fClearDirty,
    ULONG cbSize);
void __stdcall IPersistMemory_RemoteSave_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IPersistStreamInit* LPPERSISTSTREAMINIT;
extern "C" const IID IID_IPersistStreamInit;
struct __declspec(uuid("7FD52380-4E07-101B-AE2D-08002B2EC713")) __declspec(novtable)
    IPersistStreamInit : public IPersist {
public:
    virtual HRESULT __stdcall IsDirty(void) = 0;
    virtual HRESULT __stdcall Load(
        LPSTREAM pStm)
        = 0;
    virtual HRESULT __stdcall Save(
        LPSTREAM pStm,
        BOOL fClearDirty)
        = 0;
    virtual HRESULT __stdcall GetSizeMax(
        ULARGE_INTEGER* pCbSize)
        = 0;
    virtual HRESULT __stdcall InitNew(void) = 0;
};
typedef IPersistPropertyBag* LPPERSISTPROPERTYBAG;
extern "C" const IID IID_IPersistPropertyBag;
struct __declspec(uuid("37D84F60-42CB-11CE-8135-00AA004BB851")) __declspec(novtable)
    IPersistPropertyBag : public IPersist {
public:
    virtual HRESULT __stdcall InitNew(void) = 0;
    virtual HRESULT __stdcall Load(
        IPropertyBag* pPropBag,
        IErrorLog* pErrorLog)
        = 0;
    virtual HRESULT __stdcall Save(
        IPropertyBag* pPropBag,
        BOOL fClearDirty,
        BOOL fSaveAllProperties)
        = 0;
};
typedef ISimpleFrameSite* LPSIMPLEFRAMESITE;
extern "C" const IID IID_ISimpleFrameSite;
struct __declspec(uuid("742B0E01-14E6-101B-914E-00AA00300CAB")) __declspec(novtable)
    ISimpleFrameSite : public IUnknown {
public:
    virtual HRESULT __stdcall PreMessageFilter(
        HWND hWnd,
        UINT msg,
        WPARAM wp,
        LPARAM lp,
        LRESULT* plResult,
        DWORD* pdwCookie)
        = 0;
    virtual HRESULT __stdcall PostMessageFilter(
        HWND hWnd,
        UINT msg,
        WPARAM wp,
        LPARAM lp,
        LRESULT* plResult,
        DWORD dwCookie)
        = 0;
};
typedef IFont* LPFONT;
typedef TEXTMETRICW TEXTMETRICOLE;
typedef TEXTMETRICOLE* LPTEXTMETRICOLE;
extern "C" const IID IID_IFont;
struct __declspec(uuid("BEF6E002-A874-101A-8BBA-00AA00300CAB")) __declspec(novtable)
    IFont : public IUnknown {
public:
    virtual HRESULT __stdcall get_Name(
        BSTR* pName)
        = 0;
    virtual HRESULT __stdcall put_Name(
        BSTR name)
        = 0;
    virtual HRESULT __stdcall get_Size(
        CY* pSize)
        = 0;
    virtual HRESULT __stdcall put_Size(
        CY size)
        = 0;
    virtual HRESULT __stdcall get_Bold(
        BOOL* pBold)
        = 0;
    virtual HRESULT __stdcall put_Bold(
        BOOL bold)
        = 0;
    virtual HRESULT __stdcall get_Italic(
        BOOL* pItalic)
        = 0;
    virtual HRESULT __stdcall put_Italic(
        BOOL italic)
        = 0;
    virtual HRESULT __stdcall get_Underline(
        BOOL* pUnderline)
        = 0;
    virtual HRESULT __stdcall put_Underline(
        BOOL underline)
        = 0;
    virtual HRESULT __stdcall get_Strikethrough(
        BOOL* pStrikethrough)
        = 0;
    virtual HRESULT __stdcall put_Strikethrough(
        BOOL strikethrough)
        = 0;
    virtual HRESULT __stdcall get_Weight(
        SHORT* pWeight)
        = 0;
    virtual HRESULT __stdcall put_Weight(
        SHORT weight)
        = 0;
    virtual HRESULT __stdcall get_Charset(
        SHORT* pCharset)
        = 0;
    virtual HRESULT __stdcall put_Charset(
        SHORT charset)
        = 0;
    virtual HRESULT __stdcall get_hFont(
        HFONT* phFont)
        = 0;
    virtual HRESULT __stdcall Clone(
        IFont** ppFont)
        = 0;
    virtual HRESULT __stdcall IsEqual(
        IFont* pFontOther)
        = 0;
    virtual HRESULT __stdcall SetRatio(
        LONG cyLogical,
        LONG cyHimetric)
        = 0;
    virtual HRESULT __stdcall QueryTextMetrics(
        TEXTMETRICOLE* pTM)
        = 0;
    virtual HRESULT __stdcall AddRefHfont(
        HFONT hFont)
        = 0;
    virtual HRESULT __stdcall ReleaseHfont(
        HFONT hFont)
        = 0;
    virtual HRESULT __stdcall SetHdc(
        HDC hDC)
        = 0;
};
typedef IPicture* LPPICTURE;
typedef enum tagPictureAttributes {
    PICTURE_SCALABLE = 0x1,
    PICTURE_TRANSPARENT = 0x2
} PICTUREATTRIBUTES;
typedef __declspec(uuid("66504313-BE0F-101A-8BBB-00AA00300CAB")) UINT OLE_HANDLE;
typedef __declspec(uuid("66504306-BE0F-101A-8BBB-00AA00300CAB")) LONG OLE_XPOS_HIMETRIC;
typedef __declspec(uuid("66504307-BE0F-101A-8BBB-00AA00300CAB")) LONG OLE_YPOS_HIMETRIC;
typedef __declspec(uuid("66504308-BE0F-101A-8BBB-00AA00300CAB")) LONG OLE_XSIZE_HIMETRIC;
typedef __declspec(uuid("66504309-BE0F-101A-8BBB-00AA00300CAB")) LONG OLE_YSIZE_HIMETRIC;
extern "C" const IID IID_IPicture;
struct __declspec(uuid("7BF80980-BF32-101A-8BBB-00AA00300CAB")) __declspec(novtable)
    IPicture : public IUnknown {
public:
    virtual HRESULT __stdcall get_Handle(
        OLE_HANDLE* pHandle)
        = 0;
    virtual HRESULT __stdcall get_hPal(
        OLE_HANDLE* phPal)
        = 0;
    virtual HRESULT __stdcall get_Type(
        SHORT* pType)
        = 0;
    virtual HRESULT __stdcall get_Width(
        OLE_XSIZE_HIMETRIC* pWidth)
        = 0;
    virtual HRESULT __stdcall get_Height(
        OLE_YSIZE_HIMETRIC* pHeight)
        = 0;
    virtual HRESULT __stdcall Render(
        HDC hDC,
        LONG x,
        LONG y,
        LONG cx,
        LONG cy,
        OLE_XPOS_HIMETRIC xSrc,
        OLE_YPOS_HIMETRIC ySrc,
        OLE_XSIZE_HIMETRIC cxSrc,
        OLE_YSIZE_HIMETRIC cySrc,
        LPCRECT pRcWBounds)
        = 0;
    virtual HRESULT __stdcall set_hPal(
        OLE_HANDLE hPal)
        = 0;
    virtual HRESULT __stdcall get_CurDC(
        HDC* phDC)
        = 0;
    virtual HRESULT __stdcall SelectPicture(
        HDC hDCIn,
        HDC* phDCOut,
        OLE_HANDLE* phBmpOut)
        = 0;
    virtual HRESULT __stdcall get_KeepOriginalFormat(
        BOOL* pKeep)
        = 0;
    virtual HRESULT __stdcall put_KeepOriginalFormat(
        BOOL keep)
        = 0;
    virtual HRESULT __stdcall PictureChanged(void) = 0;
    virtual HRESULT __stdcall SaveAsFile(
        LPSTREAM pStream,
        BOOL fSaveMemCopy,
        LONG* pCbSize)
        = 0;
    virtual HRESULT __stdcall get_Attributes(
        DWORD* pDwAttr)
        = 0;
};
typedef IPicture2* LPPICTURE2;
typedef UINT_PTR HHANDLE;
extern "C" const IID IID_IPicture2;
struct __declspec(uuid("F5185DD8-2012-4b0b-AAD9-F052C6BD482B")) __declspec(novtable)
    IPicture2 : public IUnknown {
public:
    virtual HRESULT __stdcall get_Handle(
        HHANDLE* pHandle)
        = 0;
    virtual HRESULT __stdcall get_hPal(
        HHANDLE* phPal)
        = 0;
    virtual HRESULT __stdcall get_Type(
        SHORT* pType)
        = 0;
    virtual HRESULT __stdcall get_Width(
        OLE_XSIZE_HIMETRIC* pWidth)
        = 0;
    virtual HRESULT __stdcall get_Height(
        OLE_YSIZE_HIMETRIC* pHeight)
        = 0;
    virtual HRESULT __stdcall Render(
        HDC hDC,
        LONG x,
        LONG y,
        LONG cx,
        LONG cy,
        OLE_XPOS_HIMETRIC xSrc,
        OLE_YPOS_HIMETRIC ySrc,
        OLE_XSIZE_HIMETRIC cxSrc,
        OLE_YSIZE_HIMETRIC cySrc,
        LPCRECT pRcWBounds)
        = 0;
    virtual HRESULT __stdcall set_hPal(
        HHANDLE hPal)
        = 0;
    virtual HRESULT __stdcall get_CurDC(
        HDC* phDC)
        = 0;
    virtual HRESULT __stdcall SelectPicture(
        HDC hDCIn,
        HDC* phDCOut,
        HHANDLE* phBmpOut)
        = 0;
    virtual HRESULT __stdcall get_KeepOriginalFormat(
        BOOL* pKeep)
        = 0;
    virtual HRESULT __stdcall put_KeepOriginalFormat(
        BOOL keep)
        = 0;
    virtual HRESULT __stdcall PictureChanged(void) = 0;
    virtual HRESULT __stdcall SaveAsFile(
        LPSTREAM pStream,
        BOOL fSaveMemCopy,
        LONG* pCbSize)
        = 0;
    virtual HRESULT __stdcall get_Attributes(
        DWORD* pDwAttr)
        = 0;
};
typedef IFontEventsDisp* LPFONTEVENTS;
extern "C" const IID IID_IFontEventsDisp;
struct __declspec(uuid("4EF6100A-AF88-11D0-9846-00C04FC29993")) __declspec(novtable)
    IFontEventsDisp : public IDispatch {
public:
};
typedef IFontDisp* LPFONTDISP;
extern "C" const IID IID_IFontDisp;
struct __declspec(uuid("BEF6E003-A874-101A-8BBA-00AA00300CAB")) __declspec(novtable)
    IFontDisp : public IDispatch {
public:
};
typedef IPictureDisp* LPPICTUREDISP;
extern "C" const IID IID_IPictureDisp;
struct __declspec(uuid("7BF80981-BF32-101A-8BBB-00AA00300CAB")) __declspec(novtable)
    IPictureDisp : public IDispatch {
public:
};
typedef IOleInPlaceObjectWindowless* LPOLEINPLACEOBJECTWINDOWLESS;
extern "C" const IID IID_IOleInPlaceObjectWindowless;
struct __declspec(uuid("1C2056CC-5EF4-101B-8BC8-00AA003E3B29")) __declspec(novtable)
    IOleInPlaceObjectWindowless : public IOleInPlaceObject {
public:
    virtual HRESULT __stdcall OnWindowMessage(
        UINT msg,
        WPARAM wParam,
        LPARAM lParam,
        LRESULT* plResult)
        = 0;
    virtual HRESULT __stdcall GetDropTarget(
        IDropTarget** ppDropTarget)
        = 0;
};
typedef IOleInPlaceSiteEx* LPOLEINPLACESITEEX;
typedef enum tagACTIVATEFLAGS {
    ACTIVATE_WINDOWLESS = 1
} ACTIVATEFLAGS;
extern "C" const IID IID_IOleInPlaceSiteEx;
struct __declspec(uuid("9C2CAD80-3424-11CF-B670-00AA004CD6D8")) __declspec(novtable)
    IOleInPlaceSiteEx : public IOleInPlaceSite {
public:
    virtual HRESULT __stdcall OnInPlaceActivateEx(
        BOOL* pfNoRedraw,
        DWORD dwFlags)
        = 0;
    virtual HRESULT __stdcall OnInPlaceDeactivateEx(
        BOOL fNoRedraw)
        = 0;
    virtual HRESULT __stdcall RequestUIActivate(void) = 0;
};
typedef IOleInPlaceSiteWindowless* LPOLEINPLACESITEWINDOWLESS;
typedef enum tagOLEDCFLAGS {
    OLEDC_NODRAW = 0x1,
    OLEDC_PAINTBKGND = 0x2,
    OLEDC_OFFSCREEN = 0x4
} OLEDCFLAGS;
extern "C" const IID IID_IOleInPlaceSiteWindowless;
struct __declspec(uuid("922EADA0-3424-11CF-B670-00AA004CD6D8")) __declspec(novtable)
    IOleInPlaceSiteWindowless : public IOleInPlaceSiteEx {
public:
    virtual HRESULT __stdcall CanWindowlessActivate(void) = 0;
    virtual HRESULT __stdcall GetCapture(void) = 0;
    virtual HRESULT __stdcall SetCapture(
        BOOL fCapture)
        = 0;
    virtual HRESULT __stdcall GetFocus(void) = 0;
    virtual HRESULT __stdcall SetFocus(
        BOOL fFocus)
        = 0;
    virtual HRESULT __stdcall GetDC(
        LPCRECT pRect,
        DWORD grfFlags,
        HDC* phDC)
        = 0;
    virtual HRESULT __stdcall ReleaseDC(
        HDC hDC)
        = 0;
    virtual HRESULT __stdcall InvalidateRect(
        LPCRECT pRect,
        BOOL fErase)
        = 0;
    virtual HRESULT __stdcall InvalidateRgn(
        HRGN hRGN,
        BOOL fErase)
        = 0;
    virtual HRESULT __stdcall ScrollRect(
        INT dx,
        INT dy,
        LPCRECT pRectScroll,
        LPCRECT pRectClip)
        = 0;
    virtual HRESULT __stdcall AdjustRect(
        LPRECT prc)
        = 0;
    virtual HRESULT __stdcall OnDefWindowMessage(
        UINT msg,
        WPARAM wParam,
        LPARAM lParam,
        LRESULT* plResult)
        = 0;
};
typedef IViewObjectEx* LPVIEWOBJECTEX;
typedef enum tagVIEWSTATUS {
    VIEWSTATUS_OPAQUE = 1,
    VIEWSTATUS_SOLIDBKGND = 2,
    VIEWSTATUS_DVASPECTOPAQUE = 4,
    VIEWSTATUS_DVASPECTTRANSPARENT = 8,
    VIEWSTATUS_SURFACE = 16,
    VIEWSTATUS_3DSURFACE = 32
} VIEWSTATUS;
typedef enum tagHITRESULT {
    HITRESULT_OUTSIDE = 0,
    HITRESULT_TRANSPARENT = 1,
    HITRESULT_CLOSE = 2,
    HITRESULT_HIT = 3
} HITRESULT;
typedef enum tagDVASPECT2 {
    DVASPECT_OPAQUE = 16,
    DVASPECT_TRANSPARENT = 32
} DVASPECT2;
typedef struct tagExtentInfo {
    ULONG cb;
    DWORD dwExtentMode;
    SIZEL sizelProposed;
} DVEXTENTINFO;
typedef enum tagExtentMode {
    DVEXTENT_CONTENT = 0,
    DVEXTENT_INTEGRAL = (DVEXTENT_CONTENT + 1)
} DVEXTENTMODE;
typedef enum tagAspectInfoFlag {
    DVASPECTINFOFLAG_CANOPTIMIZE = 1
} DVASPECTINFOFLAG;
typedef struct tagAspectInfo {
    ULONG cb;
    DWORD dwFlags;
} DVASPECTINFO;
extern "C" const IID IID_IViewObjectEx;
struct __declspec(uuid("3AF24292-0C96-11CE-A0CF-00AA00600AB8")) __declspec(novtable)
    IViewObjectEx : public IViewObject2 {
public:
    virtual HRESULT __stdcall GetRect(
        DWORD dwAspect,
        LPRECTL pRect)
        = 0;
    virtual HRESULT __stdcall GetViewStatus(
        DWORD* pdwStatus)
        = 0;
    virtual HRESULT __stdcall QueryHitPoint(
        DWORD dwAspect,
        LPCRECT pRectBounds,
        POINT ptlLoc,
        LONG lCloseHint,
        DWORD* pHitResult)
        = 0;
    virtual HRESULT __stdcall QueryHitRect(
        DWORD dwAspect,
        LPCRECT pRectBounds,
        LPCRECT pRectLoc,
        LONG lCloseHint,
        DWORD* pHitResult)
        = 0;
    virtual HRESULT __stdcall GetNaturalExtent(
        DWORD dwAspect,
        LONG lindex,
        DVTARGETDEVICE* ptd,
        HDC hicTargetDev,
        DVEXTENTINFO* pExtentInfo,
        LPSIZEL pSizel)
        = 0;
};
typedef IOleUndoUnit* LPOLEUNDOUNIT;
extern "C" const IID IID_IOleUndoUnit;
struct __declspec(uuid("894AD3B0-EF97-11CE-9BC9-00AA00608E01")) __declspec(novtable)
    IOleUndoUnit : public IUnknown {
public:
    virtual HRESULT __stdcall Do(
        IOleUndoManager* pUndoManager)
        = 0;
    virtual HRESULT __stdcall GetDescription(
        BSTR* pBstr)
        = 0;
    virtual HRESULT __stdcall GetUnitType(
        CLSID* pClsid,
        LONG* plID)
        = 0;
    virtual HRESULT __stdcall OnNextAdd(void) = 0;
};
typedef IOleParentUndoUnit* LPOLEPARENTUNDOUNIT;
extern "C" const IID IID_IOleParentUndoUnit;
struct __declspec(uuid("A1FAF330-EF97-11CE-9BC9-00AA00608E01")) __declspec(novtable)
    IOleParentUndoUnit : public IOleUndoUnit {
public:
    virtual HRESULT __stdcall Open(
        IOleParentUndoUnit* pPUU)
        = 0;
    virtual HRESULT __stdcall Close(
        IOleParentUndoUnit* pPUU,
        BOOL fCommit)
        = 0;
    virtual HRESULT __stdcall Add(
        IOleUndoUnit* pUU)
        = 0;
    virtual HRESULT __stdcall FindUnit(
        IOleUndoUnit* pUU)
        = 0;
    virtual HRESULT __stdcall GetParentState(
        DWORD* pdwState)
        = 0;
};
typedef IEnumOleUndoUnits* LPENUMOLEUNDOUNITS;
extern "C" const IID IID_IEnumOleUndoUnits;
struct __declspec(uuid("B3E7C340-EF97-11CE-9BC9-00AA00608E01")) __declspec(novtable)
    IEnumOleUndoUnits : public IUnknown {
public:
    virtual HRESULT __stdcall Next(
        ULONG cElt,
        IOleUndoUnit** rgElt,
        ULONG* pcEltFetched)
        = 0;
    virtual HRESULT __stdcall Skip(
        ULONG cElt)
        = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(
        IEnumOleUndoUnits** ppEnum)
        = 0;
};
HRESULT __stdcall IEnumOleUndoUnits_RemoteNext_Proxy(
    IEnumOleUndoUnits* This,
    ULONG cElt,
    IOleUndoUnit** rgElt,
    ULONG* pcEltFetched);
void __stdcall IEnumOleUndoUnits_RemoteNext_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
typedef IOleUndoManager* LPOLEUNDOMANAGER;
extern "C" const IID IID_IOleUndoManager;
struct __declspec(uuid("D001F200-EF97-11CE-9BC9-00AA00608E01")) __declspec(novtable)
    IOleUndoManager : public IUnknown {
public:
    virtual HRESULT __stdcall Open(
        IOleParentUndoUnit* pPUU)
        = 0;
    virtual HRESULT __stdcall Close(
        IOleParentUndoUnit* pPUU,
        BOOL fCommit)
        = 0;
    virtual HRESULT __stdcall Add(
        IOleUndoUnit* pUU)
        = 0;
    virtual HRESULT __stdcall GetOpenParentState(
        DWORD* pdwState)
        = 0;
    virtual HRESULT __stdcall DiscardFrom(
        IOleUndoUnit* pUU)
        = 0;
    virtual HRESULT __stdcall UndoTo(
        IOleUndoUnit* pUU)
        = 0;
    virtual HRESULT __stdcall RedoTo(
        IOleUndoUnit* pUU)
        = 0;
    virtual HRESULT __stdcall EnumUndoable(
        IEnumOleUndoUnits** ppEnum)
        = 0;
    virtual HRESULT __stdcall EnumRedoable(
        IEnumOleUndoUnits** ppEnum)
        = 0;
    virtual HRESULT __stdcall GetLastUndoDescription(
        BSTR* pBstr)
        = 0;
    virtual HRESULT __stdcall GetLastRedoDescription(
        BSTR* pBstr)
        = 0;
    virtual HRESULT __stdcall Enable(
        BOOL fEnable)
        = 0;
};
typedef IPointerInactive* LPPOINTERINACTIVE;
typedef enum tagPOINTERINACTIVE {
    POINTERINACTIVE_ACTIVATEONENTRY = 1,
    POINTERINACTIVE_DEACTIVATEONLEAVE = 2,
    POINTERINACTIVE_ACTIVATEONDRAG = 4
} POINTERINACTIVE;
extern "C" const IID IID_IPointerInactive;
struct __declspec(uuid("55980BA0-35AA-11CF-B671-00AA004CD6D8")) __declspec(novtable)
    IPointerInactive : public IUnknown {
public:
    virtual HRESULT __stdcall GetActivationPolicy(
        DWORD* pdwPolicy)
        = 0;
    virtual HRESULT __stdcall OnInactiveMouseMove(
        LPCRECT pRectBounds,
        LONG x,
        LONG y,
        DWORD grfKeyState)
        = 0;
    virtual HRESULT __stdcall OnInactiveSetCursor(
        LPCRECT pRectBounds,
        LONG x,
        LONG y,
        DWORD dwMouseMsg,
        BOOL fSetAlways)
        = 0;
};
typedef IObjectWithSite* LPOBJECTWITHSITE;
extern "C" const IID IID_IObjectWithSite;
struct __declspec(uuid("FC4801A3-2BA9-11CF-A229-00AA003D7352")) __declspec(novtable)
    IObjectWithSite : public IUnknown {
public:
    virtual HRESULT __stdcall SetSite(
        IUnknown* pUnkSite)
        = 0;
    virtual HRESULT __stdcall GetSite(
        const IID& riid,
        void** ppvSite)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0036_v0_0_s_ifspec;
typedef IPerPropertyBrowsing* LPPERPROPERTYBROWSING;
typedef struct tagCALPOLESTR {
    ULONG cElems;
    LPOLESTR* pElems;
} CALPOLESTR;
typedef struct tagCALPOLESTR* LPCALPOLESTR;
typedef struct tagCADWORD {
    ULONG cElems;
    DWORD* pElems;
} CADWORD;
typedef struct tagCADWORD* LPCADWORD;
extern "C" const IID IID_IPerPropertyBrowsing;
struct __declspec(uuid("376BD3AA-3845-101B-84ED-08002B2EC713")) __declspec(novtable)
    IPerPropertyBrowsing : public IUnknown {
public:
    virtual HRESULT __stdcall GetDisplayString(
        DISPID dispID,
        BSTR* pBstr)
        = 0;
    virtual HRESULT __stdcall MapPropertyToPage(
        DISPID dispID,
        CLSID* pClsid)
        = 0;
    virtual HRESULT __stdcall GetPredefinedStrings(
        DISPID dispID,
        CALPOLESTR* pCaStringsOut,
        CADWORD* pCaCookiesOut)
        = 0;
    virtual HRESULT __stdcall GetPredefinedValue(
        DISPID dispID,
        DWORD dwCookie,
        VARIANT* pVarOut)
        = 0;
};
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0037_v0_0_s_ifspec;
typedef IPropertyBag2* LPPROPERTYBAG2;
typedef enum tagPROPBAG2_TYPE {
    PROPBAG2_TYPE_UNDEFINED = 0,
    PROPBAG2_TYPE_DATA = 1,
    PROPBAG2_TYPE_URL = 2,
    PROPBAG2_TYPE_OBJECT = 3,
    PROPBAG2_TYPE_STREAM = 4,
    PROPBAG2_TYPE_STORAGE = 5,
    PROPBAG2_TYPE_MONIKER = 6
} PROPBAG2_TYPE;
typedef struct tagPROPBAG2 {
    DWORD dwType;
    VARTYPE vt;
    CLIPFORMAT cfType;
    DWORD dwHint;
    LPOLESTR pstrName;
    CLSID clsid;
} PROPBAG2;
extern "C" const IID IID_IPropertyBag2;
struct __declspec(uuid("22F55882-280B-11d0-A8A9-00A0C90C2004")) __declspec(novtable)
    IPropertyBag2 : public IUnknown {
public:
    virtual HRESULT __stdcall Read(
        ULONG cProperties,
        PROPBAG2* pPropBag,
        IErrorLog* pErrLog,
        VARIANT* pvarValue,
        HRESULT* phrError)
        = 0;
    virtual HRESULT __stdcall Write(
        ULONG cProperties,
        PROPBAG2* pPropBag,
        VARIANT* pvarValue)
        = 0;
    virtual HRESULT __stdcall CountProperties(
        ULONG* pcProperties)
        = 0;
    virtual HRESULT __stdcall GetPropertyInfo(
        ULONG iProperty,
        ULONG cProperties,
        PROPBAG2* pPropBag,
        ULONG* pcProperties)
        = 0;
    virtual HRESULT __stdcall LoadObject(
        LPCOLESTR pstrName,
        DWORD dwHint,
        IUnknown* pUnkObject,
        IErrorLog* pErrLog)
        = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0038_v0_0_s_ifspec;
typedef IPersistPropertyBag2* LPPERSISTPROPERTYBAG2;
extern "C" const IID IID_IPersistPropertyBag2;
struct __declspec(uuid("22F55881-280B-11d0-A8A9-00A0C90C2004")) __declspec(novtable)
    IPersistPropertyBag2 : public IPersist {
public:
    virtual HRESULT __stdcall InitNew(void) = 0;
    virtual HRESULT __stdcall Load(
        IPropertyBag2* pPropBag,
        IErrorLog* pErrLog)
        = 0;
    virtual HRESULT __stdcall Save(
        IPropertyBag2* pPropBag,
        BOOL fClearDirty,
        BOOL fSaveAllProperties)
        = 0;
    virtual HRESULT __stdcall IsDirty(void) = 0;
};
#pragma endregion
#pragma region Desktop Family or OneCore Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0039_v0_0_s_ifspec;
typedef IAdviseSinkEx* LPADVISESINKEX;
extern "C" const IID IID_IAdviseSinkEx;
struct __declspec(uuid("3AF24290-0C96-11CE-A0CF-00AA00600AB8")) __declspec(novtable)
    IAdviseSinkEx : public IAdviseSink {
public:
    virtual void __stdcall OnViewStatusChange(
        DWORD dwViewStatus)
        = 0;
};
HRESULT __stdcall IAdviseSinkEx_RemoteOnViewStatusChange_Proxy(
    IAdviseSinkEx* This,
    DWORD dwViewStatus);
void __stdcall IAdviseSinkEx_RemoteOnViewStatusChange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma region Application Family or OneCore Family or Games Family
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0040_v0_0_s_ifspec;
typedef IQuickActivate* LPQUICKACTIVATE;
typedef enum tagQACONTAINERFLAGS {
    QACONTAINER_SHOWHATCHING = 0x1,
    QACONTAINER_SHOWGRABHANDLES = 0x2,
    QACONTAINER_USERMODE = 0x4,
    QACONTAINER_DISPLAYASDEFAULT = 0x8,
    QACONTAINER_UIDEAD = 0x10,
    QACONTAINER_AUTOCLIP = 0x20,
    QACONTAINER_MESSAGEREFLECT = 0x40,
    QACONTAINER_SUPPORTSMNEMONICS = 0x80
} QACONTAINERFLAGS;
typedef __declspec(uuid("66504301-BE0F-101A-8BBB-00AA00300CAB")) DWORD OLE_COLOR;
typedef struct tagQACONTAINER {
    ULONG cbSize;
    IOleClientSite* pClientSite;
    IAdviseSinkEx* pAdviseSink;
    IPropertyNotifySink* pPropertyNotifySink;
    IUnknown* pUnkEventSink;
    DWORD dwAmbientFlags;
    OLE_COLOR colorFore;
    OLE_COLOR colorBack;
    IFont* pFont;
    IOleUndoManager* pUndoMgr;
    DWORD dwAppearance;
    LONG lcid;
    HPALETTE hpal;
    IBindHost* pBindHost;
    IOleControlSite* pOleControlSite;
    IServiceProvider* pServiceProvider;
} QACONTAINER;
typedef struct tagQACONTROL {
    ULONG cbSize;
    DWORD dwMiscStatus;
    DWORD dwViewStatus;
    DWORD dwEventCookie;
    DWORD dwPropNotifyCookie;
    DWORD dwPointerActivationPolicy;
} QACONTROL;
extern "C" const IID IID_IQuickActivate;
struct __declspec(uuid("CF51ED10-62FE-11CF-BF86-00A0C9034836")) __declspec(novtable)
    IQuickActivate : public IUnknown {
public:
    virtual HRESULT __stdcall QuickActivate(
        QACONTAINER* pQaContainer,
        QACONTROL* pQaControl)
        = 0;
    virtual HRESULT __stdcall SetContentExtent(
        LPSIZEL pSizel)
        = 0;
    virtual HRESULT __stdcall GetContentExtent(
        LPSIZEL pSizel)
        = 0;
};
HRESULT __stdcall IQuickActivate_RemoteQuickActivate_Proxy(
    IQuickActivate* This,
    QACONTAINER* pQaContainer,
    QACONTROL* pQaControl);
void __stdcall IQuickActivate_RemoteQuickActivate_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD* _pdwStubPhase);
#pragma endregion
#pragma warning(pop)
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocidl_0000_0041_v0_0_s_ifspec;
unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree(unsigned long*, BSTR*);
unsigned long __stdcall CLIPFORMAT_UserSize(unsigned long*, unsigned long, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserMarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserUnmarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
void __stdcall CLIPFORMAT_UserFree(unsigned long*, CLIPFORMAT*);
unsigned long __stdcall HACCEL_UserSize(unsigned long*, unsigned long, HACCEL*);
unsigned char* __stdcall HACCEL_UserMarshal(unsigned long*, unsigned char*, HACCEL*);
unsigned char* __stdcall HACCEL_UserUnmarshal(unsigned long*, unsigned char*, HACCEL*);
void __stdcall HACCEL_UserFree(unsigned long*, HACCEL*);
unsigned long __stdcall HDC_UserSize(unsigned long*, unsigned long, HDC*);
unsigned char* __stdcall HDC_UserMarshal(unsigned long*, unsigned char*, HDC*);
unsigned char* __stdcall HDC_UserUnmarshal(unsigned long*, unsigned char*, HDC*);
void __stdcall HDC_UserFree(unsigned long*, HDC*);
unsigned long __stdcall HFONT_UserSize(unsigned long*, unsigned long, HFONT*);
unsigned char* __stdcall HFONT_UserMarshal(unsigned long*, unsigned char*, HFONT*);
unsigned char* __stdcall HFONT_UserUnmarshal(unsigned long*, unsigned char*, HFONT*);
void __stdcall HFONT_UserFree(unsigned long*, HFONT*);
unsigned long __stdcall HPALETTE_UserSize(unsigned long*, unsigned long, HPALETTE*);
unsigned char* __stdcall HPALETTE_UserMarshal(unsigned long*, unsigned char*, HPALETTE*);
unsigned char* __stdcall HPALETTE_UserUnmarshal(unsigned long*, unsigned char*, HPALETTE*);
void __stdcall HPALETTE_UserFree(unsigned long*, HPALETTE*);
unsigned long __stdcall HRGN_UserSize(unsigned long*, unsigned long, HRGN*);
unsigned char* __stdcall HRGN_UserMarshal(unsigned long*, unsigned char*, HRGN*);
unsigned char* __stdcall HRGN_UserUnmarshal(unsigned long*, unsigned char*, HRGN*);
void __stdcall HRGN_UserFree(unsigned long*, HRGN*);
unsigned long __stdcall HWND_UserSize(unsigned long*, unsigned long, HWND*);
unsigned char* __stdcall HWND_UserMarshal(unsigned long*, unsigned char*, HWND*);
unsigned char* __stdcall HWND_UserUnmarshal(unsigned long*, unsigned char*, HWND*);
void __stdcall HWND_UserFree(unsigned long*, HWND*);
unsigned long __stdcall VARIANT_UserSize(unsigned long*, unsigned long, VARIANT*);
unsigned char* __stdcall VARIANT_UserMarshal(unsigned long*, unsigned char*, VARIANT*);
unsigned char* __stdcall VARIANT_UserUnmarshal(unsigned long*, unsigned char*, VARIANT*);
void __stdcall VARIANT_UserFree(unsigned long*, VARIANT*);
unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);
unsigned long __stdcall CLIPFORMAT_UserSize64(unsigned long*, unsigned long, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserMarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
unsigned char* __stdcall CLIPFORMAT_UserUnmarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
void __stdcall CLIPFORMAT_UserFree64(unsigned long*, CLIPFORMAT*);
unsigned long __stdcall HACCEL_UserSize64(unsigned long*, unsigned long, HACCEL*);
unsigned char* __stdcall HACCEL_UserMarshal64(unsigned long*, unsigned char*, HACCEL*);
unsigned char* __stdcall HACCEL_UserUnmarshal64(unsigned long*, unsigned char*, HACCEL*);
void __stdcall HACCEL_UserFree64(unsigned long*, HACCEL*);
unsigned long __stdcall HDC_UserSize64(unsigned long*, unsigned long, HDC*);
unsigned char* __stdcall HDC_UserMarshal64(unsigned long*, unsigned char*, HDC*);
unsigned char* __stdcall HDC_UserUnmarshal64(unsigned long*, unsigned char*, HDC*);
void __stdcall HDC_UserFree64(unsigned long*, HDC*);
unsigned long __stdcall HFONT_UserSize64(unsigned long*, unsigned long, HFONT*);
unsigned char* __stdcall HFONT_UserMarshal64(unsigned long*, unsigned char*, HFONT*);
unsigned char* __stdcall HFONT_UserUnmarshal64(unsigned long*, unsigned char*, HFONT*);
void __stdcall HFONT_UserFree64(unsigned long*, HFONT*);
unsigned long __stdcall HPALETTE_UserSize64(unsigned long*, unsigned long, HPALETTE*);
unsigned char* __stdcall HPALETTE_UserMarshal64(unsigned long*, unsigned char*, HPALETTE*);
unsigned char* __stdcall HPALETTE_UserUnmarshal64(unsigned long*, unsigned char*, HPALETTE*);
void __stdcall HPALETTE_UserFree64(unsigned long*, HPALETTE*);
unsigned long __stdcall HRGN_UserSize64(unsigned long*, unsigned long, HRGN*);
unsigned char* __stdcall HRGN_UserMarshal64(unsigned long*, unsigned char*, HRGN*);
unsigned char* __stdcall HRGN_UserUnmarshal64(unsigned long*, unsigned char*, HRGN*);
void __stdcall HRGN_UserFree64(unsigned long*, HRGN*);
unsigned long __stdcall HWND_UserSize64(unsigned long*, unsigned long, HWND*);
unsigned char* __stdcall HWND_UserMarshal64(unsigned long*, unsigned char*, HWND*);
unsigned char* __stdcall HWND_UserUnmarshal64(unsigned long*, unsigned char*, HWND*);
void __stdcall HWND_UserFree64(unsigned long*, HWND*);
unsigned long __stdcall VARIANT_UserSize64(unsigned long*, unsigned long, VARIANT*);
unsigned char* __stdcall VARIANT_UserMarshal64(unsigned long*, unsigned char*, VARIANT*);
unsigned char* __stdcall VARIANT_UserUnmarshal64(unsigned long*, unsigned char*, VARIANT*);
void __stdcall VARIANT_UserFree64(unsigned long*, VARIANT*);
HRESULT __stdcall IEnumConnections_Next_Proxy(
    IEnumConnections* This,
    ULONG cConnections,
    LPCONNECTDATA rgcd,
    ULONG* pcFetched);
HRESULT __stdcall IEnumConnections_Next_Stub(
    IEnumConnections* This,
    ULONG cConnections,
    LPCONNECTDATA rgcd,
    ULONG* pcFetched);
HRESULT __stdcall IEnumConnectionPoints_Next_Proxy(
    IEnumConnectionPoints* This,
    ULONG cConnections,
    LPCONNECTIONPOINT* ppCP,
    ULONG* pcFetched);
HRESULT __stdcall IEnumConnectionPoints_Next_Stub(
    IEnumConnectionPoints* This,
    ULONG cConnections,
    LPCONNECTIONPOINT* ppCP,
    ULONG* pcFetched);
HRESULT __stdcall IClassFactory2_CreateInstanceLic_Proxy(
    IClassFactory2* This,
    IUnknown* pUnkOuter,
    IUnknown* pUnkReserved,
    const IID& riid,
    BSTR bstrKey,
    PVOID* ppvObj);
HRESULT __stdcall IClassFactory2_CreateInstanceLic_Stub(
    IClassFactory2* This,
    const IID& riid,
    BSTR bstrKey,
    IUnknown** ppvObj);
HRESULT __stdcall IPersistMemory_Load_Proxy(
    IPersistMemory* This,
    LPVOID pMem,
    ULONG cbSize);
HRESULT __stdcall IPersistMemory_Load_Stub(
    IPersistMemory* This,
    BYTE* pMem,
    ULONG cbSize);
HRESULT __stdcall IPersistMemory_Save_Proxy(
    IPersistMemory* This,
    LPVOID pMem,
    BOOL fClearDirty,
    ULONG cbSize);
HRESULT __stdcall IPersistMemory_Save_Stub(
    IPersistMemory* This,
    BYTE* pMem,
    BOOL fClearDirty,
    ULONG cbSize);
HRESULT __stdcall IEnumOleUndoUnits_Next_Proxy(
    IEnumOleUndoUnits* This,
    ULONG cElt,
    IOleUndoUnit** rgElt,
    ULONG* pcEltFetched);
HRESULT __stdcall IEnumOleUndoUnits_Next_Stub(
    IEnumOleUndoUnits* This,
    ULONG cElt,
    IOleUndoUnit** rgElt,
    ULONG* pcEltFetched);
void __stdcall IAdviseSinkEx_OnViewStatusChange_Proxy(
    IAdviseSinkEx* This,
    DWORD dwViewStatus);
HRESULT __stdcall IAdviseSinkEx_OnViewStatusChange_Stub(
    IAdviseSinkEx* This,
    DWORD dwViewStatus);
HRESULT __stdcall IQuickActivate_QuickActivate_Proxy(
    IQuickActivate* This,
    QACONTAINER* pQaContainer,
    QACONTROL* pQaControl);
HRESULT __stdcall IQuickActivate_QuickActivate_Stub(
    IQuickActivate* This,
    QACONTAINER* pQaContainer,
    QACONTROL* pQaControl);
}
#pragma once
typedef struct IDXGIObject IDXGIObject;
typedef struct IDXGIDeviceSubObject IDXGIDeviceSubObject;
typedef struct IDXGIResource IDXGIResource;
typedef struct IDXGIKeyedMutex IDXGIKeyedMutex;
typedef struct IDXGISurface IDXGISurface;
typedef struct IDXGISurface1 IDXGISurface1;
typedef struct IDXGIAdapter IDXGIAdapter;
typedef struct IDXGIOutput IDXGIOutput;
typedef struct IDXGISwapChain IDXGISwapChain;
typedef struct IDXGIFactory IDXGIFactory;
typedef struct IDXGIDevice IDXGIDevice;
typedef struct IDXGIFactory1 IDXGIFactory1;
typedef struct IDXGIAdapter1 IDXGIAdapter1;
typedef struct IDXGIDevice1 IDXGIDevice1;
typedef struct DXGI_RATIONAL {
    UINT Numerator;
    UINT Denominator;
} DXGI_RATIONAL;
typedef struct DXGI_SAMPLE_DESC {
    UINT Count;
    UINT Quality;
} DXGI_SAMPLE_DESC;
typedef enum DXGI_COLOR_SPACE_TYPE {
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 = 0,
    DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709 = 1,
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709 = 2,
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P2020 = 3,
    DXGI_COLOR_SPACE_RESERVED = 4,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 = 5,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 = 6,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601 = 7,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 = 8,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 = 9,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 = 10,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 = 11,
    DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 = 12,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_LEFT_P2020 = 13,
    DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020 = 14,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_TOPLEFT_P2020 = 15,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_TOPLEFT_P2020 = 16,
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020 = 17,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_GHLG_TOPLEFT_P2020 = 18,
    DXGI_COLOR_SPACE_YCBCR_FULL_GHLG_TOPLEFT_P2020 = 19,
    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P709 = 20,
    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P2020 = 21,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P709 = 22,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P2020 = 23,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_TOPLEFT_P2020 = 24,
    DXGI_COLOR_SPACE_CUSTOM = 0xFFFFFFFF
} DXGI_COLOR_SPACE_TYPE;
typedef enum DXGI_FORMAT {
    DXGI_FORMAT_UNKNOWN = 0,
    DXGI_FORMAT_R32G32B32A32_TYPELESS = 1,
    DXGI_FORMAT_R32G32B32A32_FLOAT = 2,
    DXGI_FORMAT_R32G32B32A32_UINT = 3,
    DXGI_FORMAT_R32G32B32A32_SINT = 4,
    DXGI_FORMAT_R32G32B32_TYPELESS = 5,
    DXGI_FORMAT_R32G32B32_FLOAT = 6,
    DXGI_FORMAT_R32G32B32_UINT = 7,
    DXGI_FORMAT_R32G32B32_SINT = 8,
    DXGI_FORMAT_R16G16B16A16_TYPELESS = 9,
    DXGI_FORMAT_R16G16B16A16_FLOAT = 10,
    DXGI_FORMAT_R16G16B16A16_UNORM = 11,
    DXGI_FORMAT_R16G16B16A16_UINT = 12,
    DXGI_FORMAT_R16G16B16A16_SNORM = 13,
    DXGI_FORMAT_R16G16B16A16_SINT = 14,
    DXGI_FORMAT_R32G32_TYPELESS = 15,
    DXGI_FORMAT_R32G32_FLOAT = 16,
    DXGI_FORMAT_R32G32_UINT = 17,
    DXGI_FORMAT_R32G32_SINT = 18,
    DXGI_FORMAT_R32G8X24_TYPELESS = 19,
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20,
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21,
    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22,
    DXGI_FORMAT_R10G10B10A2_TYPELESS = 23,
    DXGI_FORMAT_R10G10B10A2_UNORM = 24,
    DXGI_FORMAT_R10G10B10A2_UINT = 25,
    DXGI_FORMAT_R11G11B10_FLOAT = 26,
    DXGI_FORMAT_R8G8B8A8_TYPELESS = 27,
    DXGI_FORMAT_R8G8B8A8_UNORM = 28,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29,
    DXGI_FORMAT_R8G8B8A8_UINT = 30,
    DXGI_FORMAT_R8G8B8A8_SNORM = 31,
    DXGI_FORMAT_R8G8B8A8_SINT = 32,
    DXGI_FORMAT_R16G16_TYPELESS = 33,
    DXGI_FORMAT_R16G16_FLOAT = 34,
    DXGI_FORMAT_R16G16_UNORM = 35,
    DXGI_FORMAT_R16G16_UINT = 36,
    DXGI_FORMAT_R16G16_SNORM = 37,
    DXGI_FORMAT_R16G16_SINT = 38,
    DXGI_FORMAT_R32_TYPELESS = 39,
    DXGI_FORMAT_D32_FLOAT = 40,
    DXGI_FORMAT_R32_FLOAT = 41,
    DXGI_FORMAT_R32_UINT = 42,
    DXGI_FORMAT_R32_SINT = 43,
    DXGI_FORMAT_R24G8_TYPELESS = 44,
    DXGI_FORMAT_D24_UNORM_S8_UINT = 45,
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46,
    DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47,
    DXGI_FORMAT_R8G8_TYPELESS = 48,
    DXGI_FORMAT_R8G8_UNORM = 49,
    DXGI_FORMAT_R8G8_UINT = 50,
    DXGI_FORMAT_R8G8_SNORM = 51,
    DXGI_FORMAT_R8G8_SINT = 52,
    DXGI_FORMAT_R16_TYPELESS = 53,
    DXGI_FORMAT_R16_FLOAT = 54,
    DXGI_FORMAT_D16_UNORM = 55,
    DXGI_FORMAT_R16_UNORM = 56,
    DXGI_FORMAT_R16_UINT = 57,
    DXGI_FORMAT_R16_SNORM = 58,
    DXGI_FORMAT_R16_SINT = 59,
    DXGI_FORMAT_R8_TYPELESS = 60,
    DXGI_FORMAT_R8_UNORM = 61,
    DXGI_FORMAT_R8_UINT = 62,
    DXGI_FORMAT_R8_SNORM = 63,
    DXGI_FORMAT_R8_SINT = 64,
    DXGI_FORMAT_A8_UNORM = 65,
    DXGI_FORMAT_R1_UNORM = 66,
    DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67,
    DXGI_FORMAT_R8G8_B8G8_UNORM = 68,
    DXGI_FORMAT_G8R8_G8B8_UNORM = 69,
    DXGI_FORMAT_BC1_TYPELESS = 70,
    DXGI_FORMAT_BC1_UNORM = 71,
    DXGI_FORMAT_BC1_UNORM_SRGB = 72,
    DXGI_FORMAT_BC2_TYPELESS = 73,
    DXGI_FORMAT_BC2_UNORM = 74,
    DXGI_FORMAT_BC2_UNORM_SRGB = 75,
    DXGI_FORMAT_BC3_TYPELESS = 76,
    DXGI_FORMAT_BC3_UNORM = 77,
    DXGI_FORMAT_BC3_UNORM_SRGB = 78,
    DXGI_FORMAT_BC4_TYPELESS = 79,
    DXGI_FORMAT_BC4_UNORM = 80,
    DXGI_FORMAT_BC4_SNORM = 81,
    DXGI_FORMAT_BC5_TYPELESS = 82,
    DXGI_FORMAT_BC5_UNORM = 83,
    DXGI_FORMAT_BC5_SNORM = 84,
    DXGI_FORMAT_B5G6R5_UNORM = 85,
    DXGI_FORMAT_B5G5R5A1_UNORM = 86,
    DXGI_FORMAT_B8G8R8A8_UNORM = 87,
    DXGI_FORMAT_B8G8R8X8_UNORM = 88,
    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89,
    DXGI_FORMAT_B8G8R8A8_TYPELESS = 90,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91,
    DXGI_FORMAT_B8G8R8X8_TYPELESS = 92,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93,
    DXGI_FORMAT_BC6H_TYPELESS = 94,
    DXGI_FORMAT_BC6H_UF16 = 95,
    DXGI_FORMAT_BC6H_SF16 = 96,
    DXGI_FORMAT_BC7_TYPELESS = 97,
    DXGI_FORMAT_BC7_UNORM = 98,
    DXGI_FORMAT_BC7_UNORM_SRGB = 99,
    DXGI_FORMAT_AYUV = 100,
    DXGI_FORMAT_Y410 = 101,
    DXGI_FORMAT_Y416 = 102,
    DXGI_FORMAT_NV12 = 103,
    DXGI_FORMAT_P010 = 104,
    DXGI_FORMAT_P016 = 105,
    DXGI_FORMAT_420_OPAQUE = 106,
    DXGI_FORMAT_YUY2 = 107,
    DXGI_FORMAT_Y210 = 108,
    DXGI_FORMAT_Y216 = 109,
    DXGI_FORMAT_NV11 = 110,
    DXGI_FORMAT_AI44 = 111,
    DXGI_FORMAT_IA44 = 112,
    DXGI_FORMAT_P8 = 113,
    DXGI_FORMAT_A8P8 = 114,
    DXGI_FORMAT_B4G4R4A4_UNORM = 115,
    DXGI_FORMAT_P208 = 130,
    DXGI_FORMAT_V208 = 131,
    DXGI_FORMAT_V408 = 132,
    DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 189,
    DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 190,
    DXGI_FORMAT_FORCE_UINT = 0xffffffff
} DXGI_FORMAT;
typedef struct DXGI_RGB {
    float Red;
    float Green;
    float Blue;
} DXGI_RGB;
typedef D3DCOLORVALUE DXGI_RGBA;
typedef struct DXGI_GAMMA_CONTROL {
    DXGI_RGB Scale;
    DXGI_RGB Offset;
    DXGI_RGB GammaCurve[1025];
} DXGI_GAMMA_CONTROL;
typedef struct DXGI_GAMMA_CONTROL_CAPABILITIES {
    BOOL ScaleAndOffsetSupported;
    float MaxConvertedValue;
    float MinConvertedValue;
    UINT NumGammaControlPoints;
    float ControlPointPositions[1025];
} DXGI_GAMMA_CONTROL_CAPABILITIES;
typedef enum DXGI_MODE_SCANLINE_ORDER {
    DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED = 0,
    DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE = 1,
    DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = 2,
    DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = 3
} DXGI_MODE_SCANLINE_ORDER;
typedef enum DXGI_MODE_SCALING {
    DXGI_MODE_SCALING_UNSPECIFIED = 0,
    DXGI_MODE_SCALING_CENTERED = 1,
    DXGI_MODE_SCALING_STRETCHED = 2
} DXGI_MODE_SCALING;
typedef enum DXGI_MODE_ROTATION {
    DXGI_MODE_ROTATION_UNSPECIFIED = 0,
    DXGI_MODE_ROTATION_IDENTITY = 1,
    DXGI_MODE_ROTATION_ROTATE90 = 2,
    DXGI_MODE_ROTATION_ROTATE180 = 3,
    DXGI_MODE_ROTATION_ROTATE270 = 4
} DXGI_MODE_ROTATION;
typedef struct DXGI_MODE_DESC {
    UINT Width;
    UINT Height;
    DXGI_RATIONAL RefreshRate;
    DXGI_FORMAT Format;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
} DXGI_MODE_DESC;
typedef struct DXGI_JPEG_DC_HUFFMAN_TABLE {
    BYTE CodeCounts[12];
    BYTE CodeValues[12];
} DXGI_JPEG_DC_HUFFMAN_TABLE;
typedef struct DXGI_JPEG_AC_HUFFMAN_TABLE {
    BYTE CodeCounts[16];
    BYTE CodeValues[162];
} DXGI_JPEG_AC_HUFFMAN_TABLE;
typedef struct DXGI_JPEG_QUANTIZATION_TABLE {
    BYTE Elements[64];
} DXGI_JPEG_QUANTIZATION_TABLE;
extern "C" {
typedef UINT DXGI_USAGE;
typedef struct DXGI_FRAME_STATISTICS {
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
} DXGI_FRAME_STATISTICS;
typedef struct DXGI_MAPPED_RECT {
    INT Pitch;
    BYTE* pBits;
} DXGI_MAPPED_RECT;
typedef struct DXGI_ADAPTER_DESC {
    WCHAR Description[128];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
} DXGI_ADAPTER_DESC;
typedef struct DXGI_OUTPUT_DESC {
    WCHAR DeviceName[32];
    RECT DesktopCoordinates;
    BOOL AttachedToDesktop;
    DXGI_MODE_ROTATION Rotation;
    HMONITOR Monitor;
} DXGI_OUTPUT_DESC;
typedef struct DXGI_SHARED_RESOURCE {
    HANDLE Handle;
} DXGI_SHARED_RESOURCE;
typedef enum DXGI_RESIDENCY {
    DXGI_RESIDENCY_FULLY_RESIDENT = 1,
    DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = 2,
    DXGI_RESIDENCY_EVICTED_TO_DISK = 3
} DXGI_RESIDENCY;
typedef struct DXGI_SURFACE_DESC {
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
} DXGI_SURFACE_DESC;
typedef enum DXGI_SWAP_EFFECT {
    DXGI_SWAP_EFFECT_DISCARD = 0,
    DXGI_SWAP_EFFECT_SEQUENTIAL = 1,
    DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = 3,
    DXGI_SWAP_EFFECT_FLIP_DISCARD = 4
} DXGI_SWAP_EFFECT;
typedef enum DXGI_SWAP_CHAIN_FLAG {
    DXGI_SWAP_CHAIN_FLAG_NONPREROTATED = 1,
    DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH = 2,
    DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE = 4,
    DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT = 8,
    DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER = 16,
    DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY = 32,
    DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT = 64,
    DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER = 128,
    DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO = 256,
    DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO = 512,
    DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED = 1024,
    DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING = 2048,
    DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = 4096
} DXGI_SWAP_CHAIN_FLAG;
typedef struct DXGI_SWAP_CHAIN_DESC {
    DXGI_MODE_DESC BufferDesc;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    UINT BufferCount;
    HWND OutputWindow;
    BOOL Windowed;
    DXGI_SWAP_EFFECT SwapEffect;
    UINT Flags;
} DXGI_SWAP_CHAIN_DESC;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_IDXGIObject;
struct __declspec(uuid("aec22fb8-76f3-4639-9be0-28eb43a67a2e")) __declspec(novtable)
    IDXGIObject : public IUnknown {
public:
    virtual HRESULT __stdcall SetPrivateData(
        const GUID& Name,
        UINT DataSize,
        const void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateDataInterface(
        const GUID& Name,
        const IUnknown* pUnknown)
        = 0;
    virtual HRESULT __stdcall GetPrivateData(
        const GUID& Name,
        UINT* pDataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall GetParent(
        const IID& riid,
        void** ppParent)
        = 0;
};
extern "C" const IID IID_IDXGIDeviceSubObject;
struct __declspec(uuid("3d3e0379-f9de-4d58-bb6c-18d62992f1a6")) __declspec(novtable)
    IDXGIDeviceSubObject : public IDXGIObject {
public:
    virtual HRESULT __stdcall GetDevice(
        const IID& riid,
        void** ppDevice)
        = 0;
};
extern "C" const IID IID_IDXGIResource;
struct __declspec(uuid("035f3ab4-482e-4e50-b41f-8a7f8bd8960b")) __declspec(novtable)
    IDXGIResource : public IDXGIDeviceSubObject {
public:
    virtual HRESULT __stdcall GetSharedHandle(
        HANDLE* pSharedHandle)
        = 0;
    virtual HRESULT __stdcall GetUsage(
        DXGI_USAGE* pUsage)
        = 0;
    virtual HRESULT __stdcall SetEvictionPriority(
        UINT EvictionPriority)
        = 0;
    virtual HRESULT __stdcall GetEvictionPriority(
        UINT* pEvictionPriority)
        = 0;
};
extern "C" const IID IID_IDXGIKeyedMutex;
struct __declspec(uuid("9d8e1289-d7b3-465f-8126-250e349af85d")) __declspec(novtable)
    IDXGIKeyedMutex : public IDXGIDeviceSubObject {
public:
    virtual HRESULT __stdcall AcquireSync(
        UINT64 Key,
        DWORD dwMilliseconds)
        = 0;
    virtual HRESULT __stdcall ReleaseSync(
        UINT64 Key)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_s_ifspec;
extern "C" const IID IID_IDXGISurface;
struct __declspec(uuid("cafcb56c-6ac3-4889-bf47-9e23bbd260ec")) __declspec(novtable)
    IDXGISurface : public IDXGIDeviceSubObject {
public:
    virtual HRESULT __stdcall GetDesc(
        DXGI_SURFACE_DESC* pDesc)
        = 0;
    virtual HRESULT __stdcall Map(
        DXGI_MAPPED_RECT* pLockedRect,
        UINT MapFlags)
        = 0;
    virtual HRESULT __stdcall Unmap(void) = 0;
};
extern "C" const IID IID_IDXGISurface1;
struct __declspec(uuid("4AE63092-6327-4c1b-80AE-BFE12EA32B86")) __declspec(novtable)
    IDXGISurface1 : public IDXGISurface {
public:
    virtual HRESULT __stdcall GetDC(
        BOOL Discard,
        HDC* phdc)
        = 0;
    virtual HRESULT __stdcall ReleaseDC(
        RECT* pDirtyRect)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_s_ifspec;
extern "C" const IID IID_IDXGIAdapter;
struct __declspec(uuid("2411e7e1-12ac-4ccf-bd14-9798e8534dc0")) __declspec(novtable)
    IDXGIAdapter : public IDXGIObject {
public:
    virtual HRESULT __stdcall EnumOutputs(
        UINT Output,
        IDXGIOutput** ppOutput)
        = 0;
    virtual HRESULT __stdcall GetDesc(
        DXGI_ADAPTER_DESC* pDesc)
        = 0;
    virtual HRESULT __stdcall CheckInterfaceSupport(
        const GUID& InterfaceName,
        LARGE_INTEGER* pUMDVersion)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_s_ifspec;
extern "C" const IID IID_IDXGIOutput;
struct __declspec(uuid("ae02eedb-c735-4690-8d52-5a8dc20213aa")) __declspec(novtable)
    IDXGIOutput : public IDXGIObject {
public:
    virtual HRESULT __stdcall GetDesc(
        DXGI_OUTPUT_DESC* pDesc)
        = 0;
    virtual HRESULT __stdcall GetDisplayModeList(
        DXGI_FORMAT EnumFormat,
        UINT Flags,
        UINT* pNumModes,
        DXGI_MODE_DESC* pDesc)
        = 0;
    virtual HRESULT __stdcall FindClosestMatchingMode(
        const DXGI_MODE_DESC* pModeToMatch,
        DXGI_MODE_DESC* pClosestMatch,
        IUnknown* pConcernedDevice)
        = 0;
    virtual HRESULT __stdcall WaitForVBlank(void) = 0;
    virtual HRESULT __stdcall TakeOwnership(
        IUnknown* pDevice,
        BOOL Exclusive)
        = 0;
    virtual void __stdcall ReleaseOwnership(void) = 0;
    virtual HRESULT __stdcall GetGammaControlCapabilities(
        DXGI_GAMMA_CONTROL_CAPABILITIES* pGammaCaps)
        = 0;
    virtual HRESULT __stdcall SetGammaControl(
        const DXGI_GAMMA_CONTROL* pArray)
        = 0;
    virtual HRESULT __stdcall GetGammaControl(
        DXGI_GAMMA_CONTROL* pArray)
        = 0;
    virtual HRESULT __stdcall SetDisplaySurface(
        IDXGISurface* pScanoutSurface)
        = 0;
    virtual HRESULT __stdcall GetDisplaySurfaceData(
        IDXGISurface* pDestination)
        = 0;
    virtual HRESULT __stdcall GetFrameStatistics(
        DXGI_FRAME_STATISTICS* pStats)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_s_ifspec;
extern "C" const IID IID_IDXGISwapChain;
struct __declspec(uuid("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a")) __declspec(novtable)
    IDXGISwapChain : public IDXGIDeviceSubObject {
public:
    virtual HRESULT __stdcall Present(
        UINT SyncInterval,
        UINT Flags)
        = 0;
    virtual HRESULT __stdcall GetBuffer(
        UINT Buffer,
        const IID& riid,
        void** ppSurface)
        = 0;
    virtual HRESULT __stdcall SetFullscreenState(
        BOOL Fullscreen,
        IDXGIOutput* pTarget)
        = 0;
    virtual HRESULT __stdcall GetFullscreenState(
        BOOL* pFullscreen,
        IDXGIOutput** ppTarget)
        = 0;
    virtual HRESULT __stdcall GetDesc(
        DXGI_SWAP_CHAIN_DESC* pDesc)
        = 0;
    virtual HRESULT __stdcall ResizeBuffers(
        UINT BufferCount,
        UINT Width,
        UINT Height,
        DXGI_FORMAT NewFormat,
        UINT SwapChainFlags)
        = 0;
    virtual HRESULT __stdcall ResizeTarget(
        const DXGI_MODE_DESC* pNewTargetParameters)
        = 0;
    virtual HRESULT __stdcall GetContainingOutput(
        IDXGIOutput** ppOutput)
        = 0;
    virtual HRESULT __stdcall GetFrameStatistics(
        DXGI_FRAME_STATISTICS* pStats)
        = 0;
    virtual HRESULT __stdcall GetLastPresentCount(
        UINT* pLastPresentCount)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_s_ifspec;
extern "C" const IID IID_IDXGIFactory;
struct __declspec(uuid("7b7166ec-21c7-44ae-b21a-c9ae321ae369")) __declspec(novtable)
    IDXGIFactory : public IDXGIObject {
public:
    virtual HRESULT __stdcall EnumAdapters(
        UINT Adapter,
        IDXGIAdapter** ppAdapter)
        = 0;
    virtual HRESULT __stdcall MakeWindowAssociation(
        HWND WindowHandle,
        UINT Flags)
        = 0;
    virtual HRESULT __stdcall GetWindowAssociation(
        HWND* pWindowHandle)
        = 0;
    virtual HRESULT __stdcall CreateSwapChain(
        IUnknown* pDevice,
        DXGI_SWAP_CHAIN_DESC* pDesc,
        IDXGISwapChain** ppSwapChain)
        = 0;
    virtual HRESULT __stdcall CreateSoftwareAdapter(
        HMODULE Module,
        IDXGIAdapter** ppAdapter)
        = 0;
};
#pragma region Desktop Family
HRESULT __stdcall CreateDXGIFactory(const IID& riid, void** ppFactory);
#pragma endregion
HRESULT __stdcall CreateDXGIFactory1(const IID& riid, void** ppFactory);
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0010_v0_0_s_ifspec;
extern "C" const IID IID_IDXGIDevice;
struct __declspec(uuid("54ec77fa-1377-44e6-8c32-88fd5f44c84c")) __declspec(novtable)
    IDXGIDevice : public IDXGIObject {
public:
    virtual HRESULT __stdcall GetAdapter(
        IDXGIAdapter** pAdapter)
        = 0;
    virtual HRESULT __stdcall CreateSurface(
        const DXGI_SURFACE_DESC* pDesc,
        UINT NumSurfaces,
        DXGI_USAGE Usage,
        const DXGI_SHARED_RESOURCE* pSharedResource,
        IDXGISurface** ppSurface)
        = 0;
    virtual HRESULT __stdcall QueryResourceResidency(
        IUnknown* const* ppResources,
        DXGI_RESIDENCY* pResidencyStatus,
        UINT NumResources)
        = 0;
    virtual HRESULT __stdcall SetGPUThreadPriority(
        INT Priority)
        = 0;
    virtual HRESULT __stdcall GetGPUThreadPriority(
        INT* pPriority)
        = 0;
};
typedef enum DXGI_ADAPTER_FLAG {
    DXGI_ADAPTER_FLAG_NONE = 0,
    DXGI_ADAPTER_FLAG_REMOTE = 1,
    DXGI_ADAPTER_FLAG_SOFTWARE = 2,
    DXGI_ADAPTER_FLAG_FORCE_DWORD = 0xffffffff
} DXGI_ADAPTER_FLAG;
typedef struct DXGI_ADAPTER_DESC1 {
    WCHAR Description[128];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    UINT Flags;
} DXGI_ADAPTER_DESC1;
typedef struct DXGI_DISPLAY_COLOR_SPACE {
    FLOAT PrimaryCoordinates[8][2];
    FLOAT WhitePoints[16][2];
} DXGI_DISPLAY_COLOR_SPACE;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0011_v0_0_s_ifspec;
extern "C" const IID IID_IDXGIFactory1;
struct __declspec(uuid("770aae78-f26f-4dba-a829-253c83d1b387")) __declspec(novtable)
    IDXGIFactory1 : public IDXGIFactory {
public:
    virtual HRESULT __stdcall EnumAdapters1(
        UINT Adapter,
        IDXGIAdapter1** ppAdapter)
        = 0;
    virtual BOOL __stdcall IsCurrent(void) = 0;
};
extern "C" const IID IID_IDXGIAdapter1;
struct __declspec(uuid("29038f61-3839-4626-91fd-086879011a05")) __declspec(novtable)
    IDXGIAdapter1 : public IDXGIAdapter {
public:
    virtual HRESULT __stdcall GetDesc1(
        DXGI_ADAPTER_DESC1* pDesc)
        = 0;
};
extern "C" const IID IID_IDXGIDevice1;
struct __declspec(uuid("77db970f-6276-48ba-ba28-070143b4392c")) __declspec(novtable)
    IDXGIDevice1 : public IDXGIDevice {
public:
    virtual HRESULT __stdcall SetMaximumFrameLatency(
        UINT MaxLatency)
        = 0;
    virtual HRESULT __stdcall GetMaximumFrameLatency(
        UINT* pMaxLatency)
        = 0;
};
extern "C" const GUID IID_IDXGIObject;
extern "C" const GUID IID_IDXGIDeviceSubObject;
extern "C" const GUID IID_IDXGIResource;
extern "C" const GUID IID_IDXGIKeyedMutex;
extern "C" const GUID IID_IDXGISurface;
extern "C" const GUID IID_IDXGISurface1;
extern "C" const GUID IID_IDXGIAdapter;
extern "C" const GUID IID_IDXGIOutput;
extern "C" const GUID IID_IDXGISwapChain;
extern "C" const GUID IID_IDXGIFactory;
extern "C" const GUID IID_IDXGIDevice;
extern "C" const GUID IID_IDXGIFactory1;
extern "C" const GUID IID_IDXGIAdapter1;
extern "C" const GUID IID_IDXGIDevice1;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0014_v0_0_s_ifspec;
}
#pragma once
typedef struct ID3D10Blob ID3D10Blob;
typedef struct ID3DDestructionNotifier ID3DDestructionNotifier;
extern "C" {
typedef enum D3D_DRIVER_TYPE {
    D3D_DRIVER_TYPE_UNKNOWN = 0,
    D3D_DRIVER_TYPE_HARDWARE = (D3D_DRIVER_TYPE_UNKNOWN + 1),
    D3D_DRIVER_TYPE_REFERENCE = (D3D_DRIVER_TYPE_HARDWARE + 1),
    D3D_DRIVER_TYPE_NULL = (D3D_DRIVER_TYPE_REFERENCE + 1),
    D3D_DRIVER_TYPE_SOFTWARE = (D3D_DRIVER_TYPE_NULL + 1),
    D3D_DRIVER_TYPE_WARP = (D3D_DRIVER_TYPE_SOFTWARE + 1)
} D3D_DRIVER_TYPE;
typedef enum D3D_FEATURE_LEVEL {
    D3D_FEATURE_LEVEL_1_0_CORE = 0x1000,
    D3D_FEATURE_LEVEL_9_1 = 0x9100,
    D3D_FEATURE_LEVEL_9_2 = 0x9200,
    D3D_FEATURE_LEVEL_9_3 = 0x9300,
    D3D_FEATURE_LEVEL_10_0 = 0xa000,
    D3D_FEATURE_LEVEL_10_1 = 0xa100,
    D3D_FEATURE_LEVEL_11_0 = 0xb000,
    D3D_FEATURE_LEVEL_11_1 = 0xb100,
    D3D_FEATURE_LEVEL_12_0 = 0xc000,
    D3D_FEATURE_LEVEL_12_1 = 0xc100,
    D3D_FEATURE_LEVEL_12_2 = 0xc200
} D3D_FEATURE_LEVEL;
typedef enum D3D_PRIMITIVE_TOPOLOGY {
    D3D_PRIMITIVE_TOPOLOGY_UNDEFINED = 0,
    D3D_PRIMITIVE_TOPOLOGY_POINTLIST = 1,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST = 2,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP = 3,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST = 4,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = 5,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = 10,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = 11,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = 12,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = 13,
    D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = 33,
    D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = 34,
    D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = 35,
    D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = 36,
    D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST = 37,
    D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST = 38,
    D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST = 39,
    D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST = 40,
    D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST = 41,
    D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST = 42,
    D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST = 43,
    D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST = 44,
    D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST = 45,
    D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST = 46,
    D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST = 47,
    D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST = 48,
    D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST = 49,
    D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST = 50,
    D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST = 51,
    D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST = 52,
    D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST = 53,
    D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST = 54,
    D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST = 55,
    D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST = 56,
    D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST = 57,
    D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST = 58,
    D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST = 59,
    D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST = 60,
    D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST = 61,
    D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST = 62,
    D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST = 63,
    D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST = 64,
    D3D10_PRIMITIVE_TOPOLOGY_UNDEFINED = D3D_PRIMITIVE_TOPOLOGY_UNDEFINED,
    D3D10_PRIMITIVE_TOPOLOGY_POINTLIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST,
    D3D10_PRIMITIVE_TOPOLOGY_LINELIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST,
    D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
    D3D10_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,
    D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,
    D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED = D3D_PRIMITIVE_TOPOLOGY_UNDEFINED,
    D3D11_PRIMITIVE_TOPOLOGY_POINTLIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST,
    D3D11_PRIMITIVE_TOPOLOGY_LINELIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST,
    D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP,
    D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ,
    D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ,
    D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST,
    D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST = D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST
} D3D_PRIMITIVE_TOPOLOGY;
typedef enum D3D_PRIMITIVE {
    D3D_PRIMITIVE_UNDEFINED = 0,
    D3D_PRIMITIVE_POINT = 1,
    D3D_PRIMITIVE_LINE = 2,
    D3D_PRIMITIVE_TRIANGLE = 3,
    D3D_PRIMITIVE_LINE_ADJ = 6,
    D3D_PRIMITIVE_TRIANGLE_ADJ = 7,
    D3D_PRIMITIVE_1_CONTROL_POINT_PATCH = 8,
    D3D_PRIMITIVE_2_CONTROL_POINT_PATCH = 9,
    D3D_PRIMITIVE_3_CONTROL_POINT_PATCH = 10,
    D3D_PRIMITIVE_4_CONTROL_POINT_PATCH = 11,
    D3D_PRIMITIVE_5_CONTROL_POINT_PATCH = 12,
    D3D_PRIMITIVE_6_CONTROL_POINT_PATCH = 13,
    D3D_PRIMITIVE_7_CONTROL_POINT_PATCH = 14,
    D3D_PRIMITIVE_8_CONTROL_POINT_PATCH = 15,
    D3D_PRIMITIVE_9_CONTROL_POINT_PATCH = 16,
    D3D_PRIMITIVE_10_CONTROL_POINT_PATCH = 17,
    D3D_PRIMITIVE_11_CONTROL_POINT_PATCH = 18,
    D3D_PRIMITIVE_12_CONTROL_POINT_PATCH = 19,
    D3D_PRIMITIVE_13_CONTROL_POINT_PATCH = 20,
    D3D_PRIMITIVE_14_CONTROL_POINT_PATCH = 21,
    D3D_PRIMITIVE_15_CONTROL_POINT_PATCH = 22,
    D3D_PRIMITIVE_16_CONTROL_POINT_PATCH = 23,
    D3D_PRIMITIVE_17_CONTROL_POINT_PATCH = 24,
    D3D_PRIMITIVE_18_CONTROL_POINT_PATCH = 25,
    D3D_PRIMITIVE_19_CONTROL_POINT_PATCH = 26,
    D3D_PRIMITIVE_20_CONTROL_POINT_PATCH = 27,
    D3D_PRIMITIVE_21_CONTROL_POINT_PATCH = 28,
    D3D_PRIMITIVE_22_CONTROL_POINT_PATCH = 29,
    D3D_PRIMITIVE_23_CONTROL_POINT_PATCH = 30,
    D3D_PRIMITIVE_24_CONTROL_POINT_PATCH = 31,
    D3D_PRIMITIVE_25_CONTROL_POINT_PATCH = 32,
    D3D_PRIMITIVE_26_CONTROL_POINT_PATCH = 33,
    D3D_PRIMITIVE_27_CONTROL_POINT_PATCH = 34,
    D3D_PRIMITIVE_28_CONTROL_POINT_PATCH = 35,
    D3D_PRIMITIVE_29_CONTROL_POINT_PATCH = 36,
    D3D_PRIMITIVE_30_CONTROL_POINT_PATCH = 37,
    D3D_PRIMITIVE_31_CONTROL_POINT_PATCH = 38,
    D3D_PRIMITIVE_32_CONTROL_POINT_PATCH = 39,
    D3D10_PRIMITIVE_UNDEFINED = D3D_PRIMITIVE_UNDEFINED,
    D3D10_PRIMITIVE_POINT = D3D_PRIMITIVE_POINT,
    D3D10_PRIMITIVE_LINE = D3D_PRIMITIVE_LINE,
    D3D10_PRIMITIVE_TRIANGLE = D3D_PRIMITIVE_TRIANGLE,
    D3D10_PRIMITIVE_LINE_ADJ = D3D_PRIMITIVE_LINE_ADJ,
    D3D10_PRIMITIVE_TRIANGLE_ADJ = D3D_PRIMITIVE_TRIANGLE_ADJ,
    D3D11_PRIMITIVE_UNDEFINED = D3D_PRIMITIVE_UNDEFINED,
    D3D11_PRIMITIVE_POINT = D3D_PRIMITIVE_POINT,
    D3D11_PRIMITIVE_LINE = D3D_PRIMITIVE_LINE,
    D3D11_PRIMITIVE_TRIANGLE = D3D_PRIMITIVE_TRIANGLE,
    D3D11_PRIMITIVE_LINE_ADJ = D3D_PRIMITIVE_LINE_ADJ,
    D3D11_PRIMITIVE_TRIANGLE_ADJ = D3D_PRIMITIVE_TRIANGLE_ADJ,
    D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH = D3D_PRIMITIVE_1_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_2_CONTROL_POINT_PATCH = D3D_PRIMITIVE_2_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_3_CONTROL_POINT_PATCH = D3D_PRIMITIVE_3_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_4_CONTROL_POINT_PATCH = D3D_PRIMITIVE_4_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_5_CONTROL_POINT_PATCH = D3D_PRIMITIVE_5_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_6_CONTROL_POINT_PATCH = D3D_PRIMITIVE_6_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_7_CONTROL_POINT_PATCH = D3D_PRIMITIVE_7_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_8_CONTROL_POINT_PATCH = D3D_PRIMITIVE_8_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_9_CONTROL_POINT_PATCH = D3D_PRIMITIVE_9_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_10_CONTROL_POINT_PATCH = D3D_PRIMITIVE_10_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_11_CONTROL_POINT_PATCH = D3D_PRIMITIVE_11_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_12_CONTROL_POINT_PATCH = D3D_PRIMITIVE_12_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_13_CONTROL_POINT_PATCH = D3D_PRIMITIVE_13_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_14_CONTROL_POINT_PATCH = D3D_PRIMITIVE_14_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_15_CONTROL_POINT_PATCH = D3D_PRIMITIVE_15_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_16_CONTROL_POINT_PATCH = D3D_PRIMITIVE_16_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_17_CONTROL_POINT_PATCH = D3D_PRIMITIVE_17_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_18_CONTROL_POINT_PATCH = D3D_PRIMITIVE_18_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_19_CONTROL_POINT_PATCH = D3D_PRIMITIVE_19_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_20_CONTROL_POINT_PATCH = D3D_PRIMITIVE_20_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_21_CONTROL_POINT_PATCH = D3D_PRIMITIVE_21_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_22_CONTROL_POINT_PATCH = D3D_PRIMITIVE_22_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_23_CONTROL_POINT_PATCH = D3D_PRIMITIVE_23_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_24_CONTROL_POINT_PATCH = D3D_PRIMITIVE_24_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_25_CONTROL_POINT_PATCH = D3D_PRIMITIVE_25_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_26_CONTROL_POINT_PATCH = D3D_PRIMITIVE_26_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_27_CONTROL_POINT_PATCH = D3D_PRIMITIVE_27_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_28_CONTROL_POINT_PATCH = D3D_PRIMITIVE_28_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_29_CONTROL_POINT_PATCH = D3D_PRIMITIVE_29_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_30_CONTROL_POINT_PATCH = D3D_PRIMITIVE_30_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_31_CONTROL_POINT_PATCH = D3D_PRIMITIVE_31_CONTROL_POINT_PATCH,
    D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH = D3D_PRIMITIVE_32_CONTROL_POINT_PATCH
} D3D_PRIMITIVE;
typedef enum D3D_SRV_DIMENSION {
    D3D_SRV_DIMENSION_UNKNOWN = 0,
    D3D_SRV_DIMENSION_BUFFER = 1,
    D3D_SRV_DIMENSION_TEXTURE1D = 2,
    D3D_SRV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D_SRV_DIMENSION_TEXTURE2D = 4,
    D3D_SRV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D_SRV_DIMENSION_TEXTURE2DMS = 6,
    D3D_SRV_DIMENSION_TEXTURE2DMSARRAY = 7,
    D3D_SRV_DIMENSION_TEXTURE3D = 8,
    D3D_SRV_DIMENSION_TEXTURECUBE = 9,
    D3D_SRV_DIMENSION_TEXTURECUBEARRAY = 10,
    D3D_SRV_DIMENSION_BUFFEREX = 11,
    D3D10_SRV_DIMENSION_UNKNOWN = D3D_SRV_DIMENSION_UNKNOWN,
    D3D10_SRV_DIMENSION_BUFFER = D3D_SRV_DIMENSION_BUFFER,
    D3D10_SRV_DIMENSION_TEXTURE1D = D3D_SRV_DIMENSION_TEXTURE1D,
    D3D10_SRV_DIMENSION_TEXTURE1DARRAY = D3D_SRV_DIMENSION_TEXTURE1DARRAY,
    D3D10_SRV_DIMENSION_TEXTURE2D = D3D_SRV_DIMENSION_TEXTURE2D,
    D3D10_SRV_DIMENSION_TEXTURE2DARRAY = D3D_SRV_DIMENSION_TEXTURE2DARRAY,
    D3D10_SRV_DIMENSION_TEXTURE2DMS = D3D_SRV_DIMENSION_TEXTURE2DMS,
    D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY = D3D_SRV_DIMENSION_TEXTURE2DMSARRAY,
    D3D10_SRV_DIMENSION_TEXTURE3D = D3D_SRV_DIMENSION_TEXTURE3D,
    D3D10_SRV_DIMENSION_TEXTURECUBE = D3D_SRV_DIMENSION_TEXTURECUBE,
    D3D10_1_SRV_DIMENSION_UNKNOWN = D3D_SRV_DIMENSION_UNKNOWN,
    D3D10_1_SRV_DIMENSION_BUFFER = D3D_SRV_DIMENSION_BUFFER,
    D3D10_1_SRV_DIMENSION_TEXTURE1D = D3D_SRV_DIMENSION_TEXTURE1D,
    D3D10_1_SRV_DIMENSION_TEXTURE1DARRAY = D3D_SRV_DIMENSION_TEXTURE1DARRAY,
    D3D10_1_SRV_DIMENSION_TEXTURE2D = D3D_SRV_DIMENSION_TEXTURE2D,
    D3D10_1_SRV_DIMENSION_TEXTURE2DARRAY = D3D_SRV_DIMENSION_TEXTURE2DARRAY,
    D3D10_1_SRV_DIMENSION_TEXTURE2DMS = D3D_SRV_DIMENSION_TEXTURE2DMS,
    D3D10_1_SRV_DIMENSION_TEXTURE2DMSARRAY = D3D_SRV_DIMENSION_TEXTURE2DMSARRAY,
    D3D10_1_SRV_DIMENSION_TEXTURE3D = D3D_SRV_DIMENSION_TEXTURE3D,
    D3D10_1_SRV_DIMENSION_TEXTURECUBE = D3D_SRV_DIMENSION_TEXTURECUBE,
    D3D10_1_SRV_DIMENSION_TEXTURECUBEARRAY = D3D_SRV_DIMENSION_TEXTURECUBEARRAY,
    D3D11_SRV_DIMENSION_UNKNOWN = D3D_SRV_DIMENSION_UNKNOWN,
    D3D11_SRV_DIMENSION_BUFFER = D3D_SRV_DIMENSION_BUFFER,
    D3D11_SRV_DIMENSION_TEXTURE1D = D3D_SRV_DIMENSION_TEXTURE1D,
    D3D11_SRV_DIMENSION_TEXTURE1DARRAY = D3D_SRV_DIMENSION_TEXTURE1DARRAY,
    D3D11_SRV_DIMENSION_TEXTURE2D = D3D_SRV_DIMENSION_TEXTURE2D,
    D3D11_SRV_DIMENSION_TEXTURE2DARRAY = D3D_SRV_DIMENSION_TEXTURE2DARRAY,
    D3D11_SRV_DIMENSION_TEXTURE2DMS = D3D_SRV_DIMENSION_TEXTURE2DMS,
    D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY = D3D_SRV_DIMENSION_TEXTURE2DMSARRAY,
    D3D11_SRV_DIMENSION_TEXTURE3D = D3D_SRV_DIMENSION_TEXTURE3D,
    D3D11_SRV_DIMENSION_TEXTURECUBE = D3D_SRV_DIMENSION_TEXTURECUBE,
    D3D11_SRV_DIMENSION_TEXTURECUBEARRAY = D3D_SRV_DIMENSION_TEXTURECUBEARRAY,
    D3D11_SRV_DIMENSION_BUFFEREX = D3D_SRV_DIMENSION_BUFFEREX
} D3D_SRV_DIMENSION;
typedef struct _D3D_SHADER_MACRO {
    LPCSTR Name;
    LPCSTR Definition;
} D3D_SHADER_MACRO;
typedef struct _D3D_SHADER_MACRO* LPD3D_SHADER_MACRO;
extern "C" const GUID IID_ID3D10Blob;
extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Blob;
struct __declspec(uuid("8BA5FB08-5195-40e2-AC58-0D989C3A0102")) __declspec(novtable)
    ID3D10Blob : public IUnknown {
public:
    virtual LPVOID __stdcall GetBufferPointer(void) = 0;
    virtual SIZE_T __stdcall GetBufferSize(void) = 0;
};
typedef struct ID3D10Blob* LPD3D10BLOB;
typedef ID3D10Blob ID3DBlob;
typedef ID3DBlob* LPD3DBLOB;
typedef void(__stdcall* PFN_DESTRUCTION_CALLBACK)(
    void* pData);
extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0001_v0_0_s_ifspec;
extern "C" const IID IID_ID3DDestructionNotifier;
struct __declspec(uuid("a06eb39a-50da-425b-8c31-4eecd6c270f3")) __declspec(novtable)
    ID3DDestructionNotifier : public IUnknown {
public:
    virtual HRESULT __stdcall RegisterDestructionCallback(
        PFN_DESTRUCTION_CALLBACK callbackFn,
        void* pData,
        UINT* pCallbackID)
        = 0;
    virtual HRESULT __stdcall UnregisterDestructionCallback(
        UINT callbackID)
        = 0;
};
typedef enum _D3D_INCLUDE_TYPE {
    D3D_INCLUDE_LOCAL = 0,
    D3D_INCLUDE_SYSTEM = (D3D_INCLUDE_LOCAL + 1),
    D3D10_INCLUDE_LOCAL = D3D_INCLUDE_LOCAL,
    D3D10_INCLUDE_SYSTEM = D3D_INCLUDE_SYSTEM,
    D3D_INCLUDE_FORCE_DWORD = 0x7fffffff
} D3D_INCLUDE_TYPE;
typedef struct ID3DInclude ID3DInclude;
struct __declspec(novtable) ID3DInclude {
    virtual __declspec(nothrow) HRESULT __stdcall Open(D3D_INCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID* ppData, UINT* pBytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Close(LPCVOID pData) = 0;
};
typedef ID3DInclude* LPD3DINCLUDE;
typedef enum _D3D_SHADER_VARIABLE_CLASS {
    D3D_SVC_SCALAR = 0,
    D3D_SVC_VECTOR = (D3D_SVC_SCALAR + 1),
    D3D_SVC_MATRIX_ROWS = (D3D_SVC_VECTOR + 1),
    D3D_SVC_MATRIX_COLUMNS = (D3D_SVC_MATRIX_ROWS + 1),
    D3D_SVC_OBJECT = (D3D_SVC_MATRIX_COLUMNS + 1),
    D3D_SVC_STRUCT = (D3D_SVC_OBJECT + 1),
    D3D_SVC_INTERFACE_CLASS = (D3D_SVC_STRUCT + 1),
    D3D_SVC_INTERFACE_POINTER = (D3D_SVC_INTERFACE_CLASS + 1),
    D3D10_SVC_SCALAR = D3D_SVC_SCALAR,
    D3D10_SVC_VECTOR = D3D_SVC_VECTOR,
    D3D10_SVC_MATRIX_ROWS = D3D_SVC_MATRIX_ROWS,
    D3D10_SVC_MATRIX_COLUMNS = D3D_SVC_MATRIX_COLUMNS,
    D3D10_SVC_OBJECT = D3D_SVC_OBJECT,
    D3D10_SVC_STRUCT = D3D_SVC_STRUCT,
    D3D11_SVC_INTERFACE_CLASS = D3D_SVC_INTERFACE_CLASS,
    D3D11_SVC_INTERFACE_POINTER = D3D_SVC_INTERFACE_POINTER,
    D3D_SVC_FORCE_DWORD = 0x7fffffff
} D3D_SHADER_VARIABLE_CLASS;
typedef enum _D3D_SHADER_VARIABLE_FLAGS {
    D3D_SVF_USERPACKED = 1,
    D3D_SVF_USED = 2,
    D3D_SVF_INTERFACE_POINTER = 4,
    D3D_SVF_INTERFACE_PARAMETER = 8,
    D3D10_SVF_USERPACKED = D3D_SVF_USERPACKED,
    D3D10_SVF_USED = D3D_SVF_USED,
    D3D11_SVF_INTERFACE_POINTER = D3D_SVF_INTERFACE_POINTER,
    D3D11_SVF_INTERFACE_PARAMETER = D3D_SVF_INTERFACE_PARAMETER,
    D3D_SVF_FORCE_DWORD = 0x7fffffff
} D3D_SHADER_VARIABLE_FLAGS;
typedef enum _D3D_SHADER_VARIABLE_TYPE {
    D3D_SVT_VOID = 0,
    D3D_SVT_BOOL = 1,
    D3D_SVT_INT = 2,
    D3D_SVT_FLOAT = 3,
    D3D_SVT_STRING = 4,
    D3D_SVT_TEXTURE = 5,
    D3D_SVT_TEXTURE1D = 6,
    D3D_SVT_TEXTURE2D = 7,
    D3D_SVT_TEXTURE3D = 8,
    D3D_SVT_TEXTURECUBE = 9,
    D3D_SVT_SAMPLER = 10,
    D3D_SVT_SAMPLER1D = 11,
    D3D_SVT_SAMPLER2D = 12,
    D3D_SVT_SAMPLER3D = 13,
    D3D_SVT_SAMPLERCUBE = 14,
    D3D_SVT_PIXELSHADER = 15,
    D3D_SVT_VERTEXSHADER = 16,
    D3D_SVT_PIXELFRAGMENT = 17,
    D3D_SVT_VERTEXFRAGMENT = 18,
    D3D_SVT_UINT = 19,
    D3D_SVT_UINT8 = 20,
    D3D_SVT_GEOMETRYSHADER = 21,
    D3D_SVT_RASTERIZER = 22,
    D3D_SVT_DEPTHSTENCIL = 23,
    D3D_SVT_BLEND = 24,
    D3D_SVT_BUFFER = 25,
    D3D_SVT_CBUFFER = 26,
    D3D_SVT_TBUFFER = 27,
    D3D_SVT_TEXTURE1DARRAY = 28,
    D3D_SVT_TEXTURE2DARRAY = 29,
    D3D_SVT_RENDERTARGETVIEW = 30,
    D3D_SVT_DEPTHSTENCILVIEW = 31,
    D3D_SVT_TEXTURE2DMS = 32,
    D3D_SVT_TEXTURE2DMSARRAY = 33,
    D3D_SVT_TEXTURECUBEARRAY = 34,
    D3D_SVT_HULLSHADER = 35,
    D3D_SVT_DOMAINSHADER = 36,
    D3D_SVT_INTERFACE_POINTER = 37,
    D3D_SVT_COMPUTESHADER = 38,
    D3D_SVT_DOUBLE = 39,
    D3D_SVT_RWTEXTURE1D = 40,
    D3D_SVT_RWTEXTURE1DARRAY = 41,
    D3D_SVT_RWTEXTURE2D = 42,
    D3D_SVT_RWTEXTURE2DARRAY = 43,
    D3D_SVT_RWTEXTURE3D = 44,
    D3D_SVT_RWBUFFER = 45,
    D3D_SVT_BYTEADDRESS_BUFFER = 46,
    D3D_SVT_RWBYTEADDRESS_BUFFER = 47,
    D3D_SVT_STRUCTURED_BUFFER = 48,
    D3D_SVT_RWSTRUCTURED_BUFFER = 49,
    D3D_SVT_APPEND_STRUCTURED_BUFFER = 50,
    D3D_SVT_CONSUME_STRUCTURED_BUFFER = 51,
    D3D_SVT_MIN8FLOAT = 52,
    D3D_SVT_MIN10FLOAT = 53,
    D3D_SVT_MIN16FLOAT = 54,
    D3D_SVT_MIN12INT = 55,
    D3D_SVT_MIN16INT = 56,
    D3D_SVT_MIN16UINT = 57,
    D3D_SVT_INT16 = 58,
    D3D_SVT_UINT16 = 59,
    D3D_SVT_FLOAT16 = 60,
    D3D_SVT_INT64 = 61,
    D3D_SVT_UINT64 = 62,
    D3D10_SVT_VOID = D3D_SVT_VOID,
    D3D10_SVT_BOOL = D3D_SVT_BOOL,
    D3D10_SVT_INT = D3D_SVT_INT,
    D3D10_SVT_FLOAT = D3D_SVT_FLOAT,
    D3D10_SVT_STRING = D3D_SVT_STRING,
    D3D10_SVT_TEXTURE = D3D_SVT_TEXTURE,
    D3D10_SVT_TEXTURE1D = D3D_SVT_TEXTURE1D,
    D3D10_SVT_TEXTURE2D = D3D_SVT_TEXTURE2D,
    D3D10_SVT_TEXTURE3D = D3D_SVT_TEXTURE3D,
    D3D10_SVT_TEXTURECUBE = D3D_SVT_TEXTURECUBE,
    D3D10_SVT_SAMPLER = D3D_SVT_SAMPLER,
    D3D10_SVT_SAMPLER1D = D3D_SVT_SAMPLER1D,
    D3D10_SVT_SAMPLER2D = D3D_SVT_SAMPLER2D,
    D3D10_SVT_SAMPLER3D = D3D_SVT_SAMPLER3D,
    D3D10_SVT_SAMPLERCUBE = D3D_SVT_SAMPLERCUBE,
    D3D10_SVT_PIXELSHADER = D3D_SVT_PIXELSHADER,
    D3D10_SVT_VERTEXSHADER = D3D_SVT_VERTEXSHADER,
    D3D10_SVT_PIXELFRAGMENT = D3D_SVT_PIXELFRAGMENT,
    D3D10_SVT_VERTEXFRAGMENT = D3D_SVT_VERTEXFRAGMENT,
    D3D10_SVT_UINT = D3D_SVT_UINT,
    D3D10_SVT_UINT8 = D3D_SVT_UINT8,
    D3D10_SVT_GEOMETRYSHADER = D3D_SVT_GEOMETRYSHADER,
    D3D10_SVT_RASTERIZER = D3D_SVT_RASTERIZER,
    D3D10_SVT_DEPTHSTENCIL = D3D_SVT_DEPTHSTENCIL,
    D3D10_SVT_BLEND = D3D_SVT_BLEND,
    D3D10_SVT_BUFFER = D3D_SVT_BUFFER,
    D3D10_SVT_CBUFFER = D3D_SVT_CBUFFER,
    D3D10_SVT_TBUFFER = D3D_SVT_TBUFFER,
    D3D10_SVT_TEXTURE1DARRAY = D3D_SVT_TEXTURE1DARRAY,
    D3D10_SVT_TEXTURE2DARRAY = D3D_SVT_TEXTURE2DARRAY,
    D3D10_SVT_RENDERTARGETVIEW = D3D_SVT_RENDERTARGETVIEW,
    D3D10_SVT_DEPTHSTENCILVIEW = D3D_SVT_DEPTHSTENCILVIEW,
    D3D10_SVT_TEXTURE2DMS = D3D_SVT_TEXTURE2DMS,
    D3D10_SVT_TEXTURE2DMSARRAY = D3D_SVT_TEXTURE2DMSARRAY,
    D3D10_SVT_TEXTURECUBEARRAY = D3D_SVT_TEXTURECUBEARRAY,
    D3D11_SVT_HULLSHADER = D3D_SVT_HULLSHADER,
    D3D11_SVT_DOMAINSHADER = D3D_SVT_DOMAINSHADER,
    D3D11_SVT_INTERFACE_POINTER = D3D_SVT_INTERFACE_POINTER,
    D3D11_SVT_COMPUTESHADER = D3D_SVT_COMPUTESHADER,
    D3D11_SVT_DOUBLE = D3D_SVT_DOUBLE,
    D3D11_SVT_RWTEXTURE1D = D3D_SVT_RWTEXTURE1D,
    D3D11_SVT_RWTEXTURE1DARRAY = D3D_SVT_RWTEXTURE1DARRAY,
    D3D11_SVT_RWTEXTURE2D = D3D_SVT_RWTEXTURE2D,
    D3D11_SVT_RWTEXTURE2DARRAY = D3D_SVT_RWTEXTURE2DARRAY,
    D3D11_SVT_RWTEXTURE3D = D3D_SVT_RWTEXTURE3D,
    D3D11_SVT_RWBUFFER = D3D_SVT_RWBUFFER,
    D3D11_SVT_BYTEADDRESS_BUFFER = D3D_SVT_BYTEADDRESS_BUFFER,
    D3D11_SVT_RWBYTEADDRESS_BUFFER = D3D_SVT_RWBYTEADDRESS_BUFFER,
    D3D11_SVT_STRUCTURED_BUFFER = D3D_SVT_STRUCTURED_BUFFER,
    D3D11_SVT_RWSTRUCTURED_BUFFER = D3D_SVT_RWSTRUCTURED_BUFFER,
    D3D11_SVT_APPEND_STRUCTURED_BUFFER = D3D_SVT_APPEND_STRUCTURED_BUFFER,
    D3D11_SVT_CONSUME_STRUCTURED_BUFFER = D3D_SVT_CONSUME_STRUCTURED_BUFFER,
    D3D_SVT_FORCE_DWORD = 0x7fffffff
} D3D_SHADER_VARIABLE_TYPE;
typedef enum _D3D_SHADER_INPUT_FLAGS {
    D3D_SIF_USERPACKED = 0x1,
    D3D_SIF_COMPARISON_SAMPLER = 0x2,
    D3D_SIF_TEXTURE_COMPONENT_0 = 0x4,
    D3D_SIF_TEXTURE_COMPONENT_1 = 0x8,
    D3D_SIF_TEXTURE_COMPONENTS = 0xc,
    D3D_SIF_UNUSED = 0x10,
    D3D10_SIF_USERPACKED = D3D_SIF_USERPACKED,
    D3D10_SIF_COMPARISON_SAMPLER = D3D_SIF_COMPARISON_SAMPLER,
    D3D10_SIF_TEXTURE_COMPONENT_0 = D3D_SIF_TEXTURE_COMPONENT_0,
    D3D10_SIF_TEXTURE_COMPONENT_1 = D3D_SIF_TEXTURE_COMPONENT_1,
    D3D10_SIF_TEXTURE_COMPONENTS = D3D_SIF_TEXTURE_COMPONENTS,
    D3D_SIF_FORCE_DWORD = 0x7fffffff
} D3D_SHADER_INPUT_FLAGS;
typedef enum _D3D_SHADER_INPUT_TYPE {
    D3D_SIT_CBUFFER = 0,
    D3D_SIT_TBUFFER = (D3D_SIT_CBUFFER + 1),
    D3D_SIT_TEXTURE = (D3D_SIT_TBUFFER + 1),
    D3D_SIT_SAMPLER = (D3D_SIT_TEXTURE + 1),
    D3D_SIT_UAV_RWTYPED = (D3D_SIT_SAMPLER + 1),
    D3D_SIT_STRUCTURED = (D3D_SIT_UAV_RWTYPED + 1),
    D3D_SIT_UAV_RWSTRUCTURED = (D3D_SIT_STRUCTURED + 1),
    D3D_SIT_BYTEADDRESS = (D3D_SIT_UAV_RWSTRUCTURED + 1),
    D3D_SIT_UAV_RWBYTEADDRESS = (D3D_SIT_BYTEADDRESS + 1),
    D3D_SIT_UAV_APPEND_STRUCTURED = (D3D_SIT_UAV_RWBYTEADDRESS + 1),
    D3D_SIT_UAV_CONSUME_STRUCTURED = (D3D_SIT_UAV_APPEND_STRUCTURED + 1),
    D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER = (D3D_SIT_UAV_CONSUME_STRUCTURED + 1),
    D3D_SIT_RTACCELERATIONSTRUCTURE = (D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER + 1),
    D3D_SIT_UAV_FEEDBACKTEXTURE = (D3D_SIT_RTACCELERATIONSTRUCTURE + 1),
    D3D10_SIT_CBUFFER = D3D_SIT_CBUFFER,
    D3D10_SIT_TBUFFER = D3D_SIT_TBUFFER,
    D3D10_SIT_TEXTURE = D3D_SIT_TEXTURE,
    D3D10_SIT_SAMPLER = D3D_SIT_SAMPLER,
    D3D11_SIT_UAV_RWTYPED = D3D_SIT_UAV_RWTYPED,
    D3D11_SIT_STRUCTURED = D3D_SIT_STRUCTURED,
    D3D11_SIT_UAV_RWSTRUCTURED = D3D_SIT_UAV_RWSTRUCTURED,
    D3D11_SIT_BYTEADDRESS = D3D_SIT_BYTEADDRESS,
    D3D11_SIT_UAV_RWBYTEADDRESS = D3D_SIT_UAV_RWBYTEADDRESS,
    D3D11_SIT_UAV_APPEND_STRUCTURED = D3D_SIT_UAV_APPEND_STRUCTURED,
    D3D11_SIT_UAV_CONSUME_STRUCTURED = D3D_SIT_UAV_CONSUME_STRUCTURED,
    D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER = D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER
} D3D_SHADER_INPUT_TYPE;
typedef enum _D3D_SHADER_CBUFFER_FLAGS {
    D3D_CBF_USERPACKED = 1,
    D3D10_CBF_USERPACKED = D3D_CBF_USERPACKED,
    D3D_CBF_FORCE_DWORD = 0x7fffffff
} D3D_SHADER_CBUFFER_FLAGS;
typedef enum _D3D_CBUFFER_TYPE {
    D3D_CT_CBUFFER = 0,
    D3D_CT_TBUFFER = (D3D_CT_CBUFFER + 1),
    D3D_CT_INTERFACE_POINTERS = (D3D_CT_TBUFFER + 1),
    D3D_CT_RESOURCE_BIND_INFO = (D3D_CT_INTERFACE_POINTERS + 1),
    D3D10_CT_CBUFFER = D3D_CT_CBUFFER,
    D3D10_CT_TBUFFER = D3D_CT_TBUFFER,
    D3D11_CT_CBUFFER = D3D_CT_CBUFFER,
    D3D11_CT_TBUFFER = D3D_CT_TBUFFER,
    D3D11_CT_INTERFACE_POINTERS = D3D_CT_INTERFACE_POINTERS,
    D3D11_CT_RESOURCE_BIND_INFO = D3D_CT_RESOURCE_BIND_INFO
} D3D_CBUFFER_TYPE;
typedef enum D3D_NAME {
    D3D_NAME_UNDEFINED = 0,
    D3D_NAME_POSITION = 1,
    D3D_NAME_CLIP_DISTANCE = 2,
    D3D_NAME_CULL_DISTANCE = 3,
    D3D_NAME_RENDER_TARGET_ARRAY_INDEX = 4,
    D3D_NAME_VIEWPORT_ARRAY_INDEX = 5,
    D3D_NAME_VERTEX_ID = 6,
    D3D_NAME_PRIMITIVE_ID = 7,
    D3D_NAME_INSTANCE_ID = 8,
    D3D_NAME_IS_FRONT_FACE = 9,
    D3D_NAME_SAMPLE_INDEX = 10,
    D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR = 11,
    D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR = 12,
    D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR = 13,
    D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR = 14,
    D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR = 15,
    D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR = 16,
    D3D_NAME_BARYCENTRICS = 23,
    D3D_NAME_SHADINGRATE = 24,
    D3D_NAME_CULLPRIMITIVE = 25,
    D3D_NAME_TARGET = 64,
    D3D_NAME_DEPTH = 65,
    D3D_NAME_COVERAGE = 66,
    D3D_NAME_DEPTH_GREATER_EQUAL = 67,
    D3D_NAME_DEPTH_LESS_EQUAL = 68,
    D3D_NAME_STENCIL_REF = 69,
    D3D_NAME_INNER_COVERAGE = 70,
    D3D10_NAME_UNDEFINED = D3D_NAME_UNDEFINED,
    D3D10_NAME_POSITION = D3D_NAME_POSITION,
    D3D10_NAME_CLIP_DISTANCE = D3D_NAME_CLIP_DISTANCE,
    D3D10_NAME_CULL_DISTANCE = D3D_NAME_CULL_DISTANCE,
    D3D10_NAME_RENDER_TARGET_ARRAY_INDEX = D3D_NAME_RENDER_TARGET_ARRAY_INDEX,
    D3D10_NAME_VIEWPORT_ARRAY_INDEX = D3D_NAME_VIEWPORT_ARRAY_INDEX,
    D3D10_NAME_VERTEX_ID = D3D_NAME_VERTEX_ID,
    D3D10_NAME_PRIMITIVE_ID = D3D_NAME_PRIMITIVE_ID,
    D3D10_NAME_INSTANCE_ID = D3D_NAME_INSTANCE_ID,
    D3D10_NAME_IS_FRONT_FACE = D3D_NAME_IS_FRONT_FACE,
    D3D10_NAME_SAMPLE_INDEX = D3D_NAME_SAMPLE_INDEX,
    D3D10_NAME_TARGET = D3D_NAME_TARGET,
    D3D10_NAME_DEPTH = D3D_NAME_DEPTH,
    D3D10_NAME_COVERAGE = D3D_NAME_COVERAGE,
    D3D11_NAME_FINAL_QUAD_EDGE_TESSFACTOR = D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR,
    D3D11_NAME_FINAL_QUAD_INSIDE_TESSFACTOR = D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR,
    D3D11_NAME_FINAL_TRI_EDGE_TESSFACTOR = D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR,
    D3D11_NAME_FINAL_TRI_INSIDE_TESSFACTOR = D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR,
    D3D11_NAME_FINAL_LINE_DETAIL_TESSFACTOR = D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR,
    D3D11_NAME_FINAL_LINE_DENSITY_TESSFACTOR = D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR,
    D3D11_NAME_DEPTH_GREATER_EQUAL = D3D_NAME_DEPTH_GREATER_EQUAL,
    D3D11_NAME_DEPTH_LESS_EQUAL = D3D_NAME_DEPTH_LESS_EQUAL,
    D3D11_NAME_STENCIL_REF = D3D_NAME_STENCIL_REF,
    D3D11_NAME_INNER_COVERAGE = D3D_NAME_INNER_COVERAGE,
    D3D12_NAME_BARYCENTRICS = D3D_NAME_BARYCENTRICS,
    D3D12_NAME_SHADINGRATE = D3D_NAME_SHADINGRATE,
    D3D12_NAME_CULLPRIMITIVE = D3D_NAME_CULLPRIMITIVE
} D3D_NAME;
typedef enum D3D_RESOURCE_RETURN_TYPE {
    D3D_RETURN_TYPE_UNORM = 1,
    D3D_RETURN_TYPE_SNORM = 2,
    D3D_RETURN_TYPE_SINT = 3,
    D3D_RETURN_TYPE_UINT = 4,
    D3D_RETURN_TYPE_FLOAT = 5,
    D3D_RETURN_TYPE_MIXED = 6,
    D3D_RETURN_TYPE_DOUBLE = 7,
    D3D_RETURN_TYPE_CONTINUED = 8,
    D3D10_RETURN_TYPE_UNORM = D3D_RETURN_TYPE_UNORM,
    D3D10_RETURN_TYPE_SNORM = D3D_RETURN_TYPE_SNORM,
    D3D10_RETURN_TYPE_SINT = D3D_RETURN_TYPE_SINT,
    D3D10_RETURN_TYPE_UINT = D3D_RETURN_TYPE_UINT,
    D3D10_RETURN_TYPE_FLOAT = D3D_RETURN_TYPE_FLOAT,
    D3D10_RETURN_TYPE_MIXED = D3D_RETURN_TYPE_MIXED,
    D3D11_RETURN_TYPE_UNORM = D3D_RETURN_TYPE_UNORM,
    D3D11_RETURN_TYPE_SNORM = D3D_RETURN_TYPE_SNORM,
    D3D11_RETURN_TYPE_SINT = D3D_RETURN_TYPE_SINT,
    D3D11_RETURN_TYPE_UINT = D3D_RETURN_TYPE_UINT,
    D3D11_RETURN_TYPE_FLOAT = D3D_RETURN_TYPE_FLOAT,
    D3D11_RETURN_TYPE_MIXED = D3D_RETURN_TYPE_MIXED,
    D3D11_RETURN_TYPE_DOUBLE = D3D_RETURN_TYPE_DOUBLE,
    D3D11_RETURN_TYPE_CONTINUED = D3D_RETURN_TYPE_CONTINUED
} D3D_RESOURCE_RETURN_TYPE;
typedef enum D3D_REGISTER_COMPONENT_TYPE {
    D3D_REGISTER_COMPONENT_UNKNOWN = 0,
    D3D_REGISTER_COMPONENT_UINT32 = 1,
    D3D_REGISTER_COMPONENT_SINT32 = 2,
    D3D_REGISTER_COMPONENT_FLOAT32 = 3,
    D3D10_REGISTER_COMPONENT_UNKNOWN = D3D_REGISTER_COMPONENT_UNKNOWN,
    D3D10_REGISTER_COMPONENT_UINT32 = D3D_REGISTER_COMPONENT_UINT32,
    D3D10_REGISTER_COMPONENT_SINT32 = D3D_REGISTER_COMPONENT_SINT32,
    D3D10_REGISTER_COMPONENT_FLOAT32 = D3D_REGISTER_COMPONENT_FLOAT32
} D3D_REGISTER_COMPONENT_TYPE;
typedef enum D3D_TESSELLATOR_DOMAIN {
    D3D_TESSELLATOR_DOMAIN_UNDEFINED = 0,
    D3D_TESSELLATOR_DOMAIN_ISOLINE = 1,
    D3D_TESSELLATOR_DOMAIN_TRI = 2,
    D3D_TESSELLATOR_DOMAIN_QUAD = 3,
    D3D11_TESSELLATOR_DOMAIN_UNDEFINED = D3D_TESSELLATOR_DOMAIN_UNDEFINED,
    D3D11_TESSELLATOR_DOMAIN_ISOLINE = D3D_TESSELLATOR_DOMAIN_ISOLINE,
    D3D11_TESSELLATOR_DOMAIN_TRI = D3D_TESSELLATOR_DOMAIN_TRI,
    D3D11_TESSELLATOR_DOMAIN_QUAD = D3D_TESSELLATOR_DOMAIN_QUAD
} D3D_TESSELLATOR_DOMAIN;
typedef enum D3D_TESSELLATOR_PARTITIONING {
    D3D_TESSELLATOR_PARTITIONING_UNDEFINED = 0,
    D3D_TESSELLATOR_PARTITIONING_INTEGER = 1,
    D3D_TESSELLATOR_PARTITIONING_POW2 = 2,
    D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD = 3,
    D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN = 4,
    D3D11_TESSELLATOR_PARTITIONING_UNDEFINED = D3D_TESSELLATOR_PARTITIONING_UNDEFINED,
    D3D11_TESSELLATOR_PARTITIONING_INTEGER = D3D_TESSELLATOR_PARTITIONING_INTEGER,
    D3D11_TESSELLATOR_PARTITIONING_POW2 = D3D_TESSELLATOR_PARTITIONING_POW2,
    D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD = D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD,
    D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN = D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN
} D3D_TESSELLATOR_PARTITIONING;
typedef enum D3D_TESSELLATOR_OUTPUT_PRIMITIVE {
    D3D_TESSELLATOR_OUTPUT_UNDEFINED = 0,
    D3D_TESSELLATOR_OUTPUT_POINT = 1,
    D3D_TESSELLATOR_OUTPUT_LINE = 2,
    D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW = 3,
    D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW = 4,
    D3D11_TESSELLATOR_OUTPUT_UNDEFINED = D3D_TESSELLATOR_OUTPUT_UNDEFINED,
    D3D11_TESSELLATOR_OUTPUT_POINT = D3D_TESSELLATOR_OUTPUT_POINT,
    D3D11_TESSELLATOR_OUTPUT_LINE = D3D_TESSELLATOR_OUTPUT_LINE,
    D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CW = D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW,
    D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CCW = D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW
} D3D_TESSELLATOR_OUTPUT_PRIMITIVE;
typedef enum D3D_MIN_PRECISION {
    D3D_MIN_PRECISION_DEFAULT = 0,
    D3D_MIN_PRECISION_FLOAT_16 = 1,
    D3D_MIN_PRECISION_FLOAT_2_8 = 2,
    D3D_MIN_PRECISION_RESERVED = 3,
    D3D_MIN_PRECISION_SINT_16 = 4,
    D3D_MIN_PRECISION_UINT_16 = 5,
    D3D_MIN_PRECISION_ANY_16 = 0xf0,
    D3D_MIN_PRECISION_ANY_10 = 0xf1
} D3D_MIN_PRECISION;
typedef enum D3D_INTERPOLATION_MODE {
    D3D_INTERPOLATION_UNDEFINED = 0,
    D3D_INTERPOLATION_CONSTANT = 1,
    D3D_INTERPOLATION_LINEAR = 2,
    D3D_INTERPOLATION_LINEAR_CENTROID = 3,
    D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE = 4,
    D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE_CENTROID = 5,
    D3D_INTERPOLATION_LINEAR_SAMPLE = 6,
    D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE_SAMPLE = 7
} D3D_INTERPOLATION_MODE;
typedef enum _D3D_PARAMETER_FLAGS {
    D3D_PF_NONE = 0,
    D3D_PF_IN = 0x1,
    D3D_PF_OUT = 0x2,
    D3D_PF_FORCE_DWORD = 0x7fffffff
} D3D_PARAMETER_FLAGS;
extern "C" const GUID WKPDID_D3DDebugObjectName;
extern "C" const GUID WKPDID_D3DDebugObjectNameW;
extern "C" const GUID WKPDID_CommentStringW;
extern "C" const GUID WKPDID_D3D12UniqueObjectId;
extern "C" const GUID D3D_TEXTURE_LAYOUT_ROW_MAJOR;
extern "C" const GUID D3D_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE;
extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3dcommon_0000_0002_v0_0_s_ifspec;
}
extern "C" {
}
struct CD3D11_DEFAULT {
};
extern const __declspec(selectany) CD3D11_DEFAULT D3D11_DEFAULT;
extern "C" {
typedef enum D3D11_INPUT_CLASSIFICATION {
    D3D11_INPUT_PER_VERTEX_DATA = 0,
    D3D11_INPUT_PER_INSTANCE_DATA = 1
} D3D11_INPUT_CLASSIFICATION;
typedef struct D3D11_INPUT_ELEMENT_DESC {
    LPCSTR SemanticName;
    UINT SemanticIndex;
    DXGI_FORMAT Format;
    UINT InputSlot;
    UINT AlignedByteOffset;
    D3D11_INPUT_CLASSIFICATION InputSlotClass;
    UINT InstanceDataStepRate;
} D3D11_INPUT_ELEMENT_DESC;
typedef enum D3D11_FILL_MODE {
    D3D11_FILL_WIREFRAME = 2,
    D3D11_FILL_SOLID = 3
} D3D11_FILL_MODE;
typedef D3D_PRIMITIVE_TOPOLOGY D3D11_PRIMITIVE_TOPOLOGY;
typedef D3D_PRIMITIVE D3D11_PRIMITIVE;
typedef enum D3D11_CULL_MODE {
    D3D11_CULL_NONE = 1,
    D3D11_CULL_FRONT = 2,
    D3D11_CULL_BACK = 3
} D3D11_CULL_MODE;
typedef struct D3D11_SO_DECLARATION_ENTRY {
    UINT Stream;
    LPCSTR SemanticName;
    UINT SemanticIndex;
    BYTE StartComponent;
    BYTE ComponentCount;
    BYTE OutputSlot;
} D3D11_SO_DECLARATION_ENTRY;
typedef struct D3D11_VIEWPORT {
    FLOAT TopLeftX;
    FLOAT TopLeftY;
    FLOAT Width;
    FLOAT Height;
    FLOAT MinDepth;
    FLOAT MaxDepth;
} D3D11_VIEWPORT;
}
inline bool operator==(const D3D11_VIEWPORT& l, const D3D11_VIEWPORT& r)
{
    return l.TopLeftX == r.TopLeftX && l.TopLeftY == r.TopLeftY && l.Width == r.Width && l.Height == r.Height && l.MinDepth == r.MinDepth && l.MaxDepth == r.MaxDepth;
}
inline bool operator!=(const D3D11_VIEWPORT& l, const D3D11_VIEWPORT& r)
{
    return !(l == r);
}
extern "C" {
typedef struct D3D11_DRAW_INSTANCED_INDIRECT_ARGS {
    UINT VertexCountPerInstance;
    UINT InstanceCount;
    UINT StartVertexLocation;
    UINT StartInstanceLocation;
} D3D11_DRAW_INSTANCED_INDIRECT_ARGS;
typedef struct D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS {
    UINT IndexCountPerInstance;
    UINT InstanceCount;
    UINT StartIndexLocation;
    INT BaseVertexLocation;
    UINT StartInstanceLocation;
} D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS;
typedef enum D3D11_RESOURCE_DIMENSION {
    D3D11_RESOURCE_DIMENSION_UNKNOWN = 0,
    D3D11_RESOURCE_DIMENSION_BUFFER = 1,
    D3D11_RESOURCE_DIMENSION_TEXTURE1D = 2,
    D3D11_RESOURCE_DIMENSION_TEXTURE2D = 3,
    D3D11_RESOURCE_DIMENSION_TEXTURE3D = 4
} D3D11_RESOURCE_DIMENSION;
typedef D3D_SRV_DIMENSION D3D11_SRV_DIMENSION;
typedef enum D3D11_DSV_DIMENSION {
    D3D11_DSV_DIMENSION_UNKNOWN = 0,
    D3D11_DSV_DIMENSION_TEXTURE1D = 1,
    D3D11_DSV_DIMENSION_TEXTURE1DARRAY = 2,
    D3D11_DSV_DIMENSION_TEXTURE2D = 3,
    D3D11_DSV_DIMENSION_TEXTURE2DARRAY = 4,
    D3D11_DSV_DIMENSION_TEXTURE2DMS = 5,
    D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY = 6
} D3D11_DSV_DIMENSION;
typedef enum D3D11_RTV_DIMENSION {
    D3D11_RTV_DIMENSION_UNKNOWN = 0,
    D3D11_RTV_DIMENSION_BUFFER = 1,
    D3D11_RTV_DIMENSION_TEXTURE1D = 2,
    D3D11_RTV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D11_RTV_DIMENSION_TEXTURE2D = 4,
    D3D11_RTV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D11_RTV_DIMENSION_TEXTURE2DMS = 6,
    D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY = 7,
    D3D11_RTV_DIMENSION_TEXTURE3D = 8
} D3D11_RTV_DIMENSION;
typedef enum D3D11_UAV_DIMENSION {
    D3D11_UAV_DIMENSION_UNKNOWN = 0,
    D3D11_UAV_DIMENSION_BUFFER = 1,
    D3D11_UAV_DIMENSION_TEXTURE1D = 2,
    D3D11_UAV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D11_UAV_DIMENSION_TEXTURE2D = 4,
    D3D11_UAV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D11_UAV_DIMENSION_TEXTURE3D = 8
} D3D11_UAV_DIMENSION;
typedef enum D3D11_USAGE {
    D3D11_USAGE_DEFAULT = 0,
    D3D11_USAGE_IMMUTABLE = 1,
    D3D11_USAGE_DYNAMIC = 2,
    D3D11_USAGE_STAGING = 3
} D3D11_USAGE;
typedef enum D3D11_BIND_FLAG {
    D3D11_BIND_VERTEX_BUFFER = 0x1L,
    D3D11_BIND_INDEX_BUFFER = 0x2L,
    D3D11_BIND_CONSTANT_BUFFER = 0x4L,
    D3D11_BIND_SHADER_RESOURCE = 0x8L,
    D3D11_BIND_STREAM_OUTPUT = 0x10L,
    D3D11_BIND_RENDER_TARGET = 0x20L,
    D3D11_BIND_DEPTH_STENCIL = 0x40L,
    D3D11_BIND_UNORDERED_ACCESS = 0x80L,
    D3D11_BIND_DECODER = 0x200L,
    D3D11_BIND_VIDEO_ENCODER = 0x400L
} D3D11_BIND_FLAG;
typedef enum D3D11_CPU_ACCESS_FLAG {
    D3D11_CPU_ACCESS_WRITE = 0x10000L,
    D3D11_CPU_ACCESS_READ = 0x20000L
} D3D11_CPU_ACCESS_FLAG;
typedef enum D3D11_RESOURCE_MISC_FLAG {
    D3D11_RESOURCE_MISC_GENERATE_MIPS = 0x1L,
    D3D11_RESOURCE_MISC_SHARED = 0x2L,
    D3D11_RESOURCE_MISC_TEXTURECUBE = 0x4L,
    D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS = 0x10L,
    D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS = 0x20L,
    D3D11_RESOURCE_MISC_BUFFER_STRUCTURED = 0x40L,
    D3D11_RESOURCE_MISC_RESOURCE_CLAMP = 0x80L,
    D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX = 0x100L,
    D3D11_RESOURCE_MISC_GDI_COMPATIBLE = 0x200L,
    D3D11_RESOURCE_MISC_SHARED_NTHANDLE = 0x800L,
    D3D11_RESOURCE_MISC_RESTRICTED_CONTENT = 0x1000L,
    D3D11_RESOURCE_MISC_RESTRICT_SHARED_RESOURCE = 0x2000L,
    D3D11_RESOURCE_MISC_RESTRICT_SHARED_RESOURCE_DRIVER = 0x4000L,
    D3D11_RESOURCE_MISC_GUARDED = 0x8000L,
    D3D11_RESOURCE_MISC_TILE_POOL = 0x20000L,
    D3D11_RESOURCE_MISC_TILED = 0x40000L,
    D3D11_RESOURCE_MISC_HW_PROTECTED = 0x80000L,
    D3D11_RESOURCE_MISC_SHARED_DISPLAYABLE = 0x100000L,
    D3D11_RESOURCE_MISC_SHARED_EXCLUSIVE_WRITER = 0x200000L
} D3D11_RESOURCE_MISC_FLAG;
typedef enum D3D11_MAP {
    D3D11_MAP_READ = 1,
    D3D11_MAP_WRITE = 2,
    D3D11_MAP_READ_WRITE = 3,
    D3D11_MAP_WRITE_DISCARD = 4,
    D3D11_MAP_WRITE_NO_OVERWRITE = 5
} D3D11_MAP;
typedef enum D3D11_MAP_FLAG {
    D3D11_MAP_FLAG_DO_NOT_WAIT = 0x100000L
} D3D11_MAP_FLAG;
typedef enum D3D11_RAISE_FLAG {
    D3D11_RAISE_FLAG_DRIVER_INTERNAL_ERROR = 0x1L
} D3D11_RAISE_FLAG;
typedef enum D3D11_CLEAR_FLAG {
    D3D11_CLEAR_DEPTH = 0x1L,
    D3D11_CLEAR_STENCIL = 0x2L
} D3D11_CLEAR_FLAG;
typedef RECT D3D11_RECT;
}
struct CD3D11_RECT : public D3D11_RECT {
    CD3D11_RECT() = default;
    explicit CD3D11_RECT(const D3D11_RECT& o)
        : D3D11_RECT(o)
    {
    }
    explicit CD3D11_RECT(
        LONG Left,
        LONG Top,
        LONG Right,
        LONG Bottom)
    {
        left = Left;
        top = Top;
        right = Right;
        bottom = Bottom;
    }
    ~CD3D11_RECT() { }
};
inline bool operator==(const D3D11_RECT& l, const D3D11_RECT& r)
{
    return l.left == r.left && l.top == r.top && l.right == r.right && l.bottom == r.bottom;
}
inline bool operator!=(const D3D11_RECT& l, const D3D11_RECT& r)
{
    return !(l == r);
}
extern "C" {
typedef struct D3D11_BOX {
    UINT left;
    UINT top;
    UINT front;
    UINT right;
    UINT bottom;
    UINT back;
} D3D11_BOX;
}
struct CD3D11_BOX : public D3D11_BOX {
    CD3D11_BOX() = default;
    explicit CD3D11_BOX(const D3D11_BOX& o)
        : D3D11_BOX(o)
    {
    }
    explicit CD3D11_BOX(
        LONG Left,
        LONG Top,
        LONG Front,
        LONG Right,
        LONG Bottom,
        LONG Back)
    {
        left = Left;
        top = Top;
        front = Front;
        right = Right;
        bottom = Bottom;
        back = Back;
    }
    ~CD3D11_BOX() { }
};
inline bool operator==(const D3D11_BOX& l, const D3D11_BOX& r)
{
    return l.left == r.left && l.top == r.top && l.front == r.front && l.right == r.right && l.bottom == r.bottom && l.back == r.back;
}
inline bool operator!=(const D3D11_BOX& l, const D3D11_BOX& r)
{
    return !(l == r);
}
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11DeviceChild;
struct __declspec(uuid("1841e5c8-16b0-489b-bcc8-44cfb0d5deae")) __declspec(novtable)
    ID3D11DeviceChild : public IUnknown {
public:
    virtual void __stdcall GetDevice(
        ID3D11Device** ppDevice)
        = 0;
    virtual HRESULT __stdcall GetPrivateData(
        const GUID& guid,
        UINT* pDataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateData(
        const GUID& guid,
        UINT DataSize,
        const void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateDataInterface(
        const GUID& guid,
        const IUnknown* pData)
        = 0;
};
typedef enum D3D11_COMPARISON_FUNC {
    D3D11_COMPARISON_NEVER = 1,
    D3D11_COMPARISON_LESS = 2,
    D3D11_COMPARISON_EQUAL = 3,
    D3D11_COMPARISON_LESS_EQUAL = 4,
    D3D11_COMPARISON_GREATER = 5,
    D3D11_COMPARISON_NOT_EQUAL = 6,
    D3D11_COMPARISON_GREATER_EQUAL = 7,
    D3D11_COMPARISON_ALWAYS = 8
} D3D11_COMPARISON_FUNC;
typedef enum D3D11_DEPTH_WRITE_MASK {
    D3D11_DEPTH_WRITE_MASK_ZERO = 0,
    D3D11_DEPTH_WRITE_MASK_ALL = 1
} D3D11_DEPTH_WRITE_MASK;
typedef enum D3D11_STENCIL_OP {
    D3D11_STENCIL_OP_KEEP = 1,
    D3D11_STENCIL_OP_ZERO = 2,
    D3D11_STENCIL_OP_REPLACE = 3,
    D3D11_STENCIL_OP_INCR_SAT = 4,
    D3D11_STENCIL_OP_DECR_SAT = 5,
    D3D11_STENCIL_OP_INVERT = 6,
    D3D11_STENCIL_OP_INCR = 7,
    D3D11_STENCIL_OP_DECR = 8
} D3D11_STENCIL_OP;
typedef struct D3D11_DEPTH_STENCILOP_DESC {
    D3D11_STENCIL_OP StencilFailOp;
    D3D11_STENCIL_OP StencilDepthFailOp;
    D3D11_STENCIL_OP StencilPassOp;
    D3D11_COMPARISON_FUNC StencilFunc;
} D3D11_DEPTH_STENCILOP_DESC;
typedef struct D3D11_DEPTH_STENCIL_DESC {
    BOOL DepthEnable;
    D3D11_DEPTH_WRITE_MASK DepthWriteMask;
    D3D11_COMPARISON_FUNC DepthFunc;
    BOOL StencilEnable;
    UINT8 StencilReadMask;
    UINT8 StencilWriteMask;
    D3D11_DEPTH_STENCILOP_DESC FrontFace;
    D3D11_DEPTH_STENCILOP_DESC BackFace;
} D3D11_DEPTH_STENCIL_DESC;
}
struct CD3D11_DEPTH_STENCIL_DESC : public D3D11_DEPTH_STENCIL_DESC {
    CD3D11_DEPTH_STENCIL_DESC() = default;
    explicit CD3D11_DEPTH_STENCIL_DESC(const D3D11_DEPTH_STENCIL_DESC& o)
        : D3D11_DEPTH_STENCIL_DESC(o)
    {
    }
    explicit CD3D11_DEPTH_STENCIL_DESC(CD3D11_DEFAULT)
    {
        DepthEnable = 1;
        DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
        DepthFunc = D3D11_COMPARISON_LESS;
        StencilEnable = 0;
        StencilReadMask = (0xff);
        StencilWriteMask = (0xff);
        const D3D11_DEPTH_STENCILOP_DESC defaultStencilOp = { D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS };
        FrontFace = defaultStencilOp;
        BackFace = defaultStencilOp;
    }
    explicit CD3D11_DEPTH_STENCIL_DESC(
        BOOL depthEnable,
        D3D11_DEPTH_WRITE_MASK depthWriteMask,
        D3D11_COMPARISON_FUNC depthFunc,
        BOOL stencilEnable,
        UINT8 stencilReadMask,
        UINT8 stencilWriteMask,
        D3D11_STENCIL_OP frontStencilFailOp,
        D3D11_STENCIL_OP frontStencilDepthFailOp,
        D3D11_STENCIL_OP frontStencilPassOp,
        D3D11_COMPARISON_FUNC frontStencilFunc,
        D3D11_STENCIL_OP backStencilFailOp,
        D3D11_STENCIL_OP backStencilDepthFailOp,
        D3D11_STENCIL_OP backStencilPassOp,
        D3D11_COMPARISON_FUNC backStencilFunc)
    {
        DepthEnable = depthEnable;
        DepthWriteMask = depthWriteMask;
        DepthFunc = depthFunc;
        StencilEnable = stencilEnable;
        StencilReadMask = stencilReadMask;
        StencilWriteMask = stencilWriteMask;
        FrontFace.StencilFailOp = frontStencilFailOp;
        FrontFace.StencilDepthFailOp = frontStencilDepthFailOp;
        FrontFace.StencilPassOp = frontStencilPassOp;
        FrontFace.StencilFunc = frontStencilFunc;
        BackFace.StencilFailOp = backStencilFailOp;
        BackFace.StencilDepthFailOp = backStencilDepthFailOp;
        BackFace.StencilPassOp = backStencilPassOp;
        BackFace.StencilFunc = backStencilFunc;
    }
    ~CD3D11_DEPTH_STENCIL_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0001_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11DepthStencilState;
struct __declspec(uuid("03823efb-8d8f-4e1c-9aa2-f64bb2cbfdf1")) __declspec(novtable)
    ID3D11DepthStencilState : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D11_DEPTH_STENCIL_DESC* pDesc)
        = 0;
};
typedef enum D3D11_BLEND {
    D3D11_BLEND_ZERO = 1,
    D3D11_BLEND_ONE = 2,
    D3D11_BLEND_SRC_COLOR = 3,
    D3D11_BLEND_INV_SRC_COLOR = 4,
    D3D11_BLEND_SRC_ALPHA = 5,
    D3D11_BLEND_INV_SRC_ALPHA = 6,
    D3D11_BLEND_DEST_ALPHA = 7,
    D3D11_BLEND_INV_DEST_ALPHA = 8,
    D3D11_BLEND_DEST_COLOR = 9,
    D3D11_BLEND_INV_DEST_COLOR = 10,
    D3D11_BLEND_SRC_ALPHA_SAT = 11,
    D3D11_BLEND_BLEND_FACTOR = 14,
    D3D11_BLEND_INV_BLEND_FACTOR = 15,
    D3D11_BLEND_SRC1_COLOR = 16,
    D3D11_BLEND_INV_SRC1_COLOR = 17,
    D3D11_BLEND_SRC1_ALPHA = 18,
    D3D11_BLEND_INV_SRC1_ALPHA = 19
} D3D11_BLEND;
typedef enum D3D11_BLEND_OP {
    D3D11_BLEND_OP_ADD = 1,
    D3D11_BLEND_OP_SUBTRACT = 2,
    D3D11_BLEND_OP_REV_SUBTRACT = 3,
    D3D11_BLEND_OP_MIN = 4,
    D3D11_BLEND_OP_MAX = 5
} D3D11_BLEND_OP;
typedef enum D3D11_COLOR_WRITE_ENABLE {
    D3D11_COLOR_WRITE_ENABLE_RED = 1,
    D3D11_COLOR_WRITE_ENABLE_GREEN = 2,
    D3D11_COLOR_WRITE_ENABLE_BLUE = 4,
    D3D11_COLOR_WRITE_ENABLE_ALPHA = 8,
    D3D11_COLOR_WRITE_ENABLE_ALL = (((D3D11_COLOR_WRITE_ENABLE_RED | D3D11_COLOR_WRITE_ENABLE_GREEN) | D3D11_COLOR_WRITE_ENABLE_BLUE) | D3D11_COLOR_WRITE_ENABLE_ALPHA)
} D3D11_COLOR_WRITE_ENABLE;
typedef struct D3D11_RENDER_TARGET_BLEND_DESC {
    BOOL BlendEnable;
    D3D11_BLEND SrcBlend;
    D3D11_BLEND DestBlend;
    D3D11_BLEND_OP BlendOp;
    D3D11_BLEND SrcBlendAlpha;
    D3D11_BLEND DestBlendAlpha;
    D3D11_BLEND_OP BlendOpAlpha;
    UINT8 RenderTargetWriteMask;
} D3D11_RENDER_TARGET_BLEND_DESC;
typedef struct D3D11_BLEND_DESC {
    BOOL AlphaToCoverageEnable;
    BOOL IndependentBlendEnable;
    D3D11_RENDER_TARGET_BLEND_DESC RenderTarget[8];
} D3D11_BLEND_DESC;
}
struct CD3D11_BLEND_DESC : public D3D11_BLEND_DESC {
    CD3D11_BLEND_DESC() = default;
    explicit CD3D11_BLEND_DESC(const D3D11_BLEND_DESC& o)
        : D3D11_BLEND_DESC(o)
    {
    }
    explicit CD3D11_BLEND_DESC(CD3D11_DEFAULT)
    {
        AlphaToCoverageEnable = 0;
        IndependentBlendEnable = 0;
        const D3D11_RENDER_TARGET_BLEND_DESC defaultRenderTargetBlendDesc = {
            0,
            D3D11_BLEND_ONE,
            D3D11_BLEND_ZERO,
            D3D11_BLEND_OP_ADD,
            D3D11_BLEND_ONE,
            D3D11_BLEND_ZERO,
            D3D11_BLEND_OP_ADD,
            D3D11_COLOR_WRITE_ENABLE_ALL,
        };
        for (UINT i = 0; i < (8); ++i)
            RenderTarget[i] = defaultRenderTargetBlendDesc;
    }
    ~CD3D11_BLEND_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0002_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11BlendState;
struct __declspec(uuid("75b68faa-347d-4159-8f45-a0640f01cd9a")) __declspec(novtable)
    ID3D11BlendState : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D11_BLEND_DESC* pDesc)
        = 0;
};
typedef struct D3D11_RASTERIZER_DESC {
    D3D11_FILL_MODE FillMode;
    D3D11_CULL_MODE CullMode;
    BOOL FrontCounterClockwise;
    INT DepthBias;
    FLOAT DepthBiasClamp;
    FLOAT SlopeScaledDepthBias;
    BOOL DepthClipEnable;
    BOOL ScissorEnable;
    BOOL MultisampleEnable;
    BOOL AntialiasedLineEnable;
} D3D11_RASTERIZER_DESC;
}
struct CD3D11_RASTERIZER_DESC : public D3D11_RASTERIZER_DESC {
    CD3D11_RASTERIZER_DESC() = default;
    explicit CD3D11_RASTERIZER_DESC(const D3D11_RASTERIZER_DESC& o)
        : D3D11_RASTERIZER_DESC(o)
    {
    }
    explicit CD3D11_RASTERIZER_DESC(CD3D11_DEFAULT)
    {
        FillMode = D3D11_FILL_SOLID;
        CullMode = D3D11_CULL_BACK;
        FrontCounterClockwise = 0;
        DepthBias = (0);
        DepthBiasClamp = (0.0f);
        SlopeScaledDepthBias = (0.0f);
        DepthClipEnable = 1;
        ScissorEnable = 0;
        MultisampleEnable = 0;
        AntialiasedLineEnable = 0;
    }
    explicit CD3D11_RASTERIZER_DESC(
        D3D11_FILL_MODE fillMode,
        D3D11_CULL_MODE cullMode,
        BOOL frontCounterClockwise,
        INT depthBias,
        FLOAT depthBiasClamp,
        FLOAT slopeScaledDepthBias,
        BOOL depthClipEnable,
        BOOL scissorEnable,
        BOOL multisampleEnable,
        BOOL antialiasedLineEnable)
    {
        FillMode = fillMode;
        CullMode = cullMode;
        FrontCounterClockwise = frontCounterClockwise;
        DepthBias = depthBias;
        DepthBiasClamp = depthBiasClamp;
        SlopeScaledDepthBias = slopeScaledDepthBias;
        DepthClipEnable = depthClipEnable;
        ScissorEnable = scissorEnable;
        MultisampleEnable = multisampleEnable;
        AntialiasedLineEnable = antialiasedLineEnable;
    }
    ~CD3D11_RASTERIZER_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0003_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11RasterizerState;
struct __declspec(uuid("9bb4ab81-ab1a-4d8f-b506-fc04200b6ee7")) __declspec(novtable)
    ID3D11RasterizerState : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D11_RASTERIZER_DESC* pDesc)
        = 0;
};
}
inline UINT D3D11CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT MipLevels)
{
    return MipSlice + ArraySlice * MipLevels;
}
extern "C" {
typedef struct D3D11_SUBRESOURCE_DATA {
    const void* pSysMem;
    UINT SysMemPitch;
    UINT SysMemSlicePitch;
} D3D11_SUBRESOURCE_DATA;
typedef struct D3D11_MAPPED_SUBRESOURCE {
    void* pData;
    UINT RowPitch;
    UINT DepthPitch;
} D3D11_MAPPED_SUBRESOURCE;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0004_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Resource;
struct __declspec(uuid("dc8e63f3-d12b-4952-b47b-5e45026a862d")) __declspec(novtable)
    ID3D11Resource : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetType(
        D3D11_RESOURCE_DIMENSION* pResourceDimension)
        = 0;
    virtual void __stdcall SetEvictionPriority(
        UINT EvictionPriority)
        = 0;
    virtual UINT __stdcall GetEvictionPriority(void) = 0;
};
typedef struct D3D11_BUFFER_DESC {
    UINT ByteWidth;
    D3D11_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
    UINT StructureByteStride;
} D3D11_BUFFER_DESC;
}
struct CD3D11_BUFFER_DESC : public D3D11_BUFFER_DESC {
    CD3D11_BUFFER_DESC() = default;
    explicit CD3D11_BUFFER_DESC(const D3D11_BUFFER_DESC& o)
        : D3D11_BUFFER_DESC(o)
    {
    }
    explicit CD3D11_BUFFER_DESC(
        UINT byteWidth,
        UINT bindFlags,
        D3D11_USAGE usage = D3D11_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT miscFlags = 0,
        UINT structureByteStride = 0)
    {
        ByteWidth = byteWidth;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
        StructureByteStride = structureByteStride;
    }
    ~CD3D11_BUFFER_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0005_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Buffer;
struct __declspec(uuid("48570b85-d1ee-4fcd-a250-eb350722b037")) __declspec(novtable)
    ID3D11Buffer : public ID3D11Resource {
public:
    virtual void __stdcall GetDesc(
        D3D11_BUFFER_DESC* pDesc)
        = 0;
};
typedef struct D3D11_TEXTURE1D_DESC {
    UINT Width;
    UINT MipLevels;
    UINT ArraySize;
    DXGI_FORMAT Format;
    D3D11_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D11_TEXTURE1D_DESC;
}
struct CD3D11_TEXTURE1D_DESC : public D3D11_TEXTURE1D_DESC {
    CD3D11_TEXTURE1D_DESC() = default;
    explicit CD3D11_TEXTURE1D_DESC(const D3D11_TEXTURE1D_DESC& o)
        : D3D11_TEXTURE1D_DESC(o)
    {
    }
    explicit CD3D11_TEXTURE1D_DESC(
        DXGI_FORMAT format,
        UINT width,
        UINT arraySize = 1,
        UINT mipLevels = 0,
        UINT bindFlags = D3D11_BIND_SHADER_RESOURCE,
        D3D11_USAGE usage = D3D11_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT miscFlags = 0)
    {
        Width = width;
        MipLevels = mipLevels;
        ArraySize = arraySize;
        Format = format;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D11_TEXTURE1D_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0006_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Texture1D;
struct __declspec(uuid("f8fb5c27-c6b3-4f75-a4c8-439af2ef564c")) __declspec(novtable)
    ID3D11Texture1D : public ID3D11Resource {
public:
    virtual void __stdcall GetDesc(
        D3D11_TEXTURE1D_DESC* pDesc)
        = 0;
};
typedef struct D3D11_TEXTURE2D_DESC {
    UINT Width;
    UINT Height;
    UINT MipLevels;
    UINT ArraySize;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
    D3D11_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D11_TEXTURE2D_DESC;
}
struct CD3D11_TEXTURE2D_DESC : public D3D11_TEXTURE2D_DESC {
    CD3D11_TEXTURE2D_DESC() = default;
    explicit CD3D11_TEXTURE2D_DESC(const D3D11_TEXTURE2D_DESC& o)
        : D3D11_TEXTURE2D_DESC(o)
    {
    }
    explicit CD3D11_TEXTURE2D_DESC(
        DXGI_FORMAT format,
        UINT width,
        UINT height,
        UINT arraySize = 1,
        UINT mipLevels = 0,
        UINT bindFlags = D3D11_BIND_SHADER_RESOURCE,
        D3D11_USAGE usage = D3D11_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT sampleCount = 1,
        UINT sampleQuality = 0,
        UINT miscFlags = 0)
    {
        Width = width;
        Height = height;
        MipLevels = mipLevels;
        ArraySize = arraySize;
        Format = format;
        SampleDesc.Count = sampleCount;
        SampleDesc.Quality = sampleQuality;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D11_TEXTURE2D_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0007_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Texture2D;
struct __declspec(uuid("6f15aaf2-d208-4e89-9ab4-489535d34f9c")) __declspec(novtable)
    ID3D11Texture2D : public ID3D11Resource {
public:
    virtual void __stdcall GetDesc(
        D3D11_TEXTURE2D_DESC* pDesc)
        = 0;
};
typedef struct D3D11_TEXTURE3D_DESC {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    DXGI_FORMAT Format;
    D3D11_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D11_TEXTURE3D_DESC;
}
struct CD3D11_TEXTURE3D_DESC : public D3D11_TEXTURE3D_DESC {
    CD3D11_TEXTURE3D_DESC() = default;
    explicit CD3D11_TEXTURE3D_DESC(const D3D11_TEXTURE3D_DESC& o)
        : D3D11_TEXTURE3D_DESC(o)
    {
    }
    explicit CD3D11_TEXTURE3D_DESC(
        DXGI_FORMAT format,
        UINT width,
        UINT height,
        UINT depth,
        UINT mipLevels = 0,
        UINT bindFlags = D3D11_BIND_SHADER_RESOURCE,
        D3D11_USAGE usage = D3D11_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT miscFlags = 0)
    {
        Width = width;
        Height = height;
        Depth = depth;
        MipLevels = mipLevels;
        Format = format;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D11_TEXTURE3D_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0008_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Texture3D;
struct __declspec(uuid("037e866e-f56d-4357-a8af-9dabbe6e250e")) __declspec(novtable)
    ID3D11Texture3D : public ID3D11Resource {
public:
    virtual void __stdcall GetDesc(
        D3D11_TEXTURE3D_DESC* pDesc)
        = 0;
};
typedef enum D3D11_TEXTURECUBE_FACE {
    D3D11_TEXTURECUBE_FACE_POSITIVE_X = 0,
    D3D11_TEXTURECUBE_FACE_NEGATIVE_X = 1,
    D3D11_TEXTURECUBE_FACE_POSITIVE_Y = 2,
    D3D11_TEXTURECUBE_FACE_NEGATIVE_Y = 3,
    D3D11_TEXTURECUBE_FACE_POSITIVE_Z = 4,
    D3D11_TEXTURECUBE_FACE_NEGATIVE_Z = 5
} D3D11_TEXTURECUBE_FACE;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0009_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11View;
struct __declspec(uuid("839d1216-bb2e-412b-b7f4-a9dbebe08ed1")) __declspec(novtable)
    ID3D11View : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetResource(
        ID3D11Resource** ppResource)
        = 0;
};
typedef struct D3D11_BUFFER_SRV {
    union {
        UINT FirstElement;
        UINT ElementOffset;
    };
    union {
        UINT NumElements;
        UINT ElementWidth;
    };
} D3D11_BUFFER_SRV;
typedef enum D3D11_BUFFEREX_SRV_FLAG {
    D3D11_BUFFEREX_SRV_FLAG_RAW = 0x1
} D3D11_BUFFEREX_SRV_FLAG;
typedef struct D3D11_BUFFEREX_SRV {
    UINT FirstElement;
    UINT NumElements;
    UINT Flags;
} D3D11_BUFFEREX_SRV;
typedef struct D3D11_TEX1D_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D11_TEX1D_SRV;
typedef struct D3D11_TEX1D_ARRAY_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX1D_ARRAY_SRV;
typedef struct D3D11_TEX2D_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D11_TEX2D_SRV;
typedef struct D3D11_TEX2D_ARRAY_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2D_ARRAY_SRV;
typedef struct D3D11_TEX3D_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D11_TEX3D_SRV;
typedef struct D3D11_TEXCUBE_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D11_TEXCUBE_SRV;
typedef struct D3D11_TEXCUBE_ARRAY_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
    UINT First2DArrayFace;
    UINT NumCubes;
} D3D11_TEXCUBE_ARRAY_SRV;
typedef struct D3D11_TEX2DMS_SRV {
    UINT UnusedField_NothingToDefine;
} D3D11_TEX2DMS_SRV;
typedef struct D3D11_TEX2DMS_ARRAY_SRV {
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2DMS_ARRAY_SRV;
typedef struct D3D11_SHADER_RESOURCE_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D11_SRV_DIMENSION ViewDimension;
    union {
        D3D11_BUFFER_SRV Buffer;
        D3D11_TEX1D_SRV Texture1D;
        D3D11_TEX1D_ARRAY_SRV Texture1DArray;
        D3D11_TEX2D_SRV Texture2D;
        D3D11_TEX2D_ARRAY_SRV Texture2DArray;
        D3D11_TEX2DMS_SRV Texture2DMS;
        D3D11_TEX2DMS_ARRAY_SRV Texture2DMSArray;
        D3D11_TEX3D_SRV Texture3D;
        D3D11_TEXCUBE_SRV TextureCube;
        D3D11_TEXCUBE_ARRAY_SRV TextureCubeArray;
        D3D11_BUFFEREX_SRV BufferEx;
    };
} D3D11_SHADER_RESOURCE_VIEW_DESC;
}
struct CD3D11_SHADER_RESOURCE_VIEW_DESC : public D3D11_SHADER_RESOURCE_VIEW_DESC {
    CD3D11_SHADER_RESOURCE_VIEW_DESC() = default;
    explicit CD3D11_SHADER_RESOURCE_VIEW_DESC(const D3D11_SHADER_RESOURCE_VIEW_DESC& o)
        : D3D11_SHADER_RESOURCE_VIEW_DESC(o)
    {
    }
    explicit CD3D11_SHADER_RESOURCE_VIEW_DESC(
        D3D11_SRV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mostDetailedMip = 0,
        UINT mipLevels = -1,
        UINT firstArraySlice = 0,
        UINT arraySize = -1,
        UINT flags = 0)
    {
        Format = format;
        ViewDimension = viewDimension;
        switch (viewDimension) {
        case D3D11_SRV_DIMENSION_BUFFER:
            Buffer.FirstElement = mostDetailedMip;
            Buffer.NumElements = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE1D:
            Texture1D.MostDetailedMip = mostDetailedMip;
            Texture1D.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MostDetailedMip = mostDetailedMip;
            Texture1DArray.MipLevels = mipLevels;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2D:
            Texture2D.MostDetailedMip = mostDetailedMip;
            Texture2D.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MostDetailedMip = mostDetailedMip;
            Texture2DArray.MipLevels = mipLevels;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2DMS:
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY:
            Texture2DMSArray.FirstArraySlice = firstArraySlice;
            Texture2DMSArray.ArraySize = arraySize;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE3D:
            Texture3D.MostDetailedMip = mostDetailedMip;
            Texture3D.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURECUBE:
            TextureCube.MostDetailedMip = mostDetailedMip;
            TextureCube.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURECUBEARRAY:
            TextureCubeArray.MostDetailedMip = mostDetailedMip;
            TextureCubeArray.MipLevels = mipLevels;
            TextureCubeArray.First2DArrayFace = firstArraySlice;
            TextureCubeArray.NumCubes = arraySize;
            break;
        case D3D11_SRV_DIMENSION_BUFFEREX:
            BufferEx.FirstElement = mostDetailedMip;
            BufferEx.NumElements = mipLevels;
            BufferEx.Flags = flags;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_SHADER_RESOURCE_VIEW_DESC(
        ID3D11Buffer*,
        DXGI_FORMAT format,
        UINT firstElement,
        UINT numElements,
        UINT flags = 0)
    {
        Format = format;
        ViewDimension = D3D11_SRV_DIMENSION_BUFFEREX;
        BufferEx.FirstElement = firstElement;
        BufferEx.NumElements = numElements;
        BufferEx.Flags = flags;
    }
    explicit CD3D11_SHADER_RESOURCE_VIEW_DESC(
        ID3D11Texture1D* pTex1D,
        D3D11_SRV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mostDetailedMip = 0,
        UINT mipLevels = -1,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        ViewDimension = viewDimension;
        if (DXGI_FORMAT_UNKNOWN == format || (UINT)-1 == mipLevels || ((UINT)-1 == arraySize && D3D11_SRV_DIMENSION_TEXTURE1DARRAY == viewDimension)) {
            D3D11_TEXTURE1D_DESC TexDesc;
            pTex1D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == mipLevels)
                mipLevels = TexDesc.MipLevels - mostDetailedMip;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_SRV_DIMENSION_TEXTURE1D:
            Texture1D.MostDetailedMip = mostDetailedMip;
            Texture1D.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MostDetailedMip = mostDetailedMip;
            Texture1DArray.MipLevels = mipLevels;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_SHADER_RESOURCE_VIEW_DESC(
        ID3D11Texture2D* pTex2D,
        D3D11_SRV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mostDetailedMip = 0,
        UINT mipLevels = -1,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        ViewDimension = viewDimension;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == mipLevels && D3D11_SRV_DIMENSION_TEXTURE2DMS != viewDimension && D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY != viewDimension) || ((UINT)-1 == arraySize && (D3D11_SRV_DIMENSION_TEXTURE2DARRAY == viewDimension || D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY == viewDimension || D3D11_SRV_DIMENSION_TEXTURECUBEARRAY == viewDimension))) {
            D3D11_TEXTURE2D_DESC TexDesc;
            pTex2D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == mipLevels)
                mipLevels = TexDesc.MipLevels - mostDetailedMip;
            if ((UINT)-1 == arraySize) {
                arraySize = TexDesc.ArraySize - firstArraySlice;
                if (D3D11_SRV_DIMENSION_TEXTURECUBEARRAY == viewDimension)
                    arraySize /= 6;
            }
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_SRV_DIMENSION_TEXTURE2D:
            Texture2D.MostDetailedMip = mostDetailedMip;
            Texture2D.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MostDetailedMip = mostDetailedMip;
            Texture2DArray.MipLevels = mipLevels;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2DMS:
            break;
        case D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY:
            Texture2DMSArray.FirstArraySlice = firstArraySlice;
            Texture2DMSArray.ArraySize = arraySize;
            break;
        case D3D11_SRV_DIMENSION_TEXTURECUBE:
            TextureCube.MostDetailedMip = mostDetailedMip;
            TextureCube.MipLevels = mipLevels;
            break;
        case D3D11_SRV_DIMENSION_TEXTURECUBEARRAY:
            TextureCubeArray.MostDetailedMip = mostDetailedMip;
            TextureCubeArray.MipLevels = mipLevels;
            TextureCubeArray.First2DArrayFace = firstArraySlice;
            TextureCubeArray.NumCubes = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_SHADER_RESOURCE_VIEW_DESC(
        ID3D11Texture3D* pTex3D,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mostDetailedMip = 0,
        UINT mipLevels = -1)
    {
        ViewDimension = D3D11_SRV_DIMENSION_TEXTURE3D;
        if (DXGI_FORMAT_UNKNOWN == format || (UINT)-1 == mipLevels) {
            D3D11_TEXTURE3D_DESC TexDesc;
            pTex3D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == mipLevels)
                mipLevels = TexDesc.MipLevels - mostDetailedMip;
        }
        Format = format;
        Texture3D.MostDetailedMip = mostDetailedMip;
        Texture3D.MipLevels = mipLevels;
    }
    ~CD3D11_SHADER_RESOURCE_VIEW_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0010_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11ShaderResourceView;
struct __declspec(uuid("b0e06fe0-8192-4e1a-b1ca-36d7414710b2")) __declspec(novtable)
    ID3D11ShaderResourceView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc)
        = 0;
};
typedef struct D3D11_BUFFER_RTV {
    union {
        UINT FirstElement;
        UINT ElementOffset;
    };
    union {
        UINT NumElements;
        UINT ElementWidth;
    };
} D3D11_BUFFER_RTV;
typedef struct D3D11_TEX1D_RTV {
    UINT MipSlice;
} D3D11_TEX1D_RTV;
typedef struct D3D11_TEX1D_ARRAY_RTV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX1D_ARRAY_RTV;
typedef struct D3D11_TEX2D_RTV {
    UINT MipSlice;
} D3D11_TEX2D_RTV;
typedef struct D3D11_TEX2DMS_RTV {
    UINT UnusedField_NothingToDefine;
} D3D11_TEX2DMS_RTV;
typedef struct D3D11_TEX2D_ARRAY_RTV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2D_ARRAY_RTV;
typedef struct D3D11_TEX2DMS_ARRAY_RTV {
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2DMS_ARRAY_RTV;
typedef struct D3D11_TEX3D_RTV {
    UINT MipSlice;
    UINT FirstWSlice;
    UINT WSize;
} D3D11_TEX3D_RTV;
typedef struct D3D11_RENDER_TARGET_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D11_RTV_DIMENSION ViewDimension;
    union {
        D3D11_BUFFER_RTV Buffer;
        D3D11_TEX1D_RTV Texture1D;
        D3D11_TEX1D_ARRAY_RTV Texture1DArray;
        D3D11_TEX2D_RTV Texture2D;
        D3D11_TEX2D_ARRAY_RTV Texture2DArray;
        D3D11_TEX2DMS_RTV Texture2DMS;
        D3D11_TEX2DMS_ARRAY_RTV Texture2DMSArray;
        D3D11_TEX3D_RTV Texture3D;
    };
} D3D11_RENDER_TARGET_VIEW_DESC;
}
struct CD3D11_RENDER_TARGET_VIEW_DESC : public D3D11_RENDER_TARGET_VIEW_DESC {
    CD3D11_RENDER_TARGET_VIEW_DESC() = default;
    explicit CD3D11_RENDER_TARGET_VIEW_DESC(const D3D11_RENDER_TARGET_VIEW_DESC& o)
        : D3D11_RENDER_TARGET_VIEW_DESC(o)
    {
    }
    explicit CD3D11_RENDER_TARGET_VIEW_DESC(
        D3D11_RTV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        Format = format;
        ViewDimension = viewDimension;
        switch (viewDimension) {
        case D3D11_RTV_DIMENSION_BUFFER:
            Buffer.FirstElement = mipSlice;
            Buffer.NumElements = firstArraySlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE1D:
            Texture1D.MipSlice = mipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MipSlice = mipSlice;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2D:
            Texture2D.MipSlice = mipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MipSlice = mipSlice;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DMS:
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY:
            Texture2DMSArray.FirstArraySlice = firstArraySlice;
            Texture2DMSArray.ArraySize = arraySize;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE3D:
            Texture3D.MipSlice = mipSlice;
            Texture3D.FirstWSlice = firstArraySlice;
            Texture3D.WSize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_RENDER_TARGET_VIEW_DESC(
        ID3D11Buffer*,
        DXGI_FORMAT format,
        UINT firstElement,
        UINT numElements)
    {
        Format = format;
        ViewDimension = D3D11_RTV_DIMENSION_BUFFER;
        Buffer.FirstElement = firstElement;
        Buffer.NumElements = numElements;
    }
    explicit CD3D11_RENDER_TARGET_VIEW_DESC(
        ID3D11Texture1D* pTex1D,
        D3D11_RTV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        ViewDimension = viewDimension;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == arraySize && D3D11_RTV_DIMENSION_TEXTURE1DARRAY == viewDimension)) {
            D3D11_TEXTURE1D_DESC TexDesc;
            pTex1D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_RTV_DIMENSION_TEXTURE1D:
            Texture1D.MipSlice = mipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MipSlice = mipSlice;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_RENDER_TARGET_VIEW_DESC(
        ID3D11Texture2D* pTex2D,
        D3D11_RTV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        ViewDimension = viewDimension;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == arraySize && (D3D11_RTV_DIMENSION_TEXTURE2DARRAY == viewDimension || D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY == viewDimension))) {
            D3D11_TEXTURE2D_DESC TexDesc;
            pTex2D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_RTV_DIMENSION_TEXTURE2D:
            Texture2D.MipSlice = mipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MipSlice = mipSlice;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DMS:
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY:
            Texture2DMSArray.FirstArraySlice = firstArraySlice;
            Texture2DMSArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_RENDER_TARGET_VIEW_DESC(
        ID3D11Texture3D* pTex3D,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstWSlice = 0,
        UINT wSize = -1)
    {
        ViewDimension = D3D11_RTV_DIMENSION_TEXTURE3D;
        if (DXGI_FORMAT_UNKNOWN == format || (UINT)-1 == wSize) {
            D3D11_TEXTURE3D_DESC TexDesc;
            pTex3D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == wSize)
                wSize = TexDesc.Depth - firstWSlice;
        }
        Format = format;
        Texture3D.MipSlice = mipSlice;
        Texture3D.FirstWSlice = firstWSlice;
        Texture3D.WSize = wSize;
    }
    ~CD3D11_RENDER_TARGET_VIEW_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0011_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11RenderTargetView;
struct __declspec(uuid("dfdba067-0b8d-4865-875b-d7b4516cc164")) __declspec(novtable)
    ID3D11RenderTargetView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_RENDER_TARGET_VIEW_DESC* pDesc)
        = 0;
};
}
struct CD3D11_VIEWPORT : public D3D11_VIEWPORT {
    CD3D11_VIEWPORT() = default;
    explicit CD3D11_VIEWPORT(const D3D11_VIEWPORT& o)
        : D3D11_VIEWPORT(o)
    {
    }
    explicit CD3D11_VIEWPORT(
        FLOAT topLeftX,
        FLOAT topLeftY,
        FLOAT width,
        FLOAT height,
        FLOAT minDepth = (0.0f),
        FLOAT maxDepth = (1.0f))
    {
        TopLeftX = topLeftX;
        TopLeftY = topLeftY;
        Width = width;
        Height = height;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
    explicit CD3D11_VIEWPORT(
        ID3D11Buffer*,
        ID3D11RenderTargetView* pRTView,
        FLOAT topLeftX = 0.0f,
        FLOAT minDepth = (0.0f),
        FLOAT maxDepth = (1.0f))
    {
        D3D11_RENDER_TARGET_VIEW_DESC RTVDesc;
        pRTView->GetDesc(&RTVDesc);
        UINT NumElements = 0;
        switch (RTVDesc.ViewDimension) {
        case D3D11_RTV_DIMENSION_BUFFER:
            NumElements = RTVDesc.Buffer.NumElements;
            break;
        default:
            break;
        }
        TopLeftX = topLeftX;
        TopLeftY = 0.0f;
        Width = static_cast<FLOAT>(NumElements) - topLeftX;
        Height = 1.0f;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
    explicit CD3D11_VIEWPORT(
        ID3D11Texture1D* pTex1D,
        ID3D11RenderTargetView* pRTView,
        FLOAT topLeftX = 0.0f,
        FLOAT minDepth = (0.0f),
        FLOAT maxDepth = (1.0f))
    {
        D3D11_TEXTURE1D_DESC TexDesc;
        pTex1D->GetDesc(&TexDesc);
        D3D11_RENDER_TARGET_VIEW_DESC RTVDesc;
        pRTView->GetDesc(&RTVDesc);
        UINT MipSlice = 0;
        switch (RTVDesc.ViewDimension) {
        case D3D11_RTV_DIMENSION_TEXTURE1D:
            MipSlice = RTVDesc.Texture1D.MipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE1DARRAY:
            MipSlice = RTVDesc.Texture1DArray.MipSlice;
            break;
        default:
            break;
        }
        const UINT SubResourceWidth = TexDesc.Width / (UINT(1) << MipSlice);
        TopLeftX = topLeftX;
        TopLeftY = 0.0f;
        Width = static_cast<FLOAT>(SubResourceWidth ? SubResourceWidth : 1) - topLeftX;
        Height = 1.0f;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
    explicit CD3D11_VIEWPORT(
        ID3D11Texture2D* pTex2D,
        ID3D11RenderTargetView* pRTView,
        FLOAT topLeftX = 0.0f,
        FLOAT topLeftY = 0.0f,
        FLOAT minDepth = (0.0f),
        FLOAT maxDepth = (1.0f))
    {
        D3D11_TEXTURE2D_DESC TexDesc;
        pTex2D->GetDesc(&TexDesc);
        D3D11_RENDER_TARGET_VIEW_DESC RTVDesc;
        pRTView->GetDesc(&RTVDesc);
        UINT MipSlice = 0;
        switch (RTVDesc.ViewDimension) {
        case D3D11_RTV_DIMENSION_TEXTURE2D:
            MipSlice = RTVDesc.Texture2D.MipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DARRAY:
            MipSlice = RTVDesc.Texture2DArray.MipSlice;
            break;
        case D3D11_RTV_DIMENSION_TEXTURE2DMS:
        case D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY:
            break;
        default:
            break;
        }
        const UINT SubResourceWidth = TexDesc.Width / (UINT(1) << MipSlice);
        const UINT SubResourceHeight = TexDesc.Height / (UINT(1) << MipSlice);
        TopLeftX = topLeftX;
        TopLeftY = topLeftY;
        Width = static_cast<FLOAT>(SubResourceWidth ? SubResourceWidth : 1) - topLeftX;
        Height = static_cast<FLOAT>(SubResourceHeight ? SubResourceHeight : 1) - topLeftY;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
    explicit CD3D11_VIEWPORT(
        ID3D11Texture3D* pTex3D,
        ID3D11RenderTargetView* pRTView,
        FLOAT topLeftX = 0.0f,
        FLOAT topLeftY = 0.0f,
        FLOAT minDepth = (0.0f),
        FLOAT maxDepth = (1.0f))
    {
        D3D11_TEXTURE3D_DESC TexDesc;
        pTex3D->GetDesc(&TexDesc);
        D3D11_RENDER_TARGET_VIEW_DESC RTVDesc;
        pRTView->GetDesc(&RTVDesc);
        UINT MipSlice = 0;
        switch (RTVDesc.ViewDimension) {
        case D3D11_RTV_DIMENSION_TEXTURE3D:
            MipSlice = RTVDesc.Texture3D.MipSlice;
            break;
        default:
            break;
        }
        const UINT SubResourceWidth = TexDesc.Width / (UINT(1) << MipSlice);
        const UINT SubResourceHeight = TexDesc.Height / (UINT(1) << MipSlice);
        TopLeftX = topLeftX;
        TopLeftY = topLeftY;
        Width = static_cast<FLOAT>(SubResourceWidth ? SubResourceWidth : 1) - topLeftX;
        Height = static_cast<FLOAT>(SubResourceHeight ? SubResourceHeight : 1) - topLeftY;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
    }
    ~CD3D11_VIEWPORT() { }
};
extern "C" {
typedef struct D3D11_TEX1D_DSV {
    UINT MipSlice;
} D3D11_TEX1D_DSV;
typedef struct D3D11_TEX1D_ARRAY_DSV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX1D_ARRAY_DSV;
typedef struct D3D11_TEX2D_DSV {
    UINT MipSlice;
} D3D11_TEX2D_DSV;
typedef struct D3D11_TEX2D_ARRAY_DSV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2D_ARRAY_DSV;
typedef struct D3D11_TEX2DMS_DSV {
    UINT UnusedField_NothingToDefine;
} D3D11_TEX2DMS_DSV;
typedef struct D3D11_TEX2DMS_ARRAY_DSV {
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2DMS_ARRAY_DSV;
typedef enum D3D11_DSV_FLAG {
    D3D11_DSV_READ_ONLY_DEPTH = 0x1L,
    D3D11_DSV_READ_ONLY_STENCIL = 0x2L
} D3D11_DSV_FLAG;
typedef struct D3D11_DEPTH_STENCIL_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D11_DSV_DIMENSION ViewDimension;
    UINT Flags;
    union {
        D3D11_TEX1D_DSV Texture1D;
        D3D11_TEX1D_ARRAY_DSV Texture1DArray;
        D3D11_TEX2D_DSV Texture2D;
        D3D11_TEX2D_ARRAY_DSV Texture2DArray;
        D3D11_TEX2DMS_DSV Texture2DMS;
        D3D11_TEX2DMS_ARRAY_DSV Texture2DMSArray;
    };
} D3D11_DEPTH_STENCIL_VIEW_DESC;
}
struct CD3D11_DEPTH_STENCIL_VIEW_DESC : public D3D11_DEPTH_STENCIL_VIEW_DESC {
    CD3D11_DEPTH_STENCIL_VIEW_DESC() = default;
    explicit CD3D11_DEPTH_STENCIL_VIEW_DESC(const D3D11_DEPTH_STENCIL_VIEW_DESC& o)
        : D3D11_DEPTH_STENCIL_VIEW_DESC(o)
    {
    }
    explicit CD3D11_DEPTH_STENCIL_VIEW_DESC(
        D3D11_DSV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1,
        UINT flags = 0)
    {
        Format = format;
        ViewDimension = viewDimension;
        Flags = flags;
        switch (viewDimension) {
        case D3D11_DSV_DIMENSION_TEXTURE1D:
            Texture1D.MipSlice = mipSlice;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MipSlice = mipSlice;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2D:
            Texture2D.MipSlice = mipSlice;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MipSlice = mipSlice;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2DMS:
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY:
            Texture2DMSArray.FirstArraySlice = firstArraySlice;
            Texture2DMSArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_DEPTH_STENCIL_VIEW_DESC(
        ID3D11Texture1D* pTex1D,
        D3D11_DSV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1,
        UINT flags = 0)
    {
        ViewDimension = viewDimension;
        Flags = flags;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == arraySize && D3D11_DSV_DIMENSION_TEXTURE1DARRAY == viewDimension)) {
            D3D11_TEXTURE1D_DESC TexDesc;
            pTex1D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_DSV_DIMENSION_TEXTURE1D:
            Texture1D.MipSlice = mipSlice;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MipSlice = mipSlice;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_DEPTH_STENCIL_VIEW_DESC(
        ID3D11Texture2D* pTex2D,
        D3D11_DSV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1,
        UINT flags = 0)
    {
        ViewDimension = viewDimension;
        Flags = flags;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == arraySize && (D3D11_DSV_DIMENSION_TEXTURE2DARRAY == viewDimension || D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY == viewDimension))) {
            D3D11_TEXTURE2D_DESC TexDesc;
            pTex2D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_DSV_DIMENSION_TEXTURE2D:
            Texture2D.MipSlice = mipSlice;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MipSlice = mipSlice;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2DMS:
            break;
        case D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY:
            Texture2DMSArray.FirstArraySlice = firstArraySlice;
            Texture2DMSArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    ~CD3D11_DEPTH_STENCIL_VIEW_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0012_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11DepthStencilView;
struct __declspec(uuid("9fdac92a-1876-48c3-afad-25b94f84a9b6")) __declspec(novtable)
    ID3D11DepthStencilView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc)
        = 0;
};
typedef enum D3D11_BUFFER_UAV_FLAG {
    D3D11_BUFFER_UAV_FLAG_RAW = 0x1,
    D3D11_BUFFER_UAV_FLAG_APPEND = 0x2,
    D3D11_BUFFER_UAV_FLAG_COUNTER = 0x4
} D3D11_BUFFER_UAV_FLAG;
typedef struct D3D11_BUFFER_UAV {
    UINT FirstElement;
    UINT NumElements;
    UINT Flags;
} D3D11_BUFFER_UAV;
typedef struct D3D11_TEX1D_UAV {
    UINT MipSlice;
} D3D11_TEX1D_UAV;
typedef struct D3D11_TEX1D_ARRAY_UAV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX1D_ARRAY_UAV;
typedef struct D3D11_TEX2D_UAV {
    UINT MipSlice;
} D3D11_TEX2D_UAV;
typedef struct D3D11_TEX2D_ARRAY_UAV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2D_ARRAY_UAV;
typedef struct D3D11_TEX3D_UAV {
    UINT MipSlice;
    UINT FirstWSlice;
    UINT WSize;
} D3D11_TEX3D_UAV;
typedef struct D3D11_UNORDERED_ACCESS_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D11_UAV_DIMENSION ViewDimension;
    union {
        D3D11_BUFFER_UAV Buffer;
        D3D11_TEX1D_UAV Texture1D;
        D3D11_TEX1D_ARRAY_UAV Texture1DArray;
        D3D11_TEX2D_UAV Texture2D;
        D3D11_TEX2D_ARRAY_UAV Texture2DArray;
        D3D11_TEX3D_UAV Texture3D;
    };
} D3D11_UNORDERED_ACCESS_VIEW_DESC;
}
struct CD3D11_UNORDERED_ACCESS_VIEW_DESC : public D3D11_UNORDERED_ACCESS_VIEW_DESC {
    CD3D11_UNORDERED_ACCESS_VIEW_DESC() = default;
    explicit CD3D11_UNORDERED_ACCESS_VIEW_DESC(const D3D11_UNORDERED_ACCESS_VIEW_DESC& o)
        : D3D11_UNORDERED_ACCESS_VIEW_DESC(o)
    {
    }
    explicit CD3D11_UNORDERED_ACCESS_VIEW_DESC(
        D3D11_UAV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1,
        UINT flags = 0)
    {
        Format = format;
        ViewDimension = viewDimension;
        switch (viewDimension) {
        case D3D11_UAV_DIMENSION_BUFFER:
            Buffer.FirstElement = mipSlice;
            Buffer.NumElements = firstArraySlice;
            Buffer.Flags = flags;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE1D:
            Texture1D.MipSlice = mipSlice;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MipSlice = mipSlice;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE2D:
            Texture2D.MipSlice = mipSlice;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MipSlice = mipSlice;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE3D:
            Texture3D.MipSlice = mipSlice;
            Texture3D.FirstWSlice = firstArraySlice;
            Texture3D.WSize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_UNORDERED_ACCESS_VIEW_DESC(
        ID3D11Buffer*,
        DXGI_FORMAT format,
        UINT firstElement,
        UINT numElements,
        UINT flags = 0)
    {
        Format = format;
        ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
        Buffer.FirstElement = firstElement;
        Buffer.NumElements = numElements;
        Buffer.Flags = flags;
    }
    explicit CD3D11_UNORDERED_ACCESS_VIEW_DESC(
        ID3D11Texture1D* pTex1D,
        D3D11_UAV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        ViewDimension = viewDimension;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == arraySize && D3D11_UAV_DIMENSION_TEXTURE1DARRAY == viewDimension)) {
            D3D11_TEXTURE1D_DESC TexDesc;
            pTex1D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_UAV_DIMENSION_TEXTURE1D:
            Texture1D.MipSlice = mipSlice;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE1DARRAY:
            Texture1DArray.MipSlice = mipSlice;
            Texture1DArray.FirstArraySlice = firstArraySlice;
            Texture1DArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_UNORDERED_ACCESS_VIEW_DESC(
        ID3D11Texture2D* pTex2D,
        D3D11_UAV_DIMENSION viewDimension,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstArraySlice = 0,
        UINT arraySize = -1)
    {
        ViewDimension = viewDimension;
        if (DXGI_FORMAT_UNKNOWN == format || ((UINT)-1 == arraySize && D3D11_UAV_DIMENSION_TEXTURE2DARRAY == viewDimension)) {
            D3D11_TEXTURE2D_DESC TexDesc;
            pTex2D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == arraySize)
                arraySize = TexDesc.ArraySize - firstArraySlice;
        }
        Format = format;
        switch (viewDimension) {
        case D3D11_UAV_DIMENSION_TEXTURE2D:
            Texture2D.MipSlice = mipSlice;
            break;
        case D3D11_UAV_DIMENSION_TEXTURE2DARRAY:
            Texture2DArray.MipSlice = mipSlice;
            Texture2DArray.FirstArraySlice = firstArraySlice;
            Texture2DArray.ArraySize = arraySize;
            break;
        default:
            break;
        }
    }
    explicit CD3D11_UNORDERED_ACCESS_VIEW_DESC(
        ID3D11Texture3D* pTex3D,
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN,
        UINT mipSlice = 0,
        UINT firstWSlice = 0,
        UINT wSize = -1)
    {
        ViewDimension = D3D11_UAV_DIMENSION_TEXTURE3D;
        if (DXGI_FORMAT_UNKNOWN == format || (UINT)-1 == wSize) {
            D3D11_TEXTURE3D_DESC TexDesc;
            pTex3D->GetDesc(&TexDesc);
            if (DXGI_FORMAT_UNKNOWN == format)
                format = TexDesc.Format;
            if ((UINT)-1 == wSize)
                wSize = TexDesc.Depth - firstWSlice;
        }
        Format = format;
        Texture3D.MipSlice = mipSlice;
        Texture3D.FirstWSlice = firstWSlice;
        Texture3D.WSize = wSize;
    }
    ~CD3D11_UNORDERED_ACCESS_VIEW_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0013_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11UnorderedAccessView;
struct __declspec(uuid("28acf509-7f5c-48f6-8611-f316010a6380")) __declspec(novtable)
    ID3D11UnorderedAccessView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc)
        = 0;
};
extern "C" const IID IID_ID3D11VertexShader;
struct __declspec(uuid("3b301d64-d678-4289-8897-22f8928b72f3")) __declspec(novtable)
    ID3D11VertexShader : public ID3D11DeviceChild {
public:
};
extern "C" const IID IID_ID3D11HullShader;
struct __declspec(uuid("8e5c6061-628a-4c8e-8264-bbe45cb3d5dd")) __declspec(novtable)
    ID3D11HullShader : public ID3D11DeviceChild {
public:
};
extern "C" const IID IID_ID3D11DomainShader;
struct __declspec(uuid("f582c508-0f36-490c-9977-31eece268cfa")) __declspec(novtable)
    ID3D11DomainShader : public ID3D11DeviceChild {
public:
};
extern "C" const IID IID_ID3D11GeometryShader;
struct __declspec(uuid("38325b96-effb-4022-ba02-2e795b70275c")) __declspec(novtable)
    ID3D11GeometryShader : public ID3D11DeviceChild {
public:
};
extern "C" const IID IID_ID3D11PixelShader;
struct __declspec(uuid("ea82e40d-51dc-4f33-93d4-db7c9125ae8c")) __declspec(novtable)
    ID3D11PixelShader : public ID3D11DeviceChild {
public:
};
extern "C" const IID IID_ID3D11ComputeShader;
struct __declspec(uuid("4f5b196e-c2bd-495e-bd01-1fded38e4969")) __declspec(novtable)
    ID3D11ComputeShader : public ID3D11DeviceChild {
public:
};
extern "C" const IID IID_ID3D11InputLayout;
struct __declspec(uuid("e4819ddc-4cf0-4025-bd26-5de82a3e07b7")) __declspec(novtable)
    ID3D11InputLayout : public ID3D11DeviceChild {
public:
};
typedef enum D3D11_FILTER {
    D3D11_FILTER_MIN_MAG_MIP_POINT = 0,
    D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x1,
    D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,
    D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x5,
    D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10,
    D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14,
    D3D11_FILTER_MIN_MAG_MIP_LINEAR = 0x15,
    D3D11_FILTER_ANISOTROPIC = 0x55,
    D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT = 0x80,
    D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
    D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
    D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
    D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
    D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,
    D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
    D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
    D3D11_FILTER_COMPARISON_ANISOTROPIC = 0xd5,
    D3D11_FILTER_MINIMUM_MIN_MAG_MIP_POINT = 0x100,
    D3D11_FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x101,
    D3D11_FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x104,
    D3D11_FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x105,
    D3D11_FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x110,
    D3D11_FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111,
    D3D11_FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x114,
    D3D11_FILTER_MINIMUM_MIN_MAG_MIP_LINEAR = 0x115,
    D3D11_FILTER_MINIMUM_ANISOTROPIC = 0x155,
    D3D11_FILTER_MAXIMUM_MIN_MAG_MIP_POINT = 0x180,
    D3D11_FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x181,
    D3D11_FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x184,
    D3D11_FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x185,
    D3D11_FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x190,
    D3D11_FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191,
    D3D11_FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x194,
    D3D11_FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR = 0x195,
    D3D11_FILTER_MAXIMUM_ANISOTROPIC = 0x1d5
} D3D11_FILTER;
typedef enum D3D11_FILTER_TYPE {
    D3D11_FILTER_TYPE_POINT = 0,
    D3D11_FILTER_TYPE_LINEAR = 1
} D3D11_FILTER_TYPE;
typedef enum D3D11_FILTER_REDUCTION_TYPE {
    D3D11_FILTER_REDUCTION_TYPE_STANDARD = 0,
    D3D11_FILTER_REDUCTION_TYPE_COMPARISON = 1,
    D3D11_FILTER_REDUCTION_TYPE_MINIMUM = 2,
    D3D11_FILTER_REDUCTION_TYPE_MAXIMUM = 3
} D3D11_FILTER_REDUCTION_TYPE;
typedef enum D3D11_TEXTURE_ADDRESS_MODE {
    D3D11_TEXTURE_ADDRESS_WRAP = 1,
    D3D11_TEXTURE_ADDRESS_MIRROR = 2,
    D3D11_TEXTURE_ADDRESS_CLAMP = 3,
    D3D11_TEXTURE_ADDRESS_BORDER = 4,
    D3D11_TEXTURE_ADDRESS_MIRROR_ONCE = 5
} D3D11_TEXTURE_ADDRESS_MODE;
typedef struct D3D11_SAMPLER_DESC {
    D3D11_FILTER Filter;
    D3D11_TEXTURE_ADDRESS_MODE AddressU;
    D3D11_TEXTURE_ADDRESS_MODE AddressV;
    D3D11_TEXTURE_ADDRESS_MODE AddressW;
    FLOAT MipLODBias;
    UINT MaxAnisotropy;
    D3D11_COMPARISON_FUNC ComparisonFunc;
    FLOAT BorderColor[4];
    FLOAT MinLOD;
    FLOAT MaxLOD;
} D3D11_SAMPLER_DESC;
}
struct CD3D11_SAMPLER_DESC : public D3D11_SAMPLER_DESC {
    CD3D11_SAMPLER_DESC() = default;
    explicit CD3D11_SAMPLER_DESC(const D3D11_SAMPLER_DESC& o)
        : D3D11_SAMPLER_DESC(o)
    {
    }
    explicit CD3D11_SAMPLER_DESC(CD3D11_DEFAULT)
    {
        Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        MipLODBias = 0;
        MaxAnisotropy = 1;
        ComparisonFunc = D3D11_COMPARISON_NEVER;
        BorderColor[0] = 1.0f;
        BorderColor[1] = 1.0f;
        BorderColor[2] = 1.0f;
        BorderColor[3] = 1.0f;
        MinLOD = -3.402823466e+38F;
        MaxLOD = 3.402823466e+38F;
    }
    explicit CD3D11_SAMPLER_DESC(
        D3D11_FILTER filter,
        D3D11_TEXTURE_ADDRESS_MODE addressU,
        D3D11_TEXTURE_ADDRESS_MODE addressV,
        D3D11_TEXTURE_ADDRESS_MODE addressW,
        FLOAT mipLODBias,
        UINT maxAnisotropy,
        D3D11_COMPARISON_FUNC comparisonFunc,
        const FLOAT* borderColor,
        FLOAT minLOD,
        FLOAT maxLOD)
    {
        Filter = filter;
        AddressU = addressU;
        AddressV = addressV;
        AddressW = addressW;
        MipLODBias = mipLODBias;
        MaxAnisotropy = maxAnisotropy;
        ComparisonFunc = comparisonFunc;
        const float defaultColor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
        if (!borderColor)
            borderColor = defaultColor;
        BorderColor[0] = borderColor[0];
        BorderColor[1] = borderColor[1];
        BorderColor[2] = borderColor[2];
        BorderColor[3] = borderColor[3];
        MinLOD = minLOD;
        MaxLOD = maxLOD;
    }
    ~CD3D11_SAMPLER_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0021_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11SamplerState;
struct __declspec(uuid("da6fea51-564c-4487-9810-f0d0f9b4e3a5")) __declspec(novtable)
    ID3D11SamplerState : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D11_SAMPLER_DESC* pDesc)
        = 0;
};
typedef enum D3D11_FORMAT_SUPPORT {
    D3D11_FORMAT_SUPPORT_BUFFER = 0x1,
    D3D11_FORMAT_SUPPORT_IA_VERTEX_BUFFER = 0x2,
    D3D11_FORMAT_SUPPORT_IA_INDEX_BUFFER = 0x4,
    D3D11_FORMAT_SUPPORT_SO_BUFFER = 0x8,
    D3D11_FORMAT_SUPPORT_TEXTURE1D = 0x10,
    D3D11_FORMAT_SUPPORT_TEXTURE2D = 0x20,
    D3D11_FORMAT_SUPPORT_TEXTURE3D = 0x40,
    D3D11_FORMAT_SUPPORT_TEXTURECUBE = 0x80,
    D3D11_FORMAT_SUPPORT_SHADER_LOAD = 0x100,
    D3D11_FORMAT_SUPPORT_SHADER_SAMPLE = 0x200,
    D3D11_FORMAT_SUPPORT_SHADER_SAMPLE_COMPARISON = 0x400,
    D3D11_FORMAT_SUPPORT_SHADER_SAMPLE_MONO_TEXT = 0x800,
    D3D11_FORMAT_SUPPORT_MIP = 0x1000,
    D3D11_FORMAT_SUPPORT_MIP_AUTOGEN = 0x2000,
    D3D11_FORMAT_SUPPORT_RENDER_TARGET = 0x4000,
    D3D11_FORMAT_SUPPORT_BLENDABLE = 0x8000,
    D3D11_FORMAT_SUPPORT_DEPTH_STENCIL = 0x10000,
    D3D11_FORMAT_SUPPORT_CPU_LOCKABLE = 0x20000,
    D3D11_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE = 0x40000,
    D3D11_FORMAT_SUPPORT_DISPLAY = 0x80000,
    D3D11_FORMAT_SUPPORT_CAST_WITHIN_BIT_LAYOUT = 0x100000,
    D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET = 0x200000,
    D3D11_FORMAT_SUPPORT_MULTISAMPLE_LOAD = 0x400000,
    D3D11_FORMAT_SUPPORT_SHADER_GATHER = 0x800000,
    D3D11_FORMAT_SUPPORT_BACK_BUFFER_CAST = 0x1000000,
    D3D11_FORMAT_SUPPORT_TYPED_UNORDERED_ACCESS_VIEW = 0x2000000,
    D3D11_FORMAT_SUPPORT_SHADER_GATHER_COMPARISON = 0x4000000,
    D3D11_FORMAT_SUPPORT_DECODER_OUTPUT = 0x8000000,
    D3D11_FORMAT_SUPPORT_VIDEO_PROCESSOR_OUTPUT = 0x10000000,
    D3D11_FORMAT_SUPPORT_VIDEO_PROCESSOR_INPUT = 0x20000000,
    D3D11_FORMAT_SUPPORT_VIDEO_ENCODER = 0x40000000
} D3D11_FORMAT_SUPPORT;
typedef enum D3D11_FORMAT_SUPPORT2 {
    D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_ADD = 0x1,
    D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS = 0x2,
    D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE = 0x4,
    D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE = 0x8,
    D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX = 0x10,
    D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX = 0x20,
    D3D11_FORMAT_SUPPORT2_UAV_TYPED_LOAD = 0x40,
    D3D11_FORMAT_SUPPORT2_UAV_TYPED_STORE = 0x80,
    D3D11_FORMAT_SUPPORT2_OUTPUT_MERGER_LOGIC_OP = 0x100,
    D3D11_FORMAT_SUPPORT2_TILED = 0x200,
    D3D11_FORMAT_SUPPORT2_SHAREABLE = 0x400,
    D3D11_FORMAT_SUPPORT2_MULTIPLANE_OVERLAY = 0x4000
} D3D11_FORMAT_SUPPORT2;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0022_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Asynchronous;
struct __declspec(uuid("4b35d0cd-1e15-4258-9c98-1b1333f6dd3b")) __declspec(novtable)
    ID3D11Asynchronous : public ID3D11DeviceChild {
public:
    virtual UINT __stdcall GetDataSize(void) = 0;
};
typedef enum D3D11_ASYNC_GETDATA_FLAG {
    D3D11_ASYNC_GETDATA_DONOTFLUSH = 0x1
} D3D11_ASYNC_GETDATA_FLAG;
typedef enum D3D11_QUERY {
    D3D11_QUERY_EVENT = 0,
    D3D11_QUERY_OCCLUSION = (D3D11_QUERY_EVENT + 1),
    D3D11_QUERY_TIMESTAMP = (D3D11_QUERY_OCCLUSION + 1),
    D3D11_QUERY_TIMESTAMP_DISJOINT = (D3D11_QUERY_TIMESTAMP + 1),
    D3D11_QUERY_PIPELINE_STATISTICS = (D3D11_QUERY_TIMESTAMP_DISJOINT + 1),
    D3D11_QUERY_OCCLUSION_PREDICATE = (D3D11_QUERY_PIPELINE_STATISTICS + 1),
    D3D11_QUERY_SO_STATISTICS = (D3D11_QUERY_OCCLUSION_PREDICATE + 1),
    D3D11_QUERY_SO_OVERFLOW_PREDICATE = (D3D11_QUERY_SO_STATISTICS + 1),
    D3D11_QUERY_SO_STATISTICS_STREAM0 = (D3D11_QUERY_SO_OVERFLOW_PREDICATE + 1),
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM0 = (D3D11_QUERY_SO_STATISTICS_STREAM0 + 1),
    D3D11_QUERY_SO_STATISTICS_STREAM1 = (D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM0 + 1),
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM1 = (D3D11_QUERY_SO_STATISTICS_STREAM1 + 1),
    D3D11_QUERY_SO_STATISTICS_STREAM2 = (D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM1 + 1),
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM2 = (D3D11_QUERY_SO_STATISTICS_STREAM2 + 1),
    D3D11_QUERY_SO_STATISTICS_STREAM3 = (D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM2 + 1),
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM3 = (D3D11_QUERY_SO_STATISTICS_STREAM3 + 1)
} D3D11_QUERY;
typedef enum D3D11_QUERY_MISC_FLAG {
    D3D11_QUERY_MISC_PREDICATEHINT = 0x1
} D3D11_QUERY_MISC_FLAG;
typedef struct D3D11_QUERY_DESC {
    D3D11_QUERY Query;
    UINT MiscFlags;
} D3D11_QUERY_DESC;
}
struct CD3D11_QUERY_DESC : public D3D11_QUERY_DESC {
    CD3D11_QUERY_DESC() = default;
    explicit CD3D11_QUERY_DESC(const D3D11_QUERY_DESC& o)
        : D3D11_QUERY_DESC(o)
    {
    }
    explicit CD3D11_QUERY_DESC(
        D3D11_QUERY query,
        UINT miscFlags = 0)
    {
        Query = query;
        MiscFlags = miscFlags;
    }
    ~CD3D11_QUERY_DESC() { }
};
extern "C" {
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0023_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Query;
struct __declspec(uuid("d6c00747-87b7-425e-b84d-44d108560afd")) __declspec(novtable)
    ID3D11Query : public ID3D11Asynchronous {
public:
    virtual void __stdcall GetDesc(
        D3D11_QUERY_DESC* pDesc)
        = 0;
};
extern "C" const IID IID_ID3D11Predicate;
struct __declspec(uuid("9eb576dd-9f77-4d86-81aa-8bab5fe490e2")) __declspec(novtable)
    ID3D11Predicate : public ID3D11Query {
public:
};
typedef struct D3D11_QUERY_DATA_TIMESTAMP_DISJOINT {
    UINT64 Frequency;
    BOOL Disjoint;
} D3D11_QUERY_DATA_TIMESTAMP_DISJOINT;
typedef struct D3D11_QUERY_DATA_PIPELINE_STATISTICS {
    UINT64 IAVertices;
    UINT64 IAPrimitives;
    UINT64 VSInvocations;
    UINT64 GSInvocations;
    UINT64 GSPrimitives;
    UINT64 CInvocations;
    UINT64 CPrimitives;
    UINT64 PSInvocations;
    UINT64 HSInvocations;
    UINT64 DSInvocations;
    UINT64 CSInvocations;
} D3D11_QUERY_DATA_PIPELINE_STATISTICS;
typedef struct D3D11_QUERY_DATA_SO_STATISTICS {
    UINT64 NumPrimitivesWritten;
    UINT64 PrimitivesStorageNeeded;
} D3D11_QUERY_DATA_SO_STATISTICS;
typedef enum D3D11_COUNTER {
    D3D11_COUNTER_DEVICE_DEPENDENT_0 = 0x40000000
} D3D11_COUNTER;
typedef enum D3D11_COUNTER_TYPE {
    D3D11_COUNTER_TYPE_FLOAT32 = 0,
    D3D11_COUNTER_TYPE_UINT16 = (D3D11_COUNTER_TYPE_FLOAT32 + 1),
    D3D11_COUNTER_TYPE_UINT32 = (D3D11_COUNTER_TYPE_UINT16 + 1),
    D3D11_COUNTER_TYPE_UINT64 = (D3D11_COUNTER_TYPE_UINT32 + 1)
} D3D11_COUNTER_TYPE;
typedef struct D3D11_COUNTER_DESC {
    D3D11_COUNTER Counter;
    UINT MiscFlags;
} D3D11_COUNTER_DESC;
}
struct CD3D11_COUNTER_DESC : public D3D11_COUNTER_DESC {
    CD3D11_COUNTER_DESC() = default;
    explicit CD3D11_COUNTER_DESC(const D3D11_COUNTER_DESC& o)
        : D3D11_COUNTER_DESC(o)
    {
    }
    explicit CD3D11_COUNTER_DESC(
        D3D11_COUNTER counter,
        UINT miscFlags = 0)
    {
        Counter = counter;
        MiscFlags = miscFlags;
    }
    ~CD3D11_COUNTER_DESC() { }
};
extern "C" {
typedef struct D3D11_COUNTER_INFO {
    D3D11_COUNTER LastDeviceDependentCounter;
    UINT NumSimultaneousCounters;
    UINT8 NumDetectableParallelUnits;
} D3D11_COUNTER_INFO;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0025_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Counter;
struct __declspec(uuid("6e8c49fb-a371-4770-b440-29086022b741")) __declspec(novtable)
    ID3D11Counter : public ID3D11Asynchronous {
public:
    virtual void __stdcall GetDesc(
        D3D11_COUNTER_DESC* pDesc)
        = 0;
};
typedef enum D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS {
    D3D11_STANDARD_MULTISAMPLE_PATTERN = 0xffffffff,
    D3D11_CENTER_MULTISAMPLE_PATTERN = 0xfffffffe
} D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS;
typedef enum D3D11_DEVICE_CONTEXT_TYPE {
    D3D11_DEVICE_CONTEXT_IMMEDIATE = 0,
    D3D11_DEVICE_CONTEXT_DEFERRED = (D3D11_DEVICE_CONTEXT_IMMEDIATE + 1)
} D3D11_DEVICE_CONTEXT_TYPE;
typedef struct D3D11_CLASS_INSTANCE_DESC {
    UINT InstanceId;
    UINT InstanceIndex;
    UINT TypeId;
    UINT ConstantBuffer;
    UINT BaseConstantBufferOffset;
    UINT BaseTexture;
    UINT BaseSampler;
    BOOL Created;
} D3D11_CLASS_INSTANCE_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0026_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11ClassInstance;
struct __declspec(uuid("a6cd7faa-b0b7-4a2f-9436-8662a65797cb")) __declspec(novtable)
    ID3D11ClassInstance : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetClassLinkage(
        ID3D11ClassLinkage** ppLinkage)
        = 0;
    virtual void __stdcall GetDesc(
        D3D11_CLASS_INSTANCE_DESC* pDesc)
        = 0;
    virtual void __stdcall GetInstanceName(
        LPSTR pInstanceName,
        SIZE_T* pBufferLength)
        = 0;
    virtual void __stdcall GetTypeName(
        LPSTR pTypeName,
        SIZE_T* pBufferLength)
        = 0;
};
extern "C" const IID IID_ID3D11ClassLinkage;
struct __declspec(uuid("ddf57cba-9543-46e4-a12b-f207a0fe7fed")) __declspec(novtable)
    ID3D11ClassLinkage : public ID3D11DeviceChild {
public:
    virtual HRESULT __stdcall GetClassInstance(
        LPCSTR pClassInstanceName,
        UINT InstanceIndex,
        ID3D11ClassInstance** ppInstance)
        = 0;
    virtual HRESULT __stdcall CreateClassInstance(
        LPCSTR pClassTypeName,
        UINT ConstantBufferOffset,
        UINT ConstantVectorOffset,
        UINT TextureOffset,
        UINT SamplerOffset,
        ID3D11ClassInstance** ppInstance)
        = 0;
};
extern "C" const IID IID_ID3D11CommandList;
struct __declspec(uuid("a24bc4d1-769e-43f7-8013-98ff566c18e2")) __declspec(novtable)
    ID3D11CommandList : public ID3D11DeviceChild {
public:
    virtual UINT __stdcall GetContextFlags(void) = 0;
};
typedef enum D3D11_FEATURE {
    D3D11_FEATURE_THREADING = 0,
    D3D11_FEATURE_DOUBLES = (D3D11_FEATURE_THREADING + 1),
    D3D11_FEATURE_FORMAT_SUPPORT = (D3D11_FEATURE_DOUBLES + 1),
    D3D11_FEATURE_FORMAT_SUPPORT2 = (D3D11_FEATURE_FORMAT_SUPPORT + 1),
    D3D11_FEATURE_D3D10_X_HARDWARE_OPTIONS = (D3D11_FEATURE_FORMAT_SUPPORT2 + 1),
    D3D11_FEATURE_D3D11_OPTIONS = (D3D11_FEATURE_D3D10_X_HARDWARE_OPTIONS + 1),
    D3D11_FEATURE_ARCHITECTURE_INFO = (D3D11_FEATURE_D3D11_OPTIONS + 1),
    D3D11_FEATURE_D3D9_OPTIONS = (D3D11_FEATURE_ARCHITECTURE_INFO + 1),
    D3D11_FEATURE_SHADER_MIN_PRECISION_SUPPORT = (D3D11_FEATURE_D3D9_OPTIONS + 1),
    D3D11_FEATURE_D3D9_SHADOW_SUPPORT = (D3D11_FEATURE_SHADER_MIN_PRECISION_SUPPORT + 1),
    D3D11_FEATURE_D3D11_OPTIONS1 = (D3D11_FEATURE_D3D9_SHADOW_SUPPORT + 1),
    D3D11_FEATURE_D3D9_SIMPLE_INSTANCING_SUPPORT = (D3D11_FEATURE_D3D11_OPTIONS1 + 1),
    D3D11_FEATURE_MARKER_SUPPORT = (D3D11_FEATURE_D3D9_SIMPLE_INSTANCING_SUPPORT + 1),
    D3D11_FEATURE_D3D9_OPTIONS1 = (D3D11_FEATURE_MARKER_SUPPORT + 1),
    D3D11_FEATURE_D3D11_OPTIONS2 = (D3D11_FEATURE_D3D9_OPTIONS1 + 1),
    D3D11_FEATURE_D3D11_OPTIONS3 = (D3D11_FEATURE_D3D11_OPTIONS2 + 1),
    D3D11_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT = (D3D11_FEATURE_D3D11_OPTIONS3 + 1),
    D3D11_FEATURE_D3D11_OPTIONS4 = (D3D11_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT + 1),
    D3D11_FEATURE_SHADER_CACHE = (D3D11_FEATURE_D3D11_OPTIONS4 + 1),
    D3D11_FEATURE_D3D11_OPTIONS5 = (D3D11_FEATURE_SHADER_CACHE + 1),
    D3D11_FEATURE_DISPLAYABLE = (D3D11_FEATURE_D3D11_OPTIONS5 + 1)
} D3D11_FEATURE;
typedef struct D3D11_FEATURE_DATA_THREADING {
    BOOL DriverConcurrentCreates;
    BOOL DriverCommandLists;
} D3D11_FEATURE_DATA_THREADING;
typedef struct D3D11_FEATURE_DATA_DOUBLES {
    BOOL DoublePrecisionFloatShaderOps;
} D3D11_FEATURE_DATA_DOUBLES;
typedef struct D3D11_FEATURE_DATA_FORMAT_SUPPORT {
    DXGI_FORMAT InFormat;
    UINT OutFormatSupport;
} D3D11_FEATURE_DATA_FORMAT_SUPPORT;
typedef struct D3D11_FEATURE_DATA_FORMAT_SUPPORT2 {
    DXGI_FORMAT InFormat;
    UINT OutFormatSupport2;
} D3D11_FEATURE_DATA_FORMAT_SUPPORT2;
typedef struct D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS {
    BOOL ComputeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x;
} D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS;
typedef struct D3D11_FEATURE_DATA_D3D11_OPTIONS {
    BOOL OutputMergerLogicOp;
    BOOL UAVOnlyRenderingForcedSampleCount;
    BOOL DiscardAPIsSeenByDriver;
    BOOL FlagsForUpdateAndCopySeenByDriver;
    BOOL ClearView;
    BOOL CopyWithOverlap;
    BOOL ConstantBufferPartialUpdate;
    BOOL ConstantBufferOffsetting;
    BOOL MapNoOverwriteOnDynamicConstantBuffer;
    BOOL MapNoOverwriteOnDynamicBufferSRV;
    BOOL MultisampleRTVWithForcedSampleCountOne;
    BOOL SAD4ShaderInstructions;
    BOOL ExtendedDoublesShaderInstructions;
    BOOL ExtendedResourceSharing;
} D3D11_FEATURE_DATA_D3D11_OPTIONS;
typedef struct D3D11_FEATURE_DATA_ARCHITECTURE_INFO {
    BOOL TileBasedDeferredRenderer;
} D3D11_FEATURE_DATA_ARCHITECTURE_INFO;
typedef struct D3D11_FEATURE_DATA_D3D9_OPTIONS {
    BOOL FullNonPow2TextureSupport;
} D3D11_FEATURE_DATA_D3D9_OPTIONS;
typedef struct D3D11_FEATURE_DATA_D3D9_SHADOW_SUPPORT {
    BOOL SupportsDepthAsTextureWithLessEqualComparisonFilter;
} D3D11_FEATURE_DATA_D3D9_SHADOW_SUPPORT;
typedef enum D3D11_SHADER_MIN_PRECISION_SUPPORT {
    D3D11_SHADER_MIN_PRECISION_10_BIT = 0x1,
    D3D11_SHADER_MIN_PRECISION_16_BIT = 0x2
} D3D11_SHADER_MIN_PRECISION_SUPPORT;
typedef struct D3D11_FEATURE_DATA_SHADER_MIN_PRECISION_SUPPORT {
    UINT PixelShaderMinPrecision;
    UINT AllOtherShaderStagesMinPrecision;
} D3D11_FEATURE_DATA_SHADER_MIN_PRECISION_SUPPORT;
typedef enum D3D11_TILED_RESOURCES_TIER {
    D3D11_TILED_RESOURCES_NOT_SUPPORTED = 0,
    D3D11_TILED_RESOURCES_TIER_1 = 1,
    D3D11_TILED_RESOURCES_TIER_2 = 2,
    D3D11_TILED_RESOURCES_TIER_3 = 3
} D3D11_TILED_RESOURCES_TIER;
typedef struct D3D11_FEATURE_DATA_D3D11_OPTIONS1 {
    D3D11_TILED_RESOURCES_TIER TiledResourcesTier;
    BOOL MinMaxFiltering;
    BOOL ClearViewAlsoSupportsDepthOnlyFormats;
    BOOL MapOnDefaultBuffers;
} D3D11_FEATURE_DATA_D3D11_OPTIONS1;
typedef struct D3D11_FEATURE_DATA_D3D9_SIMPLE_INSTANCING_SUPPORT {
    BOOL SimpleInstancingSupported;
} D3D11_FEATURE_DATA_D3D9_SIMPLE_INSTANCING_SUPPORT;
typedef struct D3D11_FEATURE_DATA_MARKER_SUPPORT {
    BOOL Profile;
} D3D11_FEATURE_DATA_MARKER_SUPPORT;
typedef struct D3D11_FEATURE_DATA_D3D9_OPTIONS1 {
    BOOL FullNonPow2TextureSupported;
    BOOL DepthAsTextureWithLessEqualComparisonFilterSupported;
    BOOL SimpleInstancingSupported;
    BOOL TextureCubeFaceRenderTargetWithNonCubeDepthStencilSupported;
} D3D11_FEATURE_DATA_D3D9_OPTIONS1;
typedef enum D3D11_CONSERVATIVE_RASTERIZATION_TIER {
    D3D11_CONSERVATIVE_RASTERIZATION_NOT_SUPPORTED = 0,
    D3D11_CONSERVATIVE_RASTERIZATION_TIER_1 = 1,
    D3D11_CONSERVATIVE_RASTERIZATION_TIER_2 = 2,
    D3D11_CONSERVATIVE_RASTERIZATION_TIER_3 = 3
} D3D11_CONSERVATIVE_RASTERIZATION_TIER;
typedef struct D3D11_FEATURE_DATA_D3D11_OPTIONS2 {
    BOOL PSSpecifiedStencilRefSupported;
    BOOL TypedUAVLoadAdditionalFormats;
    BOOL ROVsSupported;
    D3D11_CONSERVATIVE_RASTERIZATION_TIER ConservativeRasterizationTier;
    D3D11_TILED_RESOURCES_TIER TiledResourcesTier;
    BOOL MapOnDefaultTextures;
    BOOL StandardSwizzle;
    BOOL UnifiedMemoryArchitecture;
} D3D11_FEATURE_DATA_D3D11_OPTIONS2;
typedef struct D3D11_FEATURE_DATA_D3D11_OPTIONS3 {
    BOOL VPAndRTArrayIndexFromAnyShaderFeedingRasterizer;
} D3D11_FEATURE_DATA_D3D11_OPTIONS3;
typedef struct D3D11_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    UINT MaxGPUVirtualAddressBitsPerResource;
    UINT MaxGPUVirtualAddressBitsPerProcess;
} D3D11_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT;
typedef enum D3D11_SHADER_CACHE_SUPPORT_FLAGS {
    D3D11_SHADER_CACHE_SUPPORT_NONE = 0,
    D3D11_SHADER_CACHE_SUPPORT_AUTOMATIC_INPROC_CACHE = 0x1,
    D3D11_SHADER_CACHE_SUPPORT_AUTOMATIC_DISK_CACHE = 0x2
} D3D11_SHADER_CACHE_SUPPORT_FLAGS;
typedef struct D3D11_FEATURE_DATA_SHADER_CACHE {
    UINT SupportFlags;
} D3D11_FEATURE_DATA_SHADER_CACHE;
typedef enum D3D11_SHARED_RESOURCE_TIER {
    D3D11_SHARED_RESOURCE_TIER_0 = 0,
    D3D11_SHARED_RESOURCE_TIER_1 = (D3D11_SHARED_RESOURCE_TIER_0 + 1),
    D3D11_SHARED_RESOURCE_TIER_2 = (D3D11_SHARED_RESOURCE_TIER_1 + 1),
    D3D11_SHARED_RESOURCE_TIER_3 = (D3D11_SHARED_RESOURCE_TIER_2 + 1)
} D3D11_SHARED_RESOURCE_TIER;
typedef struct D3D11_FEATURE_DATA_DISPLAYABLE {
    BOOL DisplayableTexture;
    D3D11_SHARED_RESOURCE_TIER SharedResourceTier;
} D3D11_FEATURE_DATA_DISPLAYABLE;
typedef struct D3D11_FEATURE_DATA_D3D11_OPTIONS5 {
    D3D11_SHARED_RESOURCE_TIER SharedResourceTier;
} D3D11_FEATURE_DATA_D3D11_OPTIONS5;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0029_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11DeviceContext;
struct __declspec(uuid("c0bfa96c-e089-44fb-8eaf-26f8796190da")) __declspec(novtable)
    ID3D11DeviceContext : public ID3D11DeviceChild {
public:
    virtual void __stdcall VSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall PSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall PSSetShader(
        ID3D11PixelShader* pPixelShader,
        ID3D11ClassInstance* const* ppClassInstances,
        UINT NumClassInstances)
        = 0;
    virtual void __stdcall PSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall VSSetShader(
        ID3D11VertexShader* pVertexShader,
        ID3D11ClassInstance* const* ppClassInstances,
        UINT NumClassInstances)
        = 0;
    virtual void __stdcall DrawIndexed(
        UINT IndexCount,
        UINT StartIndexLocation,
        INT BaseVertexLocation)
        = 0;
    virtual void __stdcall Draw(
        UINT VertexCount,
        UINT StartVertexLocation)
        = 0;
    virtual HRESULT __stdcall Map(
        ID3D11Resource* pResource,
        UINT Subresource,
        D3D11_MAP MapType,
        UINT MapFlags,
        D3D11_MAPPED_SUBRESOURCE* pMappedResource)
        = 0;
    virtual void __stdcall Unmap(
        ID3D11Resource* pResource,
        UINT Subresource)
        = 0;
    virtual void __stdcall PSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall IASetInputLayout(
        ID3D11InputLayout* pInputLayout)
        = 0;
    virtual void __stdcall IASetVertexBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppVertexBuffers,
        const UINT* pStrides,
        const UINT* pOffsets)
        = 0;
    virtual void __stdcall IASetIndexBuffer(
        ID3D11Buffer* pIndexBuffer,
        DXGI_FORMAT Format,
        UINT Offset)
        = 0;
    virtual void __stdcall DrawIndexedInstanced(
        UINT IndexCountPerInstance,
        UINT InstanceCount,
        UINT StartIndexLocation,
        INT BaseVertexLocation,
        UINT StartInstanceLocation)
        = 0;
    virtual void __stdcall DrawInstanced(
        UINT VertexCountPerInstance,
        UINT InstanceCount,
        UINT StartVertexLocation,
        UINT StartInstanceLocation)
        = 0;
    virtual void __stdcall GSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall GSSetShader(
        ID3D11GeometryShader* pShader,
        ID3D11ClassInstance* const* ppClassInstances,
        UINT NumClassInstances)
        = 0;
    virtual void __stdcall IASetPrimitiveTopology(
        D3D11_PRIMITIVE_TOPOLOGY Topology)
        = 0;
    virtual void __stdcall VSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall VSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall Begin(
        ID3D11Asynchronous* pAsync)
        = 0;
    virtual void __stdcall End(
        ID3D11Asynchronous* pAsync)
        = 0;
    virtual HRESULT __stdcall GetData(
        ID3D11Asynchronous* pAsync,
        void* pData,
        UINT DataSize,
        UINT GetDataFlags)
        = 0;
    virtual void __stdcall SetPredication(
        ID3D11Predicate* pPredicate,
        BOOL PredicateValue)
        = 0;
    virtual void __stdcall GSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall GSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall OMSetRenderTargets(
        UINT NumViews,
        ID3D11RenderTargetView* const* ppRenderTargetViews,
        ID3D11DepthStencilView* pDepthStencilView)
        = 0;
    virtual void __stdcall OMSetRenderTargetsAndUnorderedAccessViews(
        UINT NumRTVs,
        ID3D11RenderTargetView* const* ppRenderTargetViews,
        ID3D11DepthStencilView* pDepthStencilView,
        UINT UAVStartSlot,
        UINT NumUAVs,
        ID3D11UnorderedAccessView* const* ppUnorderedAccessViews,
        const UINT* pUAVInitialCounts)
        = 0;
    virtual void __stdcall OMSetBlendState(
        ID3D11BlendState* pBlendState,
        const FLOAT BlendFactor[4],
        UINT SampleMask)
        = 0;
    virtual void __stdcall OMSetDepthStencilState(
        ID3D11DepthStencilState* pDepthStencilState,
        UINT StencilRef)
        = 0;
    virtual void __stdcall SOSetTargets(
        UINT NumBuffers,
        ID3D11Buffer* const* ppSOTargets,
        const UINT* pOffsets)
        = 0;
    virtual void __stdcall DrawAuto(void) = 0;
    virtual void __stdcall DrawIndexedInstancedIndirect(
        ID3D11Buffer* pBufferForArgs,
        UINT AlignedByteOffsetForArgs)
        = 0;
    virtual void __stdcall DrawInstancedIndirect(
        ID3D11Buffer* pBufferForArgs,
        UINT AlignedByteOffsetForArgs)
        = 0;
    virtual void __stdcall Dispatch(
        UINT ThreadGroupCountX,
        UINT ThreadGroupCountY,
        UINT ThreadGroupCountZ)
        = 0;
    virtual void __stdcall DispatchIndirect(
        ID3D11Buffer* pBufferForArgs,
        UINT AlignedByteOffsetForArgs)
        = 0;
    virtual void __stdcall RSSetState(
        ID3D11RasterizerState* pRasterizerState)
        = 0;
    virtual void __stdcall RSSetViewports(
        UINT NumViewports,
        const D3D11_VIEWPORT* pViewports)
        = 0;
    virtual void __stdcall RSSetScissorRects(
        UINT NumRects,
        const D3D11_RECT* pRects)
        = 0;
    virtual void __stdcall CopySubresourceRegion(
        ID3D11Resource* pDstResource,
        UINT DstSubresource,
        UINT DstX,
        UINT DstY,
        UINT DstZ,
        ID3D11Resource* pSrcResource,
        UINT SrcSubresource,
        const D3D11_BOX* pSrcBox)
        = 0;
    virtual void __stdcall CopyResource(
        ID3D11Resource* pDstResource,
        ID3D11Resource* pSrcResource)
        = 0;
    virtual void __stdcall UpdateSubresource(
        ID3D11Resource* pDstResource,
        UINT DstSubresource,
        const D3D11_BOX* pDstBox,
        const void* pSrcData,
        UINT SrcRowPitch,
        UINT SrcDepthPitch)
        = 0;
    virtual void __stdcall CopyStructureCount(
        ID3D11Buffer* pDstBuffer,
        UINT DstAlignedByteOffset,
        ID3D11UnorderedAccessView* pSrcView)
        = 0;
    virtual void __stdcall ClearRenderTargetView(
        ID3D11RenderTargetView* pRenderTargetView,
        const FLOAT ColorRGBA[4])
        = 0;
    virtual void __stdcall ClearUnorderedAccessViewUint(
        ID3D11UnorderedAccessView* pUnorderedAccessView,
        const UINT Values[4])
        = 0;
    virtual void __stdcall ClearUnorderedAccessViewFloat(
        ID3D11UnorderedAccessView* pUnorderedAccessView,
        const FLOAT Values[4])
        = 0;
    virtual void __stdcall ClearDepthStencilView(
        ID3D11DepthStencilView* pDepthStencilView,
        UINT ClearFlags,
        FLOAT Depth,
        UINT8 Stencil)
        = 0;
    virtual void __stdcall GenerateMips(
        ID3D11ShaderResourceView* pShaderResourceView)
        = 0;
    virtual void __stdcall SetResourceMinLOD(
        ID3D11Resource* pResource,
        FLOAT MinLOD)
        = 0;
    virtual FLOAT __stdcall GetResourceMinLOD(
        ID3D11Resource* pResource)
        = 0;
    virtual void __stdcall ResolveSubresource(
        ID3D11Resource* pDstResource,
        UINT DstSubresource,
        ID3D11Resource* pSrcResource,
        UINT SrcSubresource,
        DXGI_FORMAT Format)
        = 0;
    virtual void __stdcall ExecuteCommandList(
        ID3D11CommandList* pCommandList,
        BOOL RestoreContextState)
        = 0;
    virtual void __stdcall HSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall HSSetShader(
        ID3D11HullShader* pHullShader,
        ID3D11ClassInstance* const* ppClassInstances,
        UINT NumClassInstances)
        = 0;
    virtual void __stdcall HSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall HSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall DSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall DSSetShader(
        ID3D11DomainShader* pDomainShader,
        ID3D11ClassInstance* const* ppClassInstances,
        UINT NumClassInstances)
        = 0;
    virtual void __stdcall DSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall DSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall CSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall CSSetUnorderedAccessViews(
        UINT StartSlot,
        UINT NumUAVs,
        ID3D11UnorderedAccessView* const* ppUnorderedAccessViews,
        const UINT* pUAVInitialCounts)
        = 0;
    virtual void __stdcall CSSetShader(
        ID3D11ComputeShader* pComputeShader,
        ID3D11ClassInstance* const* ppClassInstances,
        UINT NumClassInstances)
        = 0;
    virtual void __stdcall CSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall CSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall VSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall PSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall PSGetShader(
        ID3D11PixelShader** ppPixelShader,
        ID3D11ClassInstance** ppClassInstances,
        UINT* pNumClassInstances)
        = 0;
    virtual void __stdcall PSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall VSGetShader(
        ID3D11VertexShader** ppVertexShader,
        ID3D11ClassInstance** ppClassInstances,
        UINT* pNumClassInstances)
        = 0;
    virtual void __stdcall PSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall IAGetInputLayout(
        ID3D11InputLayout** ppInputLayout)
        = 0;
    virtual void __stdcall IAGetVertexBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppVertexBuffers,
        UINT* pStrides,
        UINT* pOffsets)
        = 0;
    virtual void __stdcall IAGetIndexBuffer(
        ID3D11Buffer** pIndexBuffer,
        DXGI_FORMAT* Format,
        UINT* Offset)
        = 0;
    virtual void __stdcall GSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall GSGetShader(
        ID3D11GeometryShader** ppGeometryShader,
        ID3D11ClassInstance** ppClassInstances,
        UINT* pNumClassInstances)
        = 0;
    virtual void __stdcall IAGetPrimitiveTopology(
        D3D11_PRIMITIVE_TOPOLOGY* pTopology)
        = 0;
    virtual void __stdcall VSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall VSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall GetPredication(
        ID3D11Predicate** ppPredicate,
        BOOL* pPredicateValue)
        = 0;
    virtual void __stdcall GSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall GSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall OMGetRenderTargets(
        UINT NumViews,
        ID3D11RenderTargetView** ppRenderTargetViews,
        ID3D11DepthStencilView** ppDepthStencilView)
        = 0;
    virtual void __stdcall OMGetRenderTargetsAndUnorderedAccessViews(
        UINT NumRTVs,
        ID3D11RenderTargetView** ppRenderTargetViews,
        ID3D11DepthStencilView** ppDepthStencilView,
        UINT UAVStartSlot,
        UINT NumUAVs,
        ID3D11UnorderedAccessView** ppUnorderedAccessViews)
        = 0;
    virtual void __stdcall OMGetBlendState(
        ID3D11BlendState** ppBlendState,
        FLOAT BlendFactor[4],
        UINT* pSampleMask)
        = 0;
    virtual void __stdcall OMGetDepthStencilState(
        ID3D11DepthStencilState** ppDepthStencilState,
        UINT* pStencilRef)
        = 0;
    virtual void __stdcall SOGetTargets(
        UINT NumBuffers,
        ID3D11Buffer** ppSOTargets)
        = 0;
    virtual void __stdcall RSGetState(
        ID3D11RasterizerState** ppRasterizerState)
        = 0;
    virtual void __stdcall RSGetViewports(
        UINT* pNumViewports,
        D3D11_VIEWPORT* pViewports)
        = 0;
    virtual void __stdcall RSGetScissorRects(
        UINT* pNumRects,
        D3D11_RECT* pRects)
        = 0;
    virtual void __stdcall HSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall HSGetShader(
        ID3D11HullShader** ppHullShader,
        ID3D11ClassInstance** ppClassInstances,
        UINT* pNumClassInstances)
        = 0;
    virtual void __stdcall HSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall HSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall DSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall DSGetShader(
        ID3D11DomainShader** ppDomainShader,
        ID3D11ClassInstance** ppClassInstances,
        UINT* pNumClassInstances)
        = 0;
    virtual void __stdcall DSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall DSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall CSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D11ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall CSGetUnorderedAccessViews(
        UINT StartSlot,
        UINT NumUAVs,
        ID3D11UnorderedAccessView** ppUnorderedAccessViews)
        = 0;
    virtual void __stdcall CSGetShader(
        ID3D11ComputeShader** ppComputeShader,
        ID3D11ClassInstance** ppClassInstances,
        UINT* pNumClassInstances)
        = 0;
    virtual void __stdcall CSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D11SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall CSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D11Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall ClearState(void) = 0;
    virtual void __stdcall Flush(void) = 0;
    virtual D3D11_DEVICE_CONTEXT_TYPE __stdcall GetType(void) = 0;
    virtual UINT __stdcall GetContextFlags(void) = 0;
    virtual HRESULT __stdcall FinishCommandList(
        BOOL RestoreDeferredContextState,
        ID3D11CommandList** ppCommandList)
        = 0;
};
}
struct CD3D11_VIDEO_DEFAULT {
};
extern const __declspec(selectany) CD3D11_VIDEO_DEFAULT D3D11_VIDEO_DEFAULT;
extern "C" {
typedef HRESULT APP_DEPRECATED_HRESULT;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG2_MOCOMP;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG2_IDCT;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG2_VLD;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG1_VLD;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG2and1_VLD;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_MOCOMP_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_MOCOMP_FGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_IDCT_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_IDCT_FGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_VLD_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_VLD_FGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_VLD_WITHFMOASO_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_VLD_STEREO_PROGRESSIVE_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_VLD_STEREO_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_H264_VLD_MULTIVIEW_NOFGT;
extern "C" const GUID D3D11_DECODER_PROFILE_WMV8_POSTPROC;
extern "C" const GUID D3D11_DECODER_PROFILE_WMV8_MOCOMP;
extern "C" const GUID D3D11_DECODER_PROFILE_WMV9_POSTPROC;
extern "C" const GUID D3D11_DECODER_PROFILE_WMV9_MOCOMP;
extern "C" const GUID D3D11_DECODER_PROFILE_WMV9_IDCT;
extern "C" const GUID D3D11_DECODER_PROFILE_VC1_POSTPROC;
extern "C" const GUID D3D11_DECODER_PROFILE_VC1_MOCOMP;
extern "C" const GUID D3D11_DECODER_PROFILE_VC1_IDCT;
extern "C" const GUID D3D11_DECODER_PROFILE_VC1_VLD;
extern "C" const GUID D3D11_DECODER_PROFILE_VC1_D2010;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG4PT2_VLD_SIMPLE;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG4PT2_VLD_ADVSIMPLE_NOGMC;
extern "C" const GUID D3D11_DECODER_PROFILE_MPEG4PT2_VLD_ADVSIMPLE_GMC;
extern "C" const GUID D3D11_DECODER_PROFILE_HEVC_VLD_MAIN;
extern "C" const GUID D3D11_DECODER_PROFILE_HEVC_VLD_MAIN10;
extern "C" const GUID D3D11_DECODER_PROFILE_VP9_VLD_PROFILE0;
extern "C" const GUID D3D11_DECODER_PROFILE_VP9_VLD_10BIT_PROFILE2;
extern "C" const GUID D3D11_DECODER_PROFILE_VP8_VLD;
extern "C" const GUID D3D11_DECODER_PROFILE_AV1_VLD_PROFILE0;
extern "C" const GUID D3D11_DECODER_PROFILE_AV1_VLD_PROFILE1;
extern "C" const GUID D3D11_DECODER_PROFILE_AV1_VLD_PROFILE2;
extern "C" const GUID D3D11_DECODER_PROFILE_AV1_VLD_12BIT_PROFILE2;
extern "C" const GUID D3D11_DECODER_PROFILE_AV1_VLD_12BIT_PROFILE2_420;
typedef struct D3D11_VIDEO_DECODER_DESC {
    GUID Guid;
    UINT SampleWidth;
    UINT SampleHeight;
    DXGI_FORMAT OutputFormat;
} D3D11_VIDEO_DECODER_DESC;
typedef struct D3D11_VIDEO_DECODER_CONFIG {
    GUID guidConfigBitstreamEncryption;
    GUID guidConfigMBcontrolEncryption;
    GUID guidConfigResidDiffEncryption;
    UINT ConfigBitstreamRaw;
    UINT ConfigMBcontrolRasterOrder;
    UINT ConfigResidDiffHost;
    UINT ConfigSpatialResid8;
    UINT ConfigResid8Subtraction;
    UINT ConfigSpatialHost8or9Clipping;
    UINT ConfigSpatialResidInterleaved;
    UINT ConfigIntraResidUnsigned;
    UINT ConfigResidDiffAccelerator;
    UINT ConfigHostInverseScan;
    UINT ConfigSpecificIDCT;
    UINT Config4GroupedCoefs;
    USHORT ConfigMinRenderTargetBuffCount;
    USHORT ConfigDecoderSpecific;
} D3D11_VIDEO_DECODER_CONFIG;
typedef enum D3D11_VIDEO_DECODER_BUFFER_TYPE {
    D3D11_VIDEO_DECODER_BUFFER_PICTURE_PARAMETERS = 0,
    D3D11_VIDEO_DECODER_BUFFER_MACROBLOCK_CONTROL = 1,
    D3D11_VIDEO_DECODER_BUFFER_RESIDUAL_DIFFERENCE = 2,
    D3D11_VIDEO_DECODER_BUFFER_DEBLOCKING_CONTROL = 3,
    D3D11_VIDEO_DECODER_BUFFER_INVERSE_QUANTIZATION_MATRIX = 4,
    D3D11_VIDEO_DECODER_BUFFER_SLICE_CONTROL = 5,
    D3D11_VIDEO_DECODER_BUFFER_BITSTREAM = 6,
    D3D11_VIDEO_DECODER_BUFFER_MOTION_VECTOR = 7,
    D3D11_VIDEO_DECODER_BUFFER_FILM_GRAIN = 8
} D3D11_VIDEO_DECODER_BUFFER_TYPE;
typedef struct _D3D11_AES_CTR_IV {
    UINT64 IV;
    UINT64 Count;
} D3D11_AES_CTR_IV;
typedef struct D3D11_ENCRYPTED_BLOCK_INFO {
    UINT NumEncryptedBytesAtBeginning;
    UINT NumBytesInSkipPattern;
    UINT NumBytesInEncryptPattern;
} D3D11_ENCRYPTED_BLOCK_INFO;
typedef struct D3D11_VIDEO_DECODER_BUFFER_DESC {
    D3D11_VIDEO_DECODER_BUFFER_TYPE BufferType;
    UINT BufferIndex;
    UINT DataOffset;
    UINT DataSize;
    UINT FirstMBaddress;
    UINT NumMBsInBuffer;
    UINT Width;
    UINT Height;
    UINT Stride;
    UINT ReservedBits;
    void* pIV;
    UINT IVSize;
    BOOL PartialEncryption;
    D3D11_ENCRYPTED_BLOCK_INFO EncryptedBlockInfo;
} D3D11_VIDEO_DECODER_BUFFER_DESC;
typedef struct D3D11_VIDEO_DECODER_EXTENSION {
    UINT Function;
    void* pPrivateInputData;
    UINT PrivateInputDataSize;
    void* pPrivateOutputData;
    UINT PrivateOutputDataSize;
    UINT ResourceCount;
    ID3D11Resource** ppResourceList;
} D3D11_VIDEO_DECODER_EXTENSION;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0030_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11VideoDecoder;
struct __declspec(uuid("3C9C5B51-995D-48d1-9B8D-FA5CAEDED65C")) __declspec(novtable)
    ID3D11VideoDecoder : public ID3D11DeviceChild {
public:
    virtual HRESULT __stdcall GetCreationParameters(
        D3D11_VIDEO_DECODER_DESC* pVideoDesc,
        D3D11_VIDEO_DECODER_CONFIG* pConfig)
        = 0;
    virtual HRESULT __stdcall GetDriverHandle(
        HANDLE* pDriverHandle)
        = 0;
};
typedef enum D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT {
    D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_INPUT = 0x1,
    D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_OUTPUT = 0x2
} D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT;
typedef enum D3D11_VIDEO_PROCESSOR_DEVICE_CAPS {
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_LINEAR_SPACE = 0x1,
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_xvYCC = 0x2,
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_RGB_RANGE_CONVERSION = 0x4,
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION = 0x8,
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_NOMINAL_RANGE = 0x10
} D3D11_VIDEO_PROCESSOR_DEVICE_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_FEATURE_CAPS {
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_FILL = 0x1,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_CONSTRICTION = 0x2,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LUMA_KEY = 0x4,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_PALETTE = 0x8,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LEGACY = 0x10,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_STEREO = 0x20,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ROTATION = 0x40,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_STREAM = 0x80,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_PIXEL_ASPECT_RATIO = 0x100,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_MIRROR = 0x200,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_SHADER_USAGE = 0x400,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_METADATA_HDR10 = 0x800
} D3D11_VIDEO_PROCESSOR_FEATURE_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_FILTER_CAPS {
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_BRIGHTNESS = 0x1,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_CONTRAST = 0x2,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_HUE = 0x4,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_SATURATION = 0x8,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_NOISE_REDUCTION = 0x10,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_EDGE_ENHANCEMENT = 0x20,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_ANAMORPHIC_SCALING = 0x40,
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_STEREO_ADJUSTMENT = 0x80
} D3D11_VIDEO_PROCESSOR_FILTER_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_FORMAT_CAPS {
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_INTERLACED = 0x1,
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_PROCAMP = 0x2,
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_LUMA_KEY = 0x4,
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_PALETTE_INTERLACED = 0x8
} D3D11_VIDEO_PROCESSOR_FORMAT_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS {
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_DENOISE = 0x1,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_DERINGING = 0x2,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_EDGE_ENHANCEMENT = 0x4,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_COLOR_CORRECTION = 0x8,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_FLESH_TONE_MAPPING = 0x10,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_IMAGE_STABILIZATION = 0x20,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_SUPER_RESOLUTION = 0x40,
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_ANAMORPHIC_SCALING = 0x80
} D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_STEREO_CAPS {
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_MONO_OFFSET = 0x1,
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_ROW_INTERLEAVED = 0x2,
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_COLUMN_INTERLEAVED = 0x4,
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_CHECKERBOARD = 0x8,
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_FLIP_MODE = 0x10
} D3D11_VIDEO_PROCESSOR_STEREO_CAPS;
typedef struct D3D11_VIDEO_PROCESSOR_CAPS {
    UINT DeviceCaps;
    UINT FeatureCaps;
    UINT FilterCaps;
    UINT InputFormatCaps;
    UINT AutoStreamCaps;
    UINT StereoCaps;
    UINT RateConversionCapsCount;
    UINT MaxInputStreams;
    UINT MaxStreamStates;
} D3D11_VIDEO_PROCESSOR_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS {
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_BLEND = 0x1,
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_BOB = 0x2,
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE = 0x4,
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION = 0x8,
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_INVERSE_TELECINE = 0x10,
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_FRAME_RATE_CONVERSION = 0x20
} D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS;
typedef enum D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS {
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_32 = 0x1,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_22 = 0x2,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_2224 = 0x4,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_2332 = 0x8,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_32322 = 0x10,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_55 = 0x20,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_64 = 0x40,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_87 = 0x80,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_222222222223 = 0x100,
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_OTHER = 0x80000000
} D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS;
typedef struct D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS {
    UINT PastFrames;
    UINT FutureFrames;
    UINT ProcessorCaps;
    UINT ITelecineCaps;
    UINT CustomRateCount;
} D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS;
typedef enum D3D11_CONTENT_PROTECTION_CAPS {
    D3D11_CONTENT_PROTECTION_CAPS_SOFTWARE = 0x1,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE = 0x2,
    D3D11_CONTENT_PROTECTION_CAPS_PROTECTION_ALWAYS_ON = 0x4,
    D3D11_CONTENT_PROTECTION_CAPS_PARTIAL_DECRYPTION = 0x8,
    D3D11_CONTENT_PROTECTION_CAPS_CONTENT_KEY = 0x10,
    D3D11_CONTENT_PROTECTION_CAPS_FRESHEN_SESSION_KEY = 0x20,
    D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK = 0x40,
    D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK_KEY = 0x80,
    D3D11_CONTENT_PROTECTION_CAPS_SEQUENTIAL_CTR_IV = 0x100,
    D3D11_CONTENT_PROTECTION_CAPS_ENCRYPT_SLICEDATA_ONLY = 0x200,
    D3D11_CONTENT_PROTECTION_CAPS_DECRYPTION_BLT = 0x400,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_PROTECT_UNCOMPRESSED = 0x800,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_PROTECTED_MEMORY_PAGEABLE = 0x1000,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_TEARDOWN = 0x2000,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_DRM_COMMUNICATION = 0x4000,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_DRM_COMMUNICATION_MULTI_THREADED = 0x8000
} D3D11_CONTENT_PROTECTION_CAPS;
extern "C" const GUID D3D11_CRYPTO_TYPE_AES128_CTR;
extern "C" const GUID D3D11_DECODER_ENCRYPTION_HW_CENC;
extern "C" const GUID D3D11_DECODER_BITSTREAM_ENCRYPTION_TYPE_CENC;
extern "C" const GUID D3D11_DECODER_BITSTREAM_ENCRYPTION_TYPE_CBCS;
extern "C" const GUID D3D11_KEY_EXCHANGE_HW_PROTECTION;
typedef struct D3D11_VIDEO_CONTENT_PROTECTION_CAPS {
    UINT Caps;
    UINT KeyExchangeTypeCount;
    UINT BlockAlignmentSize;
    ULONGLONG ProtectedMemorySize;
} D3D11_VIDEO_CONTENT_PROTECTION_CAPS;
typedef struct D3D11_VIDEO_PROCESSOR_CUSTOM_RATE {
    DXGI_RATIONAL CustomRate;
    UINT OutputFrames;
    BOOL InputInterlaced;
    UINT InputFramesOrFields;
} D3D11_VIDEO_PROCESSOR_CUSTOM_RATE;
typedef enum D3D11_VIDEO_PROCESSOR_FILTER {
    D3D11_VIDEO_PROCESSOR_FILTER_BRIGHTNESS = 0,
    D3D11_VIDEO_PROCESSOR_FILTER_CONTRAST = 1,
    D3D11_VIDEO_PROCESSOR_FILTER_HUE = 2,
    D3D11_VIDEO_PROCESSOR_FILTER_SATURATION = 3,
    D3D11_VIDEO_PROCESSOR_FILTER_NOISE_REDUCTION = 4,
    D3D11_VIDEO_PROCESSOR_FILTER_EDGE_ENHANCEMENT = 5,
    D3D11_VIDEO_PROCESSOR_FILTER_ANAMORPHIC_SCALING = 6,
    D3D11_VIDEO_PROCESSOR_FILTER_STEREO_ADJUSTMENT = 7
} D3D11_VIDEO_PROCESSOR_FILTER;
typedef struct D3D11_VIDEO_PROCESSOR_FILTER_RANGE {
    int Minimum;
    int Maximum;
    int Default;
    float Multiplier;
} D3D11_VIDEO_PROCESSOR_FILTER_RANGE;
typedef enum D3D11_VIDEO_FRAME_FORMAT {
    D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE = 0,
    D3D11_VIDEO_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST = 1,
    D3D11_VIDEO_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST = 2
} D3D11_VIDEO_FRAME_FORMAT;
typedef enum D3D11_VIDEO_USAGE {
    D3D11_VIDEO_USAGE_PLAYBACK_NORMAL = 0,
    D3D11_VIDEO_USAGE_OPTIMAL_SPEED = 1,
    D3D11_VIDEO_USAGE_OPTIMAL_QUALITY = 2
} D3D11_VIDEO_USAGE;
typedef struct D3D11_VIDEO_PROCESSOR_CONTENT_DESC {
    D3D11_VIDEO_FRAME_FORMAT InputFrameFormat;
    DXGI_RATIONAL InputFrameRate;
    UINT InputWidth;
    UINT InputHeight;
    DXGI_RATIONAL OutputFrameRate;
    UINT OutputWidth;
    UINT OutputHeight;
    D3D11_VIDEO_USAGE Usage;
} D3D11_VIDEO_PROCESSOR_CONTENT_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0031_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11VideoProcessorEnumerator;
struct __declspec(uuid("31627037-53AB-4200-9061-05FAA9AB45F9")) __declspec(novtable)
    ID3D11VideoProcessorEnumerator : public ID3D11DeviceChild {
public:
    virtual HRESULT __stdcall GetVideoProcessorContentDesc(
        D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pContentDesc)
        = 0;
    virtual HRESULT __stdcall CheckVideoProcessorFormat(
        DXGI_FORMAT Format,
        UINT* pFlags)
        = 0;
    virtual HRESULT __stdcall GetVideoProcessorCaps(
        D3D11_VIDEO_PROCESSOR_CAPS* pCaps)
        = 0;
    virtual HRESULT __stdcall GetVideoProcessorRateConversionCaps(
        UINT TypeIndex,
        D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps)
        = 0;
    virtual HRESULT __stdcall GetVideoProcessorCustomRate(
        UINT TypeIndex,
        UINT CustomRateIndex,
        D3D11_VIDEO_PROCESSOR_CUSTOM_RATE* pRate)
        = 0;
    virtual HRESULT __stdcall GetVideoProcessorFilterRange(
        D3D11_VIDEO_PROCESSOR_FILTER Filter,
        D3D11_VIDEO_PROCESSOR_FILTER_RANGE* pRange)
        = 0;
};
typedef struct D3D11_VIDEO_COLOR_RGBA {
    float R;
    float G;
    float B;
    float A;
} D3D11_VIDEO_COLOR_RGBA;
typedef struct D3D11_VIDEO_COLOR_YCbCrA {
    float Y;
    float Cb;
    float Cr;
    float A;
} D3D11_VIDEO_COLOR_YCbCrA;
typedef struct D3D11_VIDEO_COLOR {
    union {
        D3D11_VIDEO_COLOR_YCbCrA YCbCr;
        D3D11_VIDEO_COLOR_RGBA RGBA;
    };
} D3D11_VIDEO_COLOR;
typedef enum D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE {
    D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_UNDEFINED = 0,
    D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_16_235 = 1,
    D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_0_255 = 2
} D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE;
typedef struct D3D11_VIDEO_PROCESSOR_COLOR_SPACE {
    UINT Usage : 1;
    UINT RGB_Range : 1;
    UINT YCbCr_Matrix : 1;
    UINT YCbCr_xvYCC : 1;
    UINT Nominal_Range : 2;
    UINT Reserved : 26;
} D3D11_VIDEO_PROCESSOR_COLOR_SPACE;
typedef enum D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE {
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_OPAQUE = 0,
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_BACKGROUND = 1,
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_DESTINATION = 2,
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM = 3
} D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE;
typedef enum D3D11_VIDEO_PROCESSOR_OUTPUT_RATE {
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_NORMAL = 0,
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_HALF = 1,
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM = 2
} D3D11_VIDEO_PROCESSOR_OUTPUT_RATE;
typedef enum D3D11_VIDEO_PROCESSOR_STEREO_FORMAT {
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO = 0,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_HORIZONTAL = 1,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_VERTICAL = 2,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE = 3,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET = 4,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_ROW_INTERLEAVED = 5,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_COLUMN_INTERLEAVED = 6,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_CHECKERBOARD = 7
} D3D11_VIDEO_PROCESSOR_STEREO_FORMAT;
typedef enum D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE {
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_NONE = 0,
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME0 = 1,
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME1 = 2
} D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE;
typedef enum D3D11_VIDEO_PROCESSOR_ROTATION {
    D3D11_VIDEO_PROCESSOR_ROTATION_IDENTITY = 0,
    D3D11_VIDEO_PROCESSOR_ROTATION_90 = 1,
    D3D11_VIDEO_PROCESSOR_ROTATION_180 = 2,
    D3D11_VIDEO_PROCESSOR_ROTATION_270 = 3
} D3D11_VIDEO_PROCESSOR_ROTATION;
typedef struct D3D11_VIDEO_PROCESSOR_STREAM {
    BOOL Enable;
    UINT OutputIndex;
    UINT InputFrameOrField;
    UINT PastFrames;
    UINT FutureFrames;
    ID3D11VideoProcessorInputView** ppPastSurfaces;
    ID3D11VideoProcessorInputView* pInputSurface;
    ID3D11VideoProcessorInputView** ppFutureSurfaces;
    ID3D11VideoProcessorInputView** ppPastSurfacesRight;
    ID3D11VideoProcessorInputView* pInputSurfaceRight;
    ID3D11VideoProcessorInputView** ppFutureSurfacesRight;
} D3D11_VIDEO_PROCESSOR_STREAM;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0032_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11VideoProcessor;
struct __declspec(uuid("1D7B0652-185F-41c6-85CE-0C5BE3D4AE6C")) __declspec(novtable)
    ID3D11VideoProcessor : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetContentDesc(
        D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc)
        = 0;
    virtual void __stdcall GetRateConversionCaps(
        D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps)
        = 0;
};
typedef struct D3D11_OMAC {
    BYTE Omac[16];
} D3D11_OMAC;
typedef enum D3D11_AUTHENTICATED_CHANNEL_TYPE {
    D3D11_AUTHENTICATED_CHANNEL_D3D11 = 1,
    D3D11_AUTHENTICATED_CHANNEL_DRIVER_SOFTWARE = 2,
    D3D11_AUTHENTICATED_CHANNEL_DRIVER_HARDWARE = 3
} D3D11_AUTHENTICATED_CHANNEL_TYPE;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0033_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11AuthenticatedChannel;
struct __declspec(uuid("3015A308-DCBD-47aa-A747-192486D14D4A")) __declspec(novtable)
    ID3D11AuthenticatedChannel : public ID3D11DeviceChild {
public:
    virtual HRESULT __stdcall GetCertificateSize(
        UINT* pCertificateSize)
        = 0;
    virtual HRESULT __stdcall GetCertificate(
        UINT CertificateSize,
        BYTE* pCertificate)
        = 0;
    virtual void __stdcall GetChannelHandle(
        HANDLE* pChannelHandle)
        = 0;
};
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_PROTECTION;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_OUTPUT_ID;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ATTRIBUTES;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID_COUNT;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID;
extern "C" const GUID D3D11_AUTHENTICATED_QUERY_CURRENT_ENCRYPTION_WHEN_ACCESSIBLE;
extern "C" const GUID D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE;
extern "C" const GUID D3D11_AUTHENTICATED_CONFIGURE_PROTECTION;
extern "C" const GUID D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION;
extern "C" const GUID D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE;
extern "C" const GUID D3D11_AUTHENTICATED_CONFIGURE_ENCRYPTION_WHEN_ACCESSIBLE;
typedef struct D3D11_AUTHENTICATED_QUERY_INPUT {
    GUID QueryType;
    HANDLE hChannel;
    UINT SequenceNumber;
} D3D11_AUTHENTICATED_QUERY_INPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_OUTPUT {
    D3D11_OMAC omac;
    GUID QueryType;
    HANDLE hChannel;
    UINT SequenceNumber;
    HRESULT ReturnCode;
} D3D11_AUTHENTICATED_QUERY_OUTPUT;
typedef union D3D11_AUTHENTICATED_PROTECTION_FLAGS {
    struct __MIDL___MIDL_itf_d3d11_0000_0034_0001 {
        UINT ProtectionEnabled : 1;
        UINT OverlayOrFullscreenRequired : 1;
        UINT Reserved : 30;
    } Flags;
    UINT Value;
} D3D11_AUTHENTICATED_PROTECTION_FLAGS;
typedef struct D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    D3D11_AUTHENTICATED_PROTECTION_FLAGS ProtectionFlags;
} D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType;
} D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    HANDLE DeviceHandle;
} D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT {
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    HANDLE DecoderHandle;
} D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    HANDLE DecoderHandle;
    HANDLE CryptoSessionHandle;
    HANDLE DeviceHandle;
} D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    UINT RestrictedSharedResourceProcessCount;
} D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT {
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    UINT ProcessIndex;
} D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT;
typedef enum D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE {
    D3D11_PROCESSIDTYPE_UNKNOWN = 0,
    D3D11_PROCESSIDTYPE_DWM = 1,
    D3D11_PROCESSIDTYPE_HANDLE = 2
} D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE;
typedef struct D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    UINT ProcessIndex;
    D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE ProcessIdentifier;
    HANDLE ProcessHandle;
} D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    UINT UnrestrictedProtectedSharedResourceCount;
} D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT {
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
} D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
    UINT OutputIDCount;
} D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT {
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
    UINT OutputIDIndex;
} D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    HANDLE DeviceHandle;
    HANDLE CryptoSessionHandle;
    UINT OutputIDIndex;
    UINT64 OutputID;
} D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT;
typedef enum D3D11_BUS_TYPE {
    D3D11_BUS_TYPE_OTHER = 0,
    D3D11_BUS_TYPE_PCI = 0x1,
    D3D11_BUS_TYPE_PCIX = 0x2,
    D3D11_BUS_TYPE_PCIEXPRESS = 0x3,
    D3D11_BUS_TYPE_AGP = 0x4,
    D3D11_BUS_IMPL_MODIFIER_INSIDE_OF_CHIPSET = 0x10000,
    D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = 0x20000,
    D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 0x30000,
    D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR = 0x40000,
    D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 0x50000,
    D3D11_BUS_IMPL_MODIFIER_NON_STANDARD = 0x80000000
} D3D11_BUS_TYPE;
typedef struct D3D11_AUTHENTICATED_QUERY_ACESSIBILITY_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    D3D11_BUS_TYPE BusType;
    BOOL AccessibleInContiguousBlocks;
    BOOL AccessibleInNonContiguousBlocks;
} D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    UINT EncryptionGuidCount;
} D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT {
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    UINT EncryptionGuidIndex;
} D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    UINT EncryptionGuidIndex;
    GUID EncryptionGuid;
} D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT;
typedef struct D3D11_AUTHENTICATED_QUERY_CURRENT_ACCESSIBILITY_ENCRYPTION_OUTPUT {
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    GUID EncryptionGuid;
} D3D11_AUTHENTICATED_QUERY_CURRENT_ACCESSIBILITY_ENCRYPTION_OUTPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_INPUT {
    D3D11_OMAC omac;
    GUID ConfigureType;
    HANDLE hChannel;
    UINT SequenceNumber;
} D3D11_AUTHENTICATED_CONFIGURE_INPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_OUTPUT {
    D3D11_OMAC omac;
    GUID ConfigureType;
    HANDLE hChannel;
    UINT SequenceNumber;
    HRESULT ReturnCode;
} D3D11_AUTHENTICATED_CONFIGURE_OUTPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT {
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    UINT StartSequenceQuery;
    UINT StartSequenceConfigure;
} D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT {
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    D3D11_AUTHENTICATED_PROTECTION_FLAGS Protections;
} D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT {
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    HANDLE DecoderHandle;
    HANDLE CryptoSessionHandle;
    HANDLE DeviceHandle;
} D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT {
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE ProcessType;
    HANDLE ProcessHandle;
    BOOL AllowAccess;
} D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT;
typedef struct D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT {
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    GUID EncryptionGuid;
} D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT;
extern "C" const GUID D3D11_KEY_EXCHANGE_RSAES_OAEP;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0034_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11CryptoSession;
struct __declspec(uuid("9B32F9AD-BDCC-40a6-A39D-D5C865845720")) __declspec(novtable)
    ID3D11CryptoSession : public ID3D11DeviceChild {
public:
    virtual void __stdcall GetCryptoType(
        GUID* pCryptoType)
        = 0;
    virtual void __stdcall GetDecoderProfile(
        GUID* pDecoderProfile)
        = 0;
    virtual HRESULT __stdcall GetCertificateSize(
        UINT* pCertificateSize)
        = 0;
    virtual HRESULT __stdcall GetCertificate(
        UINT CertificateSize,
        BYTE* pCertificate)
        = 0;
    virtual void __stdcall GetCryptoSessionHandle(
        HANDLE* pCryptoSessionHandle)
        = 0;
};
typedef enum D3D11_VDOV_DIMENSION {
    D3D11_VDOV_DIMENSION_UNKNOWN = 0,
    D3D11_VDOV_DIMENSION_TEXTURE2D = 1
} D3D11_VDOV_DIMENSION;
typedef struct D3D11_TEX2D_VDOV {
    UINT ArraySlice;
} D3D11_TEX2D_VDOV;
typedef struct D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC {
    GUID DecodeProfile;
    D3D11_VDOV_DIMENSION ViewDimension;
    union {
        D3D11_TEX2D_VDOV Texture2D;
    };
} D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0035_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11VideoDecoderOutputView;
struct __declspec(uuid("C2931AEA-2A85-4f20-860F-FBA1FD256E18")) __declspec(novtable)
    ID3D11VideoDecoderOutputView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc)
        = 0;
};
typedef enum D3D11_VPIV_DIMENSION {
    D3D11_VPIV_DIMENSION_UNKNOWN = 0,
    D3D11_VPIV_DIMENSION_TEXTURE2D = 1
} D3D11_VPIV_DIMENSION;
typedef struct D3D11_TEX2D_VPIV {
    UINT MipSlice;
    UINT ArraySlice;
} D3D11_TEX2D_VPIV;
typedef struct D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC {
    UINT FourCC;
    D3D11_VPIV_DIMENSION ViewDimension;
    union {
        D3D11_TEX2D_VPIV Texture2D;
    };
} D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0036_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11VideoProcessorInputView;
struct __declspec(uuid("11EC5A5F-51DC-4945-AB34-6E8C21300EA5")) __declspec(novtable)
    ID3D11VideoProcessorInputView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc)
        = 0;
};
typedef enum D3D11_VPOV_DIMENSION {
    D3D11_VPOV_DIMENSION_UNKNOWN = 0,
    D3D11_VPOV_DIMENSION_TEXTURE2D = 1,
    D3D11_VPOV_DIMENSION_TEXTURE2DARRAY = 2
} D3D11_VPOV_DIMENSION;
typedef struct D3D11_TEX2D_VPOV {
    UINT MipSlice;
} D3D11_TEX2D_VPOV;
typedef struct D3D11_TEX2D_ARRAY_VPOV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D11_TEX2D_ARRAY_VPOV;
typedef struct D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC {
    D3D11_VPOV_DIMENSION ViewDimension;
    union {
        D3D11_TEX2D_VPOV Texture2D;
        D3D11_TEX2D_ARRAY_VPOV Texture2DArray;
    };
} D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0037_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11VideoProcessorOutputView;
struct __declspec(uuid("A048285E-25A9-4527-BD93-D68B68C44254")) __declspec(novtable)
    ID3D11VideoProcessorOutputView : public ID3D11View {
public:
    virtual void __stdcall GetDesc(
        D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc)
        = 0;
};
extern "C" const IID IID_ID3D11VideoContext;
struct __declspec(uuid("61F21C45-3C0E-4a74-9CEA-67100D9AD5E4")) __declspec(novtable)
    ID3D11VideoContext : public ID3D11DeviceChild {
public:
    virtual HRESULT __stdcall GetDecoderBuffer(
        ID3D11VideoDecoder* pDecoder,
        D3D11_VIDEO_DECODER_BUFFER_TYPE Type,
        UINT* pBufferSize,
        void** ppBuffer)
        = 0;
    virtual HRESULT __stdcall ReleaseDecoderBuffer(
        ID3D11VideoDecoder* pDecoder,
        D3D11_VIDEO_DECODER_BUFFER_TYPE Type)
        = 0;
    virtual HRESULT __stdcall DecoderBeginFrame(
        ID3D11VideoDecoder* pDecoder,
        ID3D11VideoDecoderOutputView* pView,
        UINT ContentKeySize,
        const void* pContentKey)
        = 0;
    virtual HRESULT __stdcall DecoderEndFrame(
        ID3D11VideoDecoder* pDecoder)
        = 0;
    virtual HRESULT __stdcall SubmitDecoderBuffers(
        ID3D11VideoDecoder* pDecoder,
        UINT NumBuffers,
        const D3D11_VIDEO_DECODER_BUFFER_DESC* pBufferDesc)
        = 0;
    virtual APP_DEPRECATED_HRESULT __stdcall DecoderExtension(
        ID3D11VideoDecoder* pDecoder,
        const D3D11_VIDEO_DECODER_EXTENSION* pExtensionData)
        = 0;
    virtual void __stdcall VideoProcessorSetOutputTargetRect(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL Enable,
        const RECT* pRect)
        = 0;
    virtual void __stdcall VideoProcessorSetOutputBackgroundColor(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL YCbCr,
        const D3D11_VIDEO_COLOR* pColor)
        = 0;
    virtual void __stdcall VideoProcessorSetOutputColorSpace(
        ID3D11VideoProcessor* pVideoProcessor,
        const D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
        = 0;
    virtual void __stdcall VideoProcessorSetOutputAlphaFillMode(
        ID3D11VideoProcessor* pVideoProcessor,
        D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE AlphaFillMode,
        UINT StreamIndex)
        = 0;
    virtual void __stdcall VideoProcessorSetOutputConstriction(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL Enable,
        SIZE Size)
        = 0;
    virtual void __stdcall VideoProcessorSetOutputStereoMode(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL Enable)
        = 0;
    virtual APP_DEPRECATED_HRESULT __stdcall VideoProcessorSetOutputExtension(
        ID3D11VideoProcessor* pVideoProcessor,
        const GUID* pExtensionGuid,
        UINT DataSize,
        void* pData)
        = 0;
    virtual void __stdcall VideoProcessorGetOutputTargetRect(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL* Enabled,
        RECT* pRect)
        = 0;
    virtual void __stdcall VideoProcessorGetOutputBackgroundColor(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL* pYCbCr,
        D3D11_VIDEO_COLOR* pColor)
        = 0;
    virtual void __stdcall VideoProcessorGetOutputColorSpace(
        ID3D11VideoProcessor* pVideoProcessor,
        D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
        = 0;
    virtual void __stdcall VideoProcessorGetOutputAlphaFillMode(
        ID3D11VideoProcessor* pVideoProcessor,
        D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE* pAlphaFillMode,
        UINT* pStreamIndex)
        = 0;
    virtual void __stdcall VideoProcessorGetOutputConstriction(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL* pEnabled,
        SIZE* pSize)
        = 0;
    virtual void __stdcall VideoProcessorGetOutputStereoMode(
        ID3D11VideoProcessor* pVideoProcessor,
        BOOL* pEnabled)
        = 0;
    virtual APP_DEPRECATED_HRESULT __stdcall VideoProcessorGetOutputExtension(
        ID3D11VideoProcessor* pVideoProcessor,
        const GUID* pExtensionGuid,
        UINT DataSize,
        void* pData)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamFrameFormat(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_FRAME_FORMAT FrameFormat)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamColorSpace(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        const D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamOutputRate(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_PROCESSOR_OUTPUT_RATE OutputRate,
        BOOL RepeatFrame,
        const DXGI_RATIONAL* pCustomRate)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamSourceRect(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        const RECT* pRect)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamDestRect(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        const RECT* pRect)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamAlpha(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        FLOAT Alpha)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamPalette(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        UINT Count,
        const UINT* pEntries)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamPixelAspectRatio(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        const DXGI_RATIONAL* pSourceAspectRatio,
        const DXGI_RATIONAL* pDestinationAspectRatio)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamLumaKey(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        FLOAT Lower,
        FLOAT Upper)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamStereoFormat(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        D3D11_VIDEO_PROCESSOR_STEREO_FORMAT Format,
        BOOL LeftViewFrame0,
        BOOL BaseViewFrame0,
        D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE FlipMode,
        int MonoOffset)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamAutoProcessingMode(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamFilter(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_PROCESSOR_FILTER Filter,
        BOOL Enable,
        int Level)
        = 0;
    virtual APP_DEPRECATED_HRESULT __stdcall VideoProcessorSetStreamExtension(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        const GUID* pExtensionGuid,
        UINT DataSize,
        void* pData)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamFrameFormat(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_FRAME_FORMAT* pFrameFormat)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamColorSpace(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamOutputRate(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_PROCESSOR_OUTPUT_RATE* pOutputRate,
        BOOL* pRepeatFrame,
        DXGI_RATIONAL* pCustomRate)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamSourceRect(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnabled,
        RECT* pRect)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamDestRect(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnabled,
        RECT* pRect)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamAlpha(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnabled,
        FLOAT* pAlpha)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamPalette(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        UINT Count,
        UINT* pEntries)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamPixelAspectRatio(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnabled,
        DXGI_RATIONAL* pSourceAspectRatio,
        DXGI_RATIONAL* pDestinationAspectRatio)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamLumaKey(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnabled,
        FLOAT* pLower,
        FLOAT* pUpper)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamStereoFormat(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnable,
        D3D11_VIDEO_PROCESSOR_STEREO_FORMAT* pFormat,
        BOOL* pLeftViewFrame0,
        BOOL* pBaseViewFrame0,
        D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE* pFlipMode,
        int* MonoOffset)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamAutoProcessingMode(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnabled)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamFilter(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        D3D11_VIDEO_PROCESSOR_FILTER Filter,
        BOOL* pEnabled,
        int* pLevel)
        = 0;
    virtual APP_DEPRECATED_HRESULT __stdcall VideoProcessorGetStreamExtension(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        const GUID* pExtensionGuid,
        UINT DataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall VideoProcessorBlt(
        ID3D11VideoProcessor* pVideoProcessor,
        ID3D11VideoProcessorOutputView* pView,
        UINT OutputFrame,
        UINT StreamCount,
        const D3D11_VIDEO_PROCESSOR_STREAM* pStreams)
        = 0;
    virtual HRESULT __stdcall NegotiateCryptoSessionKeyExchange(
        ID3D11CryptoSession* pCryptoSession,
        UINT DataSize,
        void* pData)
        = 0;
    virtual void __stdcall EncryptionBlt(
        ID3D11CryptoSession* pCryptoSession,
        ID3D11Texture2D* pSrcSurface,
        ID3D11Texture2D* pDstSurface,
        UINT IVSize,
        void* pIV)
        = 0;
    virtual void __stdcall DecryptionBlt(
        ID3D11CryptoSession* pCryptoSession,
        ID3D11Texture2D* pSrcSurface,
        ID3D11Texture2D* pDstSurface,
        D3D11_ENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo,
        UINT ContentKeySize,
        const void* pContentKey,
        UINT IVSize,
        void* pIV)
        = 0;
    virtual void __stdcall StartSessionKeyRefresh(
        ID3D11CryptoSession* pCryptoSession,
        UINT RandomNumberSize,
        void* pRandomNumber)
        = 0;
    virtual void __stdcall FinishSessionKeyRefresh(
        ID3D11CryptoSession* pCryptoSession)
        = 0;
    virtual HRESULT __stdcall GetEncryptionBltKey(
        ID3D11CryptoSession* pCryptoSession,
        UINT KeySize,
        void* pReadbackKey)
        = 0;
    virtual HRESULT __stdcall NegotiateAuthenticatedChannelKeyExchange(
        ID3D11AuthenticatedChannel* pChannel,
        UINT DataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall QueryAuthenticatedChannel(
        ID3D11AuthenticatedChannel* pChannel,
        UINT InputSize,
        const void* pInput,
        UINT OutputSize,
        void* pOutput)
        = 0;
    virtual HRESULT __stdcall ConfigureAuthenticatedChannel(
        ID3D11AuthenticatedChannel* pChannel,
        UINT InputSize,
        const void* pInput,
        D3D11_AUTHENTICATED_CONFIGURE_OUTPUT* pOutput)
        = 0;
    virtual void __stdcall VideoProcessorSetStreamRotation(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL Enable,
        D3D11_VIDEO_PROCESSOR_ROTATION Rotation)
        = 0;
    virtual void __stdcall VideoProcessorGetStreamRotation(
        ID3D11VideoProcessor* pVideoProcessor,
        UINT StreamIndex,
        BOOL* pEnable,
        D3D11_VIDEO_PROCESSOR_ROTATION* pRotation)
        = 0;
};
extern "C" const IID IID_ID3D11VideoDevice;
struct __declspec(uuid("10EC4D5B-975A-4689-B9E4-D0AAC30FE333")) __declspec(novtable)
    ID3D11VideoDevice : public IUnknown {
public:
    virtual HRESULT __stdcall CreateVideoDecoder(
        const D3D11_VIDEO_DECODER_DESC* pVideoDesc,
        const D3D11_VIDEO_DECODER_CONFIG* pConfig,
        ID3D11VideoDecoder** ppDecoder)
        = 0;
    virtual HRESULT __stdcall CreateVideoProcessor(
        ID3D11VideoProcessorEnumerator* pEnum,
        UINT RateConversionIndex,
        ID3D11VideoProcessor** ppVideoProcessor)
        = 0;
    virtual HRESULT __stdcall CreateAuthenticatedChannel(
        D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType,
        ID3D11AuthenticatedChannel** ppAuthenticatedChannel)
        = 0;
    virtual HRESULT __stdcall CreateCryptoSession(
        const GUID* pCryptoType,
        const GUID* pDecoderProfile,
        const GUID* pKeyExchangeType,
        ID3D11CryptoSession** ppCryptoSession)
        = 0;
    virtual HRESULT __stdcall CreateVideoDecoderOutputView(
        ID3D11Resource* pResource,
        const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc,
        ID3D11VideoDecoderOutputView** ppVDOVView)
        = 0;
    virtual HRESULT __stdcall CreateVideoProcessorInputView(
        ID3D11Resource* pResource,
        ID3D11VideoProcessorEnumerator* pEnum,
        const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc,
        ID3D11VideoProcessorInputView** ppVPIView)
        = 0;
    virtual HRESULT __stdcall CreateVideoProcessorOutputView(
        ID3D11Resource* pResource,
        ID3D11VideoProcessorEnumerator* pEnum,
        const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc,
        ID3D11VideoProcessorOutputView** ppVPOView)
        = 0;
    virtual HRESULT __stdcall CreateVideoProcessorEnumerator(
        const D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc,
        ID3D11VideoProcessorEnumerator** ppEnum)
        = 0;
    virtual UINT __stdcall GetVideoDecoderProfileCount(void) = 0;
    virtual HRESULT __stdcall GetVideoDecoderProfile(
        UINT Index,
        GUID* pDecoderProfile)
        = 0;
    virtual HRESULT __stdcall CheckVideoDecoderFormat(
        const GUID* pDecoderProfile,
        DXGI_FORMAT Format,
        BOOL* pSupported)
        = 0;
    virtual HRESULT __stdcall GetVideoDecoderConfigCount(
        const D3D11_VIDEO_DECODER_DESC* pDesc,
        UINT* pCount)
        = 0;
    virtual HRESULT __stdcall GetVideoDecoderConfig(
        const D3D11_VIDEO_DECODER_DESC* pDesc,
        UINT Index,
        D3D11_VIDEO_DECODER_CONFIG* pConfig)
        = 0;
    virtual HRESULT __stdcall GetContentProtectionCaps(
        const GUID* pCryptoType,
        const GUID* pDecoderProfile,
        D3D11_VIDEO_CONTENT_PROTECTION_CAPS* pCaps)
        = 0;
    virtual HRESULT __stdcall CheckCryptoKeyExchange(
        const GUID* pCryptoType,
        const GUID* pDecoderProfile,
        UINT Index,
        GUID* pKeyExchangeType)
        = 0;
    virtual HRESULT __stdcall SetPrivateData(
        const GUID& guid,
        UINT DataSize,
        const void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateDataInterface(
        const GUID& guid,
        const IUnknown* pData)
        = 0;
};
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0040_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Device;
struct __declspec(uuid("db6f6ddb-ac77-4e88-8253-819df9bbf140")) __declspec(novtable)
    ID3D11Device : public IUnknown {
public:
    virtual HRESULT __stdcall CreateBuffer(
        const D3D11_BUFFER_DESC* pDesc,
        const D3D11_SUBRESOURCE_DATA* pInitialData,
        ID3D11Buffer** ppBuffer)
        = 0;
    virtual HRESULT __stdcall CreateTexture1D(
        const D3D11_TEXTURE1D_DESC* pDesc,
        const D3D11_SUBRESOURCE_DATA* pInitialData,
        ID3D11Texture1D** ppTexture1D)
        = 0;
    virtual HRESULT __stdcall CreateTexture2D(
        const D3D11_TEXTURE2D_DESC* pDesc,
        const D3D11_SUBRESOURCE_DATA* pInitialData,
        ID3D11Texture2D** ppTexture2D)
        = 0;
    virtual HRESULT __stdcall CreateTexture3D(
        const D3D11_TEXTURE3D_DESC* pDesc,
        const D3D11_SUBRESOURCE_DATA* pInitialData,
        ID3D11Texture3D** ppTexture3D)
        = 0;
    virtual HRESULT __stdcall CreateShaderResourceView(
        ID3D11Resource* pResource,
        const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
        ID3D11ShaderResourceView** ppSRView)
        = 0;
    virtual HRESULT __stdcall CreateUnorderedAccessView(
        ID3D11Resource* pResource,
        const D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc,
        ID3D11UnorderedAccessView** ppUAView)
        = 0;
    virtual HRESULT __stdcall CreateRenderTargetView(
        ID3D11Resource* pResource,
        const D3D11_RENDER_TARGET_VIEW_DESC* pDesc,
        ID3D11RenderTargetView** ppRTView)
        = 0;
    virtual HRESULT __stdcall CreateDepthStencilView(
        ID3D11Resource* pResource,
        const D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc,
        ID3D11DepthStencilView** ppDepthStencilView)
        = 0;
    virtual HRESULT __stdcall CreateInputLayout(
        const D3D11_INPUT_ELEMENT_DESC* pInputElementDescs,
        UINT NumElements,
        const void* pShaderBytecodeWithInputSignature,
        SIZE_T BytecodeLength,
        ID3D11InputLayout** ppInputLayout)
        = 0;
    virtual HRESULT __stdcall CreateVertexShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11VertexShader** ppVertexShader)
        = 0;
    virtual HRESULT __stdcall CreateGeometryShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11GeometryShader** ppGeometryShader)
        = 0;
    virtual HRESULT __stdcall CreateGeometryShaderWithStreamOutput(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        const D3D11_SO_DECLARATION_ENTRY* pSODeclaration,
        UINT NumEntries,
        const UINT* pBufferStrides,
        UINT NumStrides,
        UINT RasterizedStream,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11GeometryShader** ppGeometryShader)
        = 0;
    virtual HRESULT __stdcall CreatePixelShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11PixelShader** ppPixelShader)
        = 0;
    virtual HRESULT __stdcall CreateHullShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11HullShader** ppHullShader)
        = 0;
    virtual HRESULT __stdcall CreateDomainShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11DomainShader** ppDomainShader)
        = 0;
    virtual HRESULT __stdcall CreateComputeShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D11ClassLinkage* pClassLinkage,
        ID3D11ComputeShader** ppComputeShader)
        = 0;
    virtual HRESULT __stdcall CreateClassLinkage(
        ID3D11ClassLinkage** ppLinkage)
        = 0;
    virtual HRESULT __stdcall CreateBlendState(
        const D3D11_BLEND_DESC* pBlendStateDesc,
        ID3D11BlendState** ppBlendState)
        = 0;
    virtual HRESULT __stdcall CreateDepthStencilState(
        const D3D11_DEPTH_STENCIL_DESC* pDepthStencilDesc,
        ID3D11DepthStencilState** ppDepthStencilState)
        = 0;
    virtual HRESULT __stdcall CreateRasterizerState(
        const D3D11_RASTERIZER_DESC* pRasterizerDesc,
        ID3D11RasterizerState** ppRasterizerState)
        = 0;
    virtual HRESULT __stdcall CreateSamplerState(
        const D3D11_SAMPLER_DESC* pSamplerDesc,
        ID3D11SamplerState** ppSamplerState)
        = 0;
    virtual HRESULT __stdcall CreateQuery(
        const D3D11_QUERY_DESC* pQueryDesc,
        ID3D11Query** ppQuery)
        = 0;
    virtual HRESULT __stdcall CreatePredicate(
        const D3D11_QUERY_DESC* pPredicateDesc,
        ID3D11Predicate** ppPredicate)
        = 0;
    virtual HRESULT __stdcall CreateCounter(
        const D3D11_COUNTER_DESC* pCounterDesc,
        ID3D11Counter** ppCounter)
        = 0;
    virtual HRESULT __stdcall CreateDeferredContext(
        UINT ContextFlags,
        ID3D11DeviceContext** ppDeferredContext)
        = 0;
    virtual HRESULT __stdcall OpenSharedResource(
        HANDLE hResource,
        const IID& ReturnedInterface,
        void** ppResource)
        = 0;
    virtual HRESULT __stdcall CheckFormatSupport(
        DXGI_FORMAT Format,
        UINT* pFormatSupport)
        = 0;
    virtual HRESULT __stdcall CheckMultisampleQualityLevels(
        DXGI_FORMAT Format,
        UINT SampleCount,
        UINT* pNumQualityLevels)
        = 0;
    virtual void __stdcall CheckCounterInfo(
        D3D11_COUNTER_INFO* pCounterInfo)
        = 0;
    virtual HRESULT __stdcall CheckCounter(
        const D3D11_COUNTER_DESC* pDesc,
        D3D11_COUNTER_TYPE* pType,
        UINT* pActiveCounters,
        LPSTR szName,
        UINT* pNameLength,
        LPSTR szUnits,
        UINT* pUnitsLength,
        LPSTR szDescription,
        UINT* pDescriptionLength)
        = 0;
    virtual HRESULT __stdcall CheckFeatureSupport(
        D3D11_FEATURE Feature,
        void* pFeatureSupportData,
        UINT FeatureSupportDataSize)
        = 0;
    virtual HRESULT __stdcall GetPrivateData(
        const GUID& guid,
        UINT* pDataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateData(
        const GUID& guid,
        UINT DataSize,
        const void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateDataInterface(
        const GUID& guid,
        const IUnknown* pData)
        = 0;
    virtual D3D_FEATURE_LEVEL __stdcall GetFeatureLevel(void) = 0;
    virtual UINT __stdcall GetCreationFlags(void) = 0;
    virtual HRESULT __stdcall GetDeviceRemovedReason(void) = 0;
    virtual void __stdcall GetImmediateContext(
        ID3D11DeviceContext** ppImmediateContext)
        = 0;
    virtual HRESULT __stdcall SetExceptionMode(
        UINT RaiseFlags)
        = 0;
    virtual UINT __stdcall GetExceptionMode(void) = 0;
};
typedef enum D3D11_CREATE_DEVICE_FLAG {
    D3D11_CREATE_DEVICE_SINGLETHREADED = 0x1,
    D3D11_CREATE_DEVICE_DEBUG = 0x2,
    D3D11_CREATE_DEVICE_SWITCH_TO_REF = 0x4,
    D3D11_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS = 0x8,
    D3D11_CREATE_DEVICE_BGRA_SUPPORT = 0x20,
    D3D11_CREATE_DEVICE_DEBUGGABLE = 0x40,
    D3D11_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY = 0x80,
    D3D11_CREATE_DEVICE_DISABLE_GPU_TIMEOUT = 0x100,
    D3D11_CREATE_DEVICE_VIDEO_SUPPORT = 0x800
} D3D11_CREATE_DEVICE_FLAG;
#pragma once
typedef struct ID3D11Debug ID3D11Debug;
typedef struct ID3D11SwitchToRef ID3D11SwitchToRef;
typedef struct ID3D11TracingDevice ID3D11TracingDevice;
typedef struct ID3D11RefTrackingOptions ID3D11RefTrackingOptions;
typedef struct ID3D11RefDefaultTrackingOptions ID3D11RefDefaultTrackingOptions;
typedef struct ID3D11InfoQueue ID3D11InfoQueue;
extern "C" {
#pragma region Application Family
#pragma region Application Family
typedef enum D3D11_RLDO_FLAGS {
    D3D11_RLDO_SUMMARY = 0x1,
    D3D11_RLDO_DETAIL = 0x2,
    D3D11_RLDO_IGNORE_INTERNAL = 0x4
} D3D11_RLDO_FLAGS;
extern "C++" {
inline constexpr D3D11_RLDO_FLAGS operator|(D3D11_RLDO_FLAGS a, D3D11_RLDO_FLAGS b) noexcept { return D3D11_RLDO_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)b)); }
inline D3D11_RLDO_FLAGS& operator|=(D3D11_RLDO_FLAGS& a, D3D11_RLDO_FLAGS b) noexcept { return (D3D11_RLDO_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)b)); }
inline constexpr D3D11_RLDO_FLAGS operator&(D3D11_RLDO_FLAGS a, D3D11_RLDO_FLAGS b) noexcept { return D3D11_RLDO_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)b)); }
inline D3D11_RLDO_FLAGS& operator&=(D3D11_RLDO_FLAGS& a, D3D11_RLDO_FLAGS b) noexcept { return (D3D11_RLDO_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)b)); }
inline constexpr D3D11_RLDO_FLAGS operator~(D3D11_RLDO_FLAGS a) noexcept { return D3D11_RLDO_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)a)); }
inline constexpr D3D11_RLDO_FLAGS operator^(D3D11_RLDO_FLAGS a, D3D11_RLDO_FLAGS b) noexcept { return D3D11_RLDO_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)b)); }
inline D3D11_RLDO_FLAGS& operator^=(D3D11_RLDO_FLAGS& a, D3D11_RLDO_FLAGS b) noexcept { return (D3D11_RLDO_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<D3D11_RLDO_FLAGS>::type)b)); }
}
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11Debug;
struct __declspec(uuid("79cf2233-7536-4948-9d36-1e4692dc5760")) __declspec(novtable)
    ID3D11Debug : public IUnknown {
public:
    virtual HRESULT __stdcall SetFeatureMask(
        UINT Mask)
        = 0;
    virtual UINT __stdcall GetFeatureMask(void) = 0;
    virtual HRESULT __stdcall SetPresentPerRenderOpDelay(
        UINT Milliseconds)
        = 0;
    virtual UINT __stdcall GetPresentPerRenderOpDelay(void) = 0;
    virtual HRESULT __stdcall SetSwapChain(
        IDXGISwapChain* pSwapChain)
        = 0;
    virtual HRESULT __stdcall GetSwapChain(
        IDXGISwapChain** ppSwapChain)
        = 0;
    virtual HRESULT __stdcall ValidateContext(
        ID3D11DeviceContext* pContext)
        = 0;
    virtual HRESULT __stdcall ReportLiveDeviceObjects(
        D3D11_RLDO_FLAGS Flags)
        = 0;
    virtual HRESULT __stdcall ValidateContextForDispatch(
        ID3D11DeviceContext* pContext)
        = 0;
};
#pragma endregion
#pragma endregion
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0001_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11SwitchToRef;
struct __declspec(uuid("1ef337e3-58e7-4f83-a692-db221f5ed47e")) __declspec(novtable)
    ID3D11SwitchToRef : public IUnknown {
public:
    virtual BOOL __stdcall SetUseRef(
        BOOL UseRef)
        = 0;
    virtual BOOL __stdcall GetUseRef(void) = 0;
};
#pragma endregion
#pragma region PC Application Family
#pragma region PC Application Family
typedef enum D3D11_SHADER_TRACKING_RESOURCE_TYPE {
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_NONE = 0,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_UAV_DEVICEMEMORY = 1,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_NON_UAV_DEVICEMEMORY = 2,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_ALL_DEVICEMEMORY = 3,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_GROUPSHARED_MEMORY = 4,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_ALL_SHARED_MEMORY = 5,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_GROUPSHARED_NON_UAV = 6,
    D3D11_SHADER_TRACKING_RESOURCE_TYPE_ALL = 7
} D3D11_SHADER_TRACKING_RESOURCE_TYPE;
typedef enum D3D11_SHADER_TRACKING_OPTION {
    D3D11_SHADER_TRACKING_OPTION_IGNORE = 0,
    D3D11_SHADER_TRACKING_OPTION_TRACK_UNINITIALIZED = 0x1,
    D3D11_SHADER_TRACKING_OPTION_TRACK_RAW = 0x2,
    D3D11_SHADER_TRACKING_OPTION_TRACK_WAR = 0x4,
    D3D11_SHADER_TRACKING_OPTION_TRACK_WAW = 0x8,
    D3D11_SHADER_TRACKING_OPTION_ALLOW_SAME = 0x10,
    D3D11_SHADER_TRACKING_OPTION_TRACK_ATOMIC_CONSISTENCY = 0x20,
    D3D11_SHADER_TRACKING_OPTION_TRACK_RAW_ACROSS_THREADGROUPS = 0x40,
    D3D11_SHADER_TRACKING_OPTION_TRACK_WAR_ACROSS_THREADGROUPS = 0x80,
    D3D11_SHADER_TRACKING_OPTION_TRACK_WAW_ACROSS_THREADGROUPS = 0x100,
    D3D11_SHADER_TRACKING_OPTION_TRACK_ATOMIC_CONSISTENCY_ACROSS_THREADGROUPS = 0x200,
    D3D11_SHADER_TRACKING_OPTION_UAV_SPECIFIC_FLAGS = (((D3D11_SHADER_TRACKING_OPTION_TRACK_RAW_ACROSS_THREADGROUPS | D3D11_SHADER_TRACKING_OPTION_TRACK_WAR_ACROSS_THREADGROUPS) | D3D11_SHADER_TRACKING_OPTION_TRACK_WAW_ACROSS_THREADGROUPS) | D3D11_SHADER_TRACKING_OPTION_TRACK_ATOMIC_CONSISTENCY_ACROSS_THREADGROUPS),
    D3D11_SHADER_TRACKING_OPTION_ALL_HAZARDS = (((((((D3D11_SHADER_TRACKING_OPTION_TRACK_RAW | D3D11_SHADER_TRACKING_OPTION_TRACK_WAR) | D3D11_SHADER_TRACKING_OPTION_TRACK_WAW) | D3D11_SHADER_TRACKING_OPTION_TRACK_ATOMIC_CONSISTENCY) | D3D11_SHADER_TRACKING_OPTION_TRACK_RAW_ACROSS_THREADGROUPS) | D3D11_SHADER_TRACKING_OPTION_TRACK_WAR_ACROSS_THREADGROUPS) | D3D11_SHADER_TRACKING_OPTION_TRACK_WAW_ACROSS_THREADGROUPS) | D3D11_SHADER_TRACKING_OPTION_TRACK_ATOMIC_CONSISTENCY_ACROSS_THREADGROUPS),
    D3D11_SHADER_TRACKING_OPTION_ALL_HAZARDS_ALLOWING_SAME = (D3D11_SHADER_TRACKING_OPTION_ALL_HAZARDS | D3D11_SHADER_TRACKING_OPTION_ALLOW_SAME),
    D3D11_SHADER_TRACKING_OPTION_ALL_OPTIONS = (D3D11_SHADER_TRACKING_OPTION_ALL_HAZARDS_ALLOWING_SAME | D3D11_SHADER_TRACKING_OPTION_TRACK_UNINITIALIZED)
} D3D11_SHADER_TRACKING_OPTIONS;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0002_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11TracingDevice;
struct __declspec(uuid("1911c771-1587-413e-a7e0-fb26c3de0268")) __declspec(novtable)
    ID3D11TracingDevice : public IUnknown {
public:
    virtual HRESULT __stdcall SetShaderTrackingOptionsByType(
        UINT ResourceTypeFlags,
        UINT Options)
        = 0;
    virtual HRESULT __stdcall SetShaderTrackingOptions(
        IUnknown* pShader,
        UINT Options)
        = 0;
};
extern "C" const IID IID_ID3D11RefTrackingOptions;
struct __declspec(uuid("193dacdf-0db2-4c05-a55c-ef06cac56fd9")) __declspec(novtable)
    ID3D11RefTrackingOptions : public IUnknown {
public:
    virtual HRESULT __stdcall SetTrackingOptions(
        UINT uOptions)
        = 0;
};
extern "C" const IID IID_ID3D11RefDefaultTrackingOptions;
struct __declspec(uuid("03916615-c644-418c-9bf4-75db5be63ca0")) __declspec(novtable)
    ID3D11RefDefaultTrackingOptions : public IUnknown {
public:
    virtual HRESULT __stdcall SetTrackingOptions(
        UINT ResourceTypeFlags,
        UINT Options)
        = 0;
};
#pragma endregion
#pragma endregion
#pragma region Application Family
#pragma region Application Family
extern "C" const GUID DXGI_DEBUG_D3D11;
typedef enum D3D11_MESSAGE_CATEGORY {
    D3D11_MESSAGE_CATEGORY_APPLICATION_DEFINED = 0,
    D3D11_MESSAGE_CATEGORY_MISCELLANEOUS = (D3D11_MESSAGE_CATEGORY_APPLICATION_DEFINED + 1),
    D3D11_MESSAGE_CATEGORY_INITIALIZATION = (D3D11_MESSAGE_CATEGORY_MISCELLANEOUS + 1),
    D3D11_MESSAGE_CATEGORY_CLEANUP = (D3D11_MESSAGE_CATEGORY_INITIALIZATION + 1),
    D3D11_MESSAGE_CATEGORY_COMPILATION = (D3D11_MESSAGE_CATEGORY_CLEANUP + 1),
    D3D11_MESSAGE_CATEGORY_STATE_CREATION = (D3D11_MESSAGE_CATEGORY_COMPILATION + 1),
    D3D11_MESSAGE_CATEGORY_STATE_SETTING = (D3D11_MESSAGE_CATEGORY_STATE_CREATION + 1),
    D3D11_MESSAGE_CATEGORY_STATE_GETTING = (D3D11_MESSAGE_CATEGORY_STATE_SETTING + 1),
    D3D11_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = (D3D11_MESSAGE_CATEGORY_STATE_GETTING + 1),
    D3D11_MESSAGE_CATEGORY_EXECUTION = (D3D11_MESSAGE_CATEGORY_RESOURCE_MANIPULATION + 1),
    D3D11_MESSAGE_CATEGORY_SHADER = (D3D11_MESSAGE_CATEGORY_EXECUTION + 1)
} D3D11_MESSAGE_CATEGORY;
typedef enum D3D11_MESSAGE_SEVERITY {
    D3D11_MESSAGE_SEVERITY_CORRUPTION = 0,
    D3D11_MESSAGE_SEVERITY_ERROR = (D3D11_MESSAGE_SEVERITY_CORRUPTION + 1),
    D3D11_MESSAGE_SEVERITY_WARNING = (D3D11_MESSAGE_SEVERITY_ERROR + 1),
    D3D11_MESSAGE_SEVERITY_INFO = (D3D11_MESSAGE_SEVERITY_WARNING + 1),
    D3D11_MESSAGE_SEVERITY_MESSAGE = (D3D11_MESSAGE_SEVERITY_INFO + 1)
} D3D11_MESSAGE_SEVERITY;
typedef enum D3D11_MESSAGE_ID {
    D3D11_MESSAGE_ID_UNKNOWN = 0,
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD = (D3D11_MESSAGE_ID_UNKNOWN + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD = (D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD = (D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD = (D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD = (D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD + 1),
    D3D11_MESSAGE_ID_STRING_FROM_APPLICATION = (D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD + 1),
    D3D11_MESSAGE_ID_CORRUPTED_THIS = (D3D11_MESSAGE_ID_STRING_FROM_APPLICATION + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER1 = (D3D11_MESSAGE_ID_CORRUPTED_THIS + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER2 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER1 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER3 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER2 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER4 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER3 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER5 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER4 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER6 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER5 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER7 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER6 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER8 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER7 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER9 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER8 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER10 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER9 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER11 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER10 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER12 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER11 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER13 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER12 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER14 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER13 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER15 = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER14 + 1),
    D3D11_MESSAGE_ID_CORRUPTED_MULTITHREADING = (D3D11_MESSAGE_ID_CORRUPTED_PARAMETER15 + 1),
    D3D11_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY = (D3D11_MESSAGE_ID_CORRUPTED_MULTITHREADING + 1),
    D3D11_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_GETPRIVATEDATA_MOREDATA = (D3D11_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA = (D3D11_MESSAGE_ID_GETPRIVATEDATA_MOREDATA + 1),
    D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN = (D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA + 1),
    D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS = (D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN + 1),
    D3D11_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS = (D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY = (D3D11_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES = (D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_NULLDESC = (D3D11_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS = (D3D11_MESSAGE_ID_CREATEBUFFER_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES = (D3D11_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_NULLDESC = (D3D11_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION = (D3D11_MESSAGE_ID_CREATETEXTURE1D_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES = (D3D11_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_NULLDESC = (D3D11_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION = (D3D11_MESSAGE_ID_CREATETEXTURE2D_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES = (D3D11_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_NULLDESC = (D3D11_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION = (D3D11_MESSAGE_ID_CREATETEXTURE3D_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT + 1),
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX + 1),
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE + 1),
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE = (D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC + 1),
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED = (D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED + 1),
    D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE = (D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE + 1),
    D3D11_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID = (D3D11_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE = (D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE + 1),
    D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT = (D3D11_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR = (D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT + 1),
    D3D11_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH = (D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR + 1),
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH = (D3D11_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH + 1),
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID = (D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH + 1),
    D3D11_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID + 1),
    D3D11_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID = (D3D11_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE = (D3D11_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE = (D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE = (D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE + 1),
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE = (D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE + 1),
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX = (D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE = (D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX + 1),
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID = (D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE + 1),
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID = (D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID + 1),
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID = (D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID + 1),
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID = (D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID + 1),
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID = (D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID + 1),
    D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE = (D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID + 1),
    D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS = (D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE + 1),
    D3D11_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED = (D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN = (D3D11_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED + 1),
    D3D11_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED = (D3D11_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE = (D3D11_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS = (D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED = (D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN = (D3D11_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN + 1),
    D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED = (D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE = (D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS = (D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED = (D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN = (D3D11_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN + 1),
    D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED = (D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE = (D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS = (D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED = (D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN = (D3D11_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN + 1),
    D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED = (D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED = (D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED + 1),
    D3D11_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED = (D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED + 1),
    D3D11_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS = (D3D11_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED + 1),
    D3D11_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS + 1),
    D3D11_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN = (D3D11_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE = (D3D11_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN + 1),
    D3D11_MESSAGE_ID_REF_THREADING_MODE = (D3D11_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE + 1),
    D3D11_MESSAGE_ID_REF_UMDRIVER_EXCEPTION = (D3D11_MESSAGE_ID_REF_THREADING_MODE + 1),
    D3D11_MESSAGE_ID_REF_KMDRIVER_EXCEPTION = (D3D11_MESSAGE_ID_REF_UMDRIVER_EXCEPTION + 1),
    D3D11_MESSAGE_ID_REF_HARDWARE_EXCEPTION = (D3D11_MESSAGE_ID_REF_KMDRIVER_EXCEPTION + 1),
    D3D11_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE = (D3D11_MESSAGE_ID_REF_HARDWARE_EXCEPTION + 1),
    D3D11_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER = (D3D11_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE + 1),
    D3D11_MESSAGE_ID_REF_OUT_OF_MEMORY = (D3D11_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER + 1),
    D3D11_MESSAGE_ID_REF_INFO = (D3D11_MESSAGE_ID_REF_OUT_OF_MEMORY + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW = (D3D11_MESSAGE_ID_REF_INFO + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL = (D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL = (D3D11_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID = (D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL = (D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED = (D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY = (D3D11_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER = (D3D11_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING = (D3D11_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = (D3D11_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING + 1),
    D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT = (D3D11_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 + 1),
    D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT = (D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT + 1),
    D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT = (D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT + 1),
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT + 1),
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN = (D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC = (D3D11_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC + 1),
    D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC + 1),
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW = (D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH + 1),
    D3D11_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH + 1),
    D3D11_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH + 1),
    D3D11_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY = (D3D11_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY + 1),
    D3D11_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY + 1),
    D3D11_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER = (D3D11_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED = (D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER + 1),
    D3D11_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = (D3D11_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED + 1),
    D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER + 1),
    D3D11_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN = (D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATECOUNTER_NULLDESC = (D3D11_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN + 1),
    D3D11_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER = (D3D11_MESSAGE_ID_CREATECOUNTER_NULLDESC + 1),
    D3D11_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = (D3D11_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER + 1),
    D3D11_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE = (D3D11_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER + 1),
    D3D11_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED = (D3D11_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE + 1),
    D3D11_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION = (D3D11_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_QUERY_BEGIN_DUPLICATE = (D3D11_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION + 1),
    D3D11_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS = (D3D11_MESSAGE_ID_QUERY_BEGIN_DUPLICATE + 1),
    D3D11_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION = (D3D11_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS + 1),
    D3D11_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS = (D3D11_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION + 1),
    D3D11_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN = (D3D11_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS + 1),
    D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE = (D3D11_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN + 1),
    D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS = (D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE + 1),
    D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL = (D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH = (D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE = (D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE = (D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT = (D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT + 1),
    D3D11_MESSAGE_ID_LIVE_OBJECT_SUMMARY = (D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH + 1),
    D3D11_MESSAGE_ID_LIVE_BUFFER = (D3D11_MESSAGE_ID_LIVE_OBJECT_SUMMARY + 1),
    D3D11_MESSAGE_ID_LIVE_TEXTURE1D = (D3D11_MESSAGE_ID_LIVE_BUFFER + 1),
    D3D11_MESSAGE_ID_LIVE_TEXTURE2D = (D3D11_MESSAGE_ID_LIVE_TEXTURE1D + 1),
    D3D11_MESSAGE_ID_LIVE_TEXTURE3D = (D3D11_MESSAGE_ID_LIVE_TEXTURE2D + 1),
    D3D11_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW = (D3D11_MESSAGE_ID_LIVE_TEXTURE3D + 1),
    D3D11_MESSAGE_ID_LIVE_RENDERTARGETVIEW = (D3D11_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW = (D3D11_MESSAGE_ID_LIVE_RENDERTARGETVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_VERTEXSHADER = (D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_GEOMETRYSHADER = (D3D11_MESSAGE_ID_LIVE_VERTEXSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_PIXELSHADER = (D3D11_MESSAGE_ID_LIVE_GEOMETRYSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_INPUTLAYOUT = (D3D11_MESSAGE_ID_LIVE_PIXELSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_SAMPLER = (D3D11_MESSAGE_ID_LIVE_INPUTLAYOUT + 1),
    D3D11_MESSAGE_ID_LIVE_BLENDSTATE = (D3D11_MESSAGE_ID_LIVE_SAMPLER + 1),
    D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE = (D3D11_MESSAGE_ID_LIVE_BLENDSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_RASTERIZERSTATE = (D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_QUERY = (D3D11_MESSAGE_ID_LIVE_RASTERIZERSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_PREDICATE = (D3D11_MESSAGE_ID_LIVE_QUERY + 1),
    D3D11_MESSAGE_ID_LIVE_COUNTER = (D3D11_MESSAGE_ID_LIVE_PREDICATE + 1),
    D3D11_MESSAGE_ID_LIVE_DEVICE = (D3D11_MESSAGE_ID_LIVE_COUNTER + 1),
    D3D11_MESSAGE_ID_LIVE_SWAPCHAIN = (D3D11_MESSAGE_ID_LIVE_DEVICE + 1),
    D3D11_MESSAGE_ID_D3D10_MESSAGES_END = (D3D11_MESSAGE_ID_LIVE_SWAPCHAIN + 1),
    D3D11_MESSAGE_ID_D3D10L9_MESSAGES_START = 0x100000,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED = (D3D11_MESSAGE_ID_D3D10L9_MESSAGES_START + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY + 1),
    D3D11_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE + 1),
    D3D11_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS = (D3D11_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS = (D3D11_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS = (D3D11_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND = (D3D11_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D = (D3D11_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE = (D3D11_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE = (D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE + 1),
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS = (D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE + 1),
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS = (D3D11_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS + 1),
    D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX = (D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS + 1),
    D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS = (D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS + 1),
    D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS = (D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY = (D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK = (D3D11_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK = (D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT = (D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE + 1),
    D3D11_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD = (D3D11_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER = (D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE = (D3D11_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE = (D3D11_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE = (D3D11_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS = (D3D11_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES = (D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED = (D3D11_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES + 1),
    D3D11_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED + 1),
    D3D11_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED = (D3D11_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED = (D3D11_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED = (D3D11_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND = (D3D11_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE + 1),
    D3D11_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3 = (D3D11_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED = (D3D11_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3 + 1),
    D3D11_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO = (D3D11_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION = (D3D11_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED = (D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION + 1),
    D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR = (D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED + 1),
    D3D11_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA = (D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR + 1),
    D3D11_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP = (D3D11_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA + 1),
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP + 1),
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT = (D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_COPYRESOURCE_NO_3D_MISMATCHED_UPDATES = (D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT + 1),
    D3D11_MESSAGE_ID_D3D10L9_MESSAGES_END = (D3D11_MESSAGE_ID_COPYRESOURCE_NO_3D_MISMATCHED_UPDATES + 1),
    D3D11_MESSAGE_ID_D3D11_MESSAGES_START = 0x200000,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS = (D3D11_MESSAGE_ID_D3D11_MESSAGES_START + 1),
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTREAMS = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTREAMS + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTREAMS = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTREAMS + 1),
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_COMMANDLISTFLAGS = (D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_SINGLETHREADED = (D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_COMMANDLISTFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_SINGLETHREADED + 1),
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_CALL_RETURN = (D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_CALL_RETURN + 1),
    D3D11_MESSAGE_ID_FINISHDISPLAYLIST_ONIMMEDIATECONTEXT = (D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_FINISHDISPLAYLIST_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_FINISHDISPLAYLIST_ONIMMEDIATECONTEXT + 1),
    D3D11_MESSAGE_ID_FINISHDISPLAYLIST_INVALID_CALL_RETURN = (D3D11_MESSAGE_ID_FINISHDISPLAYLIST_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM = (D3D11_MESSAGE_ID_FINISHDISPLAYLIST_INVALID_CALL_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES + 1),
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES + 1),
    D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_HAZARD = (D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES + 1),
    D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_HAZARD + 1),
    D3D11_MESSAGE_ID_HSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_HSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCALL = (D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCALL + 1),
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_HSSETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_HSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_HSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_HSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_HSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_HSGETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_HSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_HAZARD = (D3D11_MESSAGE_ID_DEVICE_HSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_HAZARD + 1),
    D3D11_MESSAGE_ID_DSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCALL = (D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCALL + 1),
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_DSSETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_DSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_DSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DSGETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_DSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_XOR_DS_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEFERRED_CONTEXT_REMOVAL_PROCESS_AT_FAULT = (D3D11_MESSAGE_ID_DEVICE_DRAW_HS_XOR_DS_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_INVALID_ARG_BUFFER = (D3D11_MESSAGE_ID_DEFERRED_CONTEXT_REMOVAL_PROCESS_AT_FAULT + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_INVALID_ARG_BUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDMAPTYPE = (D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_OVERFLOW + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDMAPTYPE + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDFLAGS = (D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_ALREADYMAPPED = (D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_DEVICEREMOVED_RETURN = (D3D11_MESSAGE_ID_RESOURCE_MAP_ALREADYMAPPED + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_RESOURCE_MAP_DEVICEREMOVED_RETURN + 1),
    D3D11_MESSAGE_ID_RESOURCE_MAP_WITHOUT_INITIAL_DISCARD = (D3D11_MESSAGE_ID_RESOURCE_MAP_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_RESOURCE_UNMAP_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_RESOURCE_MAP_WITHOUT_INITIAL_DISCARD + 1),
    D3D11_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED = (D3D11_MESSAGE_ID_RESOURCE_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RASTERIZING_CONTROL_POINTS = (D3D11_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED + 1),
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_RASTERIZING_CONTROL_POINTS + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_SIGNATURE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_SIGNATURE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_CONTROL_POINT_COUNT_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_TESSELLATOR_DOMAIN_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_CONTROL_POINT_COUNT_MISMATCH + 1),
    D3D11_MESSAGE_ID_CREATE_CONTEXT = (D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_TESSELLATOR_DOMAIN_MISMATCH + 1),
    D3D11_MESSAGE_ID_LIVE_CONTEXT = (D3D11_MESSAGE_ID_CREATE_CONTEXT + 1),
    D3D11_MESSAGE_ID_DESTROY_CONTEXT = (D3D11_MESSAGE_ID_LIVE_CONTEXT + 1),
    D3D11_MESSAGE_ID_CREATE_BUFFER = (D3D11_MESSAGE_ID_DESTROY_CONTEXT + 1),
    D3D11_MESSAGE_ID_LIVE_BUFFER_WIN7 = (D3D11_MESSAGE_ID_CREATE_BUFFER + 1),
    D3D11_MESSAGE_ID_DESTROY_BUFFER = (D3D11_MESSAGE_ID_LIVE_BUFFER_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_TEXTURE1D = (D3D11_MESSAGE_ID_DESTROY_BUFFER + 1),
    D3D11_MESSAGE_ID_LIVE_TEXTURE1D_WIN7 = (D3D11_MESSAGE_ID_CREATE_TEXTURE1D + 1),
    D3D11_MESSAGE_ID_DESTROY_TEXTURE1D = (D3D11_MESSAGE_ID_LIVE_TEXTURE1D_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_TEXTURE2D = (D3D11_MESSAGE_ID_DESTROY_TEXTURE1D + 1),
    D3D11_MESSAGE_ID_LIVE_TEXTURE2D_WIN7 = (D3D11_MESSAGE_ID_CREATE_TEXTURE2D + 1),
    D3D11_MESSAGE_ID_DESTROY_TEXTURE2D = (D3D11_MESSAGE_ID_LIVE_TEXTURE2D_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_TEXTURE3D = (D3D11_MESSAGE_ID_DESTROY_TEXTURE2D + 1),
    D3D11_MESSAGE_ID_LIVE_TEXTURE3D_WIN7 = (D3D11_MESSAGE_ID_CREATE_TEXTURE3D + 1),
    D3D11_MESSAGE_ID_DESTROY_TEXTURE3D = (D3D11_MESSAGE_ID_LIVE_TEXTURE3D_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_SHADERRESOURCEVIEW = (D3D11_MESSAGE_ID_DESTROY_TEXTURE3D + 1),
    D3D11_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW_WIN7 = (D3D11_MESSAGE_ID_CREATE_SHADERRESOURCEVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_SHADERRESOURCEVIEW = (D3D11_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_RENDERTARGETVIEW = (D3D11_MESSAGE_ID_DESTROY_SHADERRESOURCEVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_RENDERTARGETVIEW_WIN7 = (D3D11_MESSAGE_ID_CREATE_RENDERTARGETVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_RENDERTARGETVIEW = (D3D11_MESSAGE_ID_LIVE_RENDERTARGETVIEW_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILVIEW = (D3D11_MESSAGE_ID_DESTROY_RENDERTARGETVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW_WIN7 = (D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILVIEW = (D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_VERTEXSHADER = (D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_VERTEXSHADER_WIN7 = (D3D11_MESSAGE_ID_CREATE_VERTEXSHADER + 1),
    D3D11_MESSAGE_ID_DESTROY_VERTEXSHADER = (D3D11_MESSAGE_ID_LIVE_VERTEXSHADER_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_HULLSHADER = (D3D11_MESSAGE_ID_DESTROY_VERTEXSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_HULLSHADER = (D3D11_MESSAGE_ID_CREATE_HULLSHADER + 1),
    D3D11_MESSAGE_ID_DESTROY_HULLSHADER = (D3D11_MESSAGE_ID_LIVE_HULLSHADER + 1),
    D3D11_MESSAGE_ID_CREATE_DOMAINSHADER = (D3D11_MESSAGE_ID_DESTROY_HULLSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_DOMAINSHADER = (D3D11_MESSAGE_ID_CREATE_DOMAINSHADER + 1),
    D3D11_MESSAGE_ID_DESTROY_DOMAINSHADER = (D3D11_MESSAGE_ID_LIVE_DOMAINSHADER + 1),
    D3D11_MESSAGE_ID_CREATE_GEOMETRYSHADER = (D3D11_MESSAGE_ID_DESTROY_DOMAINSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_GEOMETRYSHADER_WIN7 = (D3D11_MESSAGE_ID_CREATE_GEOMETRYSHADER + 1),
    D3D11_MESSAGE_ID_DESTROY_GEOMETRYSHADER = (D3D11_MESSAGE_ID_LIVE_GEOMETRYSHADER_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_PIXELSHADER = (D3D11_MESSAGE_ID_DESTROY_GEOMETRYSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_PIXELSHADER_WIN7 = (D3D11_MESSAGE_ID_CREATE_PIXELSHADER + 1),
    D3D11_MESSAGE_ID_DESTROY_PIXELSHADER = (D3D11_MESSAGE_ID_LIVE_PIXELSHADER_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_INPUTLAYOUT = (D3D11_MESSAGE_ID_DESTROY_PIXELSHADER + 1),
    D3D11_MESSAGE_ID_LIVE_INPUTLAYOUT_WIN7 = (D3D11_MESSAGE_ID_CREATE_INPUTLAYOUT + 1),
    D3D11_MESSAGE_ID_DESTROY_INPUTLAYOUT = (D3D11_MESSAGE_ID_LIVE_INPUTLAYOUT_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_SAMPLER = (D3D11_MESSAGE_ID_DESTROY_INPUTLAYOUT + 1),
    D3D11_MESSAGE_ID_LIVE_SAMPLER_WIN7 = (D3D11_MESSAGE_ID_CREATE_SAMPLER + 1),
    D3D11_MESSAGE_ID_DESTROY_SAMPLER = (D3D11_MESSAGE_ID_LIVE_SAMPLER_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_BLENDSTATE = (D3D11_MESSAGE_ID_DESTROY_SAMPLER + 1),
    D3D11_MESSAGE_ID_LIVE_BLENDSTATE_WIN7 = (D3D11_MESSAGE_ID_CREATE_BLENDSTATE + 1),
    D3D11_MESSAGE_ID_DESTROY_BLENDSTATE = (D3D11_MESSAGE_ID_LIVE_BLENDSTATE_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILSTATE = (D3D11_MESSAGE_ID_DESTROY_BLENDSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE_WIN7 = (D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILSTATE + 1),
    D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILSTATE = (D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_RASTERIZERSTATE = (D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_RASTERIZERSTATE_WIN7 = (D3D11_MESSAGE_ID_CREATE_RASTERIZERSTATE + 1),
    D3D11_MESSAGE_ID_DESTROY_RASTERIZERSTATE = (D3D11_MESSAGE_ID_LIVE_RASTERIZERSTATE_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_QUERY = (D3D11_MESSAGE_ID_DESTROY_RASTERIZERSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_QUERY_WIN7 = (D3D11_MESSAGE_ID_CREATE_QUERY + 1),
    D3D11_MESSAGE_ID_DESTROY_QUERY = (D3D11_MESSAGE_ID_LIVE_QUERY_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_PREDICATE = (D3D11_MESSAGE_ID_DESTROY_QUERY + 1),
    D3D11_MESSAGE_ID_LIVE_PREDICATE_WIN7 = (D3D11_MESSAGE_ID_CREATE_PREDICATE + 1),
    D3D11_MESSAGE_ID_DESTROY_PREDICATE = (D3D11_MESSAGE_ID_LIVE_PREDICATE_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_COUNTER = (D3D11_MESSAGE_ID_DESTROY_PREDICATE + 1),
    D3D11_MESSAGE_ID_DESTROY_COUNTER = (D3D11_MESSAGE_ID_CREATE_COUNTER + 1),
    D3D11_MESSAGE_ID_CREATE_COMMANDLIST = (D3D11_MESSAGE_ID_DESTROY_COUNTER + 1),
    D3D11_MESSAGE_ID_LIVE_COMMANDLIST = (D3D11_MESSAGE_ID_CREATE_COMMANDLIST + 1),
    D3D11_MESSAGE_ID_DESTROY_COMMANDLIST = (D3D11_MESSAGE_ID_LIVE_COMMANDLIST + 1),
    D3D11_MESSAGE_ID_CREATE_CLASSINSTANCE = (D3D11_MESSAGE_ID_DESTROY_COMMANDLIST + 1),
    D3D11_MESSAGE_ID_LIVE_CLASSINSTANCE = (D3D11_MESSAGE_ID_CREATE_CLASSINSTANCE + 1),
    D3D11_MESSAGE_ID_DESTROY_CLASSINSTANCE = (D3D11_MESSAGE_ID_LIVE_CLASSINSTANCE + 1),
    D3D11_MESSAGE_ID_CREATE_CLASSLINKAGE = (D3D11_MESSAGE_ID_DESTROY_CLASSINSTANCE + 1),
    D3D11_MESSAGE_ID_LIVE_CLASSLINKAGE = (D3D11_MESSAGE_ID_CREATE_CLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_DESTROY_CLASSLINKAGE = (D3D11_MESSAGE_ID_LIVE_CLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_LIVE_DEVICE_WIN7 = (D3D11_MESSAGE_ID_DESTROY_CLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_LIVE_OBJECT_SUMMARY_WIN7 = (D3D11_MESSAGE_ID_LIVE_DEVICE_WIN7 + 1),
    D3D11_MESSAGE_ID_CREATE_COMPUTESHADER = (D3D11_MESSAGE_ID_LIVE_OBJECT_SUMMARY_WIN7 + 1),
    D3D11_MESSAGE_ID_LIVE_COMPUTESHADER = (D3D11_MESSAGE_ID_CREATE_COMPUTESHADER + 1),
    D3D11_MESSAGE_ID_DESTROY_COMPUTESHADER = (D3D11_MESSAGE_ID_LIVE_COMPUTESHADER + 1),
    D3D11_MESSAGE_ID_CREATE_UNORDEREDACCESSVIEW = (D3D11_MESSAGE_ID_DESTROY_COMPUTESHADER + 1),
    D3D11_MESSAGE_ID_LIVE_UNORDEREDACCESSVIEW = (D3D11_MESSAGE_ID_CREATE_UNORDEREDACCESSVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_UNORDEREDACCESSVIEW = (D3D11_MESSAGE_ID_LIVE_UNORDEREDACCESSVIEW + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACES_FEATURELEVEL = (D3D11_MESSAGE_ID_DESTROY_UNORDEREDACCESSVIEW + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACE_COUNT_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACES_FEATURELEVEL + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACE_COUNT_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_INDEX = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_TYPE = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_INDEX + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_DATA = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_TYPE + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_UNBOUND_INSTANCE_DATA = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_DATA + 1),
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INSTANCE_DATA_BINDINGS = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_UNBOUND_INSTANCE_DATA + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATESHADER_CLASSLINKAGE_FULL = (D3D11_MESSAGE_ID_DEVICE_SETSHADER_INSTANCE_DATA_BINDINGS + 1),
    D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_UNRECOGNIZED_FEATURE = (D3D11_MESSAGE_ID_DEVICE_CREATESHADER_CLASSLINKAGE_FULL + 1),
    D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE = (D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_UNRECOGNIZED_FEATURE + 1),
    D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_HAZARD = (D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_HAZARD = (D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_HAZARD + 1),
    D3D11_MESSAGE_ID_CSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_CSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCALL = (D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCALL + 1),
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE = (D3D11_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERTYPE = (D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE + 1),
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE = (D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERTYPE + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE + 1),
    D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_CSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_CSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_CSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_CSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_CSGETSAMPLERS_SAMPLERS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_CSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSTRUCTURESTRIDE = (D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFLAGS = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSTRUCTURESTRIDE + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_HAZARD = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_OVERLAPPING_OLD_SLOTS = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NO_OP = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_OVERLAPPING_OLD_SLOTS + 1),
    D3D11_MESSAGE_ID_CSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NO_OP + 1),
    D3D11_MESSAGE_ID_PSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_CSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_PSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_HAZARD = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_DENORMFLUSH = (D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_HAZARD + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSS_VIEWS_EMPTY = (D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_DENORMFLUSH + 1),
    D3D11_MESSAGE_ID_DEVICE_CSGETUNORDEREDACCESSS_VIEWS_EMPTY = (D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSS_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS = (D3D11_MESSAGE_ID_DEVICE_CSGETUNORDEREDACCESSS_VIEWS_EMPTY + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESESOURCEVIEW_TOOMANYOBJECTS = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_INVALID_ARG_BUFFER = (D3D11_MESSAGE_ID_CREATESHADERRESESOURCEVIEW_TOOMANYOBJECTS + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_UNALIGNED = (D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_INVALID_ARG_BUFFER + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_UNALIGNED + 1),
    D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDCONTEXT = (D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDRESOURCE = (D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDCONTEXT + 1),
    D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDMINLOD = (D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDCONTEXT = (D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDMINLOD + 1),
    D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDRESOURCE = (D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDCONTEXT + 1),
    D3D11_MESSAGE_ID_OMSETDEPTHSTENCIL_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DEPTH_READONLY = (D3D11_MESSAGE_ID_OMSETDEPTHSTENCIL_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_STENCIL_READONLY = (D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DEPTH_READONLY + 1),
    D3D11_MESSAGE_ID_CHECKFEATURESUPPORT_FORMAT_DEPRECATED = (D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_STENCIL_READONLY + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RETURN_TYPE_MISMATCH = (D3D11_MESSAGE_ID_CHECKFEATURESUPPORT_FORMAT_DEPRECATED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RETURN_TYPE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_UNORDEREDACCESSVIEW_RENDERTARGETVIEW_OVERLAP = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_DIMENSION_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DRAW_UNORDEREDACCESSVIEW_RENDERTARGETVIEW_OVERLAP + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_APPEND_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_DIMENSION_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMICS_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_APPEND_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_STRUCTURE_STRIDE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMICS_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_BUFFER_TYPE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_STRUCTURE_STRIDE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RAW_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_BUFFER_TYPE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_LD_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RAW_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_STORE_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_LD_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_ADD_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_STORE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_BITWISE_OPS_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_ADD_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_CMPSTORE_CMPEXCHANGE_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_BITWISE_OPS_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_EXCHANGE_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_CMPSTORE_CMPEXCHANGE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_SIGNED_MINMAX_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_EXCHANGE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_UNSIGNED_MINMAX_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_SIGNED_MINMAX_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_BOUND_RESOURCE_MAPPED = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_UNSIGNED_MINMAX_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_OVERFLOW = (D3D11_MESSAGE_ID_DEVICE_DISPATCH_BOUND_RESOURCE_MAPPED + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_ZERO = (D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_OVERFLOW + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_STRUCTURE_STRIDE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_ZERO + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_BUFFER_TYPE_MISMATCH = (D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_STRUCTURE_STRIDE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_RAW_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_BUFFER_TYPE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_RAW_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DISPATCH_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDOFFSET = (D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_LARGEOFFSET = (D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDOFFSET + 1),
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDDESTINATIONSTATE = (D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_LARGEOFFSET + 1),
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDSOURCESTATE = (D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDDESTINATIONSTATE + 1),
    D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_NOT_SUPPORTED = (D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDSOURCESTATE + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDVIEW = (D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDOFFSET = (D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDVIEW + 1),
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_TOOMANYVIEWS = (D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDOFFSET + 1),
    D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_INVALIDFORMAT = (D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_TOOMANYVIEWS + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_COUNTER_UNSUPPORTED = (D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_REF_WARNING = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_COUNTER_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_PIXEL_SHADER_WITHOUT_RTV_OR_DSV = (D3D11_MESSAGE_ID_REF_WARNING + 1),
    D3D11_MESSAGE_ID_SHADER_ABORT = (D3D11_MESSAGE_ID_DEVICE_DRAW_PIXEL_SHADER_WITHOUT_RTV_OR_DSV + 1),
    D3D11_MESSAGE_ID_SHADER_MESSAGE = (D3D11_MESSAGE_ID_SHADER_ABORT + 1),
    D3D11_MESSAGE_ID_SHADER_ERROR = (D3D11_MESSAGE_ID_SHADER_MESSAGE + 1),
    D3D11_MESSAGE_ID_OFFERRESOURCES_INVALIDRESOURCE = (D3D11_MESSAGE_ID_SHADER_ERROR + 1),
    D3D11_MESSAGE_ID_HSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_OFFERRESOURCES_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_DSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_HSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_HSSETSHADER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_CSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_DSSETSHADER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_HSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_CSSETSHADER_UNBINDDELETINGOBJECT = (D3D11_MESSAGE_ID_DSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_ENQUEUESETEVENT_INVALIDARG_RETURN = (D3D11_MESSAGE_ID_CSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D11_MESSAGE_ID_ENQUEUESETEVENT_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_ENQUEUESETEVENT_INVALIDARG_RETURN + 1),
    D3D11_MESSAGE_ID_ENQUEUESETEVENT_ACCESSDENIED_RETURN = (D3D11_MESSAGE_ID_ENQUEUESETEVENT_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NUMUAVS_INVALIDRANGE = (D3D11_MESSAGE_ID_ENQUEUESETEVENT_ACCESSDENIED_RETURN + 1),
    D3D11_MESSAGE_ID_USE_OF_ZERO_REFCOUNT_OBJECT = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NUMUAVS_INVALIDRANGE + 1),
    D3D11_MESSAGE_ID_D3D11_MESSAGES_END = (D3D11_MESSAGE_ID_USE_OF_ZERO_REFCOUNT_OBJECT + 1),
    D3D11_MESSAGE_ID_D3D11_1_MESSAGES_START = 0x300000,
    D3D11_MESSAGE_ID_CREATE_VIDEODECODER = (D3D11_MESSAGE_ID_D3D11_1_MESSAGES_START + 1),
    D3D11_MESSAGE_ID_CREATE_VIDEOPROCESSORENUM = (D3D11_MESSAGE_ID_CREATE_VIDEODECODER + 1),
    D3D11_MESSAGE_ID_CREATE_VIDEOPROCESSOR = (D3D11_MESSAGE_ID_CREATE_VIDEOPROCESSORENUM + 1),
    D3D11_MESSAGE_ID_CREATE_DECODEROUTPUTVIEW = (D3D11_MESSAGE_ID_CREATE_VIDEOPROCESSOR + 1),
    D3D11_MESSAGE_ID_CREATE_PROCESSORINPUTVIEW = (D3D11_MESSAGE_ID_CREATE_DECODEROUTPUTVIEW + 1),
    D3D11_MESSAGE_ID_CREATE_PROCESSOROUTPUTVIEW = (D3D11_MESSAGE_ID_CREATE_PROCESSORINPUTVIEW + 1),
    D3D11_MESSAGE_ID_CREATE_DEVICECONTEXTSTATE = (D3D11_MESSAGE_ID_CREATE_PROCESSOROUTPUTVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_VIDEODECODER = (D3D11_MESSAGE_ID_CREATE_DEVICECONTEXTSTATE + 1),
    D3D11_MESSAGE_ID_LIVE_VIDEOPROCESSORENUM = (D3D11_MESSAGE_ID_LIVE_VIDEODECODER + 1),
    D3D11_MESSAGE_ID_LIVE_VIDEOPROCESSOR = (D3D11_MESSAGE_ID_LIVE_VIDEOPROCESSORENUM + 1),
    D3D11_MESSAGE_ID_LIVE_DECODEROUTPUTVIEW = (D3D11_MESSAGE_ID_LIVE_VIDEOPROCESSOR + 1),
    D3D11_MESSAGE_ID_LIVE_PROCESSORINPUTVIEW = (D3D11_MESSAGE_ID_LIVE_DECODEROUTPUTVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_PROCESSOROUTPUTVIEW = (D3D11_MESSAGE_ID_LIVE_PROCESSORINPUTVIEW + 1),
    D3D11_MESSAGE_ID_LIVE_DEVICECONTEXTSTATE = (D3D11_MESSAGE_ID_LIVE_PROCESSOROUTPUTVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_VIDEODECODER = (D3D11_MESSAGE_ID_LIVE_DEVICECONTEXTSTATE + 1),
    D3D11_MESSAGE_ID_DESTROY_VIDEOPROCESSORENUM = (D3D11_MESSAGE_ID_DESTROY_VIDEODECODER + 1),
    D3D11_MESSAGE_ID_DESTROY_VIDEOPROCESSOR = (D3D11_MESSAGE_ID_DESTROY_VIDEOPROCESSORENUM + 1),
    D3D11_MESSAGE_ID_DESTROY_DECODEROUTPUTVIEW = (D3D11_MESSAGE_ID_DESTROY_VIDEOPROCESSOR + 1),
    D3D11_MESSAGE_ID_DESTROY_PROCESSORINPUTVIEW = (D3D11_MESSAGE_ID_DESTROY_DECODEROUTPUTVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_PROCESSOROUTPUTVIEW = (D3D11_MESSAGE_ID_DESTROY_PROCESSORINPUTVIEW + 1),
    D3D11_MESSAGE_ID_DESTROY_DEVICECONTEXTSTATE = (D3D11_MESSAGE_ID_DESTROY_PROCESSOROUTPUTVIEW + 1),
    D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_INVALIDFLAGS = (D3D11_MESSAGE_ID_DESTROY_DEVICECONTEXTSTATE + 1),
    D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_INVALIDFEATURELEVEL = (D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_FEATURELEVELS_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_INVALIDFEATURELEVEL + 1),
    D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_INVALIDREFIID = (D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_FEATURELEVELS_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_DISCARDVIEW_INVALIDVIEW = (D3D11_MESSAGE_ID_CREATEDEVICECONTEXTSTATE_INVALIDREFIID + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION1_INVALIDCOPYFLAGS = (D3D11_MESSAGE_ID_DEVICE_DISCARDVIEW_INVALIDVIEW + 1),
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE1_INVALIDCOPYFLAGS = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION1_INVALIDCOPYFLAGS + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFORCEDSAMPLECOUNT = (D3D11_MESSAGE_ID_UPDATESUBRESOURCE1_INVALIDCOPYFLAGS + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODER_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFORCEDSAMPLECOUNT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODER_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEODECODER_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODER_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATEVIDEODECODER_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODER_ZEROWIDTHHEIGHT = (D3D11_MESSAGE_ID_CREATEVIDEODECODER_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODER_DRIVER_INVALIDBUFFERSIZE = (D3D11_MESSAGE_ID_CREATEVIDEODECODER_ZEROWIDTHHEIGHT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODER_DRIVER_INVALIDBUFFERUSAGE = (D3D11_MESSAGE_ID_CREATEVIDEODECODER_DRIVER_INVALIDBUFFERSIZE + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERPROFILECOUNT_OUTOFMEMORY = (D3D11_MESSAGE_ID_CREATEVIDEODECODER_DRIVER_INVALIDBUFFERUSAGE + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERPROFILE_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEODECODERPROFILECOUNT_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERPROFILE_INVALIDINDEX = (D3D11_MESSAGE_ID_GETVIDEODECODERPROFILE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERPROFILE_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_GETVIDEODECODERPROFILE_INVALIDINDEX + 1),
    D3D11_MESSAGE_ID_CHECKVIDEODECODERFORMAT_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEODECODERPROFILE_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CHECKVIDEODECODERFORMAT_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CHECKVIDEODECODERFORMAT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCONFIGCOUNT_NULLPARAM = (D3D11_MESSAGE_ID_CHECKVIDEODECODERFORMAT_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCONFIGCOUNT_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_GETVIDEODECODERCONFIGCOUNT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCONFIG_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEODECODERCONFIGCOUNT_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCONFIG_INVALIDINDEX = (D3D11_MESSAGE_ID_GETVIDEODECODERCONFIG_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCONFIG_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_GETVIDEODECODERCONFIG_INVALIDINDEX + 1),
    D3D11_MESSAGE_ID_GETDECODERCREATIONPARAMS_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEODECODERCONFIG_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_GETDECODERDRIVERHANDLE_NULLPARAM = (D3D11_MESSAGE_ID_GETDECODERCREATIONPARAMS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETDECODERBUFFER_NULLPARAM = (D3D11_MESSAGE_ID_GETDECODERDRIVERHANDLE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETDECODERBUFFER_INVALIDBUFFER = (D3D11_MESSAGE_ID_GETDECODERBUFFER_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETDECODERBUFFER_INVALIDTYPE = (D3D11_MESSAGE_ID_GETDECODERBUFFER_INVALIDBUFFER + 1),
    D3D11_MESSAGE_ID_GETDECODERBUFFER_LOCKED = (D3D11_MESSAGE_ID_GETDECODERBUFFER_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_RELEASEDECODERBUFFER_NULLPARAM = (D3D11_MESSAGE_ID_GETDECODERBUFFER_LOCKED + 1),
    D3D11_MESSAGE_ID_RELEASEDECODERBUFFER_INVALIDTYPE = (D3D11_MESSAGE_ID_RELEASEDECODERBUFFER_NULLPARAM + 1),
    D3D11_MESSAGE_ID_RELEASEDECODERBUFFER_NOTLOCKED = (D3D11_MESSAGE_ID_RELEASEDECODERBUFFER_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_NULLPARAM = (D3D11_MESSAGE_ID_RELEASEDECODERBUFFER_NOTLOCKED + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_HAZARD = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_NULLPARAM + 1),
    D3D11_MESSAGE_ID_DECODERENDFRAME_NULLPARAM = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_HAZARD + 1),
    D3D11_MESSAGE_ID_SUBMITDECODERBUFFERS_NULLPARAM = (D3D11_MESSAGE_ID_DECODERENDFRAME_NULLPARAM + 1),
    D3D11_MESSAGE_ID_SUBMITDECODERBUFFERS_INVALIDTYPE = (D3D11_MESSAGE_ID_SUBMITDECODERBUFFERS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_DECODEREXTENSION_NULLPARAM = (D3D11_MESSAGE_ID_SUBMITDECODERBUFFERS_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_DECODEREXTENSION_INVALIDRESOURCE = (D3D11_MESSAGE_ID_DECODEREXTENSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_DECODEREXTENSION_INVALIDRESOURCE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDFRAMEFORMAT = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDUSAGE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDFRAMEFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDINPUTFRAMERATE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDOUTPUTFRAMERATE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDINPUTFRAMERATE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDWIDTHHEIGHT = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDOUTPUTFRAMERATE + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORCONTENTDESC_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORENUMERATOR_INVALIDWIDTHHEIGHT + 1),
    D3D11_MESSAGE_ID_CHECKVIDEOPROCESSORFORMAT_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORCONTENTDESC_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORCAPS_NULLPARAM = (D3D11_MESSAGE_ID_CHECKVIDEOPROCESSORFORMAT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORRATECONVERSIONCAPS_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORCAPS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORRATECONVERSIONCAPS_INVALIDINDEX = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORRATECONVERSIONCAPS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORCUSTOMRATE_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORRATECONVERSIONCAPS_INVALIDINDEX + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORCUSTOMRATE_INVALIDINDEX = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORCUSTOMRATE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORFILTERRANGE_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORCUSTOMRATE_INVALIDINDEX + 1),
    D3D11_MESSAGE_ID_GETVIDEOPROCESSORFILTERRANGE_UNSUPPORTED = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORFILTERRANGE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOR_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_GETVIDEOPROCESSORFILTERRANGE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOR_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOR_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTTARGETRECT_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOR_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTBACKGROUNDCOLOR_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTTARGETRECT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTBACKGROUNDCOLOR_INVALIDALPHA = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTBACKGROUNDCOLOR_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCOLORSPACE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTBACKGROUNDCOLOR_INVALIDALPHA + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCOLORSPACE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_INVALIDFILLMODE = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCONSTRICTION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTALPHAFILLMODE_INVALIDFILLMODE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSTEREOMODE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCONSTRICTION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSTEREOMODE_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSTEREOMODE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTEXTENSION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSTEREOMODE_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTTARGETRECT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTEXTENSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTBACKGROUNDCOLOR_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTTARGETRECT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCOLORSPACE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTBACKGROUNDCOLOR_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTALPHAFILLMODE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCOLORSPACE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCONSTRICTION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTALPHAFILLMODE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCONSTRICTION_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCONSTRICTION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCONSTRICTION_INVALIDSIZE = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCONSTRICTION_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTSTEREOMODE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCONSTRICTION_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTEXTENSION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTSTEREOMODE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFRAMEFORMAT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTEXTENSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFRAMEFORMAT_INVALIDFORMAT = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFRAMEFORMAT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFRAMEFORMAT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFRAMEFORMAT_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFRAMEFORMAT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_INVALIDRATE = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_INVALIDFLAG = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_INVALIDRATE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_INVALIDFLAG + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSOURCERECT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMOUTPUTRATE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSOURCERECT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSOURCERECT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSOURCERECT_INVALIDRECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSOURCERECT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMDESTRECT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSOURCERECT_INVALIDRECT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMDESTRECT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMDESTRECT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMDESTRECT_INVALIDRECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMDESTRECT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMDESTRECT_INVALIDRECT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_INVALIDALPHA = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_INVALIDALPHA + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_INVALIDCOUNT = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_INVALIDALPHA = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_INVALIDCOUNT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPALETTE_INVALIDALPHA + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_INVALIDRATIO = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_INVALIDRATIO + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_INVALIDRANGE = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_INVALIDRANGE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMLUMAKEY_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_FLIPUNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_MONOOFFSETUNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_FLIPUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_FORMATUNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_MONOOFFSETUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_INVALIDFORMAT = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_FORMATUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMAUTOPROCESSINGMODE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMSTEREOFORMAT_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMAUTOPROCESSINGMODE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMAUTOPROCESSINGMODE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMAUTOPROCESSINGMODE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_INVALIDFILTER = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_INVALIDFILTER + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_INVALIDLEVEL = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMEXTENSION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMFILTER_INVALIDLEVEL + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMEXTENSION_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMEXTENSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFRAMEFORMAT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMEXTENSION_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFRAMEFORMAT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMOUTPUTRATE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSOURCERECT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMOUTPUTRATE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMDESTRECT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSOURCERECT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMALPHA_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMDESTRECT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPALETTE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMALPHA_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPIXELASPECTRATIO_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPALETTE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMLUMAKEY_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPIXELASPECTRATIO_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSTEREOFORMAT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMLUMAKEY_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMAUTOPROCESSINGMODE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSTEREOFORMAT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFILTER_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMAUTOPROCESSINGMODE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMEXTENSION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFILTER_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMEXTENSION_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMEXTENSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMEXTENSION_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDSTREAMCOUNT = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_TARGETRECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDSTREAMCOUNT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDOUTPUT = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_TARGETRECT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDPASTFRAMES = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDOUTPUT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDFUTUREFRAMES = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDPASTFRAMES + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDSOURCERECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDFUTUREFRAMES + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDDESTRECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDSOURCERECT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDINPUTRESOURCE = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDDESTRECT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDARRAYSIZE = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDINPUTRESOURCE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDARRAY = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDARRAYSIZE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_RIGHTEXPECTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDARRAY + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_RIGHTNOTEXPECTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_RIGHTEXPECTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_STEREONOTENABLED = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_RIGHTNOTEXPECTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDRIGHTRESOURCE = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_STEREONOTENABLED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_NOSTEREOSTREAMS = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INVALIDRIGHTRESOURCE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INPUTHAZARD = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_NOSTEREOSTREAMS + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_OUTPUTHAZARD = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_INPUTHAZARD + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_VIDEOPROCESSORBLT_OUTPUTHAZARD + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDTYPE = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDBIND = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_UNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDBIND + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDMIP = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_UNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_UNSUPPORTEMIP = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDMIP + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDARRAYSIZE = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_UNSUPPORTEMIP + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDARRAY = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDARRAYSIZE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDDIMENSION = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDARRAY + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEVIDEODECODEROUTPUTVIEW_INVALIDDIMENSION + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDTYPE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDBIND = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMISC = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDBIND + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDUSAGE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMISC + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDFOURCC = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMIP = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDFOURCC + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_UNSUPPORTEDMIP = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMIP + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDARRAYSIZE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_UNSUPPORTEDMIP + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDARRAY = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDARRAYSIZE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDDIMENSION = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDARRAY + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDDIMENSION + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_NULLPARAM = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDTYPE = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDBIND = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDFORMAT = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDBIND + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDMIP = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDFORMAT + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_UNSUPPORTEDMIP = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDMIP + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_UNSUPPORTEDARRAY = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_UNSUPPORTEDMIP + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDARRAY = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_UNSUPPORTEDARRAY + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDDIMENSION = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDARRAY + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_FORCED_SAMPLE_COUNT = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDDIMENSION + 1),
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDLOGICOPS = (D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_FORCED_SAMPLE_COUNT + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDARRAYWITHDECODER = (D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDLOGICOPS + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDARRAYWITHDECODER = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDARRAYWITHDECODER + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDARRAYWITHDECODER = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDARRAYWITHDECODER + 1),
    D3D11_MESSAGE_ID_DEVICE_LOCKEDOUT_INTERFACE = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDARRAYWITHDECODER + 1),
    D3D11_MESSAGE_ID_REF_WARNING_ATOMIC_INCONSISTENT = (D3D11_MESSAGE_ID_DEVICE_LOCKEDOUT_INTERFACE + 1),
    D3D11_MESSAGE_ID_REF_WARNING_READING_UNINITIALIZED_RESOURCE = (D3D11_MESSAGE_ID_REF_WARNING_ATOMIC_INCONSISTENT + 1),
    D3D11_MESSAGE_ID_REF_WARNING_RAW_HAZARD = (D3D11_MESSAGE_ID_REF_WARNING_READING_UNINITIALIZED_RESOURCE + 1),
    D3D11_MESSAGE_ID_REF_WARNING_WAR_HAZARD = (D3D11_MESSAGE_ID_REF_WARNING_RAW_HAZARD + 1),
    D3D11_MESSAGE_ID_REF_WARNING_WAW_HAZARD = (D3D11_MESSAGE_ID_REF_WARNING_WAR_HAZARD + 1),
    D3D11_MESSAGE_ID_CREATECRYPTOSESSION_NULLPARAM = (D3D11_MESSAGE_ID_REF_WARNING_WAW_HAZARD + 1),
    D3D11_MESSAGE_ID_CREATECRYPTOSESSION_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATECRYPTOSESSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCRYPTOTYPE_NULLPARAM = (D3D11_MESSAGE_ID_CREATECRYPTOSESSION_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_GETDECODERPROFILE_NULLPARAM = (D3D11_MESSAGE_ID_GETCRYPTOTYPE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONCERTIFICATESIZE_NULLPARAM = (D3D11_MESSAGE_ID_GETDECODERPROFILE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONCERTIFICATE_NULLPARAM = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONCERTIFICATESIZE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONCERTIFICATE_WRONGSIZE = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONCERTIFICATE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONHANDLE_WRONGSIZE = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONCERTIFICATE_WRONGSIZE + 1),
    D3D11_MESSAGE_ID_NEGOTIATECRPYTOSESSIONKEYEXCHANGE_NULLPARAM = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONHANDLE_WRONGSIZE + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_UNSUPPORTED = (D3D11_MESSAGE_ID_NEGOTIATECRPYTOSESSIONKEYEXCHANGE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_NULLPARAM = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_WRONGDEVICE = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_WRONGDEVICE = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_WRONGDEVICE + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_FORMAT_MISMATCH = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_WRONGDEVICE + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_SIZE_MISMATCH = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_FORMAT_MISMATCH + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_MULTISAMPLED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_SIZE_MISMATCH + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_NOT_STAGING = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_MULTISAMPLED + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_MAPPED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_NOT_STAGING + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_MAPPED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_MAPPED + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_OFFERED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_MAPPED + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_OFFERED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_OFFERED + 1),
    D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_CONTENT_UNDEFINED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_DST_OFFERED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_UNSUPPORTED = (D3D11_MESSAGE_ID_ENCRYPTIONBLT_SRC_CONTENT_UNDEFINED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_NULLPARAM = (D3D11_MESSAGE_ID_DECRYPTIONBLT_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_WRONGDEVICE = (D3D11_MESSAGE_ID_DECRYPTIONBLT_NULLPARAM + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_WRONGDEVICE = (D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_WRONGDEVICE + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_FORMAT_MISMATCH = (D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_WRONGDEVICE + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_SIZE_MISMATCH = (D3D11_MESSAGE_ID_DECRYPTIONBLT_FORMAT_MISMATCH + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_MULTISAMPLED = (D3D11_MESSAGE_ID_DECRYPTIONBLT_SIZE_MISMATCH + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_NOT_STAGING = (D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_MULTISAMPLED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_NOT_RENDER_TARGET = (D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_NOT_STAGING + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_MAPPED = (D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_NOT_RENDER_TARGET + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_MAPPED = (D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_MAPPED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_OFFERED = (D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_MAPPED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_OFFERED = (D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_OFFERED + 1),
    D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_CONTENT_UNDEFINED = (D3D11_MESSAGE_ID_DECRYPTIONBLT_DST_OFFERED + 1),
    D3D11_MESSAGE_ID_STARTSESSIONKEYREFRESH_NULLPARAM = (D3D11_MESSAGE_ID_DECRYPTIONBLT_SRC_CONTENT_UNDEFINED + 1),
    D3D11_MESSAGE_ID_STARTSESSIONKEYREFRESH_INVALIDSIZE = (D3D11_MESSAGE_ID_STARTSESSIONKEYREFRESH_NULLPARAM + 1),
    D3D11_MESSAGE_ID_FINISHSESSIONKEYREFRESH_NULLPARAM = (D3D11_MESSAGE_ID_STARTSESSIONKEYREFRESH_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_GETENCRYPTIONBLTKEY_NULLPARAM = (D3D11_MESSAGE_ID_FINISHSESSIONKEYREFRESH_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETENCRYPTIONBLTKEY_INVALIDSIZE = (D3D11_MESSAGE_ID_GETENCRYPTIONBLTKEY_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCONTENTPROTECTIONCAPS_NULLPARAM = (D3D11_MESSAGE_ID_GETENCRYPTIONBLTKEY_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_CHECKCRYPTOKEYEXCHANGE_NULLPARAM = (D3D11_MESSAGE_ID_GETCONTENTPROTECTIONCAPS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CHECKCRYPTOKEYEXCHANGE_INVALIDINDEX = (D3D11_MESSAGE_ID_CHECKCRYPTOKEYEXCHANGE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_NULLPARAM = (D3D11_MESSAGE_ID_CHECKCRYPTOKEYEXCHANGE_INVALIDINDEX + 1),
    D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_UNSUPPORTED = (D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_INVALIDTYPE = (D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_OUTOFMEMORY_RETURN = (D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATESIZE_INVALIDCHANNEL = (D3D11_MESSAGE_ID_CREATEAUTHENTICATEDCHANNEL_OUTOFMEMORY_RETURN + 1),
    D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATESIZE_NULLPARAM = (D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATESIZE_INVALIDCHANNEL + 1),
    D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATE_INVALIDCHANNEL = (D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATESIZE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATE_NULLPARAM = (D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATE_INVALIDCHANNEL + 1),
    D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATE_WRONGSIZE = (D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_NEGOTIATEAUTHENTICATEDCHANNELKEYEXCHANGE_INVALIDCHANNEL = (D3D11_MESSAGE_ID_GETAUTHENTICATEDCHANNELCERTIFICATE_WRONGSIZE + 1),
    D3D11_MESSAGE_ID_NEGOTIATEAUTHENTICATEDCHANNELKEYEXCHANGE_NULLPARAM = (D3D11_MESSAGE_ID_NEGOTIATEAUTHENTICATEDCHANNELKEYEXCHANGE_INVALIDCHANNEL + 1),
    D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_NULLPARAM = (D3D11_MESSAGE_ID_NEGOTIATEAUTHENTICATEDCHANNELKEYEXCHANGE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_WRONGCHANNEL = (D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_NULLPARAM + 1),
    D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_UNSUPPORTEDQUERY = (D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_WRONGCHANNEL + 1),
    D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_WRONGSIZE = (D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_UNSUPPORTEDQUERY + 1),
    D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_INVALIDPROCESSINDEX = (D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_WRONGSIZE + 1),
    D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_NULLPARAM = (D3D11_MESSAGE_ID_QUERYAUTHENTICATEDCHANNEL_INVALIDPROCESSINDEX + 1),
    D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_WRONGCHANNEL = (D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_UNSUPPORTEDCONFIGURE = (D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_WRONGCHANNEL + 1),
    D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_WRONGSIZE = (D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_UNSUPPORTEDCONFIGURE + 1),
    D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_INVALIDPROCESSIDTYPE = (D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_WRONGSIZE + 1),
    D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT = (D3D11_MESSAGE_ID_CONFIGUREAUTHENTICATEDCHANNEL_INVALIDPROCESSIDTYPE + 1),
    D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT = (D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT + 1),
    D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT = (D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT + 1),
    D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT = (D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT + 1),
    D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT = (D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT + 1),
    D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT = (D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT + 1),
    D3D11_MESSAGE_ID_NEGOTIATECRPYTOSESSIONKEYEXCHANGE_INVALIDSIZE = (D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFEROFFSETORCOUNT + 1),
    D3D11_MESSAGE_ID_NEGOTIATEAUTHENTICATEDCHANNELKEYEXCHANGE_INVALIDSIZE = (D3D11_MESSAGE_ID_NEGOTIATECRPYTOSESSIONKEYEXCHANGE_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_OFFERRESOURCES_INVALIDPRIORITY = (D3D11_MESSAGE_ID_NEGOTIATEAUTHENTICATEDCHANNELKEYEXCHANGE_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONHANDLE_OUTOFMEMORY = (D3D11_MESSAGE_ID_OFFERRESOURCES_INVALIDPRIORITY + 1),
    D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_NULLPARAM = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONHANDLE_OUTOFMEMORY + 1),
    D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_INVALIDTYPE = (D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_INVALIDBIND = (D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_INVALIDTYPE + 1),
    D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_INVALIDARRAY = (D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_INVALIDBIND + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_NULLPARAM = (D3D11_MESSAGE_ID_ACQUIREHANDLEFORCAPTURE_INVALIDARRAY + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_INVALID = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_INVALID + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMROTATION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMROTATION_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDVIEW = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMROTATION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDVIEW + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEEXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_SHADEREXTENSIONSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEEXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_MINPRECISION = (D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_SHADEREXTENSIONSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_UNSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_MINPRECISION + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMALPHA_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMPIXELASPECTRATIO_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_UAVSNOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_INVALIDOFFSET = (D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_UAVSNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_TOOMANYVIEWS = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_INVALIDOFFSET + 1),
    D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_NOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_TOOMANYVIEWS + 1),
    D3D11_MESSAGE_ID_SWAPDEVICECONTEXTSTATE_NOTSUPPORTED = (D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_NOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_PREFERUPDATESUBRESOURCE1 = (D3D11_MESSAGE_ID_SWAPDEVICECONTEXTSTATE_NOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_GETDC_INACCESSIBLE = (D3D11_MESSAGE_ID_UPDATESUBRESOURCE_PREFERUPDATESUBRESOURCE1 + 1),
    D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDRECT = (D3D11_MESSAGE_ID_GETDC_INACCESSIBLE + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLE_MASK_IGNORED_ON_FL9 = (D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDRECT + 1),
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE1_NOT_SUPPORTED = (D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLE_MASK_IGNORED_ON_FL9 + 1),
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BY_NAME_NOT_SUPPORTED = (D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE1_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_ENQUEUESETEVENT_NOT_SUPPORTED = (D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BY_NAME_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_OFFERRELEASE_NOT_SUPPORTED = (D3D11_MESSAGE_ID_ENQUEUESETEVENT_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_OFFERRESOURCES_INACCESSIBLE = (D3D11_MESSAGE_ID_OFFERRELEASE_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMSAA = (D3D11_MESSAGE_ID_OFFERRESOURCES_INACCESSIBLE + 1),
    D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDMSAA = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSORINPUTVIEW_INVALIDMSAA + 1),
    D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDSOURCERECT = (D3D11_MESSAGE_ID_CREATEVIDEOPROCESSOROUTPUTVIEW_INVALIDMSAA + 1),
    D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_EMPTYRECT = (D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDSOURCERECT + 1),
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_EMPTYDESTBOX = (D3D11_MESSAGE_ID_DEVICE_CLEARVIEW_EMPTYRECT + 1),
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_EMPTYSOURCEBOX = (D3D11_MESSAGE_ID_UPDATESUBRESOURCE_EMPTYDESTBOX + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS = (D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_EMPTYSOURCEBOX + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_DEPTHSTENCILVIEW_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET = (D3D11_MESSAGE_ID_DEVICE_DRAW_DEPTHSTENCILVIEW_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET_DUE_TO_FLIP_PRESENT = (D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET + 1),
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET_DUE_TO_FLIP_PRESENT = (D3D11_MESSAGE_ID_DEVICE_DRAW_RENDERTARGETVIEW_NOT_SET_DUE_TO_FLIP_PRESENT + 1),
    D3D11_MESSAGE_ID_GETDATAFORNEWHARDWAREKEY_NULLPARAM = (D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET_DUE_TO_FLIP_PRESENT + 1),
    D3D11_MESSAGE_ID_CHECKCRYPTOSESSIONSTATUS_NULLPARAM = (D3D11_MESSAGE_ID_GETDATAFORNEWHARDWAREKEY_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONPRIVATEDATASIZE_NULLPARAM = (D3D11_MESSAGE_ID_CHECKCRYPTOSESSIONSTATUS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCAPS_NULLPARAM = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONPRIVATEDATASIZE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_GETVIDEODECODERCAPS_ZEROWIDTHHEIGHT = (D3D11_MESSAGE_ID_GETVIDEODECODERCAPS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_NULLPARAM = (D3D11_MESSAGE_ID_GETVIDEODECODERCAPS_ZEROWIDTHHEIGHT + 1),
    D3D11_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE = (D3D11_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT = (D3D11_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE + 1),
    D3D11_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_NULLPARAM = (D3D11_MESSAGE_ID_CHECKVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT + 1),
    D3D11_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_NULLPARAM = (D3D11_MESSAGE_ID_VIDEODECODERENABLEDOWNSAMPLING_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CHECKVIDEOPROCESSORFORMATCONVERSION_NULLPARAM = (D3D11_MESSAGE_ID_VIDEODECODERUPDATEDOWNSAMPLING_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCOLORSPACE1_NULLPARAM = (D3D11_MESSAGE_ID_CHECKVIDEOPROCESSORFORMATCONVERSION_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCOLORSPACE1_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTCOLORSPACE1_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTCOLORSPACE1_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMCOLORSPACE1_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_UNSUPPORTED = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE1_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMMIRROR_UNSUPPORTED + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMMIRROR_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE1_NULLPARAM + 1),
    D3D11_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMMIRROR_NULLPARAM + 1),
    D3D11_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE = (D3D11_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_NULLPARAM + 1),
    D3D11_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT = (D3D11_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_INVALIDCOLORSPACE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSHADERUSAGE_NULLPARAM = (D3D11_MESSAGE_ID_RECOMMENDVIDEODECODERDOWNSAMPLING_ZEROWIDTHHEIGHT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTSHADERUSAGE_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTSHADERUSAGE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTSHADERUSAGE_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSTREAMCOUNT = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_TARGETRECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSTREAMCOUNT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSOURCERECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_TARGETRECT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDDESTRECT = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDSOURCERECT + 1),
    D3D11_MESSAGE_ID_GETCRYPTOSESSIONPRIVATEDATASIZE_INVALID_KEY_EXCHANGE_TYPE = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETBEHAVIORHINTS_INVALIDDESTRECT + 1),
    D3D11_MESSAGE_ID_D3D11_1_MESSAGES_END = (D3D11_MESSAGE_ID_GETCRYPTOSESSIONPRIVATEDATASIZE_INVALID_KEY_EXCHANGE_TYPE + 1),
    D3D11_MESSAGE_ID_D3D11_2_MESSAGES_START = (D3D11_MESSAGE_ID_D3D11_1_MESSAGES_END + 1),
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDUSAGE = (D3D11_MESSAGE_ID_D3D11_2_MESSAGES_START + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDUSAGE = (D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDUSAGE = (D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_STEPRATE_NOT_1 = (D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDUSAGE + 1),
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_INSTANCING_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_STEPRATE_NOT_1 + 1),
    D3D11_MESSAGE_ID_UPDATETILEMAPPINGS_INVALID_PARAMETER = (D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_LEVEL9_INSTANCING_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_COPYTILEMAPPINGS_INVALID_PARAMETER = (D3D11_MESSAGE_ID_UPDATETILEMAPPINGS_INVALID_PARAMETER + 1),
    D3D11_MESSAGE_ID_COPYTILES_INVALID_PARAMETER = (D3D11_MESSAGE_ID_COPYTILEMAPPINGS_INVALID_PARAMETER + 1),
    D3D11_MESSAGE_ID_UPDATETILES_INVALID_PARAMETER = (D3D11_MESSAGE_ID_COPYTILES_INVALID_PARAMETER + 1),
    D3D11_MESSAGE_ID_RESIZETILEPOOL_INVALID_PARAMETER = (D3D11_MESSAGE_ID_UPDATETILES_INVALID_PARAMETER + 1),
    D3D11_MESSAGE_ID_TILEDRESOURCEBARRIER_INVALID_PARAMETER = (D3D11_MESSAGE_ID_RESIZETILEPOOL_INVALID_PARAMETER + 1),
    D3D11_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_WARNING = (D3D11_MESSAGE_ID_TILEDRESOURCEBARRIER_INVALID_PARAMETER + 1),
    D3D11_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_ERROR = (D3D11_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_WARNING + 1),
    D3D11_MESSAGE_ID_DIRTY_TILE_MAPPING_ACCESS = (D3D11_MESSAGE_ID_NULL_TILE_MAPPING_ACCESS_ERROR + 1),
    D3D11_MESSAGE_ID_DUPLICATE_TILE_MAPPINGS_IN_COVERED_AREA = (D3D11_MESSAGE_ID_DIRTY_TILE_MAPPING_ACCESS + 1),
    D3D11_MESSAGE_ID_TILE_MAPPINGS_IN_COVERED_AREA_DUPLICATED_OUTSIDE = (D3D11_MESSAGE_ID_DUPLICATE_TILE_MAPPINGS_IN_COVERED_AREA + 1),
    D3D11_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INCOMPATIBLE_RESOURCES = (D3D11_MESSAGE_ID_TILE_MAPPINGS_IN_COVERED_AREA_DUPLICATED_OUTSIDE + 1),
    D3D11_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INPUT_AND_OUTPUT = (D3D11_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INCOMPATIBLE_RESOURCES + 1),
    D3D11_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_INVALIDFLAGS = (D3D11_MESSAGE_ID_TILE_MAPPINGS_SHARED_BETWEEN_INPUT_AND_OUTPUT + 1),
    D3D11_MESSAGE_ID_GETRESOURCETILING_NONTILED_RESOURCE = (D3D11_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_RESIZETILEPOOL_SHRINK_WITH_MAPPINGS_STILL_DEFINED_PAST_END = (D3D11_MESSAGE_ID_GETRESOURCETILING_NONTILED_RESOURCE + 1),
    D3D11_MESSAGE_ID_NEED_TO_CALL_TILEDRESOURCEBARRIER = (D3D11_MESSAGE_ID_RESIZETILEPOOL_SHRINK_WITH_MAPPINGS_STILL_DEFINED_PAST_END + 1),
    D3D11_MESSAGE_ID_CREATEDEVICE_INVALIDARGS = (D3D11_MESSAGE_ID_NEED_TO_CALL_TILEDRESOURCEBARRIER + 1),
    D3D11_MESSAGE_ID_CREATEDEVICE_WARNING = (D3D11_MESSAGE_ID_CREATEDEVICE_INVALIDARGS + 1),
    D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWUINT_HAZARD = (D3D11_MESSAGE_ID_CREATEDEVICE_WARNING + 1),
    D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_HAZARD = (D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWUINT_HAZARD + 1),
    D3D11_MESSAGE_ID_TILED_RESOURCE_TIER_1_BUFFER_TEXTURE_MISMATCH = (D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_HAZARD + 1),
    D3D11_MESSAGE_ID_CREATE_CRYPTOSESSION = (D3D11_MESSAGE_ID_TILED_RESOURCE_TIER_1_BUFFER_TEXTURE_MISMATCH + 1),
    D3D11_MESSAGE_ID_CREATE_AUTHENTICATEDCHANNEL = (D3D11_MESSAGE_ID_CREATE_CRYPTOSESSION + 1),
    D3D11_MESSAGE_ID_LIVE_CRYPTOSESSION = (D3D11_MESSAGE_ID_CREATE_AUTHENTICATEDCHANNEL + 1),
    D3D11_MESSAGE_ID_LIVE_AUTHENTICATEDCHANNEL = (D3D11_MESSAGE_ID_LIVE_CRYPTOSESSION + 1),
    D3D11_MESSAGE_ID_DESTROY_CRYPTOSESSION = (D3D11_MESSAGE_ID_LIVE_AUTHENTICATEDCHANNEL + 1),
    D3D11_MESSAGE_ID_DESTROY_AUTHENTICATEDCHANNEL = (D3D11_MESSAGE_ID_DESTROY_CRYPTOSESSION + 1),
    D3D11_MESSAGE_ID_D3D11_2_MESSAGES_END = (D3D11_MESSAGE_ID_DESTROY_AUTHENTICATEDCHANNEL + 1),
    D3D11_MESSAGE_ID_D3D11_3_MESSAGES_START = (D3D11_MESSAGE_ID_D3D11_2_MESSAGES_END + 1),
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALID_CONSERVATIVERASTERMODE = (D3D11_MESSAGE_ID_D3D11_3_MESSAGES_START + 1),
    D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_SYSTEMVALUE = (D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALID_CONSERVATIVERASTERMODE + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDCONTEXTTYPE = (D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_SYSTEMVALUE + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_DECODENOTSUPPORTED = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDCONTEXTTYPE + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_ENCODENOTSUPPORTED = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_DECODENOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANEINDEX = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_ENCODENOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANEINDEX = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_AMBIGUOUSVIDEOPLANEINDEX = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANEINDEX = (D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_AMBIGUOUSVIDEOPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANEINDEX = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_AMBIGUOUSVIDEOPLANEINDEX = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANEINDEX = (D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_AMBIGUOUSVIDEOPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANEINDEX = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANEINDEX + 1),
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_AMBIGUOUSVIDEOPLANEINDEX = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANEINDEX + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDSCANDATAOFFSET = (D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_AMBIGUOUSVIDEOPLANEINDEX + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_NOTSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDSCANDATAOFFSET + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_DIMENSIONSTOOLARGE = (D3D11_MESSAGE_ID_JPEGDECODE_NOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDCOMPONENTS = (D3D11_MESSAGE_ID_JPEGDECODE_DIMENSIONSTOOLARGE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_DESTINATIONNOT2D = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDCOMPONENTS + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_TILEDRESOURCESUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_DESTINATIONNOT2D + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_GUARDRECTSUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_TILEDRESOURCESUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_FORMATUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_GUARDRECTSUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_JPEGDECODE_FORMATUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDMIPLEVEL = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_EMPTYDESTBOX = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDMIPLEVEL + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_DESTBOXNOT2D = (D3D11_MESSAGE_ID_JPEGDECODE_EMPTYDESTBOX + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_DESTBOXNOTSUB = (D3D11_MESSAGE_ID_JPEGDECODE_DESTBOXNOT2D + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_DESTBOXESINTERSECT = (D3D11_MESSAGE_ID_JPEGDECODE_DESTBOXNOTSUB + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEMISMATCH = (D3D11_MESSAGE_ID_JPEGDECODE_DESTBOXESINTERSECT + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEMISMATCH = (D3D11_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEMISMATCH + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEODD = (D3D11_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEMISMATCH + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEODD = (D3D11_MESSAGE_ID_JPEGDECODE_XSUBSAMPLEODD + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_OUTPUTDIMENSIONSTOOLARGE = (D3D11_MESSAGE_ID_JPEGDECODE_YSUBSAMPLEODD + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_NONPOW2SCALEUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_OUTPUTDIMENSIONSTOOLARGE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_FRACTIONALDOWNSCALETOLARGE = (D3D11_MESSAGE_ID_JPEGDECODE_NONPOW2SCALEUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_CHROMASIZEMISMATCH = (D3D11_MESSAGE_ID_JPEGDECODE_FRACTIONALDOWNSCALETOLARGE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_LUMACHROMASIZEMISMATCH = (D3D11_MESSAGE_ID_JPEGDECODE_CHROMASIZEMISMATCH + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDNUMDESTINATIONS = (D3D11_MESSAGE_ID_JPEGDECODE_LUMACHROMASIZEMISMATCH + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_SUBBOXUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDNUMDESTINATIONS + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_1DESTUNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_JPEGDECODE_SUBBOXUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_3DESTUNSUPPORTEDFORMAT = (D3D11_MESSAGE_ID_JPEGDECODE_1DESTUNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_SCALEUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_3DESTUNSUPPORTEDFORMAT + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDSOURCESIZE = (D3D11_MESSAGE_ID_JPEGDECODE_SCALEUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_INVALIDCOPYFLAGS = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDSOURCESIZE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_HAZARD = (D3D11_MESSAGE_ID_JPEGDECODE_INVALIDCOPYFLAGS + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERUSAGE = (D3D11_MESSAGE_ID_JPEGDECODE_HAZARD + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERMISCFLAGS = (D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERUSAGE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDDSTTEXTUREUSAGE = (D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDSRCBUFFERMISCFLAGS + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_BACKBUFFERNOTSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPORTEDDSTTEXTUREUSAGE + 1),
    D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPRTEDCOPYFLAGS = (D3D11_MESSAGE_ID_JPEGDECODE_BACKBUFFERNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_NOTSUPPORTED = (D3D11_MESSAGE_ID_JPEGDECODE_UNSUPPRTEDCOPYFLAGS + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_INVALIDSCANDATAOFFSET = (D3D11_MESSAGE_ID_JPEGENCODE_NOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_INVALIDCOMPONENTS = (D3D11_MESSAGE_ID_JPEGENCODE_INVALIDSCANDATAOFFSET + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_SOURCENOT2D = (D3D11_MESSAGE_ID_JPEGENCODE_INVALIDCOMPONENTS + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_TILEDRESOURCESUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGENCODE_SOURCENOT2D + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_GUARDRECTSUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGENCODE_TILEDRESOURCESUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_XSUBSAMPLEMISMATCH = (D3D11_MESSAGE_ID_JPEGENCODE_GUARDRECTSUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_YSUBSAMPLEMISMATCH = (D3D11_MESSAGE_ID_JPEGENCODE_XSUBSAMPLEMISMATCH + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_FORMATUNSUPPORTED = (D3D11_MESSAGE_ID_JPEGENCODE_YSUBSAMPLEMISMATCH + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_INVALIDSUBRESOURCE = (D3D11_MESSAGE_ID_JPEGENCODE_FORMATUNSUPPORTED + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_INVALIDMIPLEVEL = (D3D11_MESSAGE_ID_JPEGENCODE_INVALIDSUBRESOURCE + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_DIMENSIONSTOOLARGE = (D3D11_MESSAGE_ID_JPEGENCODE_INVALIDMIPLEVEL + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_HAZARD = (D3D11_MESSAGE_ID_JPEGENCODE_DIMENSIONSTOOLARGE + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERUSAGE = (D3D11_MESSAGE_ID_JPEGENCODE_HAZARD + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERMISCFLAGS = (D3D11_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERUSAGE + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDSRCTEXTUREUSAGE = (D3D11_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDDSTBUFFERMISCFLAGS + 1),
    D3D11_MESSAGE_ID_JPEGENCODE_BACKBUFFERNOTSUPPORTED = (D3D11_MESSAGE_ID_JPEGENCODE_UNSUPPORTEDSRCTEXTUREUSAGE + 1),
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_UNSUPPORTEDCONTEXTTTYPEFORQUERY = (D3D11_MESSAGE_ID_JPEGENCODE_BACKBUFFERNOTSUPPORTED + 1),
    D3D11_MESSAGE_ID_FLUSH1_INVALIDCONTEXTTYPE = (D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_UNSUPPORTEDCONTEXTTTYPEFORQUERY + 1),
    D3D11_MESSAGE_ID_DEVICE_SETHARDWAREPROTECTION_INVALIDCONTEXT = (D3D11_MESSAGE_ID_FLUSH1_INVALIDCONTEXTTYPE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTHDRMETADATA_NULLPARAM = (D3D11_MESSAGE_ID_DEVICE_SETHARDWAREPROTECTION_INVALIDCONTEXT + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTHDRMETADATA_INVALIDSIZE = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTHDRMETADATA_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTHDRMETADATA_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETOUTPUTHDRMETADATA_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTHDRMETADATA_INVALIDSIZE = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTHDRMETADATA_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMHDRMETADATA_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETOUTPUTHDRMETADATA_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMHDRMETADATA_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMHDRMETADATA_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMHDRMETADATA_INVALIDSIZE = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMHDRMETADATA_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMHDRMETADATA_NULLPARAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORSETSTREAMHDRMETADATA_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMHDRMETADATA_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMHDRMETADATA_NULLPARAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMHDRMETADATA_INVALIDSIZE = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMHDRMETADATA_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFRAMEFORMAT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMHDRMETADATA_INVALIDSIZE + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFRAMEFORMAT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMOUTPUTRATE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSOURCERECT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMOUTPUTRATE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMDESTRECT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSOURCERECT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMALPHA_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMDESTRECT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPALETTE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMALPHA_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPIXELASPECTRATIO_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPALETTE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMLUMAKEY_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMPIXELASPECTRATIO_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSTEREOFORMAT_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMLUMAKEY_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMAUTOPROCESSINGMODE_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMSTEREOFORMAT_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFILTER_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMAUTOPROCESSINGMODE_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMROTATION_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMFILTER_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE1_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMROTATION_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMMIRROR_INVALIDSTREAM = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMCOLORSPACE1_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_CREATE_FENCE = (D3D11_MESSAGE_ID_VIDEOPROCESSORGETSTREAMMIRROR_INVALIDSTREAM + 1),
    D3D11_MESSAGE_ID_LIVE_FENCE = (D3D11_MESSAGE_ID_CREATE_FENCE + 1),
    D3D11_MESSAGE_ID_DESTROY_FENCE = (D3D11_MESSAGE_ID_LIVE_FENCE + 1),
    D3D11_MESSAGE_ID_CREATE_SYNCHRONIZEDCHANNEL = (D3D11_MESSAGE_ID_DESTROY_FENCE + 1),
    D3D11_MESSAGE_ID_LIVE_SYNCHRONIZEDCHANNEL = (D3D11_MESSAGE_ID_CREATE_SYNCHRONIZEDCHANNEL + 1),
    D3D11_MESSAGE_ID_DESTROY_SYNCHRONIZEDCHANNEL = (D3D11_MESSAGE_ID_LIVE_SYNCHRONIZEDCHANNEL + 1),
    D3D11_MESSAGE_ID_CREATEFENCE_INVALIDFLAGS = (D3D11_MESSAGE_ID_DESTROY_SYNCHRONIZEDCHANNEL + 1),
    D3D11_MESSAGE_ID_D3D11_3_MESSAGES_END = (D3D11_MESSAGE_ID_CREATEFENCE_INVALIDFLAGS + 1),
    D3D11_MESSAGE_ID_D3D11_5_MESSAGES_START = (D3D11_MESSAGE_ID_D3D11_3_MESSAGES_END + 1),
    D3D11_MESSAGE_ID_NEGOTIATECRYPTOSESSIONKEYEXCHANGEMT_INVALIDKEYEXCHANGETYPE = (D3D11_MESSAGE_ID_D3D11_5_MESSAGES_START + 1),
    D3D11_MESSAGE_ID_NEGOTIATECRYPTOSESSIONKEYEXCHANGEMT_NOT_SUPPORTED = (D3D11_MESSAGE_ID_NEGOTIATECRYPTOSESSIONKEYEXCHANGEMT_INVALIDKEYEXCHANGETYPE + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_COMPONENT_COUNT = (D3D11_MESSAGE_ID_NEGOTIATECRYPTOSESSIONKEYEXCHANGEMT_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_COMPONENT = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_COMPONENT_COUNT + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_SIZE = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_COMPONENT + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_USAGE = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_SIZE + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_MISC_FLAGS = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_USAGE + 1),
    D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_OFFSET = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_MISC_FLAGS + 1),
    D3D11_MESSAGE_ID_CREATE_TRACKEDWORKLOAD = (D3D11_MESSAGE_ID_DECODERBEGINFRAME_INVALID_HISTOGRAM_BUFFER_OFFSET + 1),
    D3D11_MESSAGE_ID_LIVE_TRACKEDWORKLOAD = (D3D11_MESSAGE_ID_CREATE_TRACKEDWORKLOAD + 1),
    D3D11_MESSAGE_ID_DESTROY_TRACKEDWORKLOAD = (D3D11_MESSAGE_ID_LIVE_TRACKEDWORKLOAD + 1),
    D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_NULLPARAM = (D3D11_MESSAGE_ID_DESTROY_TRACKEDWORKLOAD + 1),
    D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_INVALID_MAX_INSTANCES = (D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_NULLPARAM + 1),
    D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_INVALID_DEADLINE_TYPE = (D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_INVALID_MAX_INSTANCES + 1),
    D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_INVALID_ENGINE_TYPE = (D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_INVALID_DEADLINE_TYPE + 1),
    D3D11_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOADS = (D3D11_MESSAGE_ID_CREATE_TRACKED_WORKLOAD_INVALID_ENGINE_TYPE + 1),
    D3D11_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOAD_PAIRS = (D3D11_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOADS + 1),
    D3D11_MESSAGE_ID_INCOMPLETE_TRACKED_WORKLOAD_PAIR = (D3D11_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOAD_PAIRS + 1),
    D3D11_MESSAGE_ID_OUT_OF_ORDER_TRACKED_WORKLOAD_PAIR = (D3D11_MESSAGE_ID_INCOMPLETE_TRACKED_WORKLOAD_PAIR + 1),
    D3D11_MESSAGE_ID_CANNOT_ADD_TRACKED_WORKLOAD = (D3D11_MESSAGE_ID_OUT_OF_ORDER_TRACKED_WORKLOAD_PAIR + 1),
    D3D11_MESSAGE_ID_TRACKED_WORKLOAD_NOT_SUPPORTED = (D3D11_MESSAGE_ID_CANNOT_ADD_TRACKED_WORKLOAD + 1),
    D3D11_MESSAGE_ID_TRACKED_WORKLOAD_ENGINE_TYPE_NOT_FOUND = (D3D11_MESSAGE_ID_TRACKED_WORKLOAD_NOT_SUPPORTED + 1),
    D3D11_MESSAGE_ID_NO_TRACKED_WORKLOAD_SLOT_AVAILABLE = (D3D11_MESSAGE_ID_TRACKED_WORKLOAD_ENGINE_TYPE_NOT_FOUND + 1),
    D3D11_MESSAGE_ID_END_TRACKED_WORKLOAD_INVALID_ARG = (D3D11_MESSAGE_ID_NO_TRACKED_WORKLOAD_SLOT_AVAILABLE + 1),
    D3D11_MESSAGE_ID_TRACKED_WORKLOAD_DISJOINT_FAILURE = (D3D11_MESSAGE_ID_END_TRACKED_WORKLOAD_INVALID_ARG + 1),
    D3D11_MESSAGE_ID_D3D11_5_MESSAGES_END = (D3D11_MESSAGE_ID_TRACKED_WORKLOAD_DISJOINT_FAILURE + 1)
} D3D11_MESSAGE_ID;
typedef struct D3D11_MESSAGE {
    D3D11_MESSAGE_CATEGORY Category;
    D3D11_MESSAGE_SEVERITY Severity;
    D3D11_MESSAGE_ID ID;
    const char* pDescription;
    SIZE_T DescriptionByteLength;
} D3D11_MESSAGE;
typedef struct D3D11_INFO_QUEUE_FILTER_DESC {
    UINT NumCategories;
    D3D11_MESSAGE_CATEGORY* pCategoryList;
    UINT NumSeverities;
    D3D11_MESSAGE_SEVERITY* pSeverityList;
    UINT NumIDs;
    D3D11_MESSAGE_ID* pIDList;
} D3D11_INFO_QUEUE_FILTER_DESC;
typedef struct D3D11_INFO_QUEUE_FILTER {
    D3D11_INFO_QUEUE_FILTER_DESC AllowList;
    D3D11_INFO_QUEUE_FILTER_DESC DenyList;
} D3D11_INFO_QUEUE_FILTER;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0005_v0_0_s_ifspec;
extern "C" const IID IID_ID3D11InfoQueue;
struct __declspec(uuid("6543dbb6-1b48-42f5-ab82-e97ec74326f6")) __declspec(novtable)
    ID3D11InfoQueue : public IUnknown {
public:
    virtual HRESULT __stdcall SetMessageCountLimit(
        UINT64 MessageCountLimit)
        = 0;
    virtual void __stdcall ClearStoredMessages(void) = 0;
    virtual HRESULT __stdcall GetMessageW(
        UINT64 MessageIndex,
        D3D11_MESSAGE* pMessage,
        SIZE_T* pMessageByteLength)
        = 0;
    virtual UINT64 __stdcall GetNumMessagesAllowedByStorageFilter(void) = 0;
    virtual UINT64 __stdcall GetNumMessagesDeniedByStorageFilter(void) = 0;
    virtual UINT64 __stdcall GetNumStoredMessages(void) = 0;
    virtual UINT64 __stdcall GetNumStoredMessagesAllowedByRetrievalFilter(void) = 0;
    virtual UINT64 __stdcall GetNumMessagesDiscardedByMessageCountLimit(void) = 0;
    virtual UINT64 __stdcall GetMessageCountLimit(void) = 0;
    virtual HRESULT __stdcall AddStorageFilterEntries(
        D3D11_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual HRESULT __stdcall GetStorageFilter(
        D3D11_INFO_QUEUE_FILTER* pFilter,
        SIZE_T* pFilterByteLength)
        = 0;
    virtual void __stdcall ClearStorageFilter(void) = 0;
    virtual HRESULT __stdcall PushEmptyStorageFilter(void) = 0;
    virtual HRESULT __stdcall PushCopyOfStorageFilter(void) = 0;
    virtual HRESULT __stdcall PushStorageFilter(
        D3D11_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual void __stdcall PopStorageFilter(void) = 0;
    virtual UINT __stdcall GetStorageFilterStackSize(void) = 0;
    virtual HRESULT __stdcall AddRetrievalFilterEntries(
        D3D11_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual HRESULT __stdcall GetRetrievalFilter(
        D3D11_INFO_QUEUE_FILTER* pFilter,
        SIZE_T* pFilterByteLength)
        = 0;
    virtual void __stdcall ClearRetrievalFilter(void) = 0;
    virtual HRESULT __stdcall PushEmptyRetrievalFilter(void) = 0;
    virtual HRESULT __stdcall PushCopyOfRetrievalFilter(void) = 0;
    virtual HRESULT __stdcall PushRetrievalFilter(
        D3D11_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual void __stdcall PopRetrievalFilter(void) = 0;
    virtual UINT __stdcall GetRetrievalFilterStackSize(void) = 0;
    virtual HRESULT __stdcall AddMessage(
        D3D11_MESSAGE_CATEGORY Category,
        D3D11_MESSAGE_SEVERITY Severity,
        D3D11_MESSAGE_ID ID,
        LPCSTR pDescription)
        = 0;
    virtual HRESULT __stdcall AddApplicationMessage(
        D3D11_MESSAGE_SEVERITY Severity,
        LPCSTR pDescription)
        = 0;
    virtual HRESULT __stdcall SetBreakOnCategory(
        D3D11_MESSAGE_CATEGORY Category,
        BOOL bEnable)
        = 0;
    virtual HRESULT __stdcall SetBreakOnSeverity(
        D3D11_MESSAGE_SEVERITY Severity,
        BOOL bEnable)
        = 0;
    virtual HRESULT __stdcall SetBreakOnID(
        D3D11_MESSAGE_ID ID,
        BOOL bEnable)
        = 0;
    virtual BOOL __stdcall GetBreakOnCategory(
        D3D11_MESSAGE_CATEGORY Category)
        = 0;
    virtual BOOL __stdcall GetBreakOnSeverity(
        D3D11_MESSAGE_SEVERITY Severity)
        = 0;
    virtual BOOL __stdcall GetBreakOnID(
        D3D11_MESSAGE_ID ID)
        = 0;
    virtual void __stdcall SetMuteDebugOutput(
        BOOL bMute)
        = 0;
    virtual BOOL __stdcall GetMuteDebugOutput(void) = 0;
};
#pragma endregion
#pragma endregion
extern "C" const GUID IID_ID3D11Debug;
extern "C" const GUID IID_ID3D11SwitchToRef;
extern "C" const GUID IID_ID3D11TracingDevice;
extern "C" const GUID IID_ID3D11RefTrackingOptions;
extern "C" const GUID IID_ID3D11RefDefaultTrackingOptions;
extern "C" const GUID IID_ID3D11InfoQueue;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11sdklayers_0000_0006_v0_0_s_ifspec;
}
#pragma once
typedef struct ID3D10BlendState1 ID3D10BlendState1;
typedef struct ID3D10ShaderResourceView1 ID3D10ShaderResourceView1;
typedef struct ID3D10Device1 ID3D10Device1;
extern "C" {
#pragma once
typedef struct ID3D10DeviceChild ID3D10DeviceChild;
typedef struct ID3D10DepthStencilState ID3D10DepthStencilState;
typedef struct ID3D10BlendState ID3D10BlendState;
typedef struct ID3D10RasterizerState ID3D10RasterizerState;
typedef struct ID3D10Resource ID3D10Resource;
typedef struct ID3D10Buffer ID3D10Buffer;
typedef struct ID3D10Texture1D ID3D10Texture1D;
typedef struct ID3D10Texture2D ID3D10Texture2D;
typedef struct ID3D10Texture3D ID3D10Texture3D;
typedef struct ID3D10View ID3D10View;
typedef struct ID3D10ShaderResourceView ID3D10ShaderResourceView;
typedef struct ID3D10RenderTargetView ID3D10RenderTargetView;
typedef struct ID3D10DepthStencilView ID3D10DepthStencilView;
typedef struct ID3D10VertexShader ID3D10VertexShader;
typedef struct ID3D10GeometryShader ID3D10GeometryShader;
typedef struct ID3D10PixelShader ID3D10PixelShader;
typedef struct ID3D10InputLayout ID3D10InputLayout;
typedef struct ID3D10SamplerState ID3D10SamplerState;
typedef struct ID3D10Asynchronous ID3D10Asynchronous;
typedef struct ID3D10Query ID3D10Query;
typedef struct ID3D10Predicate ID3D10Predicate;
typedef struct ID3D10Counter ID3D10Counter;
typedef struct ID3D10Device ID3D10Device;
typedef struct ID3D10Multithread ID3D10Multithread;
extern "C" {
#pragma region Desktop Family
typedef enum D3D10_INPUT_CLASSIFICATION {
    D3D10_INPUT_PER_VERTEX_DATA = 0,
    D3D10_INPUT_PER_INSTANCE_DATA = 1
} D3D10_INPUT_CLASSIFICATION;
typedef struct D3D10_INPUT_ELEMENT_DESC {
    LPCSTR SemanticName;
    UINT SemanticIndex;
    DXGI_FORMAT Format;
    UINT InputSlot;
    UINT AlignedByteOffset;
    D3D10_INPUT_CLASSIFICATION InputSlotClass;
    UINT InstanceDataStepRate;
} D3D10_INPUT_ELEMENT_DESC;
typedef enum D3D10_FILL_MODE {
    D3D10_FILL_WIREFRAME = 2,
    D3D10_FILL_SOLID = 3
} D3D10_FILL_MODE;
typedef D3D_PRIMITIVE_TOPOLOGY D3D10_PRIMITIVE_TOPOLOGY;
typedef D3D_PRIMITIVE D3D10_PRIMITIVE;
typedef enum D3D10_CULL_MODE {
    D3D10_CULL_NONE = 1,
    D3D10_CULL_FRONT = 2,
    D3D10_CULL_BACK = 3
} D3D10_CULL_MODE;
typedef struct D3D10_SO_DECLARATION_ENTRY {
    LPCSTR SemanticName;
    UINT SemanticIndex;
    BYTE StartComponent;
    BYTE ComponentCount;
    BYTE OutputSlot;
} D3D10_SO_DECLARATION_ENTRY;
typedef struct D3D10_VIEWPORT {
    INT TopLeftX;
    INT TopLeftY;
    UINT Width;
    UINT Height;
    FLOAT MinDepth;
    FLOAT MaxDepth;
} D3D10_VIEWPORT;
typedef enum D3D10_RESOURCE_DIMENSION {
    D3D10_RESOURCE_DIMENSION_UNKNOWN = 0,
    D3D10_RESOURCE_DIMENSION_BUFFER = 1,
    D3D10_RESOURCE_DIMENSION_TEXTURE1D = 2,
    D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3,
    D3D10_RESOURCE_DIMENSION_TEXTURE3D = 4
} D3D10_RESOURCE_DIMENSION;
typedef D3D_SRV_DIMENSION D3D10_SRV_DIMENSION;
typedef enum D3D10_DSV_DIMENSION {
    D3D10_DSV_DIMENSION_UNKNOWN = 0,
    D3D10_DSV_DIMENSION_TEXTURE1D = 1,
    D3D10_DSV_DIMENSION_TEXTURE1DARRAY = 2,
    D3D10_DSV_DIMENSION_TEXTURE2D = 3,
    D3D10_DSV_DIMENSION_TEXTURE2DARRAY = 4,
    D3D10_DSV_DIMENSION_TEXTURE2DMS = 5,
    D3D10_DSV_DIMENSION_TEXTURE2DMSARRAY = 6
} D3D10_DSV_DIMENSION;
typedef enum D3D10_RTV_DIMENSION {
    D3D10_RTV_DIMENSION_UNKNOWN = 0,
    D3D10_RTV_DIMENSION_BUFFER = 1,
    D3D10_RTV_DIMENSION_TEXTURE1D = 2,
    D3D10_RTV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D10_RTV_DIMENSION_TEXTURE2D = 4,
    D3D10_RTV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D10_RTV_DIMENSION_TEXTURE2DMS = 6,
    D3D10_RTV_DIMENSION_TEXTURE2DMSARRAY = 7,
    D3D10_RTV_DIMENSION_TEXTURE3D = 8
} D3D10_RTV_DIMENSION;
typedef enum D3D10_USAGE {
    D3D10_USAGE_DEFAULT = 0,
    D3D10_USAGE_IMMUTABLE = 1,
    D3D10_USAGE_DYNAMIC = 2,
    D3D10_USAGE_STAGING = 3
} D3D10_USAGE;
typedef enum D3D10_BIND_FLAG {
    D3D10_BIND_VERTEX_BUFFER = 0x1L,
    D3D10_BIND_INDEX_BUFFER = 0x2L,
    D3D10_BIND_CONSTANT_BUFFER = 0x4L,
    D3D10_BIND_SHADER_RESOURCE = 0x8L,
    D3D10_BIND_STREAM_OUTPUT = 0x10L,
    D3D10_BIND_RENDER_TARGET = 0x20L,
    D3D10_BIND_DEPTH_STENCIL = 0x40L
} D3D10_BIND_FLAG;
typedef enum D3D10_CPU_ACCESS_FLAG {
    D3D10_CPU_ACCESS_WRITE = 0x10000L,
    D3D10_CPU_ACCESS_READ = 0x20000L
} D3D10_CPU_ACCESS_FLAG;
typedef enum D3D10_RESOURCE_MISC_FLAG {
    D3D10_RESOURCE_MISC_GENERATE_MIPS = 0x1L,
    D3D10_RESOURCE_MISC_SHARED = 0x2L,
    D3D10_RESOURCE_MISC_TEXTURECUBE = 0x4L,
    D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX = 0x10L,
    D3D10_RESOURCE_MISC_GDI_COMPATIBLE = 0x20L
} D3D10_RESOURCE_MISC_FLAG;
typedef enum D3D10_MAP {
    D3D10_MAP_READ = 1,
    D3D10_MAP_WRITE = 2,
    D3D10_MAP_READ_WRITE = 3,
    D3D10_MAP_WRITE_DISCARD = 4,
    D3D10_MAP_WRITE_NO_OVERWRITE = 5
} D3D10_MAP;
typedef enum D3D10_MAP_FLAG {
    D3D10_MAP_FLAG_DO_NOT_WAIT = 0x100000L
} D3D10_MAP_FLAG;
typedef enum D3D10_RAISE_FLAG {
    D3D10_RAISE_FLAG_DRIVER_INTERNAL_ERROR = 0x1L
} D3D10_RAISE_FLAG;
typedef enum D3D10_CLEAR_FLAG {
    D3D10_CLEAR_DEPTH = 0x1L,
    D3D10_CLEAR_STENCIL = 0x2L
} D3D10_CLEAR_FLAG;
typedef RECT D3D10_RECT;
typedef struct D3D10_BOX {
    UINT left;
    UINT top;
    UINT front;
    UINT right;
    UINT bottom;
    UINT back;
} D3D10_BOX;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10DeviceChild;
struct __declspec(uuid("9B7E4C00-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10DeviceChild : public IUnknown {
public:
    virtual void __stdcall GetDevice(
        ID3D10Device** ppDevice)
        = 0;
    virtual HRESULT __stdcall GetPrivateData(
        const GUID& guid,
        UINT* pDataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateData(
        const GUID& guid,
        UINT DataSize,
        const void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateDataInterface(
        const GUID& guid,
        const IUnknown* pData)
        = 0;
};
typedef enum D3D10_COMPARISON_FUNC {
    D3D10_COMPARISON_NEVER = 1,
    D3D10_COMPARISON_LESS = 2,
    D3D10_COMPARISON_EQUAL = 3,
    D3D10_COMPARISON_LESS_EQUAL = 4,
    D3D10_COMPARISON_GREATER = 5,
    D3D10_COMPARISON_NOT_EQUAL = 6,
    D3D10_COMPARISON_GREATER_EQUAL = 7,
    D3D10_COMPARISON_ALWAYS = 8
} D3D10_COMPARISON_FUNC;
typedef enum D3D10_DEPTH_WRITE_MASK {
    D3D10_DEPTH_WRITE_MASK_ZERO = 0,
    D3D10_DEPTH_WRITE_MASK_ALL = 1
} D3D10_DEPTH_WRITE_MASK;
typedef enum D3D10_STENCIL_OP {
    D3D10_STENCIL_OP_KEEP = 1,
    D3D10_STENCIL_OP_ZERO = 2,
    D3D10_STENCIL_OP_REPLACE = 3,
    D3D10_STENCIL_OP_INCR_SAT = 4,
    D3D10_STENCIL_OP_DECR_SAT = 5,
    D3D10_STENCIL_OP_INVERT = 6,
    D3D10_STENCIL_OP_INCR = 7,
    D3D10_STENCIL_OP_DECR = 8
} D3D10_STENCIL_OP;
typedef struct D3D10_DEPTH_STENCILOP_DESC {
    D3D10_STENCIL_OP StencilFailOp;
    D3D10_STENCIL_OP StencilDepthFailOp;
    D3D10_STENCIL_OP StencilPassOp;
    D3D10_COMPARISON_FUNC StencilFunc;
} D3D10_DEPTH_STENCILOP_DESC;
typedef struct D3D10_DEPTH_STENCIL_DESC {
    BOOL DepthEnable;
    D3D10_DEPTH_WRITE_MASK DepthWriteMask;
    D3D10_COMPARISON_FUNC DepthFunc;
    BOOL StencilEnable;
    UINT8 StencilReadMask;
    UINT8 StencilWriteMask;
    D3D10_DEPTH_STENCILOP_DESC FrontFace;
    D3D10_DEPTH_STENCILOP_DESC BackFace;
} D3D10_DEPTH_STENCIL_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0001_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10DepthStencilState;
struct __declspec(uuid("2B4B1CC8-A4AD-41f8-8322-CA86FC3EC675")) __declspec(novtable)
    ID3D10DepthStencilState : public ID3D10DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D10_DEPTH_STENCIL_DESC* pDesc)
        = 0;
};
typedef enum D3D10_BLEND {
    D3D10_BLEND_ZERO = 1,
    D3D10_BLEND_ONE = 2,
    D3D10_BLEND_SRC_COLOR = 3,
    D3D10_BLEND_INV_SRC_COLOR = 4,
    D3D10_BLEND_SRC_ALPHA = 5,
    D3D10_BLEND_INV_SRC_ALPHA = 6,
    D3D10_BLEND_DEST_ALPHA = 7,
    D3D10_BLEND_INV_DEST_ALPHA = 8,
    D3D10_BLEND_DEST_COLOR = 9,
    D3D10_BLEND_INV_DEST_COLOR = 10,
    D3D10_BLEND_SRC_ALPHA_SAT = 11,
    D3D10_BLEND_BLEND_FACTOR = 14,
    D3D10_BLEND_INV_BLEND_FACTOR = 15,
    D3D10_BLEND_SRC1_COLOR = 16,
    D3D10_BLEND_INV_SRC1_COLOR = 17,
    D3D10_BLEND_SRC1_ALPHA = 18,
    D3D10_BLEND_INV_SRC1_ALPHA = 19
} D3D10_BLEND;
typedef enum D3D10_BLEND_OP {
    D3D10_BLEND_OP_ADD = 1,
    D3D10_BLEND_OP_SUBTRACT = 2,
    D3D10_BLEND_OP_REV_SUBTRACT = 3,
    D3D10_BLEND_OP_MIN = 4,
    D3D10_BLEND_OP_MAX = 5
} D3D10_BLEND_OP;
typedef enum D3D10_COLOR_WRITE_ENABLE {
    D3D10_COLOR_WRITE_ENABLE_RED = 1,
    D3D10_COLOR_WRITE_ENABLE_GREEN = 2,
    D3D10_COLOR_WRITE_ENABLE_BLUE = 4,
    D3D10_COLOR_WRITE_ENABLE_ALPHA = 8,
    D3D10_COLOR_WRITE_ENABLE_ALL = (((D3D10_COLOR_WRITE_ENABLE_RED | D3D10_COLOR_WRITE_ENABLE_GREEN) | D3D10_COLOR_WRITE_ENABLE_BLUE) | D3D10_COLOR_WRITE_ENABLE_ALPHA)
} D3D10_COLOR_WRITE_ENABLE;
typedef struct D3D10_BLEND_DESC {
    BOOL AlphaToCoverageEnable;
    BOOL BlendEnable[8];
    D3D10_BLEND SrcBlend;
    D3D10_BLEND DestBlend;
    D3D10_BLEND_OP BlendOp;
    D3D10_BLEND SrcBlendAlpha;
    D3D10_BLEND DestBlendAlpha;
    D3D10_BLEND_OP BlendOpAlpha;
    UINT8 RenderTargetWriteMask[8];
} D3D10_BLEND_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0002_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10BlendState;
struct __declspec(uuid("EDAD8D19-8A35-4d6d-8566-2EA276CDE161")) __declspec(novtable)
    ID3D10BlendState : public ID3D10DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D10_BLEND_DESC* pDesc)
        = 0;
};
typedef struct D3D10_RASTERIZER_DESC {
    D3D10_FILL_MODE FillMode;
    D3D10_CULL_MODE CullMode;
    BOOL FrontCounterClockwise;
    INT DepthBias;
    FLOAT DepthBiasClamp;
    FLOAT SlopeScaledDepthBias;
    BOOL DepthClipEnable;
    BOOL ScissorEnable;
    BOOL MultisampleEnable;
    BOOL AntialiasedLineEnable;
} D3D10_RASTERIZER_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0003_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10RasterizerState;
struct __declspec(uuid("A2A07292-89AF-4345-BE2E-C53D9FBB6E9F")) __declspec(novtable)
    ID3D10RasterizerState : public ID3D10DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D10_RASTERIZER_DESC* pDesc)
        = 0;
};
inline UINT D3D10CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT MipLevels)
{
    return MipSlice + ArraySlice * MipLevels;
}
typedef struct D3D10_SUBRESOURCE_DATA {
    const void* pSysMem;
    UINT SysMemPitch;
    UINT SysMemSlicePitch;
} D3D10_SUBRESOURCE_DATA;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0004_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Resource;
struct __declspec(uuid("9B7E4C01-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Resource : public ID3D10DeviceChild {
public:
    virtual void __stdcall GetType(
        D3D10_RESOURCE_DIMENSION* rType)
        = 0;
    virtual void __stdcall SetEvictionPriority(
        UINT EvictionPriority)
        = 0;
    virtual UINT __stdcall GetEvictionPriority(void) = 0;
};
typedef struct D3D10_BUFFER_DESC {
    UINT ByteWidth;
    D3D10_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D10_BUFFER_DESC;
struct CD3D10_BUFFER_DESC : public D3D10_BUFFER_DESC {
    CD3D10_BUFFER_DESC() = default;
    explicit CD3D10_BUFFER_DESC(const D3D10_BUFFER_DESC& o)
        : D3D10_BUFFER_DESC(o)
    {
    }
    explicit CD3D10_BUFFER_DESC(
        UINT byteWidth,
        UINT bindFlags,
        D3D10_USAGE usage = D3D10_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT miscFlags = 0)
    {
        ByteWidth = byteWidth;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D10_BUFFER_DESC() { }
};
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0005_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Buffer;
struct __declspec(uuid("9B7E4C02-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Buffer : public ID3D10Resource {
public:
    virtual HRESULT __stdcall Map(
        D3D10_MAP MapType,
        UINT MapFlags,
        void** ppData)
        = 0;
    virtual void __stdcall Unmap(void) = 0;
    virtual void __stdcall GetDesc(
        D3D10_BUFFER_DESC* pDesc)
        = 0;
};
typedef struct D3D10_TEXTURE1D_DESC {
    UINT Width;
    UINT MipLevels;
    UINT ArraySize;
    DXGI_FORMAT Format;
    D3D10_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D10_TEXTURE1D_DESC;
struct CD3D10_TEXTURE1D_DESC : public D3D10_TEXTURE1D_DESC {
    CD3D10_TEXTURE1D_DESC() = default;
    explicit CD3D10_TEXTURE1D_DESC(const D3D10_TEXTURE1D_DESC& o)
        : D3D10_TEXTURE1D_DESC(o)
    {
    }
    explicit CD3D10_TEXTURE1D_DESC(
        DXGI_FORMAT format,
        UINT width,
        UINT arraySize = 1,
        UINT mipLevels = 0,
        UINT bindFlags = D3D10_BIND_SHADER_RESOURCE,
        D3D10_USAGE usage = D3D10_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT miscFlags = 0)
    {
        Width = width;
        MipLevels = mipLevels;
        ArraySize = arraySize;
        Format = format;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D10_TEXTURE1D_DESC() { }
};
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0006_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Texture1D;
struct __declspec(uuid("9B7E4C03-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Texture1D : public ID3D10Resource {
public:
    virtual HRESULT __stdcall Map(
        UINT Subresource,
        D3D10_MAP MapType,
        UINT MapFlags,
        void** ppData)
        = 0;
    virtual void __stdcall Unmap(
        UINT Subresource)
        = 0;
    virtual void __stdcall GetDesc(
        D3D10_TEXTURE1D_DESC* pDesc)
        = 0;
};
typedef struct D3D10_TEXTURE2D_DESC {
    UINT Width;
    UINT Height;
    UINT MipLevels;
    UINT ArraySize;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
    D3D10_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D10_TEXTURE2D_DESC;
struct CD3D10_TEXTURE2D_DESC : public D3D10_TEXTURE2D_DESC {
    CD3D10_TEXTURE2D_DESC() = default;
    explicit CD3D10_TEXTURE2D_DESC(const D3D10_TEXTURE2D_DESC& o)
        : D3D10_TEXTURE2D_DESC(o)
    {
    }
    explicit CD3D10_TEXTURE2D_DESC(
        DXGI_FORMAT format,
        UINT width,
        UINT height,
        UINT arraySize = 1,
        UINT mipLevels = 0,
        UINT bindFlags = D3D10_BIND_SHADER_RESOURCE,
        D3D10_USAGE usage = D3D10_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT sampleCount = 1,
        UINT sampleQuality = 0,
        UINT miscFlags = 0)
    {
        Width = width;
        Height = height;
        MipLevels = mipLevels;
        ArraySize = arraySize;
        Format = format;
        SampleDesc.Count = sampleCount;
        SampleDesc.Quality = sampleQuality;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D10_TEXTURE2D_DESC() { }
};
typedef struct D3D10_MAPPED_TEXTURE2D {
    void* pData;
    UINT RowPitch;
} D3D10_MAPPED_TEXTURE2D;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0007_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Texture2D;
struct __declspec(uuid("9B7E4C04-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Texture2D : public ID3D10Resource {
public:
    virtual HRESULT __stdcall Map(
        UINT Subresource,
        D3D10_MAP MapType,
        UINT MapFlags,
        D3D10_MAPPED_TEXTURE2D* pMappedTex2D)
        = 0;
    virtual void __stdcall Unmap(
        UINT Subresource)
        = 0;
    virtual void __stdcall GetDesc(
        D3D10_TEXTURE2D_DESC* pDesc)
        = 0;
};
typedef struct D3D10_TEXTURE3D_DESC {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    DXGI_FORMAT Format;
    D3D10_USAGE Usage;
    UINT BindFlags;
    UINT CPUAccessFlags;
    UINT MiscFlags;
} D3D10_TEXTURE3D_DESC;
struct CD3D10_TEXTURE3D_DESC : public D3D10_TEXTURE3D_DESC {
    CD3D10_TEXTURE3D_DESC() = default;
    explicit CD3D10_TEXTURE3D_DESC(const D3D10_TEXTURE3D_DESC& o)
        : D3D10_TEXTURE3D_DESC(o)
    {
    }
    explicit CD3D10_TEXTURE3D_DESC(
        DXGI_FORMAT format,
        UINT width,
        UINT height,
        UINT depth,
        UINT mipLevels = 0,
        UINT bindFlags = D3D10_BIND_SHADER_RESOURCE,
        D3D10_USAGE usage = D3D10_USAGE_DEFAULT,
        UINT cpuaccessFlags = 0,
        UINT miscFlags = 0)
    {
        Width = width;
        Height = height;
        Depth = depth;
        MipLevels = mipLevels;
        Format = format;
        Usage = usage;
        BindFlags = bindFlags;
        CPUAccessFlags = cpuaccessFlags;
        MiscFlags = miscFlags;
    }
    ~CD3D10_TEXTURE3D_DESC() { }
};
typedef struct D3D10_MAPPED_TEXTURE3D {
    void* pData;
    UINT RowPitch;
    UINT DepthPitch;
} D3D10_MAPPED_TEXTURE3D;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0008_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Texture3D;
struct __declspec(uuid("9B7E4C05-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Texture3D : public ID3D10Resource {
public:
    virtual HRESULT __stdcall Map(
        UINT Subresource,
        D3D10_MAP MapType,
        UINT MapFlags,
        D3D10_MAPPED_TEXTURE3D* pMappedTex3D)
        = 0;
    virtual void __stdcall Unmap(
        UINT Subresource)
        = 0;
    virtual void __stdcall GetDesc(
        D3D10_TEXTURE3D_DESC* pDesc)
        = 0;
};
typedef enum D3D10_TEXTURECUBE_FACE {
    D3D10_TEXTURECUBE_FACE_POSITIVE_X = 0,
    D3D10_TEXTURECUBE_FACE_NEGATIVE_X = 1,
    D3D10_TEXTURECUBE_FACE_POSITIVE_Y = 2,
    D3D10_TEXTURECUBE_FACE_NEGATIVE_Y = 3,
    D3D10_TEXTURECUBE_FACE_POSITIVE_Z = 4,
    D3D10_TEXTURECUBE_FACE_NEGATIVE_Z = 5
} D3D10_TEXTURECUBE_FACE;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0009_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10View;
struct __declspec(uuid("C902B03F-60A7-49BA-9936-2A3AB37A7E33")) __declspec(novtable)
    ID3D10View : public ID3D10DeviceChild {
public:
    virtual void __stdcall GetResource(
        ID3D10Resource** ppResource)
        = 0;
};
typedef struct D3D10_BUFFER_SRV {
    union {
        UINT FirstElement;
        UINT ElementOffset;
    };
    union {
        UINT NumElements;
        UINT ElementWidth;
    };
} D3D10_BUFFER_SRV;
typedef struct D3D10_TEX1D_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D10_TEX1D_SRV;
typedef struct D3D10_TEX1D_ARRAY_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX1D_ARRAY_SRV;
typedef struct D3D10_TEX2D_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D10_TEX2D_SRV;
typedef struct D3D10_TEX2D_ARRAY_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX2D_ARRAY_SRV;
typedef struct D3D10_TEX3D_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D10_TEX3D_SRV;
typedef struct D3D10_TEXCUBE_SRV {
    UINT MostDetailedMip;
    UINT MipLevels;
} D3D10_TEXCUBE_SRV;
typedef struct D3D10_TEX2DMS_SRV {
    UINT UnusedField_NothingToDefine;
} D3D10_TEX2DMS_SRV;
typedef struct D3D10_TEX2DMS_ARRAY_SRV {
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX2DMS_ARRAY_SRV;
typedef struct D3D10_SHADER_RESOURCE_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D10_SRV_DIMENSION ViewDimension;
    union {
        D3D10_BUFFER_SRV Buffer;
        D3D10_TEX1D_SRV Texture1D;
        D3D10_TEX1D_ARRAY_SRV Texture1DArray;
        D3D10_TEX2D_SRV Texture2D;
        D3D10_TEX2D_ARRAY_SRV Texture2DArray;
        D3D10_TEX2DMS_SRV Texture2DMS;
        D3D10_TEX2DMS_ARRAY_SRV Texture2DMSArray;
        D3D10_TEX3D_SRV Texture3D;
        D3D10_TEXCUBE_SRV TextureCube;
    };
} D3D10_SHADER_RESOURCE_VIEW_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0010_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10ShaderResourceView;
struct __declspec(uuid("9B7E4C07-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10ShaderResourceView : public ID3D10View {
public:
    virtual void __stdcall GetDesc(
        D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc)
        = 0;
};
typedef struct D3D10_BUFFER_RTV {
    union {
        UINT FirstElement;
        UINT ElementOffset;
    };
    union {
        UINT NumElements;
        UINT ElementWidth;
    };
} D3D10_BUFFER_RTV;
typedef struct D3D10_TEX1D_RTV {
    UINT MipSlice;
} D3D10_TEX1D_RTV;
typedef struct D3D10_TEX1D_ARRAY_RTV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX1D_ARRAY_RTV;
typedef struct D3D10_TEX2D_RTV {
    UINT MipSlice;
} D3D10_TEX2D_RTV;
typedef struct D3D10_TEX2DMS_RTV {
    UINT UnusedField_NothingToDefine;
} D3D10_TEX2DMS_RTV;
typedef struct D3D10_TEX2D_ARRAY_RTV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX2D_ARRAY_RTV;
typedef struct D3D10_TEX2DMS_ARRAY_RTV {
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX2DMS_ARRAY_RTV;
typedef struct D3D10_TEX3D_RTV {
    UINT MipSlice;
    UINT FirstWSlice;
    UINT WSize;
} D3D10_TEX3D_RTV;
typedef struct D3D10_RENDER_TARGET_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D10_RTV_DIMENSION ViewDimension;
    union {
        D3D10_BUFFER_RTV Buffer;
        D3D10_TEX1D_RTV Texture1D;
        D3D10_TEX1D_ARRAY_RTV Texture1DArray;
        D3D10_TEX2D_RTV Texture2D;
        D3D10_TEX2D_ARRAY_RTV Texture2DArray;
        D3D10_TEX2DMS_RTV Texture2DMS;
        D3D10_TEX2DMS_ARRAY_RTV Texture2DMSArray;
        D3D10_TEX3D_RTV Texture3D;
    };
} D3D10_RENDER_TARGET_VIEW_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0011_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10RenderTargetView;
struct __declspec(uuid("9B7E4C08-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10RenderTargetView : public ID3D10View {
public:
    virtual void __stdcall GetDesc(
        D3D10_RENDER_TARGET_VIEW_DESC* pDesc)
        = 0;
};
typedef struct D3D10_TEX1D_DSV {
    UINT MipSlice;
} D3D10_TEX1D_DSV;
typedef struct D3D10_TEX1D_ARRAY_DSV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX1D_ARRAY_DSV;
typedef struct D3D10_TEX2D_DSV {
    UINT MipSlice;
} D3D10_TEX2D_DSV;
typedef struct D3D10_TEX2D_ARRAY_DSV {
    UINT MipSlice;
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX2D_ARRAY_DSV;
typedef struct D3D10_TEX2DMS_DSV {
    UINT UnusedField_NothingToDefine;
} D3D10_TEX2DMS_DSV;
typedef struct D3D10_TEX2DMS_ARRAY_DSV {
    UINT FirstArraySlice;
    UINT ArraySize;
} D3D10_TEX2DMS_ARRAY_DSV;
typedef struct D3D10_DEPTH_STENCIL_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D10_DSV_DIMENSION ViewDimension;
    union {
        D3D10_TEX1D_DSV Texture1D;
        D3D10_TEX1D_ARRAY_DSV Texture1DArray;
        D3D10_TEX2D_DSV Texture2D;
        D3D10_TEX2D_ARRAY_DSV Texture2DArray;
        D3D10_TEX2DMS_DSV Texture2DMS;
        D3D10_TEX2DMS_ARRAY_DSV Texture2DMSArray;
    };
} D3D10_DEPTH_STENCIL_VIEW_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0012_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10DepthStencilView;
struct __declspec(uuid("9B7E4C09-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10DepthStencilView : public ID3D10View {
public:
    virtual void __stdcall GetDesc(
        D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc)
        = 0;
};
extern "C" const IID IID_ID3D10VertexShader;
struct __declspec(uuid("9B7E4C0A-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10VertexShader : public ID3D10DeviceChild {
public:
};
extern "C" const IID IID_ID3D10GeometryShader;
struct __declspec(uuid("6316BE88-54CD-4040-AB44-20461BC81F68")) __declspec(novtable)
    ID3D10GeometryShader : public ID3D10DeviceChild {
public:
};
extern "C" const IID IID_ID3D10PixelShader;
struct __declspec(uuid("4968B601-9D00-4cde-8346-8E7F675819B6")) __declspec(novtable)
    ID3D10PixelShader : public ID3D10DeviceChild {
public:
};
extern "C" const IID IID_ID3D10InputLayout;
struct __declspec(uuid("9B7E4C0B-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10InputLayout : public ID3D10DeviceChild {
public:
};
typedef enum D3D10_FILTER {
    D3D10_FILTER_MIN_MAG_MIP_POINT = 0,
    D3D10_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x1,
    D3D10_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,
    D3D10_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x5,
    D3D10_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10,
    D3D10_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    D3D10_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14,
    D3D10_FILTER_MIN_MAG_MIP_LINEAR = 0x15,
    D3D10_FILTER_ANISOTROPIC = 0x55,
    D3D10_FILTER_COMPARISON_MIN_MAG_MIP_POINT = 0x80,
    D3D10_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
    D3D10_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
    D3D10_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
    D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
    D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,
    D3D10_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
    D3D10_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
    D3D10_FILTER_COMPARISON_ANISOTROPIC = 0xd5,
    D3D10_FILTER_TEXT_1BIT = 0x80000000
} D3D10_FILTER;
typedef enum D3D10_FILTER_TYPE {
    D3D10_FILTER_TYPE_POINT = 0,
    D3D10_FILTER_TYPE_LINEAR = 1
} D3D10_FILTER_TYPE;
typedef enum D3D10_TEXTURE_ADDRESS_MODE {
    D3D10_TEXTURE_ADDRESS_WRAP = 1,
    D3D10_TEXTURE_ADDRESS_MIRROR = 2,
    D3D10_TEXTURE_ADDRESS_CLAMP = 3,
    D3D10_TEXTURE_ADDRESS_BORDER = 4,
    D3D10_TEXTURE_ADDRESS_MIRROR_ONCE = 5
} D3D10_TEXTURE_ADDRESS_MODE;
typedef struct D3D10_SAMPLER_DESC {
    D3D10_FILTER Filter;
    D3D10_TEXTURE_ADDRESS_MODE AddressU;
    D3D10_TEXTURE_ADDRESS_MODE AddressV;
    D3D10_TEXTURE_ADDRESS_MODE AddressW;
    FLOAT MipLODBias;
    UINT MaxAnisotropy;
    D3D10_COMPARISON_FUNC ComparisonFunc;
    FLOAT BorderColor[4];
    FLOAT MinLOD;
    FLOAT MaxLOD;
} D3D10_SAMPLER_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0017_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10SamplerState;
struct __declspec(uuid("9B7E4C0C-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10SamplerState : public ID3D10DeviceChild {
public:
    virtual void __stdcall GetDesc(
        D3D10_SAMPLER_DESC* pDesc)
        = 0;
};
typedef enum D3D10_FORMAT_SUPPORT {
    D3D10_FORMAT_SUPPORT_BUFFER = 0x1,
    D3D10_FORMAT_SUPPORT_IA_VERTEX_BUFFER = 0x2,
    D3D10_FORMAT_SUPPORT_IA_INDEX_BUFFER = 0x4,
    D3D10_FORMAT_SUPPORT_SO_BUFFER = 0x8,
    D3D10_FORMAT_SUPPORT_TEXTURE1D = 0x10,
    D3D10_FORMAT_SUPPORT_TEXTURE2D = 0x20,
    D3D10_FORMAT_SUPPORT_TEXTURE3D = 0x40,
    D3D10_FORMAT_SUPPORT_TEXTURECUBE = 0x80,
    D3D10_FORMAT_SUPPORT_SHADER_LOAD = 0x100,
    D3D10_FORMAT_SUPPORT_SHADER_SAMPLE = 0x200,
    D3D10_FORMAT_SUPPORT_SHADER_SAMPLE_COMPARISON = 0x400,
    D3D10_FORMAT_SUPPORT_SHADER_SAMPLE_MONO_TEXT = 0x800,
    D3D10_FORMAT_SUPPORT_MIP = 0x1000,
    D3D10_FORMAT_SUPPORT_MIP_AUTOGEN = 0x2000,
    D3D10_FORMAT_SUPPORT_RENDER_TARGET = 0x4000,
    D3D10_FORMAT_SUPPORT_BLENDABLE = 0x8000,
    D3D10_FORMAT_SUPPORT_DEPTH_STENCIL = 0x10000,
    D3D10_FORMAT_SUPPORT_CPU_LOCKABLE = 0x20000,
    D3D10_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE = 0x40000,
    D3D10_FORMAT_SUPPORT_DISPLAY = 0x80000,
    D3D10_FORMAT_SUPPORT_CAST_WITHIN_BIT_LAYOUT = 0x100000,
    D3D10_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET = 0x200000,
    D3D10_FORMAT_SUPPORT_MULTISAMPLE_LOAD = 0x400000,
    D3D10_FORMAT_SUPPORT_SHADER_GATHER = 0x800000,
    D3D10_FORMAT_SUPPORT_BACK_BUFFER_CAST = 0x1000000
} D3D10_FORMAT_SUPPORT;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0018_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Asynchronous;
struct __declspec(uuid("9B7E4C0D-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Asynchronous : public ID3D10DeviceChild {
public:
    virtual void __stdcall Begin(void) = 0;
    virtual void __stdcall End(void) = 0;
    virtual HRESULT __stdcall GetData(
        void* pData,
        UINT DataSize,
        UINT GetDataFlags)
        = 0;
    virtual UINT __stdcall GetDataSize(void) = 0;
};
typedef enum D3D10_ASYNC_GETDATA_FLAG {
    D3D10_ASYNC_GETDATA_DONOTFLUSH = 0x1
} D3D10_ASYNC_GETDATA_FLAG;
typedef enum D3D10_QUERY {
    D3D10_QUERY_EVENT = 0,
    D3D10_QUERY_OCCLUSION = (D3D10_QUERY_EVENT + 1),
    D3D10_QUERY_TIMESTAMP = (D3D10_QUERY_OCCLUSION + 1),
    D3D10_QUERY_TIMESTAMP_DISJOINT = (D3D10_QUERY_TIMESTAMP + 1),
    D3D10_QUERY_PIPELINE_STATISTICS = (D3D10_QUERY_TIMESTAMP_DISJOINT + 1),
    D3D10_QUERY_OCCLUSION_PREDICATE = (D3D10_QUERY_PIPELINE_STATISTICS + 1),
    D3D10_QUERY_SO_STATISTICS = (D3D10_QUERY_OCCLUSION_PREDICATE + 1),
    D3D10_QUERY_SO_OVERFLOW_PREDICATE = (D3D10_QUERY_SO_STATISTICS + 1)
} D3D10_QUERY;
typedef enum D3D10_QUERY_MISC_FLAG {
    D3D10_QUERY_MISC_PREDICATEHINT = 0x1
} D3D10_QUERY_MISC_FLAG;
typedef struct D3D10_QUERY_DESC {
    D3D10_QUERY Query;
    UINT MiscFlags;
} D3D10_QUERY_DESC;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0019_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Query;
struct __declspec(uuid("9B7E4C0E-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Query : public ID3D10Asynchronous {
public:
    virtual void __stdcall GetDesc(
        D3D10_QUERY_DESC* pDesc)
        = 0;
};
extern "C" const IID IID_ID3D10Predicate;
struct __declspec(uuid("9B7E4C10-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Predicate : public ID3D10Query {
public:
};
typedef struct D3D10_QUERY_DATA_TIMESTAMP_DISJOINT {
    UINT64 Frequency;
    BOOL Disjoint;
} D3D10_QUERY_DATA_TIMESTAMP_DISJOINT;
typedef struct D3D10_QUERY_DATA_PIPELINE_STATISTICS {
    UINT64 IAVertices;
    UINT64 IAPrimitives;
    UINT64 VSInvocations;
    UINT64 GSInvocations;
    UINT64 GSPrimitives;
    UINT64 CInvocations;
    UINT64 CPrimitives;
    UINT64 PSInvocations;
} D3D10_QUERY_DATA_PIPELINE_STATISTICS;
typedef struct D3D10_QUERY_DATA_SO_STATISTICS {
    UINT64 NumPrimitivesWritten;
    UINT64 PrimitivesStorageNeeded;
} D3D10_QUERY_DATA_SO_STATISTICS;
typedef enum D3D10_COUNTER {
    D3D10_COUNTER_GPU_IDLE = 0,
    D3D10_COUNTER_VERTEX_PROCESSING = (D3D10_COUNTER_GPU_IDLE + 1),
    D3D10_COUNTER_GEOMETRY_PROCESSING = (D3D10_COUNTER_VERTEX_PROCESSING + 1),
    D3D10_COUNTER_PIXEL_PROCESSING = (D3D10_COUNTER_GEOMETRY_PROCESSING + 1),
    D3D10_COUNTER_OTHER_GPU_PROCESSING = (D3D10_COUNTER_PIXEL_PROCESSING + 1),
    D3D10_COUNTER_HOST_ADAPTER_BANDWIDTH_UTILIZATION = (D3D10_COUNTER_OTHER_GPU_PROCESSING + 1),
    D3D10_COUNTER_LOCAL_VIDMEM_BANDWIDTH_UTILIZATION = (D3D10_COUNTER_HOST_ADAPTER_BANDWIDTH_UTILIZATION + 1),
    D3D10_COUNTER_VERTEX_THROUGHPUT_UTILIZATION = (D3D10_COUNTER_LOCAL_VIDMEM_BANDWIDTH_UTILIZATION + 1),
    D3D10_COUNTER_TRIANGLE_SETUP_THROUGHPUT_UTILIZATION = (D3D10_COUNTER_VERTEX_THROUGHPUT_UTILIZATION + 1),
    D3D10_COUNTER_FILLRATE_THROUGHPUT_UTILIZATION = (D3D10_COUNTER_TRIANGLE_SETUP_THROUGHPUT_UTILIZATION + 1),
    D3D10_COUNTER_VS_MEMORY_LIMITED = (D3D10_COUNTER_FILLRATE_THROUGHPUT_UTILIZATION + 1),
    D3D10_COUNTER_VS_COMPUTATION_LIMITED = (D3D10_COUNTER_VS_MEMORY_LIMITED + 1),
    D3D10_COUNTER_GS_MEMORY_LIMITED = (D3D10_COUNTER_VS_COMPUTATION_LIMITED + 1),
    D3D10_COUNTER_GS_COMPUTATION_LIMITED = (D3D10_COUNTER_GS_MEMORY_LIMITED + 1),
    D3D10_COUNTER_PS_MEMORY_LIMITED = (D3D10_COUNTER_GS_COMPUTATION_LIMITED + 1),
    D3D10_COUNTER_PS_COMPUTATION_LIMITED = (D3D10_COUNTER_PS_MEMORY_LIMITED + 1),
    D3D10_COUNTER_POST_TRANSFORM_CACHE_HIT_RATE = (D3D10_COUNTER_PS_COMPUTATION_LIMITED + 1),
    D3D10_COUNTER_TEXTURE_CACHE_HIT_RATE = (D3D10_COUNTER_POST_TRANSFORM_CACHE_HIT_RATE + 1),
    D3D10_COUNTER_DEVICE_DEPENDENT_0 = 0x40000000
} D3D10_COUNTER;
typedef enum D3D10_COUNTER_TYPE {
    D3D10_COUNTER_TYPE_FLOAT32 = 0,
    D3D10_COUNTER_TYPE_UINT16 = (D3D10_COUNTER_TYPE_FLOAT32 + 1),
    D3D10_COUNTER_TYPE_UINT32 = (D3D10_COUNTER_TYPE_UINT16 + 1),
    D3D10_COUNTER_TYPE_UINT64 = (D3D10_COUNTER_TYPE_UINT32 + 1)
} D3D10_COUNTER_TYPE;
typedef struct D3D10_COUNTER_DESC {
    D3D10_COUNTER Counter;
    UINT MiscFlags;
} D3D10_COUNTER_DESC;
typedef struct D3D10_COUNTER_INFO {
    D3D10_COUNTER LastDeviceDependentCounter;
    UINT NumSimultaneousCounters;
    UINT8 NumDetectableParallelUnits;
} D3D10_COUNTER_INFO;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0021_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Counter;
struct __declspec(uuid("9B7E4C11-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Counter : public ID3D10Asynchronous {
public:
    virtual void __stdcall GetDesc(
        D3D10_COUNTER_DESC* pDesc)
        = 0;
};
extern "C" const IID IID_ID3D10Device;
struct __declspec(uuid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Device : public IUnknown {
public:
    virtual void __stdcall VSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall PSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D10ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall PSSetShader(
        ID3D10PixelShader* pPixelShader)
        = 0;
    virtual void __stdcall PSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D10SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall VSSetShader(
        ID3D10VertexShader* pVertexShader)
        = 0;
    virtual void __stdcall DrawIndexed(
        UINT IndexCount,
        UINT StartIndexLocation,
        INT BaseVertexLocation)
        = 0;
    virtual void __stdcall Draw(
        UINT VertexCount,
        UINT StartVertexLocation)
        = 0;
    virtual void __stdcall PSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall IASetInputLayout(
        ID3D10InputLayout* pInputLayout)
        = 0;
    virtual void __stdcall IASetVertexBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer* const* ppVertexBuffers,
        const UINT* pStrides,
        const UINT* pOffsets)
        = 0;
    virtual void __stdcall IASetIndexBuffer(
        ID3D10Buffer* pIndexBuffer,
        DXGI_FORMAT Format,
        UINT Offset)
        = 0;
    virtual void __stdcall DrawIndexedInstanced(
        UINT IndexCountPerInstance,
        UINT InstanceCount,
        UINT StartIndexLocation,
        INT BaseVertexLocation,
        UINT StartInstanceLocation)
        = 0;
    virtual void __stdcall DrawInstanced(
        UINT VertexCountPerInstance,
        UINT InstanceCount,
        UINT StartVertexLocation,
        UINT StartInstanceLocation)
        = 0;
    virtual void __stdcall GSSetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer* const* ppConstantBuffers)
        = 0;
    virtual void __stdcall GSSetShader(
        ID3D10GeometryShader* pShader)
        = 0;
    virtual void __stdcall IASetPrimitiveTopology(
        D3D10_PRIMITIVE_TOPOLOGY Topology)
        = 0;
    virtual void __stdcall VSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D10ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall VSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D10SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall SetPredication(
        ID3D10Predicate* pPredicate,
        BOOL PredicateValue)
        = 0;
    virtual void __stdcall GSSetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D10ShaderResourceView* const* ppShaderResourceViews)
        = 0;
    virtual void __stdcall GSSetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D10SamplerState* const* ppSamplers)
        = 0;
    virtual void __stdcall OMSetRenderTargets(
        UINT NumViews,
        ID3D10RenderTargetView* const* ppRenderTargetViews,
        ID3D10DepthStencilView* pDepthStencilView)
        = 0;
    virtual void __stdcall OMSetBlendState(
        ID3D10BlendState* pBlendState,
        const FLOAT BlendFactor[4],
        UINT SampleMask)
        = 0;
    virtual void __stdcall OMSetDepthStencilState(
        ID3D10DepthStencilState* pDepthStencilState,
        UINT StencilRef)
        = 0;
    virtual void __stdcall SOSetTargets(
        UINT NumBuffers,
        ID3D10Buffer* const* ppSOTargets,
        const UINT* pOffsets)
        = 0;
    virtual void __stdcall DrawAuto(void) = 0;
    virtual void __stdcall RSSetState(
        ID3D10RasterizerState* pRasterizerState)
        = 0;
    virtual void __stdcall RSSetViewports(
        UINT NumViewports,
        const D3D10_VIEWPORT* pViewports)
        = 0;
    virtual void __stdcall RSSetScissorRects(
        UINT NumRects,
        const D3D10_RECT* pRects)
        = 0;
    virtual void __stdcall CopySubresourceRegion(
        ID3D10Resource* pDstResource,
        UINT DstSubresource,
        UINT DstX,
        UINT DstY,
        UINT DstZ,
        ID3D10Resource* pSrcResource,
        UINT SrcSubresource,
        const D3D10_BOX* pSrcBox)
        = 0;
    virtual void __stdcall CopyResource(
        ID3D10Resource* pDstResource,
        ID3D10Resource* pSrcResource)
        = 0;
    virtual void __stdcall UpdateSubresource(
        ID3D10Resource* pDstResource,
        UINT DstSubresource,
        const D3D10_BOX* pDstBox,
        const void* pSrcData,
        UINT SrcRowPitch,
        UINT SrcDepthPitch)
        = 0;
    virtual void __stdcall ClearRenderTargetView(
        ID3D10RenderTargetView* pRenderTargetView,
        const FLOAT ColorRGBA[4])
        = 0;
    virtual void __stdcall ClearDepthStencilView(
        ID3D10DepthStencilView* pDepthStencilView,
        UINT ClearFlags,
        FLOAT Depth,
        UINT8 Stencil)
        = 0;
    virtual void __stdcall GenerateMips(
        ID3D10ShaderResourceView* pShaderResourceView)
        = 0;
    virtual void __stdcall ResolveSubresource(
        ID3D10Resource* pDstResource,
        UINT DstSubresource,
        ID3D10Resource* pSrcResource,
        UINT SrcSubresource,
        DXGI_FORMAT Format)
        = 0;
    virtual void __stdcall VSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall PSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D10ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall PSGetShader(
        ID3D10PixelShader** ppPixelShader)
        = 0;
    virtual void __stdcall PSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D10SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall VSGetShader(
        ID3D10VertexShader** ppVertexShader)
        = 0;
    virtual void __stdcall PSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall IAGetInputLayout(
        ID3D10InputLayout** ppInputLayout)
        = 0;
    virtual void __stdcall IAGetVertexBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer** ppVertexBuffers,
        UINT* pStrides,
        UINT* pOffsets)
        = 0;
    virtual void __stdcall IAGetIndexBuffer(
        ID3D10Buffer** pIndexBuffer,
        DXGI_FORMAT* Format,
        UINT* Offset)
        = 0;
    virtual void __stdcall GSGetConstantBuffers(
        UINT StartSlot,
        UINT NumBuffers,
        ID3D10Buffer** ppConstantBuffers)
        = 0;
    virtual void __stdcall GSGetShader(
        ID3D10GeometryShader** ppGeometryShader)
        = 0;
    virtual void __stdcall IAGetPrimitiveTopology(
        D3D10_PRIMITIVE_TOPOLOGY* pTopology)
        = 0;
    virtual void __stdcall VSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D10ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall VSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D10SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall GetPredication(
        ID3D10Predicate** ppPredicate,
        BOOL* pPredicateValue)
        = 0;
    virtual void __stdcall GSGetShaderResources(
        UINT StartSlot,
        UINT NumViews,
        ID3D10ShaderResourceView** ppShaderResourceViews)
        = 0;
    virtual void __stdcall GSGetSamplers(
        UINT StartSlot,
        UINT NumSamplers,
        ID3D10SamplerState** ppSamplers)
        = 0;
    virtual void __stdcall OMGetRenderTargets(
        UINT NumViews,
        ID3D10RenderTargetView** ppRenderTargetViews,
        ID3D10DepthStencilView** ppDepthStencilView)
        = 0;
    virtual void __stdcall OMGetBlendState(
        ID3D10BlendState** ppBlendState,
        FLOAT BlendFactor[4],
        UINT* pSampleMask)
        = 0;
    virtual void __stdcall OMGetDepthStencilState(
        ID3D10DepthStencilState** ppDepthStencilState,
        UINT* pStencilRef)
        = 0;
    virtual void __stdcall SOGetTargets(
        UINT NumBuffers,
        ID3D10Buffer** ppSOTargets,
        UINT* pOffsets)
        = 0;
    virtual void __stdcall RSGetState(
        ID3D10RasterizerState** ppRasterizerState)
        = 0;
    virtual void __stdcall RSGetViewports(
        UINT* NumViewports,
        D3D10_VIEWPORT* pViewports)
        = 0;
    virtual void __stdcall RSGetScissorRects(
        UINT* NumRects,
        D3D10_RECT* pRects)
        = 0;
    virtual HRESULT __stdcall GetDeviceRemovedReason(void) = 0;
    virtual HRESULT __stdcall SetExceptionMode(
        UINT RaiseFlags)
        = 0;
    virtual UINT __stdcall GetExceptionMode(void) = 0;
    virtual HRESULT __stdcall GetPrivateData(
        const GUID& guid,
        UINT* pDataSize,
        void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateData(
        const GUID& guid,
        UINT DataSize,
        const void* pData)
        = 0;
    virtual HRESULT __stdcall SetPrivateDataInterface(
        const GUID& guid,
        const IUnknown* pData)
        = 0;
    virtual void __stdcall ClearState(void) = 0;
    virtual void __stdcall Flush(void) = 0;
    virtual HRESULT __stdcall CreateBuffer(
        const D3D10_BUFFER_DESC* pDesc,
        const D3D10_SUBRESOURCE_DATA* pInitialData,
        ID3D10Buffer** ppBuffer)
        = 0;
    virtual HRESULT __stdcall CreateTexture1D(
        const D3D10_TEXTURE1D_DESC* pDesc,
        const D3D10_SUBRESOURCE_DATA* pInitialData,
        ID3D10Texture1D** ppTexture1D)
        = 0;
    virtual HRESULT __stdcall CreateTexture2D(
        const D3D10_TEXTURE2D_DESC* pDesc,
        const D3D10_SUBRESOURCE_DATA* pInitialData,
        ID3D10Texture2D** ppTexture2D)
        = 0;
    virtual HRESULT __stdcall CreateTexture3D(
        const D3D10_TEXTURE3D_DESC* pDesc,
        const D3D10_SUBRESOURCE_DATA* pInitialData,
        ID3D10Texture3D** ppTexture3D)
        = 0;
    virtual HRESULT __stdcall CreateShaderResourceView(
        ID3D10Resource* pResource,
        const D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc,
        ID3D10ShaderResourceView** ppSRView)
        = 0;
    virtual HRESULT __stdcall CreateRenderTargetView(
        ID3D10Resource* pResource,
        const D3D10_RENDER_TARGET_VIEW_DESC* pDesc,
        ID3D10RenderTargetView** ppRTView)
        = 0;
    virtual HRESULT __stdcall CreateDepthStencilView(
        ID3D10Resource* pResource,
        const D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc,
        ID3D10DepthStencilView** ppDepthStencilView)
        = 0;
    virtual HRESULT __stdcall CreateInputLayout(
        const D3D10_INPUT_ELEMENT_DESC* pInputElementDescs,
        UINT NumElements,
        const void* pShaderBytecodeWithInputSignature,
        SIZE_T BytecodeLength,
        ID3D10InputLayout** ppInputLayout)
        = 0;
    virtual HRESULT __stdcall CreateVertexShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D10VertexShader** ppVertexShader)
        = 0;
    virtual HRESULT __stdcall CreateGeometryShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D10GeometryShader** ppGeometryShader)
        = 0;
    virtual HRESULT __stdcall CreateGeometryShaderWithStreamOutput(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        const D3D10_SO_DECLARATION_ENTRY* pSODeclaration,
        UINT NumEntries,
        UINT OutputStreamStride,
        ID3D10GeometryShader** ppGeometryShader)
        = 0;
    virtual HRESULT __stdcall CreatePixelShader(
        const void* pShaderBytecode,
        SIZE_T BytecodeLength,
        ID3D10PixelShader** ppPixelShader)
        = 0;
    virtual HRESULT __stdcall CreateBlendState(
        const D3D10_BLEND_DESC* pBlendStateDesc,
        ID3D10BlendState** ppBlendState)
        = 0;
    virtual HRESULT __stdcall CreateDepthStencilState(
        const D3D10_DEPTH_STENCIL_DESC* pDepthStencilDesc,
        ID3D10DepthStencilState** ppDepthStencilState)
        = 0;
    virtual HRESULT __stdcall CreateRasterizerState(
        const D3D10_RASTERIZER_DESC* pRasterizerDesc,
        ID3D10RasterizerState** ppRasterizerState)
        = 0;
    virtual HRESULT __stdcall CreateSamplerState(
        const D3D10_SAMPLER_DESC* pSamplerDesc,
        ID3D10SamplerState** ppSamplerState)
        = 0;
    virtual HRESULT __stdcall CreateQuery(
        const D3D10_QUERY_DESC* pQueryDesc,
        ID3D10Query** ppQuery)
        = 0;
    virtual HRESULT __stdcall CreatePredicate(
        const D3D10_QUERY_DESC* pPredicateDesc,
        ID3D10Predicate** ppPredicate)
        = 0;
    virtual HRESULT __stdcall CreateCounter(
        const D3D10_COUNTER_DESC* pCounterDesc,
        ID3D10Counter** ppCounter)
        = 0;
    virtual HRESULT __stdcall CheckFormatSupport(
        DXGI_FORMAT Format,
        UINT* pFormatSupport)
        = 0;
    virtual HRESULT __stdcall CheckMultisampleQualityLevels(
        DXGI_FORMAT Format,
        UINT SampleCount,
        UINT* pNumQualityLevels)
        = 0;
    virtual void __stdcall CheckCounterInfo(
        D3D10_COUNTER_INFO* pCounterInfo)
        = 0;
    virtual HRESULT __stdcall CheckCounter(
        const D3D10_COUNTER_DESC* pDesc,
        D3D10_COUNTER_TYPE* pType,
        UINT* pActiveCounters,
        LPSTR szName,
        UINT* pNameLength,
        LPSTR szUnits,
        UINT* pUnitsLength,
        LPSTR szDescription,
        UINT* pDescriptionLength)
        = 0;
    virtual UINT __stdcall GetCreationFlags(void) = 0;
    virtual HRESULT __stdcall OpenSharedResource(
        HANDLE hResource,
        const IID& ReturnedInterface,
        void** ppResource)
        = 0;
    virtual void __stdcall SetTextFilterSize(
        UINT Width,
        UINT Height)
        = 0;
    virtual void __stdcall GetTextFilterSize(
        UINT* pWidth,
        UINT* pHeight)
        = 0;
};
#pragma endregion
#pragma region Application Family
#pragma region Application Family
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0023_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Multithread;
struct __declspec(uuid("9B7E4E00-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Multithread : public IUnknown {
public:
    virtual void __stdcall Enter(void) = 0;
    virtual void __stdcall Leave(void) = 0;
    virtual BOOL __stdcall SetMultithreadProtected(
        BOOL bMTProtect)
        = 0;
    virtual BOOL __stdcall GetMultithreadProtected(void) = 0;
};
#pragma endregion
#pragma endregion
#pragma region Desktop Family
typedef enum D3D10_CREATE_DEVICE_FLAG {
    D3D10_CREATE_DEVICE_SINGLETHREADED = 0x1,
    D3D10_CREATE_DEVICE_DEBUG = 0x2,
    D3D10_CREATE_DEVICE_SWITCH_TO_REF = 0x4,
    D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS = 0x8,
    D3D10_CREATE_DEVICE_ALLOW_NULL_FROM_MAP = 0x10,
    D3D10_CREATE_DEVICE_BGRA_SUPPORT = 0x20,
    D3D10_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY = 0x80,
    D3D10_CREATE_DEVICE_STRICT_VALIDATION = 0x200,
    D3D10_CREATE_DEVICE_DEBUGGABLE = 0x400
} D3D10_CREATE_DEVICE_FLAG;
#pragma once
typedef struct ID3D10Debug ID3D10Debug;
typedef struct ID3D10SwitchToRef ID3D10SwitchToRef;
typedef struct ID3D10InfoQueue ID3D10InfoQueue;
extern "C" {
#pragma region Desktop Family
extern RPC_IF_HANDLE __MIDL_itf_d3d10sdklayers_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10sdklayers_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Debug;
struct __declspec(uuid("9B7E4E01-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Debug : public IUnknown {
public:
    virtual HRESULT __stdcall SetFeatureMask(
        UINT Mask)
        = 0;
    virtual UINT __stdcall GetFeatureMask(void) = 0;
    virtual HRESULT __stdcall SetPresentPerRenderOpDelay(
        UINT Milliseconds)
        = 0;
    virtual UINT __stdcall GetPresentPerRenderOpDelay(void) = 0;
    virtual HRESULT __stdcall SetSwapChain(
        IDXGISwapChain* pSwapChain)
        = 0;
    virtual HRESULT __stdcall GetSwapChain(
        IDXGISwapChain** ppSwapChain)
        = 0;
    virtual HRESULT __stdcall Validate(void) = 0;
};
extern "C" const IID IID_ID3D10SwitchToRef;
struct __declspec(uuid("9B7E4E02-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10SwitchToRef : public IUnknown {
public:
    virtual BOOL __stdcall SetUseRef(
        BOOL UseRef)
        = 0;
    virtual BOOL __stdcall GetUseRef(void) = 0;
};
extern "C" const GUID DXGI_DEBUG_D3D10;
typedef enum D3D10_MESSAGE_CATEGORY {
    D3D10_MESSAGE_CATEGORY_APPLICATION_DEFINED = 0,
    D3D10_MESSAGE_CATEGORY_MISCELLANEOUS = (D3D10_MESSAGE_CATEGORY_APPLICATION_DEFINED + 1),
    D3D10_MESSAGE_CATEGORY_INITIALIZATION = (D3D10_MESSAGE_CATEGORY_MISCELLANEOUS + 1),
    D3D10_MESSAGE_CATEGORY_CLEANUP = (D3D10_MESSAGE_CATEGORY_INITIALIZATION + 1),
    D3D10_MESSAGE_CATEGORY_COMPILATION = (D3D10_MESSAGE_CATEGORY_CLEANUP + 1),
    D3D10_MESSAGE_CATEGORY_STATE_CREATION = (D3D10_MESSAGE_CATEGORY_COMPILATION + 1),
    D3D10_MESSAGE_CATEGORY_STATE_SETTING = (D3D10_MESSAGE_CATEGORY_STATE_CREATION + 1),
    D3D10_MESSAGE_CATEGORY_STATE_GETTING = (D3D10_MESSAGE_CATEGORY_STATE_SETTING + 1),
    D3D10_MESSAGE_CATEGORY_RESOURCE_MANIPULATION = (D3D10_MESSAGE_CATEGORY_STATE_GETTING + 1),
    D3D10_MESSAGE_CATEGORY_EXECUTION = (D3D10_MESSAGE_CATEGORY_RESOURCE_MANIPULATION + 1),
    D3D10_MESSAGE_CATEGORY_SHADER = (D3D10_MESSAGE_CATEGORY_EXECUTION + 1)
} D3D10_MESSAGE_CATEGORY;
typedef enum D3D10_MESSAGE_SEVERITY {
    D3D10_MESSAGE_SEVERITY_CORRUPTION = 0,
    D3D10_MESSAGE_SEVERITY_ERROR = (D3D10_MESSAGE_SEVERITY_CORRUPTION + 1),
    D3D10_MESSAGE_SEVERITY_WARNING = (D3D10_MESSAGE_SEVERITY_ERROR + 1),
    D3D10_MESSAGE_SEVERITY_INFO = (D3D10_MESSAGE_SEVERITY_WARNING + 1),
    D3D10_MESSAGE_SEVERITY_MESSAGE = (D3D10_MESSAGE_SEVERITY_INFO + 1)
} D3D10_MESSAGE_SEVERITY;
typedef enum D3D10_MESSAGE_ID {
    D3D10_MESSAGE_ID_UNKNOWN = 0,
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD = (D3D10_MESSAGE_ID_UNKNOWN + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD = (D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD = (D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD = (D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD = (D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD = (D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD = (D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD = (D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD = (D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD + 1),
    D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD = (D3D10_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD + 1),
    D3D10_MESSAGE_ID_STRING_FROM_APPLICATION = (D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD + 1),
    D3D10_MESSAGE_ID_CORRUPTED_THIS = (D3D10_MESSAGE_ID_STRING_FROM_APPLICATION + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER1 = (D3D10_MESSAGE_ID_CORRUPTED_THIS + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER2 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER1 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER3 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER2 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER4 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER3 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER5 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER4 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER6 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER5 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER7 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER6 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER8 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER7 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER9 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER8 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER10 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER9 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER11 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER10 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER12 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER11 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER13 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER12 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER14 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER13 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER15 = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER14 + 1),
    D3D10_MESSAGE_ID_CORRUPTED_MULTITHREADING = (D3D10_MESSAGE_ID_CORRUPTED_PARAMETER15 + 1),
    D3D10_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY = (D3D10_MESSAGE_ID_CORRUPTED_MULTITHREADING + 1),
    D3D10_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT = (D3D10_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_GETPRIVATEDATA_MOREDATA = (D3D10_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT + 1),
    D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA = (D3D10_MESSAGE_ID_GETPRIVATEDATA_MOREDATA + 1),
    D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN = (D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA + 1),
    D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS = (D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN + 1),
    D3D10_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS = (D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS + 1),
    D3D10_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY = (D3D10_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES = (D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS = (D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS = (D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_NULLDESC = (D3D10_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS = (D3D10_MESSAGE_ID_CREATEBUFFER_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION = (D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT = (D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES = (D3D10_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_NULLDESC = (D3D10_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION = (D3D10_MESSAGE_ID_CREATETEXTURE1D_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT = (D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES = (D3D10_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_NULLDESC = (D3D10_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION = (D3D10_MESSAGE_ID_CREATETEXTURE2D_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT = (D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES = (D3D10_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_NULLDESC = (D3D10_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION = (D3D10_MESSAGE_ID_CREATETEXTURE3D_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT = (D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT + 1),
    D3D10_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE = (D3D10_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE = (D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY = (D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX + 1),
    D3D10_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE + 1),
    D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE = (D3D10_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY + 1),
    D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE = (D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE = (D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC + 1),
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS + 1),
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC + 1),
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS = (D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY + 1),
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG = (D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS + 1),
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC = (D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED = (D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED = (D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED + 1),
    D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER = (D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE = (D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE + 1),
    D3D10_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER = (D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID = (D3D10_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE = (D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED = (D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE + 1),
    D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED + 1),
    D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER = (D3D10_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED = (D3D10_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED + 1),
    D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER = (D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT = (D3D10_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR = (D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT + 1),
    D3D10_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH = (D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR + 1),
    D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH = (D3D10_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH + 1),
    D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID = (D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH + 1),
    D3D10_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID + 1),
    D3D10_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY = (D3D10_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY + 1),
    D3D10_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID = (D3D10_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY + 1),
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE = (D3D10_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID + 1),
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE = (D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX = (D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE + 1),
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE = (D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX + 1),
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE = (D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE + 1),
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE = (D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE = (D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE = (D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE = (D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE + 1),
    D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE = (D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE + 1),
    D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX = (D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE = (D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX + 1),
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID = (D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE + 1),
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID = (D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID + 1),
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID = (D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID + 1),
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID = (D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID + 1),
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID = (D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID + 1),
    D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE = (D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID + 1),
    D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS = (D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE + 1),
    D3D10_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED = (D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS + 1),
    D3D10_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN = (D3D10_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED + 1),
    D3D10_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED = (D3D10_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE = (D3D10_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE = (D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS = (D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED = (D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN = (D3D10_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE = (D3D10_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN + 1),
    D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED = (D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE = (D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE = (D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS = (D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED = (D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN = (D3D10_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE = (D3D10_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN + 1),
    D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED = (D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE = (D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE = (D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS = (D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED = (D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN = (D3D10_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE = (D3D10_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN + 1),
    D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED = (D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE + 1),
    D3D10_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED = (D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED + 1),
    D3D10_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED = (D3D10_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED + 1),
    D3D10_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS = (D3D10_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED + 1),
    D3D10_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS + 1),
    D3D10_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN = (D3D10_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE = (D3D10_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN + 1),
    D3D10_MESSAGE_ID_REF_THREADING_MODE = (D3D10_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE + 1),
    D3D10_MESSAGE_ID_REF_UMDRIVER_EXCEPTION = (D3D10_MESSAGE_ID_REF_THREADING_MODE + 1),
    D3D10_MESSAGE_ID_REF_KMDRIVER_EXCEPTION = (D3D10_MESSAGE_ID_REF_UMDRIVER_EXCEPTION + 1),
    D3D10_MESSAGE_ID_REF_HARDWARE_EXCEPTION = (D3D10_MESSAGE_ID_REF_KMDRIVER_EXCEPTION + 1),
    D3D10_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE = (D3D10_MESSAGE_ID_REF_HARDWARE_EXCEPTION + 1),
    D3D10_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER = (D3D10_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE + 1),
    D3D10_MESSAGE_ID_REF_OUT_OF_MEMORY = (D3D10_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER + 1),
    D3D10_MESSAGE_ID_REF_INFO = (D3D10_MESSAGE_ID_REF_OUT_OF_MEMORY + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW = (D3D10_MESSAGE_ID_REF_INFO + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW = (D3D10_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW = (D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW = (D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW = (D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW + 1),
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX = (D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND + 1),
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE = (D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX + 1),
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK = (D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE + 1),
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE = (D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK + 1),
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS = (D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL = (D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH = (D3D10_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL = (D3D10_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID = (D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL = (D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH = (D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH = (D3D10_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED = (D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY = (D3D10_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED = (D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED = (D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED = (D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED = (D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER = (D3D10_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING = (D3D10_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = (D3D10_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING + 1),
    D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT = (D3D10_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 + 1),
    D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT = (D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT + 1),
    D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT = (D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT + 1),
    D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN = (D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT + 1),
    D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN + 1),
    D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN = (D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET = (D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC = (D3D10_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET + 1),
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC + 1),
    D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH = (D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC + 1),
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW = (D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH + 1),
    D3D10_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS = (D3D10_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH = (D3D10_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH = (D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH + 1),
    D3D10_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH + 1),
    D3D10_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY = (D3D10_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY + 1),
    D3D10_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY + 1),
    D3D10_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER = (D3D10_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED = (D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER + 1),
    D3D10_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = (D3D10_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED + 1),
    D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN = (D3D10_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER + 1),
    D3D10_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN = (D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN + 1),
    D3D10_MESSAGE_ID_CREATECOUNTER_NULLDESC = (D3D10_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN + 1),
    D3D10_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER = (D3D10_MESSAGE_ID_CREATECOUNTER_NULLDESC + 1),
    D3D10_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER = (D3D10_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER + 1),
    D3D10_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE = (D3D10_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER + 1),
    D3D10_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED = (D3D10_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE + 1),
    D3D10_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION = (D3D10_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_QUERY_BEGIN_DUPLICATE = (D3D10_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION + 1),
    D3D10_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS = (D3D10_MESSAGE_ID_QUERY_BEGIN_DUPLICATE + 1),
    D3D10_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION = (D3D10_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS + 1),
    D3D10_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS = (D3D10_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION + 1),
    D3D10_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN = (D3D10_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS + 1),
    D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE = (D3D10_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN + 1),
    D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS = (D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE + 1),
    D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL = (D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH = (D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED = (D3D10_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE = (D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE = (D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT = (D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE + 1),
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT + 1),
    D3D10_MESSAGE_ID_LIVE_OBJECT_SUMMARY = (D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH + 1),
    D3D10_MESSAGE_ID_LIVE_BUFFER = (D3D10_MESSAGE_ID_LIVE_OBJECT_SUMMARY + 1),
    D3D10_MESSAGE_ID_LIVE_TEXTURE1D = (D3D10_MESSAGE_ID_LIVE_BUFFER + 1),
    D3D10_MESSAGE_ID_LIVE_TEXTURE2D = (D3D10_MESSAGE_ID_LIVE_TEXTURE1D + 1),
    D3D10_MESSAGE_ID_LIVE_TEXTURE3D = (D3D10_MESSAGE_ID_LIVE_TEXTURE2D + 1),
    D3D10_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW = (D3D10_MESSAGE_ID_LIVE_TEXTURE3D + 1),
    D3D10_MESSAGE_ID_LIVE_RENDERTARGETVIEW = (D3D10_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW + 1),
    D3D10_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW = (D3D10_MESSAGE_ID_LIVE_RENDERTARGETVIEW + 1),
    D3D10_MESSAGE_ID_LIVE_VERTEXSHADER = (D3D10_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW + 1),
    D3D10_MESSAGE_ID_LIVE_GEOMETRYSHADER = (D3D10_MESSAGE_ID_LIVE_VERTEXSHADER + 1),
    D3D10_MESSAGE_ID_LIVE_PIXELSHADER = (D3D10_MESSAGE_ID_LIVE_GEOMETRYSHADER + 1),
    D3D10_MESSAGE_ID_LIVE_INPUTLAYOUT = (D3D10_MESSAGE_ID_LIVE_PIXELSHADER + 1),
    D3D10_MESSAGE_ID_LIVE_SAMPLER = (D3D10_MESSAGE_ID_LIVE_INPUTLAYOUT + 1),
    D3D10_MESSAGE_ID_LIVE_BLENDSTATE = (D3D10_MESSAGE_ID_LIVE_SAMPLER + 1),
    D3D10_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE = (D3D10_MESSAGE_ID_LIVE_BLENDSTATE + 1),
    D3D10_MESSAGE_ID_LIVE_RASTERIZERSTATE = (D3D10_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE + 1),
    D3D10_MESSAGE_ID_LIVE_QUERY = (D3D10_MESSAGE_ID_LIVE_RASTERIZERSTATE + 1),
    D3D10_MESSAGE_ID_LIVE_PREDICATE = (D3D10_MESSAGE_ID_LIVE_QUERY + 1),
    D3D10_MESSAGE_ID_LIVE_COUNTER = (D3D10_MESSAGE_ID_LIVE_PREDICATE + 1),
    D3D10_MESSAGE_ID_LIVE_DEVICE = (D3D10_MESSAGE_ID_LIVE_COUNTER + 1),
    D3D10_MESSAGE_ID_LIVE_SWAPCHAIN = (D3D10_MESSAGE_ID_LIVE_DEVICE + 1),
    D3D10_MESSAGE_ID_D3D10_MESSAGES_END = (D3D10_MESSAGE_ID_LIVE_SWAPCHAIN + 1),
    D3D10_MESSAGE_ID_D3D10L9_MESSAGES_START = 0x100000,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED = (D3D10_MESSAGE_ID_D3D10L9_MESSAGES_START + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED = (D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY + 1),
    D3D10_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE + 1),
    D3D10_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS = (D3D10_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS = (D3D10_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS = (D3D10_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND = (D3D10_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D = (D3D10_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE = (D3D10_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE = (D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE + 1),
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS = (D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE + 1),
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS = (D3D10_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS + 1),
    D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX = (D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS + 1),
    D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS = (D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX + 1),
    D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED = (D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS + 1),
    D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS = (D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY = (D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK = (D3D10_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK = (D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK + 1),
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT = (D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE = (D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT + 1),
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE + 1),
    D3D10_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE = (D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD = (D3D10_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX + 1),
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET = (D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER = (D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE = (D3D10_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE = (D3D10_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE = (D3D10_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS = (D3D10_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES = (D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED = (D3D10_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES + 1),
    D3D10_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED = (D3D10_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED + 1),
    D3D10_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED = (D3D10_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED = (D3D10_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED = (D3D10_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND = (D3D10_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND + 1),
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE = (D3D10_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE + 1),
    D3D10_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3 = (D3D10_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED = (D3D10_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3 + 1),
    D3D10_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO = (D3D10_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION = (D3D10_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED = (D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION + 1),
    D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR = (D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED + 1),
    D3D10_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA = (D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR + 1),
    D3D10_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP = (D3D10_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA + 1),
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED = (D3D10_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP + 1),
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT = (D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED + 1),
    D3D10_MESSAGE_ID_COPYRESOURCE_NO_3D_MISMATCHED_UPDATES = (D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT + 1),
    D3D10_MESSAGE_ID_D3D10L9_MESSAGES_END = (D3D10_MESSAGE_ID_COPYRESOURCE_NO_3D_MISMATCHED_UPDATES + 1)
} D3D10_MESSAGE_ID;
typedef struct D3D10_MESSAGE {
    D3D10_MESSAGE_CATEGORY Category;
    D3D10_MESSAGE_SEVERITY Severity;
    D3D10_MESSAGE_ID ID;
    const char* pDescription;
    SIZE_T DescriptionByteLength;
} D3D10_MESSAGE;
typedef struct D3D10_INFO_QUEUE_FILTER_DESC {
    UINT NumCategories;
    D3D10_MESSAGE_CATEGORY* pCategoryList;
    UINT NumSeverities;
    D3D10_MESSAGE_SEVERITY* pSeverityList;
    UINT NumIDs;
    D3D10_MESSAGE_ID* pIDList;
} D3D10_INFO_QUEUE_FILTER_DESC;
typedef struct D3D10_INFO_QUEUE_FILTER {
    D3D10_INFO_QUEUE_FILTER_DESC AllowList;
    D3D10_INFO_QUEUE_FILTER_DESC DenyList;
} D3D10_INFO_QUEUE_FILTER;
extern RPC_IF_HANDLE __MIDL_itf_d3d10sdklayers_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10sdklayers_0000_0002_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10InfoQueue;
struct __declspec(uuid("1b940b17-2642-4d1f-ab1f-b99bad0c395f")) __declspec(novtable)
    ID3D10InfoQueue : public IUnknown {
public:
    virtual HRESULT __stdcall SetMessageCountLimit(
        UINT64 MessageCountLimit)
        = 0;
    virtual void __stdcall ClearStoredMessages(void) = 0;
    virtual HRESULT __stdcall GetMessageW(
        UINT64 MessageIndex,
        D3D10_MESSAGE* pMessage,
        SIZE_T* pMessageByteLength)
        = 0;
    virtual UINT64 __stdcall GetNumMessagesAllowedByStorageFilter(void) = 0;
    virtual UINT64 __stdcall GetNumMessagesDeniedByStorageFilter(void) = 0;
    virtual UINT64 __stdcall GetNumStoredMessages(void) = 0;
    virtual UINT64 __stdcall GetNumStoredMessagesAllowedByRetrievalFilter(void) = 0;
    virtual UINT64 __stdcall GetNumMessagesDiscardedByMessageCountLimit(void) = 0;
    virtual UINT64 __stdcall GetMessageCountLimit(void) = 0;
    virtual HRESULT __stdcall AddStorageFilterEntries(
        D3D10_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual HRESULT __stdcall GetStorageFilter(
        D3D10_INFO_QUEUE_FILTER* pFilter,
        SIZE_T* pFilterByteLength)
        = 0;
    virtual void __stdcall ClearStorageFilter(void) = 0;
    virtual HRESULT __stdcall PushEmptyStorageFilter(void) = 0;
    virtual HRESULT __stdcall PushCopyOfStorageFilter(void) = 0;
    virtual HRESULT __stdcall PushStorageFilter(
        D3D10_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual void __stdcall PopStorageFilter(void) = 0;
    virtual UINT __stdcall GetStorageFilterStackSize(void) = 0;
    virtual HRESULT __stdcall AddRetrievalFilterEntries(
        D3D10_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual HRESULT __stdcall GetRetrievalFilter(
        D3D10_INFO_QUEUE_FILTER* pFilter,
        SIZE_T* pFilterByteLength)
        = 0;
    virtual void __stdcall ClearRetrievalFilter(void) = 0;
    virtual HRESULT __stdcall PushEmptyRetrievalFilter(void) = 0;
    virtual HRESULT __stdcall PushCopyOfRetrievalFilter(void) = 0;
    virtual HRESULT __stdcall PushRetrievalFilter(
        D3D10_INFO_QUEUE_FILTER* pFilter)
        = 0;
    virtual void __stdcall PopRetrievalFilter(void) = 0;
    virtual UINT __stdcall GetRetrievalFilterStackSize(void) = 0;
    virtual HRESULT __stdcall AddMessage(
        D3D10_MESSAGE_CATEGORY Category,
        D3D10_MESSAGE_SEVERITY Severity,
        D3D10_MESSAGE_ID ID,
        LPCSTR pDescription)
        = 0;
    virtual HRESULT __stdcall AddApplicationMessage(
        D3D10_MESSAGE_SEVERITY Severity,
        LPCSTR pDescription)
        = 0;
    virtual HRESULT __stdcall SetBreakOnCategory(
        D3D10_MESSAGE_CATEGORY Category,
        BOOL bEnable)
        = 0;
    virtual HRESULT __stdcall SetBreakOnSeverity(
        D3D10_MESSAGE_SEVERITY Severity,
        BOOL bEnable)
        = 0;
    virtual HRESULT __stdcall SetBreakOnID(
        D3D10_MESSAGE_ID ID,
        BOOL bEnable)
        = 0;
    virtual BOOL __stdcall GetBreakOnCategory(
        D3D10_MESSAGE_CATEGORY Category)
        = 0;
    virtual BOOL __stdcall GetBreakOnSeverity(
        D3D10_MESSAGE_SEVERITY Severity)
        = 0;
    virtual BOOL __stdcall GetBreakOnID(
        D3D10_MESSAGE_ID ID)
        = 0;
    virtual void __stdcall SetMuteDebugOutput(
        BOOL bMute)
        = 0;
    virtual BOOL __stdcall GetMuteDebugOutput(void) = 0;
};
#pragma endregion
extern "C" const GUID IID_ID3D10Debug;
extern "C" const GUID IID_ID3D10SwitchToRef;
extern "C" const GUID IID_ID3D10InfoQueue;
extern RPC_IF_HANDLE __MIDL_itf_d3d10sdklayers_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10sdklayers_0000_0003_v0_0_s_ifspec;
}
extern "C" {
#pragma region Desktop Family
typedef enum D3D10_DRIVER_TYPE {
    D3D10_DRIVER_TYPE_HARDWARE = 0,
    D3D10_DRIVER_TYPE_REFERENCE = 1,
    D3D10_DRIVER_TYPE_NULL = 2,
    D3D10_DRIVER_TYPE_SOFTWARE = 3,
    D3D10_DRIVER_TYPE_WARP = 5,
} D3D10_DRIVER_TYPE;
extern "C" const GUID GUID_DeviceType;
HRESULT __stdcall D3D10CreateDevice(
    IDXGIAdapter* pAdapter,
    D3D10_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    UINT SDKVersion,
    ID3D10Device** ppDevice);
HRESULT __stdcall D3D10CreateDeviceAndSwapChain(
    IDXGIAdapter* pAdapter,
    D3D10_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    UINT SDKVersion,
    DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
    IDXGISwapChain** ppSwapChain,
    ID3D10Device** ppDevice);
HRESULT __stdcall D3D10CreateBlob(SIZE_T NumBytes, LPD3D10BLOB* ppBuffer);
#pragma endregion
}
#pragma region Desktop Family
typedef D3D_SHADER_MACRO D3D10_SHADER_MACRO;
typedef D3D10_SHADER_MACRO* LPD3D10_SHADER_MACRO;
typedef D3D_SHADER_VARIABLE_CLASS D3D10_SHADER_VARIABLE_CLASS;
typedef D3D10_SHADER_VARIABLE_CLASS* LPD3D10_SHADER_VARIABLE_CLASS;
typedef D3D_SHADER_VARIABLE_FLAGS D3D10_SHADER_VARIABLE_FLAGS;
typedef D3D10_SHADER_VARIABLE_FLAGS* LPD3D10_SHADER_VARIABLE_FLAGS;
typedef D3D_SHADER_VARIABLE_TYPE D3D10_SHADER_VARIABLE_TYPE;
typedef D3D10_SHADER_VARIABLE_TYPE* LPD3D10_SHADER_VARIABLE_TYPE;
typedef D3D_SHADER_INPUT_FLAGS D3D10_SHADER_INPUT_FLAGS;
typedef D3D10_SHADER_INPUT_FLAGS* LPD3D10_SHADER_INPUT_FLAGS;
typedef D3D_SHADER_INPUT_TYPE D3D10_SHADER_INPUT_TYPE;
typedef D3D10_SHADER_INPUT_TYPE* LPD3D10_SHADER_INPUT_TYPE;
typedef D3D_SHADER_CBUFFER_FLAGS D3D10_SHADER_CBUFFER_FLAGS;
typedef D3D10_SHADER_CBUFFER_FLAGS* LPD3D10_SHADER_CBUFFER_FLAGS;
typedef D3D_CBUFFER_TYPE D3D10_CBUFFER_TYPE;
typedef D3D10_CBUFFER_TYPE* LPD3D10_CBUFFER_TYPE;
typedef D3D_NAME D3D10_NAME;
typedef D3D_RESOURCE_RETURN_TYPE D3D10_RESOURCE_RETURN_TYPE;
typedef D3D_REGISTER_COMPONENT_TYPE D3D10_REGISTER_COMPONENT_TYPE;
typedef D3D_INCLUDE_TYPE D3D10_INCLUDE_TYPE;
typedef struct ID3DInclude ID3D10Include;
typedef struct ID3DInclude* LPD3D10INCLUDE;
typedef struct _D3D10_SHADER_DESC {
    UINT Version;
    LPCSTR Creator;
    UINT Flags;
    UINT ConstantBuffers;
    UINT BoundResources;
    UINT InputParameters;
    UINT OutputParameters;
    UINT InstructionCount;
    UINT TempRegisterCount;
    UINT TempArrayCount;
    UINT DefCount;
    UINT DclCount;
    UINT TextureNormalInstructions;
    UINT TextureLoadInstructions;
    UINT TextureCompInstructions;
    UINT TextureBiasInstructions;
    UINT TextureGradientInstructions;
    UINT FloatInstructionCount;
    UINT IntInstructionCount;
    UINT UintInstructionCount;
    UINT StaticFlowControlCount;
    UINT DynamicFlowControlCount;
    UINT MacroInstructionCount;
    UINT ArrayInstructionCount;
    UINT CutInstructionCount;
    UINT EmitInstructionCount;
    D3D10_PRIMITIVE_TOPOLOGY GSOutputTopology;
    UINT GSMaxOutputVertexCount;
} D3D10_SHADER_DESC;
typedef struct _D3D10_SHADER_BUFFER_DESC {
    LPCSTR Name;
    D3D10_CBUFFER_TYPE Type;
    UINT Variables;
    UINT Size;
    UINT uFlags;
} D3D10_SHADER_BUFFER_DESC;
typedef struct _D3D10_SHADER_VARIABLE_DESC {
    LPCSTR Name;
    UINT StartOffset;
    UINT Size;
    UINT uFlags;
    LPVOID DefaultValue;
} D3D10_SHADER_VARIABLE_DESC;
typedef struct _D3D10_SHADER_TYPE_DESC {
    D3D10_SHADER_VARIABLE_CLASS Class;
    D3D10_SHADER_VARIABLE_TYPE Type;
    UINT Rows;
    UINT Columns;
    UINT Elements;
    UINT Members;
    UINT Offset;
} D3D10_SHADER_TYPE_DESC;
typedef struct _D3D10_SHADER_INPUT_BIND_DESC {
    LPCSTR Name;
    D3D10_SHADER_INPUT_TYPE Type;
    UINT BindPoint;
    UINT BindCount;
    UINT uFlags;
    D3D10_RESOURCE_RETURN_TYPE ReturnType;
    D3D10_SRV_DIMENSION Dimension;
    UINT NumSamples;
} D3D10_SHADER_INPUT_BIND_DESC;
typedef struct _D3D10_SIGNATURE_PARAMETER_DESC {
    LPCSTR SemanticName;
    UINT SemanticIndex;
    UINT Register;
    D3D10_NAME SystemValueType;
    D3D10_REGISTER_COMPONENT_TYPE ComponentType;
    BYTE Mask;
    BYTE ReadWriteMask;
} D3D10_SIGNATURE_PARAMETER_DESC;
typedef struct ID3D10ShaderReflectionType ID3D10ShaderReflectionType;
typedef struct ID3D10ShaderReflectionType* LPD3D10SHADERREFLECTIONTYPE;
struct __declspec(uuid("C530AD7D-9B16-4395-A979-BA2ECFF83ADD")) ID3D10ShaderReflectionType;
extern "C" const GUID IID_ID3D10ShaderReflectionType;
struct __declspec(novtable) ID3D10ShaderReflectionType {
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_SHADER_TYPE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionType* __stdcall GetMemberTypeByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionType* __stdcall GetMemberTypeByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetMemberTypeName(UINT Index) = 0;
};
typedef struct ID3D10ShaderReflectionVariable ID3D10ShaderReflectionVariable;
typedef struct ID3D10ShaderReflectionVariable* LPD3D10SHADERREFLECTIONVARIABLE;
struct __declspec(uuid("1BF63C95-2650-405d-99C1-3636BD1DA0A1")) ID3D10ShaderReflectionVariable;
extern "C" const GUID IID_ID3D10ShaderReflectionVariable;
struct __declspec(novtable) ID3D10ShaderReflectionVariable {
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_SHADER_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionType* __stdcall GetType(void) = 0;
};
typedef struct ID3D10ShaderReflectionConstantBuffer ID3D10ShaderReflectionConstantBuffer;
typedef struct ID3D10ShaderReflectionConstantBuffer* LPD3D10SHADERREFLECTIONCONSTANTBUFFER;
struct __declspec(uuid("66C66A94-DDDD-4b62-A66A-F0DA33C2B4D0")) ID3D10ShaderReflectionConstantBuffer;
extern "C" const GUID IID_ID3D10ShaderReflectionConstantBuffer;
struct __declspec(novtable) ID3D10ShaderReflectionConstantBuffer {
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_SHADER_BUFFER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionVariable* __stdcall GetVariableByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionVariable* __stdcall GetVariableByName(LPCSTR Name) = 0;
};
typedef struct ID3D10ShaderReflection ID3D10ShaderReflection;
typedef struct ID3D10ShaderReflection* LPD3D10SHADERREFLECTION;
struct __declspec(uuid("D40E20B6-F8F7-42ad-AB20-4BAF8F15DFAA")) ID3D10ShaderReflection;
extern "C" const GUID IID_ID3D10ShaderReflection;
struct __declspec(novtable) ID3D10ShaderReflection : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_SHADER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionConstantBuffer* __stdcall GetConstantBufferByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionConstantBuffer* __stdcall GetConstantBufferByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetResourceBindingDesc(UINT ResourceIndex, D3D10_SHADER_INPUT_BIND_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInputParameterDesc(UINT ParameterIndex, D3D10_SIGNATURE_PARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetOutputParameterDesc(UINT ParameterIndex, D3D10_SIGNATURE_PARAMETER_DESC* pDesc) = 0;
};
extern "C" {
HRESULT __stdcall D3D10CompileShader(LPCSTR pSrcData, SIZE_T SrcDataSize, LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs);
HRESULT __stdcall D3D10DisassembleShader(const void* pShader, SIZE_T BytecodeLength, BOOL EnableColorCode, LPCSTR pComments, ID3D10Blob** ppDisassembly);
LPCSTR __stdcall D3D10GetPixelShaderProfile(ID3D10Device* pDevice);
LPCSTR __stdcall D3D10GetVertexShaderProfile(ID3D10Device* pDevice);
LPCSTR __stdcall D3D10GetGeometryShaderProfile(ID3D10Device* pDevice);
HRESULT __stdcall D3D10ReflectShader(const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D10ShaderReflection** ppReflector);
HRESULT __stdcall D3D10PreprocessShader(LPCSTR pSrcData, SIZE_T SrcDataSize, LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs);
HRESULT __stdcall D3D10GetInputSignatureBlob(const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D10Blob** ppSignatureBlob);
HRESULT __stdcall D3D10GetOutputSignatureBlob(const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D10Blob** ppSignatureBlob);
HRESULT __stdcall D3D10GetInputAndOutputSignatureBlob(const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D10Blob** ppSignatureBlob);
HRESULT __stdcall D3D10GetShaderDebugInfo(const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D10Blob** ppDebugInfo);
}
#pragma endregion
#pragma region Desktop Family
typedef enum _D3D10_DEVICE_STATE_TYPES {
    D3D10_DST_SO_BUFFERS = 1,
    D3D10_DST_OM_RENDER_TARGETS,
    D3D10_DST_OM_DEPTH_STENCIL_STATE,
    D3D10_DST_OM_BLEND_STATE,
    D3D10_DST_VS,
    D3D10_DST_VS_SAMPLERS,
    D3D10_DST_VS_SHADER_RESOURCES,
    D3D10_DST_VS_CONSTANT_BUFFERS,
    D3D10_DST_GS,
    D3D10_DST_GS_SAMPLERS,
    D3D10_DST_GS_SHADER_RESOURCES,
    D3D10_DST_GS_CONSTANT_BUFFERS,
    D3D10_DST_PS,
    D3D10_DST_PS_SAMPLERS,
    D3D10_DST_PS_SHADER_RESOURCES,
    D3D10_DST_PS_CONSTANT_BUFFERS,
    D3D10_DST_IA_VERTEX_BUFFERS,
    D3D10_DST_IA_INDEX_BUFFER,
    D3D10_DST_IA_INPUT_LAYOUT,
    D3D10_DST_IA_PRIMITIVE_TOPOLOGY,
    D3D10_DST_RS_VIEWPORTS,
    D3D10_DST_RS_SCISSOR_RECTS,
    D3D10_DST_RS_RASTERIZER_STATE,
    D3D10_DST_PREDICATION,
} D3D10_DEVICE_STATE_TYPES;
typedef struct _D3D10_STATE_BLOCK_MASK {
    BYTE VS;
    BYTE VSSamplers[((((16)) + 7) / 8)];
    BYTE VSShaderResources[((((128)) + 7) / 8)];
    BYTE VSConstantBuffers[((((14)) + 7) / 8)];
    BYTE GS;
    BYTE GSSamplers[((((16)) + 7) / 8)];
    BYTE GSShaderResources[((((128)) + 7) / 8)];
    BYTE GSConstantBuffers[((((14)) + 7) / 8)];
    BYTE PS;
    BYTE PSSamplers[((((16)) + 7) / 8)];
    BYTE PSShaderResources[((((128)) + 7) / 8)];
    BYTE PSConstantBuffers[((((14)) + 7) / 8)];
    BYTE IAVertexBuffers[((((16)) + 7) / 8)];
    BYTE IAIndexBuffer;
    BYTE IAInputLayout;
    BYTE IAPrimitiveTopology;
    BYTE OMRenderTargets;
    BYTE OMDepthStencilState;
    BYTE OMBlendState;
    BYTE RSViewports;
    BYTE RSScissorRects;
    BYTE RSRasterizerState;
    BYTE SOBuffers;
    BYTE Predication;
} D3D10_STATE_BLOCK_MASK;
typedef struct ID3D10StateBlock ID3D10StateBlock;
typedef struct ID3D10StateBlock* LPD3D10STATEBLOCK;
extern "C" const GUID IID_ID3D10StateBlock;
struct __declspec(novtable) ID3D10StateBlock : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Capture(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Apply(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ReleaseAllDeviceObjects(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(ID3D10Device** ppDevice) = 0;
};
extern "C" {
HRESULT __stdcall D3D10StateBlockMaskUnion(D3D10_STATE_BLOCK_MASK* pA, D3D10_STATE_BLOCK_MASK* pB, D3D10_STATE_BLOCK_MASK* pResult);
HRESULT __stdcall D3D10StateBlockMaskIntersect(D3D10_STATE_BLOCK_MASK* pA, D3D10_STATE_BLOCK_MASK* pB, D3D10_STATE_BLOCK_MASK* pResult);
HRESULT __stdcall D3D10StateBlockMaskDifference(D3D10_STATE_BLOCK_MASK* pA, D3D10_STATE_BLOCK_MASK* pB, D3D10_STATE_BLOCK_MASK* pResult);
HRESULT __stdcall D3D10StateBlockMaskEnableCapture(D3D10_STATE_BLOCK_MASK* pMask, D3D10_DEVICE_STATE_TYPES StateType, UINT RangeStart, UINT RangeLength);
HRESULT __stdcall D3D10StateBlockMaskDisableCapture(D3D10_STATE_BLOCK_MASK* pMask, D3D10_DEVICE_STATE_TYPES StateType, UINT RangeStart, UINT RangeLength);
HRESULT __stdcall D3D10StateBlockMaskEnableAll(D3D10_STATE_BLOCK_MASK* pMask);
HRESULT __stdcall D3D10StateBlockMaskDisableAll(D3D10_STATE_BLOCK_MASK* pMask);
BOOL __stdcall D3D10StateBlockMaskGetSetting(D3D10_STATE_BLOCK_MASK* pMask, D3D10_DEVICE_STATE_TYPES StateType, UINT Entry);
HRESULT __stdcall D3D10CreateStateBlock(ID3D10Device* pDevice, D3D10_STATE_BLOCK_MASK* pStateBlockMask, ID3D10StateBlock** ppStateBlock);
}
typedef struct _D3D10_EFFECT_TYPE_DESC {
    LPCSTR TypeName;
    D3D10_SHADER_VARIABLE_CLASS Class;
    D3D10_SHADER_VARIABLE_TYPE Type;
    UINT Elements;
    UINT Members;
    UINT Rows;
    UINT Columns;
    UINT PackedSize;
    UINT UnpackedSize;
    UINT Stride;
} D3D10_EFFECT_TYPE_DESC;
typedef struct ID3D10EffectType ID3D10EffectType;
typedef struct ID3D10EffectType* LPD3D10EFFECTTYPE;
extern "C" const GUID IID_ID3D10EffectType;
struct __declspec(novtable) ID3D10EffectType {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_TYPE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetMemberTypeByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetMemberTypeByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetMemberTypeBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetMemberName(UINT Index) = 0;
    virtual __declspec(nothrow) LPCSTR __stdcall GetMemberSemantic(UINT Index) = 0;
};
typedef struct _D3D10_EFFECT_VARIABLE_DESC {
    LPCSTR Name;
    LPCSTR Semantic;
    UINT Flags;
    UINT Annotations;
    UINT BufferOffset;
    UINT ExplicitBindPoint;
} D3D10_EFFECT_VARIABLE_DESC;
typedef struct ID3D10EffectVariable ID3D10EffectVariable;
typedef struct ID3D10EffectVariable* LPD3D10EFFECTVARIABLE;
extern "C" const GUID IID_ID3D10EffectVariable;
typedef struct ID3D10EffectScalarVariable ID3D10EffectScalarVariable;
typedef struct ID3D10EffectVectorVariable ID3D10EffectVectorVariable;
typedef struct ID3D10EffectMatrixVariable ID3D10EffectMatrixVariable;
typedef struct ID3D10EffectStringVariable ID3D10EffectStringVariable;
typedef struct ID3D10EffectShaderResourceVariable ID3D10EffectShaderResourceVariable;
typedef struct ID3D10EffectRenderTargetViewVariable ID3D10EffectRenderTargetViewVariable;
typedef struct ID3D10EffectDepthStencilViewVariable ID3D10EffectDepthStencilViewVariable;
typedef struct ID3D10EffectConstantBuffer ID3D10EffectConstantBuffer;
typedef struct ID3D10EffectShaderVariable ID3D10EffectShaderVariable;
typedef struct ID3D10EffectBlendVariable ID3D10EffectBlendVariable;
typedef struct ID3D10EffectDepthStencilVariable ID3D10EffectDepthStencilVariable;
typedef struct ID3D10EffectRasterizerVariable ID3D10EffectRasterizerVariable;
typedef struct ID3D10EffectSamplerVariable ID3D10EffectSamplerVariable;
struct __declspec(novtable) ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
};
typedef struct ID3D10EffectScalarVariable ID3D10EffectScalarVariable;
typedef struct ID3D10EffectScalarVariable* LPD3D10EFFECTSCALARVARIABLE;
extern "C" const GUID IID_ID3D10EffectScalarVariable;
struct __declspec(novtable) ID3D10EffectScalarVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT ByteOffset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT ByteOffset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloat(float Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloat(float* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatArray(float* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloatArray(float* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetInt(int Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInt(int* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntArray(int* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIntArray(int* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBool(BOOL Value) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBool(BOOL* pValue) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolArray(BOOL* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoolArray(BOOL* pData, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectVectorVariable ID3D10EffectVectorVariable;
typedef struct ID3D10EffectVectorVariable* LPD3D10EFFECTVECTORVARIABLE;
extern "C" const GUID IID_ID3D10EffectVectorVariable;
struct __declspec(novtable) ID3D10EffectVectorVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT ByteOffset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT ByteOffset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolVector(BOOL* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntVector(int* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatVector(float* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoolVector(BOOL* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIntVector(int* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloatVector(float* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoolVectorArray(BOOL* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIntVectorArray(int* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetFloatVectorArray(float* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoolVectorArray(BOOL* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIntVectorArray(int* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetFloatVectorArray(float* pData, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectMatrixVariable ID3D10EffectMatrixVariable;
typedef struct ID3D10EffectMatrixVariable* LPD3D10EFFECTMATRIXVARIABLE;
extern "C" const GUID IID_ID3D10EffectMatrixVariable;
struct __declspec(novtable) ID3D10EffectMatrixVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT ByteOffset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT ByteOffset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrix(float* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrix(float* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixArray(float* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixArray(float* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTranspose(float* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTranspose(float* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetMatrixTransposeArray(float* pData, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMatrixTransposeArray(float* pData, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectStringVariable ID3D10EffectStringVariable;
typedef struct ID3D10EffectStringVariable* LPD3D10EFFECTSTRINGVARIABLE;
extern "C" const GUID IID_ID3D10EffectStringVariable;
struct __declspec(novtable) ID3D10EffectStringVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetString(LPCSTR* ppString) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetStringArray(LPCSTR* ppStrings, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectShaderResourceVariable ID3D10EffectShaderResourceVariable;
typedef struct ID3D10EffectShaderResourceVariable* LPD3D10EFFECTSHADERRESOURCEVARIABLE;
extern "C" const GUID IID_ID3D10EffectShaderResourceVariable;
struct __declspec(novtable) ID3D10EffectShaderResourceVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetResource(ID3D10ShaderResourceView* pResource) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetResource(ID3D10ShaderResourceView** ppResource) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetResourceArray(ID3D10ShaderResourceView** ppResources, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetResourceArray(ID3D10ShaderResourceView** ppResources, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectRenderTargetViewVariable ID3D10EffectRenderTargetViewVariable;
typedef struct ID3D10EffectRenderTargetViewVariable* LPD3D10EFFECTRENDERTARGETVIEWVARIABLE;
extern "C" const GUID IID_ID3D10EffectRenderTargetViewVariable;
struct __declspec(novtable) ID3D10EffectRenderTargetViewVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderTarget(ID3D10RenderTargetView* pResource) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderTarget(ID3D10RenderTargetView** ppResource) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRenderTargetArray(ID3D10RenderTargetView** ppResources, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRenderTargetArray(ID3D10RenderTargetView** ppResources, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectDepthStencilViewVariable ID3D10EffectDepthStencilViewVariable;
typedef struct ID3D10EffectDepthStencilViewVariable* LPD3D10EFFECTDEPTHSTENCILVIEWVARIABLE;
extern "C" const GUID IID_ID3D10EffectDepthStencilViewVariable;
struct __declspec(novtable) ID3D10EffectDepthStencilViewVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDepthStencil(ID3D10DepthStencilView* pResource) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDepthStencil(ID3D10DepthStencilView** ppResource) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetDepthStencilArray(ID3D10DepthStencilView** ppResources, UINT Offset, UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDepthStencilArray(ID3D10DepthStencilView** ppResources, UINT Offset, UINT Count) = 0;
};
typedef struct ID3D10EffectConstantBuffer ID3D10EffectConstantBuffer;
typedef struct ID3D10EffectConstantBuffer* LPD3D10EFFECTCONSTANTBUFFER;
extern "C" const GUID IID_ID3D10EffectConstantBuffer;
struct __declspec(novtable) ID3D10EffectConstantBuffer : public ID3D10EffectVariable {
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetConstantBuffer(ID3D10Buffer* pConstantBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetConstantBuffer(ID3D10Buffer** ppConstantBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetTextureBuffer(ID3D10ShaderResourceView* pTextureBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetTextureBuffer(ID3D10ShaderResourceView** ppTextureBuffer) = 0;
};
typedef struct _D3D10_EFFECT_SHADER_DESC {
    const BYTE* pInputSignature;
    BOOL IsInline;
    const BYTE* pBytecode;
    UINT BytecodeLength;
    LPCSTR SODecl;
    UINT NumInputSignatureEntries;
    UINT NumOutputSignatureEntries;
} D3D10_EFFECT_SHADER_DESC;
typedef struct ID3D10EffectShaderVariable ID3D10EffectShaderVariable;
typedef struct ID3D10EffectShaderVariable* LPD3D10EFFECTSHADERVARIABLE;
extern "C" const GUID IID_ID3D10EffectShaderVariable;
struct __declspec(novtable) ID3D10EffectShaderVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetShaderDesc(UINT ShaderIndex, D3D10_EFFECT_SHADER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShader(UINT ShaderIndex, ID3D10VertexShader** ppVS) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGeometryShader(UINT ShaderIndex, ID3D10GeometryShader** ppGS) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShader(UINT ShaderIndex, ID3D10PixelShader** ppPS) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInputSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D10_SIGNATURE_PARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetOutputSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D10_SIGNATURE_PARAMETER_DESC* pDesc) = 0;
};
typedef struct ID3D10EffectBlendVariable ID3D10EffectBlendVariable;
typedef struct ID3D10EffectBlendVariable* LPD3D10EFFECTBLENDVARIABLE;
extern "C" const GUID IID_ID3D10EffectBlendVariable;
struct __declspec(novtable) ID3D10EffectBlendVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBlendState(UINT Index, ID3D10BlendState** ppBlendState) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackingStore(UINT Index, D3D10_BLEND_DESC* pBlendDesc) = 0;
};
typedef struct ID3D10EffectDepthStencilVariable ID3D10EffectDepthStencilVariable;
typedef struct ID3D10EffectDepthStencilVariable* LPD3D10EFFECTDEPTHSTENCILVARIABLE;
extern "C" const GUID IID_ID3D10EffectDepthStencilVariable;
struct __declspec(novtable) ID3D10EffectDepthStencilVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDepthStencilState(UINT Index, ID3D10DepthStencilState** ppDepthStencilState) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackingStore(UINT Index, D3D10_DEPTH_STENCIL_DESC* pDepthStencilDesc) = 0;
};
typedef struct ID3D10EffectRasterizerVariable ID3D10EffectRasterizerVariable;
typedef struct ID3D10EffectRasterizerVariable* LPD3D10EFFECTRASTERIZERVARIABLE;
extern "C" const GUID IID_ID3D10EffectRasterizerVariable;
struct __declspec(novtable) ID3D10EffectRasterizerVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRasterizerState(UINT Index, ID3D10RasterizerState** ppRasterizerState) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackingStore(UINT Index, D3D10_RASTERIZER_DESC* pRasterizerDesc) = 0;
};
typedef struct ID3D10EffectSamplerVariable ID3D10EffectSamplerVariable;
typedef struct ID3D10EffectSamplerVariable* LPD3D10EFFECTSAMPLERVARIABLE;
extern "C" const GUID IID_ID3D10EffectSamplerVariable;
struct __declspec(novtable) ID3D10EffectSamplerVariable : public ID3D10EffectVariable {
    virtual __declspec(nothrow) ID3D10EffectType* __stdcall GetType(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_VARIABLE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetMemberBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetElement(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetParentConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectScalarVariable* __stdcall AsScalar(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectVectorVariable* __stdcall AsVector(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectMatrixVariable* __stdcall AsMatrix(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectStringVariable* __stdcall AsString(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderResourceVariable* __stdcall AsShaderResource(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRenderTargetViewVariable* __stdcall AsRenderTargetView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilViewVariable* __stdcall AsDepthStencilView(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall AsConstantBuffer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectShaderVariable* __stdcall AsShader(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectBlendVariable* __stdcall AsBlend(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectDepthStencilVariable* __stdcall AsDepthStencil(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectRasterizerVariable* __stdcall AsRasterizer(void) = 0;
    virtual __declspec(nothrow) ID3D10EffectSamplerVariable* __stdcall AsSampler(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetRawValue(void* pData, UINT Offset, UINT ByteCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetSampler(UINT Index, ID3D10SamplerState** ppSampler) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBackingStore(UINT Index, D3D10_SAMPLER_DESC* pSamplerDesc) = 0;
};
typedef struct _D3D10_PASS_DESC {
    LPCSTR Name;
    UINT Annotations;
    BYTE* pIAInputSignature;
    SIZE_T IAInputSignatureSize;
    UINT StencilRef;
    UINT SampleMask;
    FLOAT BlendFactor[4];
} D3D10_PASS_DESC;
typedef struct _D3D10_PASS_SHADER_DESC {
    ID3D10EffectShaderVariable* pShaderVariable;
    UINT ShaderIndex;
} D3D10_PASS_SHADER_DESC;
typedef struct ID3D10EffectPass ID3D10EffectPass;
typedef struct ID3D10EffectPass* LPD3D10EFFECTPASS;
extern "C" const GUID IID_ID3D10EffectPass;
struct __declspec(novtable) ID3D10EffectPass {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_PASS_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexShaderDesc(D3D10_PASS_SHADER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGeometryShaderDesc(D3D10_PASS_SHADER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPixelShaderDesc(D3D10_PASS_SHADER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Apply(UINT Flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeStateBlockMask(D3D10_STATE_BLOCK_MASK* pStateBlockMask) = 0;
};
typedef struct _D3D10_TECHNIQUE_DESC {
    LPCSTR Name;
    UINT Passes;
    UINT Annotations;
} D3D10_TECHNIQUE_DESC;
typedef struct ID3D10EffectTechnique ID3D10EffectTechnique;
typedef struct ID3D10EffectTechnique* LPD3D10EFFECTTECHNIQUE;
extern "C" const GUID IID_ID3D10EffectTechnique;
struct __declspec(novtable) ID3D10EffectTechnique {
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_TECHNIQUE_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetAnnotationByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectPass* __stdcall GetPassByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectPass* __stdcall GetPassByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ComputeStateBlockMask(D3D10_STATE_BLOCK_MASK* pStateBlockMask) = 0;
};
typedef struct _D3D10_EFFECT_DESC {
    BOOL IsChildEffect;
    UINT ConstantBuffers;
    UINT SharedConstantBuffers;
    UINT GlobalVariables;
    UINT SharedGlobalVariables;
    UINT Techniques;
} D3D10_EFFECT_DESC;
typedef struct ID3D10Effect ID3D10Effect;
typedef struct ID3D10Effect* LPD3D10EFFECT;
extern "C" const GUID IID_ID3D10Effect;
struct __declspec(novtable) ID3D10Effect : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsValid(void) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsPool(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(ID3D10Device** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_EFFECT_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetConstantBufferByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectConstantBuffer* __stdcall GetConstantBufferByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetVariableByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetVariableByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) ID3D10EffectVariable* __stdcall GetVariableBySemantic(LPCSTR Semantic) = 0;
    virtual __declspec(nothrow) ID3D10EffectTechnique* __stdcall GetTechniqueByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10EffectTechnique* __stdcall GetTechniqueByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Optimize(void) = 0;
    virtual __declspec(nothrow) BOOL __stdcall IsOptimized(void) = 0;
};
typedef struct ID3D10EffectPool ID3D10EffectPool;
typedef struct ID3D10EffectPool* LPD3D10EFFECTPOOL;
extern "C" const GUID IID_ID3D10EffectPool;
struct __declspec(novtable) ID3D10EffectPool : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) ID3D10Effect* __stdcall AsEffect(void) = 0;
};
extern "C" {
HRESULT __stdcall D3D10CompileEffectFromMemory(void* pData, SIZE_T DataLength, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, UINT HLSLFlags, UINT FXFlags,
    ID3D10Blob** ppCompiledEffect, ID3D10Blob** ppErrors);
HRESULT __stdcall D3D10CreateEffectFromMemory(void* pData, SIZE_T DataLength, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pEffectPool, ID3D10Effect** ppEffect);
HRESULT __stdcall D3D10CreateEffectPoolFromMemory(void* pData, SIZE_T DataLength, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool** ppEffectPool);
HRESULT __stdcall D3D10DisassembleEffect(ID3D10Effect* pEffect, BOOL EnableColorCode, ID3D10Blob** ppDisassembly);
}
#pragma endregion
#pragma endregion
extern "C" const GUID IID_ID3D10DeviceChild;
extern "C" const GUID IID_ID3D10DepthStencilState;
extern "C" const GUID IID_ID3D10BlendState;
extern "C" const GUID IID_ID3D10RasterizerState;
extern "C" const GUID IID_ID3D10Resource;
extern "C" const GUID IID_ID3D10Buffer;
extern "C" const GUID IID_ID3D10Texture1D;
extern "C" const GUID IID_ID3D10Texture2D;
extern "C" const GUID IID_ID3D10Texture3D;
extern "C" const GUID IID_ID3D10View;
extern "C" const GUID IID_ID3D10ShaderResourceView;
extern "C" const GUID IID_ID3D10RenderTargetView;
extern "C" const GUID IID_ID3D10DepthStencilView;
extern "C" const GUID IID_ID3D10VertexShader;
extern "C" const GUID IID_ID3D10GeometryShader;
extern "C" const GUID IID_ID3D10PixelShader;
extern "C" const GUID IID_ID3D10InputLayout;
extern "C" const GUID IID_ID3D10SamplerState;
extern "C" const GUID IID_ID3D10Asynchronous;
extern "C" const GUID IID_ID3D10Query;
extern "C" const GUID IID_ID3D10Predicate;
extern "C" const GUID IID_ID3D10Counter;
extern "C" const GUID IID_ID3D10Device;
extern "C" const GUID IID_ID3D10Multithread;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_0000_0024_v0_0_s_ifspec;
}
#pragma region Desktop Family
typedef enum D3D10_FEATURE_LEVEL1 {
    D3D10_FEATURE_LEVEL_10_0 = 0xa000,
    D3D10_FEATURE_LEVEL_10_1 = 0xa100,
    D3D10_FEATURE_LEVEL_9_1 = 0x9100,
    D3D10_FEATURE_LEVEL_9_2 = 0x9200,
    D3D10_FEATURE_LEVEL_9_3 = 0x9300
} D3D10_FEATURE_LEVEL1;
typedef struct D3D10_RENDER_TARGET_BLEND_DESC1 {
    BOOL BlendEnable;
    D3D10_BLEND SrcBlend;
    D3D10_BLEND DestBlend;
    D3D10_BLEND_OP BlendOp;
    D3D10_BLEND SrcBlendAlpha;
    D3D10_BLEND DestBlendAlpha;
    D3D10_BLEND_OP BlendOpAlpha;
    UINT8 RenderTargetWriteMask;
} D3D10_RENDER_TARGET_BLEND_DESC1;
typedef struct D3D10_BLEND_DESC1 {
    BOOL AlphaToCoverageEnable;
    BOOL IndependentBlendEnable;
    D3D10_RENDER_TARGET_BLEND_DESC1 RenderTarget[8];
} D3D10_BLEND_DESC1;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10BlendState1;
struct __declspec(uuid("EDAD8D99-8A35-4d6d-8566-2EA276CDE161")) __declspec(novtable)
    ID3D10BlendState1 : public ID3D10BlendState {
public:
    virtual void __stdcall GetDesc1(
        D3D10_BLEND_DESC1* pDesc)
        = 0;
};
typedef struct D3D10_TEXCUBE_ARRAY_SRV1 {
    UINT MostDetailedMip;
    UINT MipLevels;
    UINT First2DArrayFace;
    UINT NumCubes;
} D3D10_TEXCUBE_ARRAY_SRV1;
typedef D3D_SRV_DIMENSION D3D10_SRV_DIMENSION1;
typedef struct D3D10_SHADER_RESOURCE_VIEW_DESC1 {
    DXGI_FORMAT Format;
    D3D10_SRV_DIMENSION1 ViewDimension;
    union {
        D3D10_BUFFER_SRV Buffer;
        D3D10_TEX1D_SRV Texture1D;
        D3D10_TEX1D_ARRAY_SRV Texture1DArray;
        D3D10_TEX2D_SRV Texture2D;
        D3D10_TEX2D_ARRAY_SRV Texture2DArray;
        D3D10_TEX2DMS_SRV Texture2DMS;
        D3D10_TEX2DMS_ARRAY_SRV Texture2DMSArray;
        D3D10_TEX3D_SRV Texture3D;
        D3D10_TEXCUBE_SRV TextureCube;
        D3D10_TEXCUBE_ARRAY_SRV1 TextureCubeArray;
    };
} D3D10_SHADER_RESOURCE_VIEW_DESC1;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0001_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10ShaderResourceView1;
struct __declspec(uuid("9B7E4C87-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10ShaderResourceView1 : public ID3D10ShaderResourceView {
public:
    virtual void __stdcall GetDesc1(
        D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc)
        = 0;
};
typedef enum D3D10_STANDARD_MULTISAMPLE_QUALITY_LEVELS {
    D3D10_STANDARD_MULTISAMPLE_PATTERN = 0xffffffff,
    D3D10_CENTER_MULTISAMPLE_PATTERN = 0xfffffffe
} D3D10_STANDARD_MULTISAMPLE_QUALITY_LEVELS;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0002_v0_0_s_ifspec;
extern "C" const IID IID_ID3D10Device1;
struct __declspec(uuid("9B7E4C8F-342C-4106-A19F-4F2704F689F0")) __declspec(novtable)
    ID3D10Device1 : public ID3D10Device {
public:
    virtual HRESULT __stdcall CreateShaderResourceView1(
        ID3D10Resource* pResource,
        const D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc,
        ID3D10ShaderResourceView1** ppSRView)
        = 0;
    virtual HRESULT __stdcall CreateBlendState1(
        const D3D10_BLEND_DESC1* pBlendStateDesc,
        ID3D10BlendState1** ppBlendState)
        = 0;
    virtual D3D10_FEATURE_LEVEL1 __stdcall GetFeatureLevel(void) = 0;
};
typedef enum _D3D10_SHADER_DEBUG_REGTYPE {
    D3D10_SHADER_DEBUG_REG_INPUT,
    D3D10_SHADER_DEBUG_REG_OUTPUT,
    D3D10_SHADER_DEBUG_REG_CBUFFER,
    D3D10_SHADER_DEBUG_REG_TBUFFER,
    D3D10_SHADER_DEBUG_REG_TEMP,
    D3D10_SHADER_DEBUG_REG_TEMPARRAY,
    D3D10_SHADER_DEBUG_REG_TEXTURE,
    D3D10_SHADER_DEBUG_REG_SAMPLER,
    D3D10_SHADER_DEBUG_REG_IMMEDIATECBUFFER,
    D3D10_SHADER_DEBUG_REG_LITERAL,
    D3D10_SHADER_DEBUG_REG_UNUSED,
    D3D11_SHADER_DEBUG_REG_INTERFACE_POINTERS,
    D3D11_SHADER_DEBUG_REG_UAV,
    D3D10_SHADER_DEBUG_REG_FORCE_DWORD = 0x7fffffff,
} D3D10_SHADER_DEBUG_REGTYPE;
typedef enum _D3D10_SHADER_DEBUG_SCOPETYPE {
    D3D10_SHADER_DEBUG_SCOPE_GLOBAL,
    D3D10_SHADER_DEBUG_SCOPE_BLOCK,
    D3D10_SHADER_DEBUG_SCOPE_FORLOOP,
    D3D10_SHADER_DEBUG_SCOPE_STRUCT,
    D3D10_SHADER_DEBUG_SCOPE_FUNC_PARAMS,
    D3D10_SHADER_DEBUG_SCOPE_STATEBLOCK,
    D3D10_SHADER_DEBUG_SCOPE_NAMESPACE,
    D3D10_SHADER_DEBUG_SCOPE_ANNOTATION,
    D3D10_SHADER_DEBUG_SCOPE_FORCE_DWORD = 0x7fffffff,
} D3D10_SHADER_DEBUG_SCOPETYPE;
typedef enum _D3D10_SHADER_DEBUG_VARTYPE {
    D3D10_SHADER_DEBUG_VAR_VARIABLE,
    D3D10_SHADER_DEBUG_VAR_FUNCTION,
    D3D10_SHADER_DEBUG_VAR_FORCE_DWORD = 0x7fffffff,
} D3D10_SHADER_DEBUG_VARTYPE;
typedef struct _D3D10_SHADER_DEBUG_TOKEN_INFO {
    UINT File;
    UINT Line;
    UINT Column;
    UINT TokenLength;
    UINT TokenId;
} D3D10_SHADER_DEBUG_TOKEN_INFO;
typedef struct _D3D10_SHADER_DEBUG_VAR_INFO {
    UINT TokenId;
    D3D10_SHADER_VARIABLE_TYPE Type;
    UINT Register;
    UINT Component;
    UINT ScopeVar;
    UINT ScopeVarOffset;
} D3D10_SHADER_DEBUG_VAR_INFO;
typedef struct _D3D10_SHADER_DEBUG_INPUT_INFO {
    UINT Var;
    D3D10_SHADER_DEBUG_REGTYPE InitialRegisterSet;
    UINT InitialBank;
    UINT InitialRegister;
    UINT InitialComponent;
    UINT InitialValue;
} D3D10_SHADER_DEBUG_INPUT_INFO;
typedef struct _D3D10_SHADER_DEBUG_SCOPEVAR_INFO {
    UINT TokenId;
    D3D10_SHADER_DEBUG_VARTYPE VarType;
    D3D10_SHADER_VARIABLE_CLASS Class;
    UINT Rows;
    UINT Columns;
    UINT StructMemberScope;
    UINT uArrayIndices;
    UINT ArrayElements;
    UINT ArrayStrides;
    UINT uVariables;
    UINT uFirstVariable;
} D3D10_SHADER_DEBUG_SCOPEVAR_INFO;
typedef struct _D3D10_SHADER_DEBUG_SCOPE_INFO {
    D3D10_SHADER_DEBUG_SCOPETYPE ScopeType;
    UINT Name;
    UINT uNameLen;
    UINT uVariables;
    UINT VariableData;
} D3D10_SHADER_DEBUG_SCOPE_INFO;
typedef struct _D3D10_SHADER_DEBUG_OUTPUTVAR {
    UINT Var;
    UINT uValueMin, uValueMax;
    INT iValueMin, iValueMax;
    FLOAT fValueMin, fValueMax;
    BOOL bNaNPossible, bInfPossible;
} D3D10_SHADER_DEBUG_OUTPUTVAR;
typedef struct _D3D10_SHADER_DEBUG_OUTPUTREG_INFO {
    D3D10_SHADER_DEBUG_REGTYPE OutputRegisterSet;
    UINT OutputReg;
    UINT TempArrayReg;
    UINT OutputComponents[4];
    D3D10_SHADER_DEBUG_OUTPUTVAR OutputVars[4];
    UINT IndexReg;
    UINT IndexComp;
} D3D10_SHADER_DEBUG_OUTPUTREG_INFO;
typedef struct _D3D10_SHADER_DEBUG_INST_INFO {
    UINT Id;
    UINT Opcode;
    UINT uOutputs;
    D3D10_SHADER_DEBUG_OUTPUTREG_INFO pOutputs[2];
    UINT TokenId;
    UINT NestingLevel;
    UINT Scopes;
    UINT ScopeInfo;
    UINT AccessedVars;
    UINT AccessedVarsInfo;
} D3D10_SHADER_DEBUG_INST_INFO;
typedef struct _D3D10_SHADER_DEBUG_FILE_INFO {
    UINT FileName;
    UINT FileNameLen;
    UINT FileData;
    UINT FileLen;
} D3D10_SHADER_DEBUG_FILE_INFO;
typedef struct _D3D10_SHADER_DEBUG_INFO {
    UINT Size;
    UINT Creator;
    UINT EntrypointName;
    UINT ShaderTarget;
    UINT CompileFlags;
    UINT Files;
    UINT FileInfo;
    UINT Instructions;
    UINT InstructionInfo;
    UINT Variables;
    UINT VariableInfo;
    UINT InputVariables;
    UINT InputVariableInfo;
    UINT Tokens;
    UINT TokenInfo;
    UINT Scopes;
    UINT ScopeInfo;
    UINT ScopeVariables;
    UINT ScopeVariableInfo;
    UINT UintOffset;
    UINT StringOffset;
} D3D10_SHADER_DEBUG_INFO;
typedef struct ID3D10ShaderReflection1 ID3D10ShaderReflection1;
typedef struct ID3D10ShaderReflection1* LPD3D10SHADERREFLECTION1;
extern "C" const GUID IID_ID3D10ShaderReflection1;
struct __declspec(novtable) ID3D10ShaderReflection1 : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDesc(D3D10_SHADER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionConstantBuffer* __stdcall GetConstantBufferByIndex(UINT Index) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionConstantBuffer* __stdcall GetConstantBufferByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetResourceBindingDesc(UINT ResourceIndex, D3D10_SHADER_INPUT_BIND_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetInputParameterDesc(UINT ParameterIndex, D3D10_SIGNATURE_PARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetOutputParameterDesc(UINT ParameterIndex, D3D10_SIGNATURE_PARAMETER_DESC* pDesc) = 0;
    virtual __declspec(nothrow) ID3D10ShaderReflectionVariable* __stdcall GetVariableByName(LPCSTR Name) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetResourceBindingDescByName(LPCSTR Name, D3D10_SHADER_INPUT_BIND_DESC* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMovInstructionCount(UINT* pCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetMovcInstructionCount(UINT* pCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetConversionInstructionCount(UINT* pCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBitwiseInstructionCount(UINT* pCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGSInputPrimitive(D3D10_PRIMITIVE* pPrim) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall IsLevel9Shader(BOOL* pbLevel9Shader) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall IsSampleFrequencyShader(BOOL* pbSampleFrequency) = 0;
};
extern "C" {
}
typedef HRESULT(__stdcall* PFN_D3D10_CREATE_DEVICE1)(IDXGIAdapter*,
    D3D10_DRIVER_TYPE, HMODULE, UINT, D3D10_FEATURE_LEVEL1, UINT, ID3D10Device1**);
HRESULT __stdcall D3D10CreateDevice1(
    IDXGIAdapter* pAdapter,
    D3D10_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    D3D10_FEATURE_LEVEL1 HardwareLevel,
    UINT SDKVersion,
    ID3D10Device1** ppDevice);
typedef HRESULT(__stdcall* PFN_D3D10_CREATE_DEVICE_AND_SWAP_CHAIN1)(IDXGIAdapter*,
    D3D10_DRIVER_TYPE, HMODULE, UINT, D3D10_FEATURE_LEVEL1, UINT, DXGI_SWAP_CHAIN_DESC*, IDXGISwapChain**, ID3D10Device1**);
HRESULT __stdcall D3D10CreateDeviceAndSwapChain1(
    IDXGIAdapter* pAdapter,
    D3D10_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    D3D10_FEATURE_LEVEL1 HardwareLevel,
    UINT SDKVersion,
    DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
    IDXGISwapChain** ppSwapChain,
    ID3D10Device1** ppDevice);
#pragma endregion
extern "C" const GUID IID_ID3D10BlendState1;
extern "C" const GUID IID_ID3D10ShaderResourceView1;
extern "C" const GUID IID_ID3D10Device1;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d10_1_0000_0003_v0_0_s_ifspec;
}
#pragma region Desktop Family
#pragma endregion
typedef HRESULT(__stdcall* PFN_D3D11_CREATE_DEVICE)(IDXGIAdapter*,
    D3D_DRIVER_TYPE, HMODULE, UINT,
    const D3D_FEATURE_LEVEL*,
    UINT FeatureLevels, UINT, ID3D11Device**,
    D3D_FEATURE_LEVEL*, ID3D11DeviceContext**);
HRESULT __stdcall D3D11CreateDevice(
    IDXGIAdapter* pAdapter,
    D3D_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    const D3D_FEATURE_LEVEL* pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    ID3D11Device** ppDevice,
    D3D_FEATURE_LEVEL* pFeatureLevel,
    ID3D11DeviceContext** ppImmediateContext);
#pragma region Desktop Family
typedef HRESULT(__stdcall* PFN_D3D11_CREATE_DEVICE_AND_SWAP_CHAIN)(IDXGIAdapter*,
    D3D_DRIVER_TYPE, HMODULE, UINT,
    const D3D_FEATURE_LEVEL*,
    UINT FeatureLevels, UINT, const DXGI_SWAP_CHAIN_DESC*,
    IDXGISwapChain**, ID3D11Device**,
    D3D_FEATURE_LEVEL*, ID3D11DeviceContext**);
HRESULT __stdcall D3D11CreateDeviceAndSwapChain(
    IDXGIAdapter* pAdapter,
    D3D_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    const D3D_FEATURE_LEVEL* pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    const DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
    IDXGISwapChain** ppSwapChain,
    ID3D11Device** ppDevice,
    D3D_FEATURE_LEVEL* pFeatureLevel,
    ID3D11DeviceContext** ppImmediateContext);
#pragma endregion
extern "C" const GUID IID_ID3D11DeviceChild;
extern "C" const GUID IID_ID3D11DepthStencilState;
extern "C" const GUID IID_ID3D11BlendState;
extern "C" const GUID IID_ID3D11RasterizerState;
extern "C" const GUID IID_ID3D11Resource;
extern "C" const GUID IID_ID3D11Buffer;
extern "C" const GUID IID_ID3D11Texture1D;
extern "C" const GUID IID_ID3D11Texture2D;
extern "C" const GUID IID_ID3D11Texture3D;
extern "C" const GUID IID_ID3D11View;
extern "C" const GUID IID_ID3D11ShaderResourceView;
extern "C" const GUID IID_ID3D11RenderTargetView;
extern "C" const GUID IID_ID3D11DepthStencilView;
extern "C" const GUID IID_ID3D11UnorderedAccessView;
extern "C" const GUID IID_ID3D11VertexShader;
extern "C" const GUID IID_ID3D11HullShader;
extern "C" const GUID IID_ID3D11DomainShader;
extern "C" const GUID IID_ID3D11GeometryShader;
extern "C" const GUID IID_ID3D11PixelShader;
extern "C" const GUID IID_ID3D11ComputeShader;
extern "C" const GUID IID_ID3D11InputLayout;
extern "C" const GUID IID_ID3D11SamplerState;
extern "C" const GUID IID_ID3D11Asynchronous;
extern "C" const GUID IID_ID3D11Query;
extern "C" const GUID IID_ID3D11Predicate;
extern "C" const GUID IID_ID3D11Counter;
extern "C" const GUID IID_ID3D11ClassInstance;
extern "C" const GUID IID_ID3D11ClassLinkage;
extern "C" const GUID IID_ID3D11CommandList;
extern "C" const GUID IID_ID3D11DeviceContext;
extern "C" const GUID IID_ID3D11VideoDecoder;
extern "C" const GUID IID_ID3D11VideoProcessorEnumerator;
extern "C" const GUID IID_ID3D11VideoProcessor;
extern "C" const GUID IID_ID3D11AuthenticatedChannel;
extern "C" const GUID IID_ID3D11CryptoSession;
extern "C" const GUID IID_ID3D11VideoDecoderOutputView;
extern "C" const GUID IID_ID3D11VideoProcessorInputView;
extern "C" const GUID IID_ID3D11VideoProcessorOutputView;
extern "C" const GUID IID_ID3D11VideoContext;
extern "C" const GUID IID_ID3D11VideoDevice;
extern "C" const GUID IID_ID3D11Device;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_d3d11_0000_0041_v0_0_s_ifspec;
}
#pragma external_header(push)
#pragma external_header(push)
#pragma warning(disable : 4049)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
HRESULT __stdcall D3DX11CheckVersion(UINT D3DSdkVersion, UINT D3DX11SdkVersion);
}
struct __declspec(novtable) ID3DX11DataLoader {
    virtual __declspec(nothrow) HRESULT __stdcall Load(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Decompress(void** ppData, SIZE_T* pcBytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Destroy(void) = 0;
};
struct __declspec(novtable) ID3DX11DataProcessor {
    virtual __declspec(nothrow) HRESULT __stdcall Process(void* pData, SIZE_T cBytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDeviceObject(void** ppDataObject) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Destroy(void) = 0;
};
extern "C" const GUID IID_ID3DX11ThreadPump;
struct __declspec(novtable) ID3DX11ThreadPump : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddWorkItem(ID3DX11DataLoader* pDataLoader, ID3DX11DataProcessor* pDataProcessor, HRESULT* pHResult, void** ppDeviceObject) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetWorkItemCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall WaitForAllItems(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ProcessDeviceWorkItems(UINT iWorkItemCount);
    virtual __declspec(nothrow) HRESULT __stdcall PurgeAllItems(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetQueueStatus(UINT* pIoQueue, UINT* pProcessQueue, UINT* pDeviceQueue) = 0;
};
extern "C" {
HRESULT __stdcall D3DX11CreateThreadPump(UINT cIoThreads, UINT cProcThreads, ID3DX11ThreadPump** ppThreadPump);
HRESULT __stdcall D3DX11UnsetAllDeviceObjects(ID3D11DeviceContext* pContext);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
typedef enum D3DX11_FILTER_FLAG {
    D3DX11_FILTER_NONE = (1 << 0),
    D3DX11_FILTER_POINT = (2 << 0),
    D3DX11_FILTER_LINEAR = (3 << 0),
    D3DX11_FILTER_TRIANGLE = (4 << 0),
    D3DX11_FILTER_BOX = (5 << 0),
    D3DX11_FILTER_MIRROR_U = (1 << 16),
    D3DX11_FILTER_MIRROR_V = (2 << 16),
    D3DX11_FILTER_MIRROR_W = (4 << 16),
    D3DX11_FILTER_MIRROR = (7 << 16),
    D3DX11_FILTER_DITHER = (1 << 19),
    D3DX11_FILTER_DITHER_DIFFUSION = (2 << 19),
    D3DX11_FILTER_SRGB_IN = (1 << 21),
    D3DX11_FILTER_SRGB_OUT = (2 << 21),
    D3DX11_FILTER_SRGB = (3 << 21),
} D3DX11_FILTER_FLAG;
typedef enum D3DX11_NORMALMAP_FLAG {
    D3DX11_NORMALMAP_MIRROR_U = (1 << 16),
    D3DX11_NORMALMAP_MIRROR_V = (2 << 16),
    D3DX11_NORMALMAP_MIRROR = (3 << 16),
    D3DX11_NORMALMAP_INVERTSIGN = (8 << 16),
    D3DX11_NORMALMAP_COMPUTE_OCCLUSION = (16 << 16),
} D3DX11_NORMALMAP_FLAG;
typedef enum D3DX11_CHANNEL_FLAG {
    D3DX11_CHANNEL_RED = (1 << 0),
    D3DX11_CHANNEL_BLUE = (1 << 1),
    D3DX11_CHANNEL_GREEN = (1 << 2),
    D3DX11_CHANNEL_ALPHA = (1 << 3),
    D3DX11_CHANNEL_LUMINANCE = (1 << 4),
} D3DX11_CHANNEL_FLAG;
typedef enum D3DX11_IMAGE_FILE_FORMAT {
    D3DX11_IFF_BMP = 0,
    D3DX11_IFF_JPG = 1,
    D3DX11_IFF_PNG = 3,
    D3DX11_IFF_DDS = 4,
    D3DX11_IFF_TIFF = 10,
    D3DX11_IFF_GIF = 11,
    D3DX11_IFF_WMP = 12,
    D3DX11_IFF_FORCE_DWORD = 0x7fffffff
} D3DX11_IMAGE_FILE_FORMAT;
typedef enum D3DX11_SAVE_TEXTURE_FLAG {
    D3DX11_STF_USEINPUTBLOB = 0x0001,
} D3DX11_SAVE_TEXTURE_FLAG;
typedef struct D3DX11_IMAGE_INFO {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT ArraySize;
    UINT MipLevels;
    UINT MiscFlags;
    DXGI_FORMAT Format;
    D3D11_RESOURCE_DIMENSION ResourceDimension;
    D3DX11_IMAGE_FILE_FORMAT ImageFileFormat;
} D3DX11_IMAGE_INFO;
extern "C" {
typedef struct D3DX11_IMAGE_LOAD_INFO {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT FirstMipLevel;
    UINT MipLevels;
    D3D11_USAGE Usage;
    UINT BindFlags;
    UINT CpuAccessFlags;
    UINT MiscFlags;
    DXGI_FORMAT Format;
    UINT Filter;
    UINT MipFilter;
    D3DX11_IMAGE_INFO* pSrcInfo;
    D3DX11_IMAGE_LOAD_INFO()
    {
        Width = ((UINT)-1);
        Height = ((UINT)-1);
        Depth = ((UINT)-1);
        FirstMipLevel = ((UINT)-1);
        MipLevels = ((UINT)-1);
        Usage = (D3D11_USAGE)((UINT)-1);
        BindFlags = ((UINT)-1);
        CpuAccessFlags = ((UINT)-1);
        MiscFlags = ((UINT)-1);
        Format = ((DXGI_FORMAT)-3);
        Filter = ((UINT)-1);
        MipFilter = ((UINT)-1);
        pSrcInfo = 0;
    }
} D3DX11_IMAGE_LOAD_INFO;
HRESULT __stdcall D3DX11GetImageInfoFromFileA(
    LPCSTR pSrcFile,
    ID3DX11ThreadPump* pPump,
    D3DX11_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11GetImageInfoFromFileW(
    LPCWSTR pSrcFile,
    ID3DX11ThreadPump* pPump,
    D3DX11_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11GetImageInfoFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    ID3DX11ThreadPump* pPump,
    D3DX11_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11GetImageInfoFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    ID3DX11ThreadPump* pPump,
    D3DX11_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11GetImageInfoFromMemory(
    LPCVOID pSrcData,
    SIZE_T SrcDataSize,
    ID3DX11ThreadPump* pPump,
    D3DX11_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateShaderResourceViewFromFileA(
    ID3D11Device* pDevice,
    LPCSTR pSrcFile,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateShaderResourceViewFromFileW(
    ID3D11Device* pDevice,
    LPCWSTR pSrcFile,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateTextureFromFileA(
    ID3D11Device* pDevice,
    LPCSTR pSrcFile,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateTextureFromFileW(
    ID3D11Device* pDevice,
    LPCWSTR pSrcFile,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateShaderResourceViewFromResourceA(
    ID3D11Device* pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateShaderResourceViewFromResourceW(
    ID3D11Device* pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateTextureFromResourceA(
    ID3D11Device* pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateTextureFromResourceW(
    ID3D11Device* pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateShaderResourceViewFromMemory(
    ID3D11Device* pDevice,
    LPCVOID pSrcData,
    SIZE_T SrcDataSize,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateTextureFromMemory(
    ID3D11Device* pDevice,
    LPCVOID pSrcData,
    SIZE_T SrcDataSize,
    D3DX11_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX11ThreadPump* pPump,
    ID3D11Resource** ppTexture,
    HRESULT* pHResult);
typedef struct _D3DX11_TEXTURE_LOAD_INFO {
    D3D11_BOX* pSrcBox;
    D3D11_BOX* pDstBox;
    UINT SrcFirstMip;
    UINT DstFirstMip;
    UINT NumMips;
    UINT SrcFirstElement;
    UINT DstFirstElement;
    UINT NumElements;
    UINT Filter;
    UINT MipFilter;
    _D3DX11_TEXTURE_LOAD_INFO()
    {
        pSrcBox = 0;
        pDstBox = 0;
        SrcFirstMip = 0;
        DstFirstMip = 0;
        NumMips = ((UINT)-1);
        SrcFirstElement = 0;
        DstFirstElement = 0;
        NumElements = ((UINT)-1);
        Filter = ((UINT)-1);
        MipFilter = ((UINT)-1);
    }
} D3DX11_TEXTURE_LOAD_INFO;
HRESULT __stdcall D3DX11LoadTextureFromTexture(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pSrcTexture,
    D3DX11_TEXTURE_LOAD_INFO* pLoadInfo,
    ID3D11Resource* pDstTexture);
HRESULT __stdcall D3DX11FilterTexture(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pTexture,
    UINT SrcLevel,
    UINT MipFilter);
HRESULT __stdcall D3DX11SaveTextureToFileA(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pSrcTexture,
    D3DX11_IMAGE_FILE_FORMAT DestFormat,
    LPCSTR pDestFile);
HRESULT __stdcall D3DX11SaveTextureToFileW(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pSrcTexture,
    D3DX11_IMAGE_FILE_FORMAT DestFormat,
    LPCWSTR pDestFile);
HRESULT __stdcall D3DX11SaveTextureToMemory(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pSrcTexture,
    D3DX11_IMAGE_FILE_FORMAT DestFormat,
    ID3D10Blob** ppDestBuf,
    UINT Flags);
HRESULT __stdcall D3DX11ComputeNormalMap(
    ID3D11DeviceContext* pContext,
    ID3D11Texture2D* pSrcTexture,
    UINT Flags,
    UINT Channel,
    FLOAT Amplitude,
    ID3D11Texture2D* pDestTexture);
HRESULT __stdcall D3DX11SHProjectCubeMap(
    ID3D11DeviceContext* pContext,
    UINT Order,
    ID3D11Texture2D* pCubeMap,
    FLOAT* pROut,
    FLOAT* pGOut,
    FLOAT* pBOut);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
HRESULT __stdcall D3DX11CompileFromFileA(LPCSTR pSrcFile, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11CompileFromFileW(LPCWSTR pSrcFile, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11CompileFromResourceA(HMODULE hSrcModule, LPCSTR pSrcResource, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11CompileFromResourceW(HMODULE hSrcModule, LPCWSTR pSrcResource, LPCWSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11CompileFromMemory(LPCSTR pSrcData, SIZE_T SrcDataLen, LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11PreprocessShaderFromFileA(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11PreprocessShaderFromFileW(LPCWSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11PreprocessShaderFromMemory(LPCSTR pSrcData, SIZE_T SrcDataSize, LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11PreprocessShaderFromResourceA(HMODULE hModule, LPCSTR pResourceName, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11PreprocessShaderFromResourceW(HMODULE hModule, LPCWSTR pResourceName, LPCWSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX11ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX11CreateAsyncCompilerProcessor(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2,
    ID3D10Blob** ppCompiledShader, ID3D10Blob** ppErrorBuffer, ID3DX11DataProcessor** ppProcessor);
HRESULT __stdcall D3DX11CreateAsyncShaderPreprocessProcessor(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorBuffer, ID3DX11DataProcessor** ppProcessor);
HRESULT __stdcall D3DX11CreateAsyncFileLoaderW(LPCWSTR pFileName, ID3DX11DataLoader** ppDataLoader);
HRESULT __stdcall D3DX11CreateAsyncFileLoaderA(LPCSTR pFileName, ID3DX11DataLoader** ppDataLoader);
HRESULT __stdcall D3DX11CreateAsyncMemoryLoader(LPCVOID pData, SIZE_T cbData, ID3DX11DataLoader** ppDataLoader);
HRESULT __stdcall D3DX11CreateAsyncResourceLoaderW(HMODULE hSrcModule, LPCWSTR pSrcResource, ID3DX11DataLoader** ppDataLoader);
HRESULT __stdcall D3DX11CreateAsyncResourceLoaderA(HMODULE hSrcModule, LPCSTR pSrcResource, ID3DX11DataLoader** ppDataLoader);
HRESULT __stdcall D3DX11CreateAsyncTextureProcessor(ID3D11Device* pDevice, D3DX11_IMAGE_LOAD_INFO* pLoadInfo, ID3DX11DataProcessor** ppDataProcessor);
HRESULT __stdcall D3DX11CreateAsyncTextureInfoProcessor(D3DX11_IMAGE_INFO* pImageInfo, ID3DX11DataProcessor** ppDataProcessor);
HRESULT __stdcall D3DX11CreateAsyncShaderResourceViewProcessor(ID3D11Device* pDevice, D3DX11_IMAGE_LOAD_INFO* pLoadInfo, ID3DX11DataProcessor** ppDataProcessor);
}
#pragma external_header(pop)
enum _D3DX11_ERR {
    D3DX11_ERR_CANNOT_MODIFY_INDEX_BUFFER = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2900)))),
    D3DX11_ERR_INVALID_MESH = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2901)))),
    D3DX11_ERR_CANNOT_ATTR_SORT = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2902)))),
    D3DX11_ERR_SKINNING_NOT_SUPPORTED = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2903)))),
    D3DX11_ERR_TOO_MANY_INFLUENCES = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2904)))),
    D3DX11_ERR_INVALID_DATA = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2905)))),
    D3DX11_ERR_LOADED_MESH_HAS_NO_DATA = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2906)))),
    D3DX11_ERR_DUPLICATE_NAMED_FRAGMENT = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2907)))),
    D3DX11_ERR_CANNOT_REMOVE_LAST_ITEM = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2908)))),
};
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma warning(disable : 4049)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
HRESULT __stdcall D3DX10CreateDevice(IDXGIAdapter* pAdapter,
    D3D10_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    ID3D10Device** ppDevice);
HRESULT __stdcall D3DX10CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
    D3D10_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
    IDXGISwapChain** ppSwapChain,
    ID3D10Device** ppDevice);
typedef struct ID3D10Device1 ID3D10Device1;
HRESULT __stdcall D3DX10GetFeatureLevel1(ID3D10Device* pDevice, ID3D10Device1** ppDevice1);
HRESULT __stdcall D3DX10CheckVersion(UINT D3DSdkVersion, UINT D3DX10SdkVersion);
}
typedef enum _D3DX10_SPRITE_FLAG {
    D3DX10_SPRITE_SORT_TEXTURE = 0x01,
    D3DX10_SPRITE_SORT_DEPTH_BACK_TO_FRONT = 0x02,
    D3DX10_SPRITE_SORT_DEPTH_FRONT_TO_BACK = 0x04,
    D3DX10_SPRITE_SAVE_STATE = 0x08,
    D3DX10_SPRITE_ADDREF_TEXTURES = 0x10,
} D3DX10_SPRITE_FLAG;
typedef struct _D3DX10_SPRITE {
    D3DXMATRIX matWorld;
    D3DXVECTOR2 TexCoord;
    D3DXVECTOR2 TexSize;
    D3DXCOLOR ColorModulate;
    ID3D10ShaderResourceView* pTexture;
    UINT TextureIndex;
} D3DX10_SPRITE;
typedef struct ID3DX10Sprite ID3DX10Sprite;
typedef struct ID3DX10Sprite* LPD3DX10SPRITE;
extern "C" const GUID IID_ID3DX10Sprite;
struct __declspec(novtable) ID3DX10Sprite : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Begin(UINT flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSpritesBuffered(D3DX10_SPRITE* pSprites, UINT cSprites) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Flush(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSpritesImmediate(D3DX10_SPRITE* pSprites, UINT cSprites, UINT cbSprite, UINT flags) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall End(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetViewTransform(D3DXMATRIX* pViewTransform) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetViewTransform(D3DXMATRIX* pViewTransform) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetProjectionTransform(D3DXMATRIX* pProjectionTransform) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetProjectionTransform(D3DXMATRIX* pProjectionTransform) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(ID3D10Device** ppDevice) = 0;
};
extern "C" {
HRESULT __stdcall D3DX10CreateSprite(
    ID3D10Device* pDevice,
    UINT cDeviceBufferSize,
    LPD3DX10SPRITE* ppSprite);
}
struct __declspec(novtable) ID3DX10DataLoader {
    virtual __declspec(nothrow) HRESULT __stdcall Load(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Decompress(void** ppData, SIZE_T* pcBytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Destroy(void) = 0;
};
struct __declspec(novtable) ID3DX10DataProcessor {
    virtual __declspec(nothrow) HRESULT __stdcall Process(void* pData, SIZE_T cBytes) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CreateDeviceObject(void** ppDataObject) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Destroy(void) = 0;
};
extern "C" const GUID IID_ID3DX10ThreadPump;
struct __declspec(novtable) ID3DX10ThreadPump : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddWorkItem(ID3DX10DataLoader* pDataLoader, ID3DX10DataProcessor* pDataProcessor, HRESULT* pHResult, void** ppDeviceObject) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetWorkItemCount(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall WaitForAllItems(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ProcessDeviceWorkItems(UINT iWorkItemCount);
    virtual __declspec(nothrow) HRESULT __stdcall PurgeAllItems(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetQueueStatus(UINT* pIoQueue, UINT* pProcessQueue, UINT* pDeviceQueue) = 0;
};
HRESULT __stdcall D3DX10CreateThreadPump(UINT cIoThreads, UINT cProcThreads, ID3DX10ThreadPump** ppThreadPump);
typedef struct _D3DX10_FONT_DESCA {
    INT Height;
    UINT Width;
    UINT Weight;
    UINT MipLevels;
    BOOL Italic;
    BYTE CharSet;
    BYTE OutputPrecision;
    BYTE Quality;
    BYTE PitchAndFamily;
    CHAR FaceName[32];
} D3DX10_FONT_DESCA, *LPD3DX10_FONT_DESCA;
typedef struct _D3DX10_FONT_DESCW {
    INT Height;
    UINT Width;
    UINT Weight;
    UINT MipLevels;
    BOOL Italic;
    BYTE CharSet;
    BYTE OutputPrecision;
    BYTE Quality;
    BYTE PitchAndFamily;
    WCHAR FaceName[32];
} D3DX10_FONT_DESCW, *LPD3DX10_FONT_DESCW;
typedef D3DX10_FONT_DESCW D3DX10_FONT_DESC;
typedef LPD3DX10_FONT_DESCW LPD3DX10_FONT_DESC;
typedef struct ID3DX10Font ID3DX10Font;
typedef struct ID3DX10Font* LPD3DX10FONT;
extern "C" const GUID IID_ID3DX10Font;
struct __declspec(novtable) ID3DX10Font : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDevice(ID3D10Device** ppDevice) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDescA(D3DX10_FONT_DESCA* pDesc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDescW(D3DX10_FONT_DESCW* pDesc) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetTextMetricsA(TEXTMETRICA* pTextMetrics) = 0;
    virtual __declspec(nothrow) BOOL __stdcall GetTextMetricsW(TEXTMETRICW* pTextMetrics) = 0;
    virtual __declspec(nothrow) HDC __stdcall GetDC(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetGlyphData(UINT Glyph, ID3D10ShaderResourceView** ppTexture, RECT* pBlackBox, POINT* pCellInc) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadCharacters(UINT First, UINT Last) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadGlyphs(UINT First, UINT Last) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadTextA(LPCSTR pString, INT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall PreloadTextW(LPCWSTR pString, INT Count) = 0;
    virtual __declspec(nothrow) INT __stdcall DrawTextA(LPD3DX10SPRITE pSprite, LPCSTR pString, INT Count, LPRECT pRect, UINT Format, D3DXCOLOR Color) = 0;
    virtual __declspec(nothrow) INT __stdcall DrawTextW(LPD3DX10SPRITE pSprite, LPCWSTR pString, INT Count, LPRECT pRect, UINT Format, D3DXCOLOR Color) = 0;
    HRESULT __stdcall GetDesc(D3DX10_FONT_DESCW* pDesc) { return GetDescW(pDesc); }
    HRESULT __stdcall PreloadText(LPCWSTR pString, INT Count) { return PreloadTextW(pString, Count); }
};
extern "C" {
HRESULT __stdcall D3DX10CreateFontA(
    ID3D10Device* pDevice,
    INT Height,
    UINT Width,
    UINT Weight,
    UINT MipLevels,
    BOOL Italic,
    UINT CharSet,
    UINT OutputPrecision,
    UINT Quality,
    UINT PitchAndFamily,
    LPCSTR pFaceName,
    LPD3DX10FONT* ppFont);
HRESULT __stdcall D3DX10CreateFontW(
    ID3D10Device* pDevice,
    INT Height,
    UINT Width,
    UINT Weight,
    UINT MipLevels,
    BOOL Italic,
    UINT CharSet,
    UINT OutputPrecision,
    UINT Quality,
    UINT PitchAndFamily,
    LPCWSTR pFaceName,
    LPD3DX10FONT* ppFont);
HRESULT __stdcall D3DX10CreateFontIndirectA(
    ID3D10Device* pDevice,
    const D3DX10_FONT_DESCA* pDesc,
    LPD3DX10FONT* ppFont);
HRESULT __stdcall D3DX10CreateFontIndirectW(
    ID3D10Device* pDevice,
    const D3DX10_FONT_DESCW* pDesc,
    LPD3DX10FONT* ppFont);
HRESULT __stdcall D3DX10UnsetAllDeviceObjects(ID3D10Device* pDevice);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
typedef enum D3DX10_FILTER_FLAG {
    D3DX10_FILTER_NONE = (1 << 0),
    D3DX10_FILTER_POINT = (2 << 0),
    D3DX10_FILTER_LINEAR = (3 << 0),
    D3DX10_FILTER_TRIANGLE = (4 << 0),
    D3DX10_FILTER_BOX = (5 << 0),
    D3DX10_FILTER_MIRROR_U = (1 << 16),
    D3DX10_FILTER_MIRROR_V = (2 << 16),
    D3DX10_FILTER_MIRROR_W = (4 << 16),
    D3DX10_FILTER_MIRROR = (7 << 16),
    D3DX10_FILTER_DITHER = (1 << 19),
    D3DX10_FILTER_DITHER_DIFFUSION = (2 << 19),
    D3DX10_FILTER_SRGB_IN = (1 << 21),
    D3DX10_FILTER_SRGB_OUT = (2 << 21),
    D3DX10_FILTER_SRGB = (3 << 21),
} D3DX10_FILTER_FLAG;
typedef enum D3DX10_NORMALMAP_FLAG {
    D3DX10_NORMALMAP_MIRROR_U = (1 << 16),
    D3DX10_NORMALMAP_MIRROR_V = (2 << 16),
    D3DX10_NORMALMAP_MIRROR = (3 << 16),
    D3DX10_NORMALMAP_INVERTSIGN = (8 << 16),
    D3DX10_NORMALMAP_COMPUTE_OCCLUSION = (16 << 16),
} D3DX10_NORMALMAP_FLAG;
typedef enum D3DX10_CHANNEL_FLAG {
    D3DX10_CHANNEL_RED = (1 << 0),
    D3DX10_CHANNEL_BLUE = (1 << 1),
    D3DX10_CHANNEL_GREEN = (1 << 2),
    D3DX10_CHANNEL_ALPHA = (1 << 3),
    D3DX10_CHANNEL_LUMINANCE = (1 << 4),
} D3DX10_CHANNEL_FLAG;
typedef enum D3DX10_IMAGE_FILE_FORMAT {
    D3DX10_IFF_BMP = 0,
    D3DX10_IFF_JPG = 1,
    D3DX10_IFF_PNG = 3,
    D3DX10_IFF_DDS = 4,
    D3DX10_IFF_TIFF = 10,
    D3DX10_IFF_GIF = 11,
    D3DX10_IFF_WMP = 12,
    D3DX10_IFF_FORCE_DWORD = 0x7fffffff
} D3DX10_IMAGE_FILE_FORMAT;
typedef enum D3DX10_SAVE_TEXTURE_FLAG {
    D3DX10_STF_USEINPUTBLOB = 0x0001,
} D3DX10_SAVE_TEXTURE_FLAG;
typedef struct D3DX10_IMAGE_INFO {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT ArraySize;
    UINT MipLevels;
    UINT MiscFlags;
    DXGI_FORMAT Format;
    D3D10_RESOURCE_DIMENSION ResourceDimension;
    D3DX10_IMAGE_FILE_FORMAT ImageFileFormat;
} D3DX10_IMAGE_INFO;
extern "C" {
typedef struct D3DX10_IMAGE_LOAD_INFO {
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT FirstMipLevel;
    UINT MipLevels;
    D3D10_USAGE Usage;
    UINT BindFlags;
    UINT CpuAccessFlags;
    UINT MiscFlags;
    DXGI_FORMAT Format;
    UINT Filter;
    UINT MipFilter;
    D3DX10_IMAGE_INFO* pSrcInfo;
    D3DX10_IMAGE_LOAD_INFO()
    {
        Width = ((UINT)-1);
        Height = ((UINT)-1);
        Depth = ((UINT)-1);
        FirstMipLevel = ((UINT)-1);
        MipLevels = ((UINT)-1);
        Usage = (D3D10_USAGE)((UINT)-1);
        BindFlags = ((UINT)-1);
        CpuAccessFlags = ((UINT)-1);
        MiscFlags = ((UINT)-1);
        Format = ((DXGI_FORMAT)-3);
        Filter = ((UINT)-1);
        MipFilter = ((UINT)-1);
        pSrcInfo = 0;
    }
} D3DX10_IMAGE_LOAD_INFO;
HRESULT __stdcall D3DX10GetImageInfoFromFileA(
    LPCSTR pSrcFile,
    ID3DX10ThreadPump* pPump,
    D3DX10_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10GetImageInfoFromFileW(
    LPCWSTR pSrcFile,
    ID3DX10ThreadPump* pPump,
    D3DX10_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10GetImageInfoFromResourceA(
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    ID3DX10ThreadPump* pPump,
    D3DX10_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10GetImageInfoFromResourceW(
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    ID3DX10ThreadPump* pPump,
    D3DX10_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10GetImageInfoFromMemory(
    LPCVOID pSrcData,
    SIZE_T SrcDataSize,
    ID3DX10ThreadPump* pPump,
    D3DX10_IMAGE_INFO* pSrcInfo,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateShaderResourceViewFromFileA(
    ID3D10Device* pDevice,
    LPCSTR pSrcFile,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateShaderResourceViewFromFileW(
    ID3D10Device* pDevice,
    LPCWSTR pSrcFile,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateTextureFromFileA(
    ID3D10Device* pDevice,
    LPCSTR pSrcFile,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateTextureFromFileW(
    ID3D10Device* pDevice,
    LPCWSTR pSrcFile,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateShaderResourceViewFromResourceA(
    ID3D10Device* pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateShaderResourceViewFromResourceW(
    ID3D10Device* pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateTextureFromResourceA(
    ID3D10Device* pDevice,
    HMODULE hSrcModule,
    LPCSTR pSrcResource,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateTextureFromResourceW(
    ID3D10Device* pDevice,
    HMODULE hSrcModule,
    LPCWSTR pSrcResource,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10Resource** ppTexture,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateShaderResourceViewFromMemory(
    ID3D10Device* pDevice,
    LPCVOID pSrcData,
    SIZE_T SrcDataSize,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10ShaderResourceView** ppShaderResourceView,
    HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateTextureFromMemory(
    ID3D10Device* pDevice,
    LPCVOID pSrcData,
    SIZE_T SrcDataSize,
    D3DX10_IMAGE_LOAD_INFO* pLoadInfo,
    ID3DX10ThreadPump* pPump,
    ID3D10Resource** ppTexture,
    HRESULT* pHResult);
typedef struct _D3DX10_TEXTURE_LOAD_INFO {
    D3D10_BOX* pSrcBox;
    D3D10_BOX* pDstBox;
    UINT SrcFirstMip;
    UINT DstFirstMip;
    UINT NumMips;
    UINT SrcFirstElement;
    UINT DstFirstElement;
    UINT NumElements;
    UINT Filter;
    UINT MipFilter;
    _D3DX10_TEXTURE_LOAD_INFO()
    {
        pSrcBox = 0;
        pDstBox = 0;
        SrcFirstMip = 0;
        DstFirstMip = 0;
        NumMips = ((UINT)-1);
        SrcFirstElement = 0;
        DstFirstElement = 0;
        NumElements = ((UINT)-1);
        Filter = ((UINT)-1);
        MipFilter = ((UINT)-1);
    }
} D3DX10_TEXTURE_LOAD_INFO;
HRESULT __stdcall D3DX10LoadTextureFromTexture(
    ID3D10Resource* pSrcTexture,
    D3DX10_TEXTURE_LOAD_INFO* pLoadInfo,
    ID3D10Resource* pDstTexture);
HRESULT __stdcall D3DX10FilterTexture(
    ID3D10Resource* pTexture,
    UINT SrcLevel,
    UINT MipFilter);
HRESULT __stdcall D3DX10SaveTextureToFileA(
    ID3D10Resource* pSrcTexture,
    D3DX10_IMAGE_FILE_FORMAT DestFormat,
    LPCSTR pDestFile);
HRESULT __stdcall D3DX10SaveTextureToFileW(
    ID3D10Resource* pSrcTexture,
    D3DX10_IMAGE_FILE_FORMAT DestFormat,
    LPCWSTR pDestFile);
HRESULT __stdcall D3DX10SaveTextureToMemory(
    ID3D10Resource* pSrcTexture,
    D3DX10_IMAGE_FILE_FORMAT DestFormat,
    LPD3D10BLOB* ppDestBuf,
    UINT Flags);
HRESULT __stdcall D3DX10ComputeNormalMap(
    ID3D10Texture2D* pSrcTexture,
    UINT Flags,
    UINT Channel,
    FLOAT Amplitude,
    ID3D10Texture2D* pDestTexture);
HRESULT __stdcall D3DX10SHProjectCubeMap(
    UINT Order,
    ID3D10Texture2D* pCubeMap,
    FLOAT* pROut,
    FLOAT* pGOut,
    FLOAT* pBOut);
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" const GUID IID_ID3DX10BaseMesh;
extern "C" const GUID IID_ID3DX10MeshBuffer;
extern "C" const GUID IID_ID3DX10Mesh;
extern "C" const GUID IID_ID3DX10PMesh;
extern "C" const GUID IID_ID3DX10SPMesh;
extern "C" const GUID IID_ID3DX10PatchMesh;
enum _D3DX10_MESH {
    D3DX10_MESH_32_BIT = 0x001,
    D3DX10_MESH_GS_ADJACENCY = 0x004,
};
typedef struct _D3DX10_ATTRIBUTE_RANGE {
    UINT AttribId;
    UINT FaceStart;
    UINT FaceCount;
    UINT VertexStart;
    UINT VertexCount;
} D3DX10_ATTRIBUTE_RANGE;
typedef D3DX10_ATTRIBUTE_RANGE* LPD3DX10_ATTRIBUTE_RANGE;
typedef enum _D3DX10_MESH_DISCARD_FLAGS {
    D3DX10_MESH_DISCARD_ATTRIBUTE_BUFFER = 0x01,
    D3DX10_MESH_DISCARD_ATTRIBUTE_TABLE = 0x02,
    D3DX10_MESH_DISCARD_POINTREPS = 0x04,
    D3DX10_MESH_DISCARD_ADJACENCY = 0x08,
    D3DX10_MESH_DISCARD_DEVICE_BUFFERS = 0x10,
} D3DX10_MESH_DISCARD_FLAGS;
typedef struct _D3DX10_WELD_EPSILONS {
    FLOAT Position;
    FLOAT BlendWeights;
    FLOAT Normal;
    FLOAT PSize;
    FLOAT Specular;
    FLOAT Diffuse;
    FLOAT Texcoord[8];
    FLOAT Tangent;
    FLOAT Binormal;
    FLOAT TessFactor;
} D3DX10_WELD_EPSILONS;
typedef D3DX10_WELD_EPSILONS* LPD3DX10_WELD_EPSILONS;
typedef struct _D3DX10_INTERSECT_INFO {
    UINT FaceIndex;
    FLOAT U;
    FLOAT V;
    FLOAT Dist;
} D3DX10_INTERSECT_INFO, *LPD3DX10_INTERSECT_INFO;
struct __declspec(novtable) ID3DX10MeshBuffer : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Map(void** ppData, SIZE_T* pSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Unmap(void) = 0;
    virtual __declspec(nothrow) SIZE_T __stdcall GetSize(void) = 0;
};
struct __declspec(novtable) ID3DX10Mesh : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetFaceCount(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetVertexCount(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetVertexBufferCount(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetFlags(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexDescription(const D3D10_INPUT_ELEMENT_DESC** ppDesc, UINT* pDeclCount) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetVertexData(UINT iBuffer, const void* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetVertexBuffer(UINT iBuffer, ID3DX10MeshBuffer** ppVertexBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetIndexData(const void* pData, UINT cIndices) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetIndexBuffer(ID3DX10MeshBuffer** ppIndexBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAttributeData(const UINT* pData) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAttributeBuffer(ID3DX10MeshBuffer** ppAttributeBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAttributeTable(const D3DX10_ATTRIBUTE_RANGE* pAttribTable, UINT cAttribTableSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAttributeTable(D3DX10_ATTRIBUTE_RANGE* pAttribTable, UINT* pAttribTableSize) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateAdjacencyAndPointReps(FLOAT Epsilon) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateGSAdjacency(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetAdjacencyData(const UINT* pAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetAdjacencyBuffer(ID3DX10MeshBuffer** ppAdjacency) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetPointRepData(const UINT* pPointReps) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetPointRepBuffer(ID3DX10MeshBuffer** ppPointReps) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Discard(D3DX10_MESH_DISCARD_FLAGS dwDiscard) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall CloneMesh(UINT Flags, LPCSTR pPosSemantic, const D3D10_INPUT_ELEMENT_DESC* pDesc, UINT DeclCount, ID3DX10Mesh** ppCloneMesh) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Optimize(UINT Flags, UINT* pFaceRemap, LPD3D10BLOB* ppVertexRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GenerateAttributeBufferFromTable(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Intersect(D3DXVECTOR3* pRayPos, D3DXVECTOR3* pRayDir,
        UINT* pHitCount, UINT* pFaceIndex, float* pU, float* pV, float* pDist, ID3D10Blob** ppAllHits);
    virtual __declspec(nothrow) HRESULT __stdcall IntersectSubset(UINT AttribId, D3DXVECTOR3* pRayPos, D3DXVECTOR3* pRayDir,
        UINT* pHitCount, UINT* pFaceIndex, float* pU, float* pV, float* pDist, ID3D10Blob** ppAllHits);
    virtual __declspec(nothrow) HRESULT __stdcall CommitToDevice(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSubset(UINT AttribId) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DrawSubsetInstanced(UINT AttribId, UINT InstanceCount, UINT StartInstanceLocation) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeviceVertexBuffer(UINT iBuffer, ID3D10Buffer** ppVertexBuffer) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetDeviceIndexBuffer(ID3D10Buffer** ppIndexBuffer) = 0;
};
extern "C" {
HRESULT __stdcall D3DX10CreateMesh(
    ID3D10Device* pDevice,
    const D3D10_INPUT_ELEMENT_DESC* pDeclaration,
    UINT DeclCount,
    LPCSTR pPositionSemantic,
    UINT VertexCount,
    UINT FaceCount,
    UINT Options,
    ID3DX10Mesh** ppMesh);
}
enum _D3DX10_MESHOPT {
    D3DX10_MESHOPT_COMPACT = 0x01000000,
    D3DX10_MESHOPT_ATTR_SORT = 0x02000000,
    D3DX10_MESHOPT_VERTEX_CACHE = 0x04000000,
    D3DX10_MESHOPT_STRIP_REORDER = 0x08000000,
    D3DX10_MESHOPT_IGNORE_VERTS = 0x10000000,
    D3DX10_MESHOPT_DO_NOT_SPLIT = 0x20000000,
    D3DX10_MESHOPT_DEVICE_INDEPENDENT = 0x00400000,
};
extern "C" const GUID IID_ID3DX10SkinInfo;
typedef struct _D3DX10_SKINNING_CHANNEL {
    UINT SrcOffset;
    UINT DestOffset;
    BOOL IsNormal;
} D3DX10_SKINNING_CHANNEL;
typedef struct ID3DX10SkinInfo* LPD3DX10SKININFO;
struct __declspec(novtable) ID3DX10SkinInfo : public IUnknown {
    virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& iid, LPVOID* ppv) = 0;
    virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
    virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumVertices(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetNumBones(void) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetMaxBoneInfluences(void) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddVertices(UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RemapVertices(UINT NewVertexCount, UINT* pVertexRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddBones(UINT Count) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RemoveBone(UINT Index) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall RemapBones(UINT NewBoneCount, UINT* pBoneRemap) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall AddBoneInfluences(UINT BoneIndex, UINT InfluenceCount, UINT* pIndices, float* pWeights) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall ClearBoneInfluences(UINT BoneIndex) = 0;
    virtual __declspec(nothrow) UINT __stdcall GetBoneInfluenceCount(UINT BoneIndex) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoneInfluences(UINT BoneIndex, UINT Offset, UINT Count, UINT* pDestIndices, float* pDestWeights) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall FindBoneInfluenceIndex(UINT BoneIndex, UINT VertexIndex, UINT* pInfluenceIndex) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall SetBoneInfluence(UINT BoneIndex, UINT InfluenceIndex, float Weight) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall GetBoneInfluence(UINT BoneIndex, UINT InfluenceIndex, float* pWeight) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall Compact(UINT MaxPerVertexInfluences, UINT ScaleMode, float MinWeight) = 0;
    virtual __declspec(nothrow) HRESULT __stdcall DoSoftwareSkinning(UINT StartVertex, UINT VertexCount, void* pSrcVertices, UINT SrcStride, void* pDestVertices, UINT DestStride, D3DXMATRIX* pBoneMatrices, D3DXMATRIX* pInverseTransposeBoneMatrices, D3DX10_SKINNING_CHANNEL* pChannelDescs, UINT NumChannels) = 0;
};
extern "C" {
HRESULT __stdcall D3DX10CreateSkinInfo(LPD3DX10SKININFO* ppSkinInfo);
}
typedef struct _D3DX10_ATTRIBUTE_WEIGHTS {
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Texcoord[8];
    FLOAT Tangent;
    FLOAT Binormal;
} D3DX10_ATTRIBUTE_WEIGHTS, *LPD3DX10_ATTRIBUTE_WEIGHTS;
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(push)
#pragma external_header(pop)
extern "C" {
HRESULT __stdcall D3DX10CompileFromFileA(LPCSTR pSrcFile, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10CompileFromFileW(LPCWSTR pSrcFile, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10CompileFromResourceA(HMODULE hSrcModule, LPCSTR pSrcResource, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10CompileFromResourceW(HMODULE hSrcModule, LPCWSTR pSrcResource, LPCWSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10CompileFromMemory(LPCSTR pSrcData, SIZE_T SrcDataLen, LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShader, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectFromFileA(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pEffectPool, ID3DX10ThreadPump* pPump, ID3D10Effect** ppEffect, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectFromFileW(LPCWSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pEffectPool, ID3DX10ThreadPump* pPump, ID3D10Effect** ppEffect, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectFromMemory(LPCVOID pData, SIZE_T DataLength, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pEffectPool, ID3DX10ThreadPump* pPump, ID3D10Effect** ppEffect, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectFromResourceA(HMODULE hModule, LPCSTR pResourceName, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pEffectPool, ID3DX10ThreadPump* pPump, ID3D10Effect** ppEffect, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectFromResourceW(HMODULE hModule, LPCWSTR pResourceName, LPCWSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pEffectPool, ID3DX10ThreadPump* pPump, ID3D10Effect** ppEffect, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectPoolFromFileA(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice, ID3DX10ThreadPump* pPump,
    ID3D10EffectPool** ppEffectPool, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectPoolFromFileW(LPCWSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice, ID3DX10ThreadPump* pPump,
    ID3D10EffectPool** ppEffectPool, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectPoolFromMemory(LPCVOID pData, SIZE_T DataLength, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3DX10ThreadPump* pPump, ID3D10EffectPool** ppEffectPool, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectPoolFromResourceA(HMODULE hModule, LPCSTR pResourceName, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3DX10ThreadPump* pPump, ID3D10EffectPool** ppEffectPool, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateEffectPoolFromResourceW(HMODULE hModule, LPCWSTR pResourceName, LPCWSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    ID3D10Include* pInclude, LPCSTR pProfile, UINT HLSLFlags, UINT FXFlags, ID3D10Device* pDevice,
    ID3DX10ThreadPump* pPump, ID3D10EffectPool** ppEffectPool, ID3D10Blob** ppErrors, HRESULT* pHResult);
HRESULT __stdcall D3DX10PreprocessShaderFromFileA(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10PreprocessShaderFromFileW(LPCWSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10PreprocessShaderFromMemory(LPCSTR pSrcData, SIZE_T SrcDataSize, LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10PreprocessShaderFromResourceA(HMODULE hModule, LPCSTR pResourceName, LPCSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10PreprocessShaderFromResourceW(HMODULE hModule, LPCWSTR pResourceName, LPCWSTR pSrcFileName, const D3D10_SHADER_MACRO* pDefines,
    LPD3D10INCLUDE pInclude, ID3DX10ThreadPump* pPump, ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorMsgs, HRESULT* pHResult);
HRESULT __stdcall D3DX10CreateAsyncCompilerProcessor(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pFunctionName, LPCSTR pProfile, UINT Flags1, UINT Flags2,
    ID3D10Blob** ppCompiledShader, ID3D10Blob** ppErrorBuffer, ID3DX10DataProcessor** ppProcessor);
HRESULT __stdcall D3DX10CreateAsyncEffectCreateProcessor(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pProfile, UINT Flags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10EffectPool* pPool, ID3D10Blob** ppErrorBuffer, ID3DX10DataProcessor** ppProcessor);
HRESULT __stdcall D3DX10CreateAsyncEffectPoolCreateProcessor(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    LPCSTR pProfile, UINT Flags, UINT FXFlags, ID3D10Device* pDevice,
    ID3D10Blob** ppErrorBuffer, ID3DX10DataProcessor** ppProcessor);
HRESULT __stdcall D3DX10CreateAsyncShaderPreprocessProcessor(LPCSTR pFileName, const D3D10_SHADER_MACRO* pDefines, LPD3D10INCLUDE pInclude,
    ID3D10Blob** ppShaderText, ID3D10Blob** ppErrorBuffer, ID3DX10DataProcessor** ppProcessor);
HRESULT __stdcall D3DX10CreateAsyncFileLoaderW(LPCWSTR pFileName, ID3DX10DataLoader** ppDataLoader);
HRESULT __stdcall D3DX10CreateAsyncFileLoaderA(LPCSTR pFileName, ID3DX10DataLoader** ppDataLoader);
HRESULT __stdcall D3DX10CreateAsyncMemoryLoader(LPCVOID pData, SIZE_T cbData, ID3DX10DataLoader** ppDataLoader);
HRESULT __stdcall D3DX10CreateAsyncResourceLoaderW(HMODULE hSrcModule, LPCWSTR pSrcResource, ID3DX10DataLoader** ppDataLoader);
HRESULT __stdcall D3DX10CreateAsyncResourceLoaderA(HMODULE hSrcModule, LPCSTR pSrcResource, ID3DX10DataLoader** ppDataLoader);
HRESULT __stdcall D3DX10CreateAsyncTextureProcessor(ID3D10Device* pDevice, D3DX10_IMAGE_LOAD_INFO* pLoadInfo, ID3DX10DataProcessor** ppDataProcessor);
HRESULT __stdcall D3DX10CreateAsyncTextureInfoProcessor(D3DX10_IMAGE_INFO* pImageInfo, ID3DX10DataProcessor** ppDataProcessor);
HRESULT __stdcall D3DX10CreateAsyncShaderResourceViewProcessor(ID3D10Device* pDevice, D3DX10_IMAGE_LOAD_INFO* pLoadInfo, ID3DX10DataProcessor** ppDataProcessor);
}
#pragma external_header(pop)
enum _D3DX10_ERR {
    D3DX10_ERR_CANNOT_MODIFY_INDEX_BUFFER = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2900)))),
    D3DX10_ERR_INVALID_MESH = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2901)))),
    D3DX10_ERR_CANNOT_ATTR_SORT = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2902)))),
    D3DX10_ERR_SKINNING_NOT_SUPPORTED = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2903)))),
    D3DX10_ERR_TOO_MANY_INFLUENCES = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2904)))),
    D3DX10_ERR_INVALID_DATA = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2905)))),
    D3DX10_ERR_LOADED_MESH_HAS_NO_DATA = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2906)))),
    D3DX10_ERR_DUPLICATE_NAMED_FRAGMENT = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2907)))),
    D3DX10_ERR_CANNOT_REMOVE_LAST_ITEM = ((HRESULT)(((unsigned long)(1) << 31) | ((unsigned long)(0x876) << 16) | ((unsigned long)(2908)))),
};
#pragma external_header(pop)
#pragma external_header(push)
#pragma external_header(pop)
#pragma external_header(push)
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4514 4820)
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;
typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
#pragma warning(pop)
namespace vr {
static const uint32_t k_nSteamVRVersionMajor = 1;
static const uint32_t k_nSteamVRVersionMinor = 23;
static const uint32_t k_nSteamVRVersionBuild = 7;
}
namespace vr {
#pragma pack(push, 8)
typedef uint32_t PropertyTypeTag_t;
struct HmdMatrix34_t {
    float m[3][4];
};
struct HmdMatrix33_t {
    float m[3][3];
};
struct HmdMatrix44_t {
    float m[4][4];
};
struct HmdVector3_t {
    float v[3];
};
struct HmdVector4_t {
    float v[4];
};
struct HmdVector3d_t {
    double v[3];
};
struct HmdVector2_t {
    float v[2];
};
struct HmdQuaternion_t {
    double w, x, y, z;
};
struct HmdQuaternionf_t {
    float w, x, y, z;
};
struct HmdColor_t {
    float r, g, b, a;
};
struct HmdQuad_t {
    HmdVector3_t vCorners[4];
};
struct HmdRect2_t {
    HmdVector2_t vTopLeft;
    HmdVector2_t vBottomRight;
};
struct VRBoneTransform_t {
    HmdVector4_t position;
    HmdQuaternionf_t orientation;
};
#pragma pack(pop)
}
struct VkDevice_T;
struct VkPhysicalDevice_T;
struct VkInstance_T;
struct VkQueue_T;
struct ID3D12Resource;
struct ID3D12CommandQueue;
namespace vr {
#pragma pack(push, 8)
typedef uint32_t SpatialAnchorHandle_t;
typedef void* glSharedTextureHandle_t;
typedef int32_t glInt_t;
typedef uint32_t glUInt_t;
struct DistortionCoordinates_t {
    float rfRed[2];
    float rfGreen[2];
    float rfBlue[2];
};
enum EVREye {
    Eye_Left = 0,
    Eye_Right = 1
};
enum ETextureType {
    TextureType_Invalid = -1,
    TextureType_DirectX = 0,
    TextureType_OpenGL = 1,
    TextureType_Vulkan = 2,
    TextureType_IOSurface = 3,
    TextureType_DirectX12 = 4,
    TextureType_DXGISharedHandle = 5,
    TextureType_Metal = 6,
};
enum EColorSpace {
    ColorSpace_Auto = 0,
    ColorSpace_Gamma = 1,
    ColorSpace_Linear = 2,
};
struct Texture_t {
    void* handle;
    ETextureType eType;
    EColorSpace eColorSpace;
};
typedef uint64_t SharedTextureHandle_t;
enum ETrackingResult {
    TrackingResult_Uninitialized = 1,
    TrackingResult_Calibrating_InProgress = 100,
    TrackingResult_Calibrating_OutOfRange = 101,
    TrackingResult_Running_OK = 200,
    TrackingResult_Running_OutOfRange = 201,
    TrackingResult_Fallback_RotationOnly = 300,
};
typedef uint32_t DriverId_t;
static const uint32_t k_nDriverNone = 0xFFFFFFFF;
static const uint32_t k_unMaxDriverDebugResponseSize = 32768;
typedef uint32_t TrackedDeviceIndex_t;
static const uint32_t k_unTrackedDeviceIndex_Hmd = 0;
static const uint32_t k_unMaxTrackedDeviceCount = 64;
static const uint32_t k_unTrackedDeviceIndexOther = 0xFFFFFFFE;
static const uint32_t k_unTrackedDeviceIndexInvalid = 0xFFFFFFFF;
enum ETrackedDeviceClass {
    TrackedDeviceClass_Invalid = 0,
    TrackedDeviceClass_HMD = 1,
    TrackedDeviceClass_Controller = 2,
    TrackedDeviceClass_GenericTracker = 3,
    TrackedDeviceClass_TrackingReference = 4,
    TrackedDeviceClass_DisplayRedirect = 5,
    TrackedDeviceClass_Max
};
enum ETrackedControllerRole {
    TrackedControllerRole_Invalid = 0,
    TrackedControllerRole_LeftHand = 1,
    TrackedControllerRole_RightHand = 2,
    TrackedControllerRole_OptOut = 3,
    TrackedControllerRole_Treadmill = 4,
    TrackedControllerRole_Stylus = 5,
    TrackedControllerRole_Max = 5
};
inline bool IsRoleAllowedAsHand(ETrackedControllerRole eRole)
{
    switch (eRole) {
    case TrackedControllerRole_Invalid:
    case TrackedControllerRole_LeftHand:
    case TrackedControllerRole_RightHand:
        return true;
    default:
        return false;
    }
}
struct TrackedDevicePose_t {
    HmdMatrix34_t mDeviceToAbsoluteTracking;
    HmdVector3_t vVelocity;
    HmdVector3_t vAngularVelocity;
    ETrackingResult eTrackingResult;
    bool bPoseIsValid;
    bool bDeviceIsConnected;
};
enum ETrackingUniverseOrigin {
    TrackingUniverseSeated = 0,
    TrackingUniverseStanding = 1,
    TrackingUniverseRawAndUncalibrated = 2,
};
enum EAdditionalRadioFeatures {
    AdditionalRadioFeatures_None = 0x00000000,
    AdditionalRadioFeatures_HTCLinkBox = 0x00000001,
    AdditionalRadioFeatures_InternalDongle = 0x00000002,
    AdditionalRadioFeatures_ExternalDongle = 0x00000004,
};
typedef uint64_t WebConsoleHandle_t;
typedef uint64_t PropertyContainerHandle_t;
typedef uint32_t PropertyTypeTag_t;
static const PropertyContainerHandle_t k_ulInvalidPropertyContainer = 0;
static const PropertyTypeTag_t k_unInvalidPropertyTag = 0;
typedef PropertyContainerHandle_t DriverHandle_t;
static const PropertyContainerHandle_t k_ulInvalidDriverHandle = 0;
static const PropertyTypeTag_t k_unFloatPropertyTag = 1;
static const PropertyTypeTag_t k_unInt32PropertyTag = 2;
static const PropertyTypeTag_t k_unUint64PropertyTag = 3;
static const PropertyTypeTag_t k_unBoolPropertyTag = 4;
static const PropertyTypeTag_t k_unStringPropertyTag = 5;
static const PropertyTypeTag_t k_unErrorPropertyTag = 6;
static const PropertyTypeTag_t k_unDoublePropertyTag = 7;
static const PropertyTypeTag_t k_unHmdMatrix34PropertyTag = 20;
static const PropertyTypeTag_t k_unHmdMatrix44PropertyTag = 21;
static const PropertyTypeTag_t k_unHmdVector3PropertyTag = 22;
static const PropertyTypeTag_t k_unHmdVector4PropertyTag = 23;
static const PropertyTypeTag_t k_unHmdVector2PropertyTag = 24;
static const PropertyTypeTag_t k_unHmdQuadPropertyTag = 25;
static const PropertyTypeTag_t k_unHiddenAreaPropertyTag = 30;
static const PropertyTypeTag_t k_unPathHandleInfoTag = 31;
static const PropertyTypeTag_t k_unActionPropertyTag = 32;
static const PropertyTypeTag_t k_unInputValuePropertyTag = 33;
static const PropertyTypeTag_t k_unWildcardPropertyTag = 34;
static const PropertyTypeTag_t k_unHapticVibrationPropertyTag = 35;
static const PropertyTypeTag_t k_unSkeletonPropertyTag = 36;
static const PropertyTypeTag_t k_unSpatialAnchorPosePropertyTag = 40;
static const PropertyTypeTag_t k_unJsonPropertyTag = 41;
static const PropertyTypeTag_t k_unActiveActionSetPropertyTag = 42;
static const PropertyTypeTag_t k_unOpenVRInternalReserved_Start = 1000;
static const PropertyTypeTag_t k_unOpenVRInternalReserved_End = 10000;
enum ETrackedDeviceProperty {
    Prop_Invalid = 0,
    Prop_TrackingSystemName_String = 1000,
    Prop_ModelNumber_String = 1001,
    Prop_SerialNumber_String = 1002,
    Prop_RenderModelName_String = 1003,
    Prop_WillDriftInYaw_Bool = 1004,
    Prop_ManufacturerName_String = 1005,
    Prop_TrackingFirmwareVersion_String = 1006,
    Prop_HardwareRevision_String = 1007,
    Prop_AllWirelessDongleDescriptions_String = 1008,
    Prop_ConnectedWirelessDongle_String = 1009,
    Prop_DeviceIsWireless_Bool = 1010,
    Prop_DeviceIsCharging_Bool = 1011,
    Prop_DeviceBatteryPercentage_Float = 1012,
    Prop_StatusDisplayTransform_Matrix34 = 1013,
    Prop_Firmware_UpdateAvailable_Bool = 1014,
    Prop_Firmware_ManualUpdate_Bool = 1015,
    Prop_Firmware_ManualUpdateURL_String = 1016,
    Prop_HardwareRevision_Uint64 = 1017,
    Prop_FirmwareVersion_Uint64 = 1018,
    Prop_FPGAVersion_Uint64 = 1019,
    Prop_VRCVersion_Uint64 = 1020,
    Prop_RadioVersion_Uint64 = 1021,
    Prop_DongleVersion_Uint64 = 1022,
    Prop_BlockServerShutdown_Bool = 1023,
    Prop_CanUnifyCoordinateSystemWithHmd_Bool = 1024,
    Prop_ContainsProximitySensor_Bool = 1025,
    Prop_DeviceProvidesBatteryStatus_Bool = 1026,
    Prop_DeviceCanPowerOff_Bool = 1027,
    Prop_Firmware_ProgrammingTarget_String = 1028,
    Prop_DeviceClass_Int32 = 1029,
    Prop_HasCamera_Bool = 1030,
    Prop_DriverVersion_String = 1031,
    Prop_Firmware_ForceUpdateRequired_Bool = 1032,
    Prop_ViveSystemButtonFixRequired_Bool = 1033,
    Prop_ParentDriver_Uint64 = 1034,
    Prop_ResourceRoot_String = 1035,
    Prop_RegisteredDeviceType_String = 1036,
    Prop_InputProfilePath_String = 1037,
    Prop_NeverTracked_Bool = 1038,
    Prop_NumCameras_Int32 = 1039,
    Prop_CameraFrameLayout_Int32 = 1040,
    Prop_CameraStreamFormat_Int32 = 1041,
    Prop_AdditionalDeviceSettingsPath_String = 1042,
    Prop_Identifiable_Bool = 1043,
    Prop_BootloaderVersion_Uint64 = 1044,
    Prop_AdditionalSystemReportData_String = 1045,
    Prop_CompositeFirmwareVersion_String = 1046,
    Prop_Firmware_RemindUpdate_Bool = 1047,
    Prop_PeripheralApplicationVersion_Uint64 = 1048,
    Prop_ManufacturerSerialNumber_String = 1049,
    Prop_ComputedSerialNumber_String = 1050,
    Prop_EstimatedDeviceFirstUseTime_Int32 = 1051,
    Prop_DevicePowerUsage_Float = 1052,
    Prop_IgnoreMotionForStandby_Bool = 1053,
    Prop_ReportsTimeSinceVSync_Bool = 2000,
    Prop_SecondsFromVsyncToPhotons_Float = 2001,
    Prop_DisplayFrequency_Float = 2002,
    Prop_UserIpdMeters_Float = 2003,
    Prop_CurrentUniverseId_Uint64 = 2004,
    Prop_PreviousUniverseId_Uint64 = 2005,
    Prop_DisplayFirmwareVersion_Uint64 = 2006,
    Prop_IsOnDesktop_Bool = 2007,
    Prop_DisplayMCType_Int32 = 2008,
    Prop_DisplayMCOffset_Float = 2009,
    Prop_DisplayMCScale_Float = 2010,
    Prop_EdidVendorID_Int32 = 2011,
    Prop_DisplayMCImageLeft_String = 2012,
    Prop_DisplayMCImageRight_String = 2013,
    Prop_DisplayGCBlackClamp_Float = 2014,
    Prop_EdidProductID_Int32 = 2015,
    Prop_CameraToHeadTransform_Matrix34 = 2016,
    Prop_DisplayGCType_Int32 = 2017,
    Prop_DisplayGCOffset_Float = 2018,
    Prop_DisplayGCScale_Float = 2019,
    Prop_DisplayGCPrescale_Float = 2020,
    Prop_DisplayGCImage_String = 2021,
    Prop_LensCenterLeftU_Float = 2022,
    Prop_LensCenterLeftV_Float = 2023,
    Prop_LensCenterRightU_Float = 2024,
    Prop_LensCenterRightV_Float = 2025,
    Prop_UserHeadToEyeDepthMeters_Float = 2026,
    Prop_CameraFirmwareVersion_Uint64 = 2027,
    Prop_CameraFirmwareDescription_String = 2028,
    Prop_DisplayFPGAVersion_Uint64 = 2029,
    Prop_DisplayBootloaderVersion_Uint64 = 2030,
    Prop_DisplayHardwareVersion_Uint64 = 2031,
    Prop_AudioFirmwareVersion_Uint64 = 2032,
    Prop_CameraCompatibilityMode_Int32 = 2033,
    Prop_ScreenshotHorizontalFieldOfViewDegrees_Float = 2034,
    Prop_ScreenshotVerticalFieldOfViewDegrees_Float = 2035,
    Prop_DisplaySuppressed_Bool = 2036,
    Prop_DisplayAllowNightMode_Bool = 2037,
    Prop_DisplayMCImageWidth_Int32 = 2038,
    Prop_DisplayMCImageHeight_Int32 = 2039,
    Prop_DisplayMCImageNumChannels_Int32 = 2040,
    Prop_DisplayMCImageData_Binary = 2041,
    Prop_SecondsFromPhotonsToVblank_Float = 2042,
    Prop_DriverDirectModeSendsVsyncEvents_Bool = 2043,
    Prop_DisplayDebugMode_Bool = 2044,
    Prop_GraphicsAdapterLuid_Uint64 = 2045,
    Prop_DriverProvidedChaperonePath_String = 2048,
    Prop_ExpectedTrackingReferenceCount_Int32 = 2049,
    Prop_ExpectedControllerCount_Int32 = 2050,
    Prop_NamedIconPathControllerLeftDeviceOff_String = 2051,
    Prop_NamedIconPathControllerRightDeviceOff_String = 2052,
    Prop_NamedIconPathTrackingReferenceDeviceOff_String = 2053,
    Prop_DoNotApplyPrediction_Bool = 2054,
    Prop_CameraToHeadTransforms_Matrix34_Array = 2055,
    Prop_DistortionMeshResolution_Int32 = 2056,
    Prop_DriverIsDrawingControllers_Bool = 2057,
    Prop_DriverRequestsApplicationPause_Bool = 2058,
    Prop_DriverRequestsReducedRendering_Bool = 2059,
    Prop_MinimumIpdStepMeters_Float = 2060,
    Prop_AudioBridgeFirmwareVersion_Uint64 = 2061,
    Prop_ImageBridgeFirmwareVersion_Uint64 = 2062,
    Prop_ImuToHeadTransform_Matrix34 = 2063,
    Prop_ImuFactoryGyroBias_Vector3 = 2064,
    Prop_ImuFactoryGyroScale_Vector3 = 2065,
    Prop_ImuFactoryAccelerometerBias_Vector3 = 2066,
    Prop_ImuFactoryAccelerometerScale_Vector3 = 2067,
    Prop_ConfigurationIncludesLighthouse20Features_Bool = 2069,
    Prop_AdditionalRadioFeatures_Uint64 = 2070,
    Prop_CameraWhiteBalance_Vector4_Array = 2071,
    Prop_CameraDistortionFunction_Int32_Array = 2072,
    Prop_CameraDistortionCoefficients_Float_Array = 2073,
    Prop_ExpectedControllerType_String = 2074,
    Prop_HmdTrackingStyle_Int32 = 2075,
    Prop_DriverProvidedChaperoneVisibility_Bool = 2076,
    Prop_HmdColumnCorrectionSettingPrefix_String = 2077,
    Prop_CameraSupportsCompatibilityModes_Bool = 2078,
    Prop_SupportsRoomViewDepthProjection_Bool = 2079,
    Prop_DisplayAvailableFrameRates_Float_Array = 2080,
    Prop_DisplaySupportsMultipleFramerates_Bool = 2081,
    Prop_DisplayColorMultLeft_Vector3 = 2082,
    Prop_DisplayColorMultRight_Vector3 = 2083,
    Prop_DisplaySupportsRuntimeFramerateChange_Bool = 2084,
    Prop_DisplaySupportsAnalogGain_Bool = 2085,
    Prop_DisplayMinAnalogGain_Float = 2086,
    Prop_DisplayMaxAnalogGain_Float = 2087,
    Prop_CameraExposureTime_Float = 2088,
    Prop_CameraGlobalGain_Float = 2089,
    Prop_DashboardScale_Float = 2091,
    Prop_PeerButtonInfo_String = 2092,
    Prop_IpdUIRangeMinMeters_Float = 2100,
    Prop_IpdUIRangeMaxMeters_Float = 2101,
    Prop_Hmd_SupportsHDCP14LegacyCompat_Bool = 2102,
    Prop_Hmd_SupportsMicMonitoring_Bool = 2103,
    Prop_Hmd_SupportsDisplayPortTrainingMode_Bool = 2104,
    Prop_SupportsRoomViewDirect_Bool = 2105,
    Prop_SupportsAppThrottling_Bool = 2106,
    Prop_DriverRequestedMuraCorrectionMode_Int32 = 2200,
    Prop_DriverRequestedMuraFeather_InnerLeft_Int32 = 2201,
    Prop_DriverRequestedMuraFeather_InnerRight_Int32 = 2202,
    Prop_DriverRequestedMuraFeather_InnerTop_Int32 = 2203,
    Prop_DriverRequestedMuraFeather_InnerBottom_Int32 = 2204,
    Prop_DriverRequestedMuraFeather_OuterLeft_Int32 = 2205,
    Prop_DriverRequestedMuraFeather_OuterRight_Int32 = 2206,
    Prop_DriverRequestedMuraFeather_OuterTop_Int32 = 2207,
    Prop_DriverRequestedMuraFeather_OuterBottom_Int32 = 2208,
    Prop_Audio_DefaultPlaybackDeviceId_String = 2300,
    Prop_Audio_DefaultRecordingDeviceId_String = 2301,
    Prop_Audio_DefaultPlaybackDeviceVolume_Float = 2302,
    Prop_Audio_SupportsDualSpeakerAndJackOutput_Bool = 2303,
    Prop_AttachedDeviceId_String = 3000,
    Prop_SupportedButtons_Uint64 = 3001,
    Prop_Axis0Type_Int32 = 3002,
    Prop_Axis1Type_Int32 = 3003,
    Prop_Axis2Type_Int32 = 3004,
    Prop_Axis3Type_Int32 = 3005,
    Prop_Axis4Type_Int32 = 3006,
    Prop_ControllerRoleHint_Int32 = 3007,
    Prop_FieldOfViewLeftDegrees_Float = 4000,
    Prop_FieldOfViewRightDegrees_Float = 4001,
    Prop_FieldOfViewTopDegrees_Float = 4002,
    Prop_FieldOfViewBottomDegrees_Float = 4003,
    Prop_TrackingRangeMinimumMeters_Float = 4004,
    Prop_TrackingRangeMaximumMeters_Float = 4005,
    Prop_ModeLabel_String = 4006,
    Prop_CanWirelessIdentify_Bool = 4007,
    Prop_Nonce_Int32 = 4008,
    Prop_IconPathName_String = 5000,
    Prop_NamedIconPathDeviceOff_String = 5001,
    Prop_NamedIconPathDeviceSearching_String = 5002,
    Prop_NamedIconPathDeviceSearchingAlert_String = 5003,
    Prop_NamedIconPathDeviceReady_String = 5004,
    Prop_NamedIconPathDeviceReadyAlert_String = 5005,
    Prop_NamedIconPathDeviceNotReady_String = 5006,
    Prop_NamedIconPathDeviceStandby_String = 5007,
    Prop_NamedIconPathDeviceAlertLow_String = 5008,
    Prop_NamedIconPathDeviceStandbyAlert_String = 5009,
    Prop_DisplayHiddenArea_Binary_Start = 5100,
    Prop_DisplayHiddenArea_Binary_End = 5150,
    Prop_ParentContainer = 5151,
    Prop_OverrideContainer_Uint64 = 5152,
    Prop_UserConfigPath_String = 6000,
    Prop_InstallPath_String = 6001,
    Prop_HasDisplayComponent_Bool = 6002,
    Prop_HasControllerComponent_Bool = 6003,
    Prop_HasCameraComponent_Bool = 6004,
    Prop_HasDriverDirectModeComponent_Bool = 6005,
    Prop_HasVirtualDisplayComponent_Bool = 6006,
    Prop_HasSpatialAnchorsSupport_Bool = 6007,
    Prop_ControllerType_String = 7000,
    Prop_ControllerHandSelectionPriority_Int32 = 7002,
    Prop_VendorSpecific_Reserved_Start = 10000,
    Prop_VendorSpecific_Reserved_End = 10999,
    Prop_TrackedDeviceProperty_Max = 1000000,
};
static const uint32_t k_unMaxPropertyStringSize = 32 * 1024;
enum ETrackedPropertyError {
    TrackedProp_Success = 0,
    TrackedProp_WrongDataType = 1,
    TrackedProp_WrongDeviceClass = 2,
    TrackedProp_BufferTooSmall = 3,
    TrackedProp_UnknownProperty = 4,
    TrackedProp_InvalidDevice = 5,
    TrackedProp_CouldNotContactServer = 6,
    TrackedProp_ValueNotProvidedByDevice = 7,
    TrackedProp_StringExceedsMaximumLength = 8,
    TrackedProp_NotYetAvailable = 9,
    TrackedProp_PermissionDenied = 10,
    TrackedProp_InvalidOperation = 11,
    TrackedProp_CannotWriteToWildcards = 12,
    TrackedProp_IPCReadFailure = 13,
    TrackedProp_OutOfMemory = 14,
    TrackedProp_InvalidContainer = 15,
};
enum EHmdTrackingStyle {
    HmdTrackingStyle_Unknown = 0,
    HmdTrackingStyle_Lighthouse = 1,
    HmdTrackingStyle_OutsideInCameras = 2,
    HmdTrackingStyle_InsideOutCameras = 3,
};
typedef uint64_t VRActionHandle_t;
typedef uint64_t VRActionSetHandle_t;
typedef uint64_t VRInputValueHandle_t;
static const VRActionHandle_t k_ulInvalidActionHandle = 0;
static const VRActionSetHandle_t k_ulInvalidActionSetHandle = 0;
static const VRInputValueHandle_t k_ulInvalidInputValueHandle = 0;
struct VRTextureBounds_t {
    float uMin, vMin;
    float uMax, vMax;
};
struct VRTextureWithPose_t : public Texture_t {
    HmdMatrix34_t mDeviceToAbsoluteTracking;
};
struct VRTextureDepthInfo_t {
    void* handle;
    HmdMatrix44_t mProjection;
    HmdVector2_t vRange;
};
struct VRTextureWithDepth_t : public Texture_t {
    VRTextureDepthInfo_t depth;
};
struct VRTextureWithPoseAndDepth_t : public VRTextureWithPose_t {
    VRTextureDepthInfo_t depth;
};
enum EVRSubmitFlags {
    Submit_Default = 0x00,
    Submit_LensDistortionAlreadyApplied = 0x01,
    Submit_GlRenderBuffer = 0x02,
    Submit_Reserved = 0x04,
    Submit_TextureWithPose = 0x08,
    Submit_TextureWithDepth = 0x10,
    Submit_FrameDiscontinuty = 0x20,
    Submit_VulkanTextureWithArrayData = 0x40,
    Submit_GlArrayTexture = 0x80,
    Submit_Reserved2 = 0x08000,
    Submit_Reserved3 = 0x10000,
};
struct VRVulkanTextureData_t {
    uint64_t m_nImage;
    VkDevice_T* m_pDevice;
    VkPhysicalDevice_T* m_pPhysicalDevice;
    VkInstance_T* m_pInstance;
    VkQueue_T* m_pQueue;
    uint32_t m_nQueueFamilyIndex;
    uint32_t m_nWidth, m_nHeight, m_nFormat, m_nSampleCount;
};
struct VRVulkanTextureArrayData_t : public VRVulkanTextureData_t {
    uint32_t m_unArrayIndex;
    uint32_t m_unArraySize;
};
struct D3D12TextureData_t {
    ID3D12Resource* m_pResource;
    ID3D12CommandQueue* m_pCommandQueue;
    uint32_t m_nNodeMask;
};
enum EVRState {
    VRState_Undefined = -1,
    VRState_Off = 0,
    VRState_Searching = 1,
    VRState_Searching_Alert = 2,
    VRState_Ready = 3,
    VRState_Ready_Alert = 4,
    VRState_NotReady = 5,
    VRState_Standby = 6,
    VRState_Ready_Alert_Low = 7,
};
enum EVREventType {
    VREvent_None = 0,
    VREvent_TrackedDeviceActivated = 100,
    VREvent_TrackedDeviceDeactivated = 101,
    VREvent_TrackedDeviceUpdated = 102,
    VREvent_TrackedDeviceUserInteractionStarted = 103,
    VREvent_TrackedDeviceUserInteractionEnded = 104,
    VREvent_IpdChanged = 105,
    VREvent_EnterStandbyMode = 106,
    VREvent_LeaveStandbyMode = 107,
    VREvent_TrackedDeviceRoleChanged = 108,
    VREvent_WatchdogWakeUpRequested = 109,
    VREvent_LensDistortionChanged = 110,
    VREvent_PropertyChanged = 111,
    VREvent_WirelessDisconnect = 112,
    VREvent_WirelessReconnect = 113,
    VREvent_ButtonPress = 200,
    VREvent_ButtonUnpress = 201,
    VREvent_ButtonTouch = 202,
    VREvent_ButtonUntouch = 203,
    VREvent_Modal_Cancel = 257,
    VREvent_MouseMove = 300,
    VREvent_MouseButtonDown = 301,
    VREvent_MouseButtonUp = 302,
    VREvent_FocusEnter = 303,
    VREvent_FocusLeave = 304,
    VREvent_ScrollDiscrete = 305,
    VREvent_TouchPadMove = 306,
    VREvent_OverlayFocusChanged = 307,
    VREvent_ReloadOverlays = 308,
    VREvent_ScrollSmooth = 309,
    VREvent_LockMousePosition = 310,
    VREvent_UnlockMousePosition = 311,
    VREvent_InputFocusCaptured = 400,
    VREvent_InputFocusReleased = 401,
    VREvent_SceneApplicationChanged = 404,
    VREvent_SceneFocusChanged = 405,
    VREvent_InputFocusChanged = 406,
    VREvent_SceneApplicationUsingWrongGraphicsAdapter = 408,
    VREvent_ActionBindingReloaded = 409,
    VREvent_HideRenderModels = 410,
    VREvent_ShowRenderModels = 411,
    VREvent_SceneApplicationStateChanged = 412,
    VREvent_ConsoleOpened = 420,
    VREvent_ConsoleClosed = 421,
    VREvent_OverlayShown = 500,
    VREvent_OverlayHidden = 501,
    VREvent_DashboardActivated = 502,
    VREvent_DashboardDeactivated = 503,
    VREvent_DashboardRequested = 505,
    VREvent_ResetDashboard = 506,
    VREvent_ImageLoaded = 508,
    VREvent_ShowKeyboard = 509,
    VREvent_HideKeyboard = 510,
    VREvent_OverlayGamepadFocusGained = 511,
    VREvent_OverlayGamepadFocusLost = 512,
    VREvent_OverlaySharedTextureChanged = 513,
    VREvent_ScreenshotTriggered = 516,
    VREvent_ImageFailed = 517,
    VREvent_DashboardOverlayCreated = 518,
    VREvent_SwitchGamepadFocus = 519,
    VREvent_RequestScreenshot = 520,
    VREvent_ScreenshotTaken = 521,
    VREvent_ScreenshotFailed = 522,
    VREvent_SubmitScreenshotToDashboard = 523,
    VREvent_ScreenshotProgressToDashboard = 524,
    VREvent_PrimaryDashboardDeviceChanged = 525,
    VREvent_RoomViewShown = 526,
    VREvent_RoomViewHidden = 527,
    VREvent_ShowUI = 528,
    VREvent_ShowDevTools = 529,
    VREvent_DesktopViewUpdating = 530,
    VREvent_DesktopViewReady = 531,
    VREvent_StartDashboard = 532,
    VREvent_ElevatePrism = 533,
    VREvent_OverlayClosed = 534,
    VREvent_Notification_Shown = 600,
    VREvent_Notification_Hidden = 601,
    VREvent_Notification_BeginInteraction = 602,
    VREvent_Notification_Destroyed = 603,
    VREvent_Quit = 700,
    VREvent_ProcessQuit = 701,
    VREvent_QuitAcknowledged = 703,
    VREvent_DriverRequestedQuit = 704,
    VREvent_RestartRequested = 705,
    VREvent_InvalidateSwapTextureSets = 706,
    VREvent_ChaperoneDataHasChanged = 800,
    VREvent_ChaperoneUniverseHasChanged = 801,
    VREvent_ChaperoneTempDataHasChanged = 802,
    VREvent_ChaperoneSettingsHaveChanged = 803,
    VREvent_SeatedZeroPoseReset = 804,
    VREvent_ChaperoneFlushCache = 805,
    VREvent_ChaperoneRoomSetupStarting = 806,
    VREvent_ChaperoneRoomSetupFinished = 807,
    VREvent_StandingZeroPoseReset = 808,
    VREvent_AudioSettingsHaveChanged = 820,
    VREvent_BackgroundSettingHasChanged = 850,
    VREvent_CameraSettingsHaveChanged = 851,
    VREvent_ReprojectionSettingHasChanged = 852,
    VREvent_ModelSkinSettingsHaveChanged = 853,
    VREvent_EnvironmentSettingsHaveChanged = 854,
    VREvent_PowerSettingsHaveChanged = 855,
    VREvent_EnableHomeAppSettingsHaveChanged = 856,
    VREvent_SteamVRSectionSettingChanged = 857,
    VREvent_LighthouseSectionSettingChanged = 858,
    VREvent_NullSectionSettingChanged = 859,
    VREvent_UserInterfaceSectionSettingChanged = 860,
    VREvent_NotificationsSectionSettingChanged = 861,
    VREvent_KeyboardSectionSettingChanged = 862,
    VREvent_PerfSectionSettingChanged = 863,
    VREvent_DashboardSectionSettingChanged = 864,
    VREvent_WebInterfaceSectionSettingChanged = 865,
    VREvent_TrackersSectionSettingChanged = 866,
    VREvent_LastKnownSectionSettingChanged = 867,
    VREvent_DismissedWarningsSectionSettingChanged = 868,
    VREvent_GpuSpeedSectionSettingChanged = 869,
    VREvent_WindowsMRSectionSettingChanged = 870,
    VREvent_OtherSectionSettingChanged = 871,
    VREvent_StatusUpdate = 900,
    VREvent_WebInterface_InstallDriverCompleted = 950,
    VREvent_MCImageUpdated = 1000,
    VREvent_FirmwareUpdateStarted = 1100,
    VREvent_FirmwareUpdateFinished = 1101,
    VREvent_KeyboardClosed = 1200,
    VREvent_KeyboardCharInput = 1201,
    VREvent_KeyboardDone = 1202,
    VREvent_ApplicationListUpdated = 1303,
    VREvent_ApplicationMimeTypeLoad = 1304,
    VREvent_ProcessConnected = 1306,
    VREvent_ProcessDisconnected = 1307,
    VREvent_Compositor_ChaperoneBoundsShown = 1410,
    VREvent_Compositor_ChaperoneBoundsHidden = 1411,
    VREvent_Compositor_DisplayDisconnected = 1412,
    VREvent_Compositor_DisplayReconnected = 1413,
    VREvent_Compositor_HDCPError = 1414,
    VREvent_Compositor_ApplicationNotResponding = 1415,
    VREvent_Compositor_ApplicationResumed = 1416,
    VREvent_Compositor_OutOfVideoMemory = 1417,
    VREvent_Compositor_DisplayModeNotSupported = 1418,
    VREvent_Compositor_StageOverrideReady = 1419,
    VREvent_Compositor_RequestDisconnectReconnect = 1420,
    VREvent_TrackedCamera_StartVideoStream = 1500,
    VREvent_TrackedCamera_StopVideoStream = 1501,
    VREvent_TrackedCamera_PauseVideoStream = 1502,
    VREvent_TrackedCamera_ResumeVideoStream = 1503,
    VREvent_TrackedCamera_EditingSurface = 1550,
    VREvent_PerformanceTest_EnableCapture = 1600,
    VREvent_PerformanceTest_DisableCapture = 1601,
    VREvent_PerformanceTest_FidelityLevel = 1602,
    VREvent_MessageOverlay_Closed = 1650,
    VREvent_MessageOverlayCloseRequested = 1651,
    VREvent_Input_HapticVibration = 1700,
    VREvent_Input_BindingLoadFailed = 1701,
    VREvent_Input_BindingLoadSuccessful = 1702,
    VREvent_Input_ActionManifestReloaded = 1703,
    VREvent_Input_ActionManifestLoadFailed = 1704,
    VREvent_Input_ProgressUpdate = 1705,
    VREvent_Input_TrackerActivated = 1706,
    VREvent_Input_BindingsUpdated = 1707,
    VREvent_Input_BindingSubscriptionChanged = 1708,
    VREvent_SpatialAnchors_PoseUpdated = 1800,
    VREvent_SpatialAnchors_DescriptorUpdated = 1801,
    VREvent_SpatialAnchors_RequestPoseUpdate = 1802,
    VREvent_SpatialAnchors_RequestDescriptorUpdate = 1803,
    VREvent_SystemReport_Started = 1900,
    VREvent_Monitor_ShowHeadsetView = 2000,
    VREvent_Monitor_HideHeadsetView = 2001,
    VREvent_VendorSpecific_Reserved_Start = 10000,
    VREvent_VendorSpecific_Reserved_End = 19999,
};
enum EDeviceActivityLevel {
    k_EDeviceActivityLevel_Unknown = -1,
    k_EDeviceActivityLevel_Idle = 0,
    k_EDeviceActivityLevel_UserInteraction = 1,
    k_EDeviceActivityLevel_UserInteraction_Timeout = 2,
    k_EDeviceActivityLevel_Standby = 3,
    k_EDeviceActivityLevel_Idle_Timeout = 4,
};
enum EVRButtonId {
    k_EButton_System = 0,
    k_EButton_ApplicationMenu = 1,
    k_EButton_Grip = 2,
    k_EButton_DPad_Left = 3,
    k_EButton_DPad_Up = 4,
    k_EButton_DPad_Right = 5,
    k_EButton_DPad_Down = 6,
    k_EButton_A = 7,
    k_EButton_ProximitySensor = 31,
    k_EButton_Axis0 = 32,
    k_EButton_Axis1 = 33,
    k_EButton_Axis2 = 34,
    k_EButton_Axis3 = 35,
    k_EButton_Axis4 = 36,
    k_EButton_SteamVR_Touchpad = k_EButton_Axis0,
    k_EButton_SteamVR_Trigger = k_EButton_Axis1,
    k_EButton_Dashboard_Back = k_EButton_Grip,
    k_EButton_IndexController_A = k_EButton_Grip,
    k_EButton_IndexController_B = k_EButton_ApplicationMenu,
    k_EButton_IndexController_JoyStick = k_EButton_Axis3,
    k_EButton_Max = 64
};
inline uint64_t ButtonMaskFromId(EVRButtonId id) { return 1ull << id; }
struct VREvent_Controller_t {
    uint32_t button;
};
enum EVRMouseButton {
    VRMouseButton_Left = 0x0001,
    VRMouseButton_Right = 0x0002,
    VRMouseButton_Middle = 0x0004,
};
struct VREvent_Mouse_t {
    float x, y;
    uint32_t button;
};
struct VREvent_Scroll_t {
    float xdelta, ydelta;
    uint32_t unused;
    float viewportscale;
};
struct VREvent_TouchPadMove_t {
    bool bFingerDown;
    float flSecondsFingerDown;
    float fValueXFirst;
    float fValueYFirst;
    float fValueXRaw;
    float fValueYRaw;
};
struct VREvent_Notification_t {
    uint64_t ulUserValue;
    uint32_t notificationId;
};
struct VREvent_Process_t {
    uint32_t pid;
    uint32_t oldPid;
    bool bForced;
    bool bConnectionLost;
};
struct VREvent_Overlay_t {
    uint64_t overlayHandle;
    uint64_t devicePath;
    uint64_t memoryBlockId;
};
struct VREvent_Status_t {
    uint32_t statusState;
};
struct VREvent_Keyboard_t {
    char cNewInput[8];
    uint64_t uUserValue;
};
struct VREvent_Ipd_t {
    float ipdMeters;
};
struct VREvent_Chaperone_t {
    uint64_t m_nPreviousUniverse;
    uint64_t m_nCurrentUniverse;
};
struct VREvent_Reserved_t {
    uint64_t reserved0;
    uint64_t reserved1;
    uint64_t reserved2;
    uint64_t reserved3;
    uint64_t reserved4;
    uint64_t reserved5;
};
struct VREvent_PerformanceTest_t {
    uint32_t m_nFidelityLevel;
};
struct VREvent_SeatedZeroPoseReset_t {
    bool bResetBySystemMenu;
};
struct VREvent_Screenshot_t {
    uint32_t handle;
    uint32_t type;
};
struct VREvent_ScreenshotProgress_t {
    float progress;
};
struct VREvent_ApplicationLaunch_t {
    uint32_t pid;
    uint32_t unArgsHandle;
};
struct VREvent_EditingCameraSurface_t {
    uint64_t overlayHandle;
    uint32_t nVisualMode;
};
struct VREvent_MessageOverlay_t {
    uint32_t unVRMessageOverlayResponse;
};
struct VREvent_Property_t {
    PropertyContainerHandle_t container;
    ETrackedDeviceProperty prop;
};
struct VREvent_HapticVibration_t {
    uint64_t containerHandle;
    uint64_t componentHandle;
    float fDurationSeconds;
    float fFrequency;
    float fAmplitude;
};
struct VREvent_WebConsole_t {
    WebConsoleHandle_t webConsoleHandle;
};
struct VREvent_InputBindingLoad_t {
    vr::PropertyContainerHandle_t ulAppContainer;
    uint64_t pathMessage;
    uint64_t pathUrl;
    uint64_t pathControllerType;
};
struct VREvent_InputActionManifestLoad_t {
    uint64_t pathAppKey;
    uint64_t pathMessage;
    uint64_t pathMessageParam;
    uint64_t pathManifestPath;
};
struct VREvent_SpatialAnchor_t {
    SpatialAnchorHandle_t unHandle;
};
struct VREvent_ProgressUpdate_t {
    uint64_t ulApplicationPropertyContainer;
    uint64_t pathDevice;
    uint64_t pathInputSource;
    uint64_t pathProgressAction;
    uint64_t pathIcon;
    float fProgress;
};
enum EShowUIType {
    ShowUI_ControllerBinding = 0,
    ShowUI_ManageTrackers = 1,
    ShowUI_Pairing = 3,
    ShowUI_Settings = 4,
    ShowUI_DebugCommands = 5,
    ShowUI_FullControllerBinding = 6,
    ShowUI_ManageDrivers = 7,
};
struct VREvent_ShowUI_t {
    EShowUIType eType;
};
struct VREvent_ShowDevTools_t {
    int32_t nBrowserIdentifier;
};
enum EHDCPError {
    HDCPError_None = 0,
    HDCPError_LinkLost = 1,
    HDCPError_Tampered = 2,
    HDCPError_DeviceRevoked = 3,
    HDCPError_Unknown = 4
};
struct VREvent_HDCPError_t {
    EHDCPError eCode;
};
typedef union {
    VREvent_Reserved_t reserved;
    VREvent_Controller_t controller;
    VREvent_Mouse_t mouse;
    VREvent_Scroll_t scroll;
    VREvent_Process_t process;
    VREvent_Notification_t notification;
    VREvent_Overlay_t overlay;
    VREvent_Status_t status;
    VREvent_Keyboard_t keyboard;
    VREvent_Ipd_t ipd;
    VREvent_Chaperone_t chaperone;
    VREvent_PerformanceTest_t performanceTest;
    VREvent_TouchPadMove_t touchPadMove;
    VREvent_SeatedZeroPoseReset_t seatedZeroPoseReset;
    VREvent_Screenshot_t screenshot;
    VREvent_ScreenshotProgress_t screenshotProgress;
    VREvent_ApplicationLaunch_t applicationLaunch;
    VREvent_EditingCameraSurface_t cameraSurface;
    VREvent_MessageOverlay_t messageOverlay;
    VREvent_Property_t property;
    VREvent_HapticVibration_t hapticVibration;
    VREvent_WebConsole_t webConsole;
    VREvent_InputBindingLoad_t inputBinding;
    VREvent_InputActionManifestLoad_t actionManifest;
    VREvent_SpatialAnchor_t spatialAnchor;
    VREvent_ProgressUpdate_t progressUpdate;
    VREvent_ShowUI_t showUi;
    VREvent_ShowDevTools_t showDevTools;
    VREvent_HDCPError_t hdcpError;
} VREvent_Data_t;
struct VREvent_t {
    uint32_t eventType;
    TrackedDeviceIndex_t trackedDeviceIndex;
    float eventAgeSeconds;
    VREvent_Data_t data;
};
typedef uint32_t VRComponentProperties;
enum EVRComponentProperty {
    VRComponentProperty_IsStatic = (1 << 0),
    VRComponentProperty_IsVisible = (1 << 1),
    VRComponentProperty_IsTouched = (1 << 2),
    VRComponentProperty_IsPressed = (1 << 3),
    VRComponentProperty_IsScrolled = (1 << 4),
    VRComponentProperty_IsHighlighted = (1 << 5),
};
struct RenderModel_ComponentState_t {
    HmdMatrix34_t mTrackingToComponentRenderModel;
    HmdMatrix34_t mTrackingToComponentLocal;
    VRComponentProperties uProperties;
};
enum EVRInputError {
    VRInputError_None = 0,
    VRInputError_NameNotFound = 1,
    VRInputError_WrongType = 2,
    VRInputError_InvalidHandle = 3,
    VRInputError_InvalidParam = 4,
    VRInputError_NoSteam = 5,
    VRInputError_MaxCapacityReached = 6,
    VRInputError_IPCError = 7,
    VRInputError_NoActiveActionSet = 8,
    VRInputError_InvalidDevice = 9,
    VRInputError_InvalidSkeleton = 10,
    VRInputError_InvalidBoneCount = 11,
    VRInputError_InvalidCompressedData = 12,
    VRInputError_NoData = 13,
    VRInputError_BufferTooSmall = 14,
    VRInputError_MismatchedActionManifest = 15,
    VRInputError_MissingSkeletonData = 16,
    VRInputError_InvalidBoneIndex = 17,
    VRInputError_InvalidPriority = 18,
    VRInputError_PermissionDenied = 19,
    VRInputError_InvalidRenderModel = 20,
};
enum EVRSpatialAnchorError {
    VRSpatialAnchorError_Success = 0,
    VRSpatialAnchorError_Internal = 1,
    VRSpatialAnchorError_UnknownHandle = 2,
    VRSpatialAnchorError_ArrayTooSmall = 3,
    VRSpatialAnchorError_InvalidDescriptorChar = 4,
    VRSpatialAnchorError_NotYetAvailable = 5,
    VRSpatialAnchorError_NotAvailableInThisUniverse = 6,
    VRSpatialAnchorError_PermanentlyUnavailable = 7,
    VRSpatialAnchorError_WrongDriver = 8,
    VRSpatialAnchorError_DescriptorTooLong = 9,
    VRSpatialAnchorError_Unknown = 10,
    VRSpatialAnchorError_NoRoomCalibration = 11,
    VRSpatialAnchorError_InvalidArgument = 12,
    VRSpatialAnchorError_UnknownDriver = 13,
};
struct HiddenAreaMesh_t {
    const HmdVector2_t* pVertexData;
    uint32_t unTriangleCount;
};
enum EHiddenAreaMeshType {
    k_eHiddenAreaMesh_Standard = 0,
    k_eHiddenAreaMesh_Inverse = 1,
    k_eHiddenAreaMesh_LineLoop = 2,
    k_eHiddenAreaMesh_Max = 3,
};
enum EVRControllerAxisType {
    k_eControllerAxis_None = 0,
    k_eControllerAxis_TrackPad = 1,
    k_eControllerAxis_Joystick = 2,
    k_eControllerAxis_Trigger = 3,
};
struct VRControllerAxis_t {
    float x;
    float y;
};
static const uint32_t k_unControllerStateAxisCount = 5;
struct VRControllerState001_t {
    uint32_t unPacketNum;
    uint64_t ulButtonPressed;
    uint64_t ulButtonTouched;
    VRControllerAxis_t rAxis[k_unControllerStateAxisCount];
};
typedef VRControllerState001_t VRControllerState_t;
enum EVRControllerEventOutputType {
    ControllerEventOutput_OSEvents = 0,
    ControllerEventOutput_VREvents = 1,
};
enum ECollisionBoundsStyle {
    COLLISION_BOUNDS_STYLE_BEGINNER = 0,
    COLLISION_BOUNDS_STYLE_INTERMEDIATE,
    COLLISION_BOUNDS_STYLE_SQUARES,
    COLLISION_BOUNDS_STYLE_ADVANCED,
    COLLISION_BOUNDS_STYLE_NONE,
    COLLISION_BOUNDS_STYLE_COUNT
};
typedef uint64_t VROverlayHandle_t;
static const VROverlayHandle_t k_ulOverlayHandleInvalid = 0;
enum EVROverlayError {
    VROverlayError_None = 0,
    VROverlayError_UnknownOverlay = 10,
    VROverlayError_InvalidHandle = 11,
    VROverlayError_PermissionDenied = 12,
    VROverlayError_OverlayLimitExceeded = 13,
    VROverlayError_WrongVisibilityType = 14,
    VROverlayError_KeyTooLong = 15,
    VROverlayError_NameTooLong = 16,
    VROverlayError_KeyInUse = 17,
    VROverlayError_WrongTransformType = 18,
    VROverlayError_InvalidTrackedDevice = 19,
    VROverlayError_InvalidParameter = 20,
    VROverlayError_ThumbnailCantBeDestroyed = 21,
    VROverlayError_ArrayTooSmall = 22,
    VROverlayError_RequestFailed = 23,
    VROverlayError_InvalidTexture = 24,
    VROverlayError_UnableToLoadFile = 25,
    VROverlayError_KeyboardAlreadyInUse = 26,
    VROverlayError_NoNeighbor = 27,
    VROverlayError_TooManyMaskPrimitives = 29,
    VROverlayError_BadMaskPrimitive = 30,
    VROverlayError_TextureAlreadyLocked = 31,
    VROverlayError_TextureLockCapacityReached = 32,
    VROverlayError_TextureNotLocked = 33,
    VROverlayError_TimedOut = 34,
};
enum EVRApplicationType {
    VRApplication_Other = 0,
    VRApplication_Scene = 1,
    VRApplication_Overlay = 2,
    VRApplication_Background = 3,
    VRApplication_Utility = 4,
    VRApplication_VRMonitor = 5,
    VRApplication_SteamWatchdog = 6,
    VRApplication_Bootstrapper = 7,
    VRApplication_WebHelper = 8,
    VRApplication_OpenXRInstance = 9,
    VRApplication_OpenXRScene = 10,
    VRApplication_OpenXROverlay = 11,
    VRApplication_Prism = 12,
    VRApplication_RoomView = 13,
    VRApplication_Max
};
inline bool IsOpenXRAppType(EVRApplicationType eType)
{
    return eType == VRApplication_OpenXRInstance
        || eType == VRApplication_OpenXRScene
        || eType == VRApplication_OpenXROverlay;
}
inline bool BAppTypeSubmitsEyeBuffers(EVRApplicationType eType)
{
    return eType == VRApplication_Scene
        || eType == VRApplication_OpenXRScene
        || eType == VRApplication_RoomView;
}
enum EVRFirmwareError {
    VRFirmwareError_None = 0,
    VRFirmwareError_Success = 1,
    VRFirmwareError_Fail = 2,
};
enum EVRNotificationError {
    VRNotificationError_OK = 0,
    VRNotificationError_InvalidNotificationId = 100,
    VRNotificationError_NotificationQueueFull = 101,
    VRNotificationError_InvalidOverlayHandle = 102,
    VRNotificationError_SystemWithUserValueAlreadyExists = 103,
};
enum EVRSkeletalMotionRange {
    VRSkeletalMotionRange_WithController = 0,
    VRSkeletalMotionRange_WithoutController = 1,
};
enum EVRSkeletalTrackingLevel {
    VRSkeletalTracking_Estimated = 0,
    VRSkeletalTracking_Partial = 1,
    VRSkeletalTracking_Full = 2,
    VRSkeletalTrackingLevel_Count,
    VRSkeletalTrackingLevel_Max = VRSkeletalTrackingLevel_Count - 1
};
typedef int32_t BoneIndex_t;
const BoneIndex_t k_unInvalidBoneIndex = -1;
enum EVRInitError {
    VRInitError_None = 0,
    VRInitError_Unknown = 1,
    VRInitError_Init_InstallationNotFound = 100,
    VRInitError_Init_InstallationCorrupt = 101,
    VRInitError_Init_VRClientDLLNotFound = 102,
    VRInitError_Init_FileNotFound = 103,
    VRInitError_Init_FactoryNotFound = 104,
    VRInitError_Init_InterfaceNotFound = 105,
    VRInitError_Init_InvalidInterface = 106,
    VRInitError_Init_UserConfigDirectoryInvalid = 107,
    VRInitError_Init_HmdNotFound = 108,
    VRInitError_Init_NotInitialized = 109,
    VRInitError_Init_PathRegistryNotFound = 110,
    VRInitError_Init_NoConfigPath = 111,
    VRInitError_Init_NoLogPath = 112,
    VRInitError_Init_PathRegistryNotWritable = 113,
    VRInitError_Init_AppInfoInitFailed = 114,
    VRInitError_Init_Retry = 115,
    VRInitError_Init_InitCanceledByUser = 116,
    VRInitError_Init_AnotherAppLaunching = 117,
    VRInitError_Init_SettingsInitFailed = 118,
    VRInitError_Init_ShuttingDown = 119,
    VRInitError_Init_TooManyObjects = 120,
    VRInitError_Init_NoServerForBackgroundApp = 121,
    VRInitError_Init_NotSupportedWithCompositor = 122,
    VRInitError_Init_NotAvailableToUtilityApps = 123,
    VRInitError_Init_Internal = 124,
    VRInitError_Init_HmdDriverIdIsNone = 125,
    VRInitError_Init_HmdNotFoundPresenceFailed = 126,
    VRInitError_Init_VRMonitorNotFound = 127,
    VRInitError_Init_VRMonitorStartupFailed = 128,
    VRInitError_Init_LowPowerWatchdogNotSupported = 129,
    VRInitError_Init_InvalidApplicationType = 130,
    VRInitError_Init_NotAvailableToWatchdogApps = 131,
    VRInitError_Init_WatchdogDisabledInSettings = 132,
    VRInitError_Init_VRDashboardNotFound = 133,
    VRInitError_Init_VRDashboardStartupFailed = 134,
    VRInitError_Init_VRHomeNotFound = 135,
    VRInitError_Init_VRHomeStartupFailed = 136,
    VRInitError_Init_RebootingBusy = 137,
    VRInitError_Init_FirmwareUpdateBusy = 138,
    VRInitError_Init_FirmwareRecoveryBusy = 139,
    VRInitError_Init_USBServiceBusy = 140,
    VRInitError_Init_VRWebHelperStartupFailed = 141,
    VRInitError_Init_TrackerManagerInitFailed = 142,
    VRInitError_Init_AlreadyRunning = 143,
    VRInitError_Init_FailedForVrMonitor = 144,
    VRInitError_Init_PropertyManagerInitFailed = 145,
    VRInitError_Init_WebServerFailed = 146,
    VRInitError_Init_IllegalTypeTransition = 147,
    VRInitError_Init_MismatchedRuntimes = 148,
    VRInitError_Init_InvalidProcessId = 149,
    VRInitError_Init_VRServiceStartupFailed = 150,
    VRInitError_Init_PrismNeedsNewDrivers = 151,
    VRInitError_Init_PrismStartupTimedOut = 152,
    VRInitError_Init_CouldNotStartPrism = 153,
    VRInitError_Init_PrismClientInitFailed = 154,
    VRInitError_Init_PrismClientStartFailed = 155,
    VRInitError_Init_PrismExitedUnexpectedly = 156,
    VRInitError_Init_BadLuid = 157,
    VRInitError_Init_NoServerForAppContainer = 158,
    VRInitError_Init_DuplicateBootstrapper = 159,
    VRInitError_Init_VRDashboardServicePending = 160,
    VRInitError_Init_VRDashboardServiceTimeout = 161,
    VRInitError_Init_VRDashboardServiceStopped = 162,
    VRInitError_Init_VRDashboardAlreadyStarted = 163,
    VRInitError_Init_VRDashboardCopyFailed = 164,
    VRInitError_Init_VRDashboardTokenFailure = 165,
    VRInitError_Init_VRDashboardEnvironmentFailure = 166,
    VRInitError_Init_VRDashboardPathFailure = 167,
    VRInitError_Driver_Failed = 200,
    VRInitError_Driver_Unknown = 201,
    VRInitError_Driver_HmdUnknown = 202,
    VRInitError_Driver_NotLoaded = 203,
    VRInitError_Driver_RuntimeOutOfDate = 204,
    VRInitError_Driver_HmdInUse = 205,
    VRInitError_Driver_NotCalibrated = 206,
    VRInitError_Driver_CalibrationInvalid = 207,
    VRInitError_Driver_HmdDisplayNotFound = 208,
    VRInitError_Driver_TrackedDeviceInterfaceUnknown = 209,
    VRInitError_Driver_HmdDriverIdOutOfBounds = 211,
    VRInitError_Driver_HmdDisplayMirrored = 212,
    VRInitError_Driver_HmdDisplayNotFoundLaptop = 213,
    VRInitError_Driver_PeerDriverNotInstalled = 214,
    VRInitError_Driver_WirelessHmdNotConnected = 215,
    VRInitError_IPC_ServerInitFailed = 300,
    VRInitError_IPC_ConnectFailed = 301,
    VRInitError_IPC_SharedStateInitFailed = 302,
    VRInitError_IPC_CompositorInitFailed = 303,
    VRInitError_IPC_MutexInitFailed = 304,
    VRInitError_IPC_Failed = 305,
    VRInitError_IPC_CompositorConnectFailed = 306,
    VRInitError_IPC_CompositorInvalidConnectResponse = 307,
    VRInitError_IPC_ConnectFailedAfterMultipleAttempts = 308,
    VRInitError_IPC_ConnectFailedAfterTargetExited = 309,
    VRInitError_IPC_NamespaceUnavailable = 310,
    VRInitError_Compositor_Failed = 400,
    VRInitError_Compositor_D3D11HardwareRequired = 401,
    VRInitError_Compositor_FirmwareRequiresUpdate = 402,
    VRInitError_Compositor_OverlayInitFailed = 403,
    VRInitError_Compositor_ScreenshotsInitFailed = 404,
    VRInitError_Compositor_UnableToCreateDevice = 405,
    VRInitError_Compositor_SharedStateIsNull = 406,
    VRInitError_Compositor_NotificationManagerIsNull = 407,
    VRInitError_Compositor_ResourceManagerClientIsNull = 408,
    VRInitError_Compositor_MessageOverlaySharedStateInitFailure = 409,
    VRInitError_Compositor_PropertiesInterfaceIsNull = 410,
    VRInitError_Compositor_CreateFullscreenWindowFailed = 411,
    VRInitError_Compositor_SettingsInterfaceIsNull = 412,
    VRInitError_Compositor_FailedToShowWindow = 413,
    VRInitError_Compositor_DistortInterfaceIsNull = 414,
    VRInitError_Compositor_DisplayFrequencyFailure = 415,
    VRInitError_Compositor_RendererInitializationFailed = 416,
    VRInitError_Compositor_DXGIFactoryInterfaceIsNull = 417,
    VRInitError_Compositor_DXGIFactoryCreateFailed = 418,
    VRInitError_Compositor_DXGIFactoryQueryFailed = 419,
    VRInitError_Compositor_InvalidAdapterDesktop = 420,
    VRInitError_Compositor_InvalidHmdAttachment = 421,
    VRInitError_Compositor_InvalidOutputDesktop = 422,
    VRInitError_Compositor_InvalidDeviceProvided = 423,
    VRInitError_Compositor_D3D11RendererInitializationFailed = 424,
    VRInitError_Compositor_FailedToFindDisplayMode = 425,
    VRInitError_Compositor_FailedToCreateSwapChain = 426,
    VRInitError_Compositor_FailedToGetBackBuffer = 427,
    VRInitError_Compositor_FailedToCreateRenderTarget = 428,
    VRInitError_Compositor_FailedToCreateDXGI2SwapChain = 429,
    VRInitError_Compositor_FailedtoGetDXGI2BackBuffer = 430,
    VRInitError_Compositor_FailedToCreateDXGI2RenderTarget = 431,
    VRInitError_Compositor_FailedToGetDXGIDeviceInterface = 432,
    VRInitError_Compositor_SelectDisplayMode = 433,
    VRInitError_Compositor_FailedToCreateNvAPIRenderTargets = 434,
    VRInitError_Compositor_NvAPISetDisplayMode = 435,
    VRInitError_Compositor_FailedToCreateDirectModeDisplay = 436,
    VRInitError_Compositor_InvalidHmdPropertyContainer = 437,
    VRInitError_Compositor_UpdateDisplayFrequency = 438,
    VRInitError_Compositor_CreateRasterizerState = 439,
    VRInitError_Compositor_CreateWireframeRasterizerState = 440,
    VRInitError_Compositor_CreateSamplerState = 441,
    VRInitError_Compositor_CreateClampToBorderSamplerState = 442,
    VRInitError_Compositor_CreateAnisoSamplerState = 443,
    VRInitError_Compositor_CreateOverlaySamplerState = 444,
    VRInitError_Compositor_CreatePanoramaSamplerState = 445,
    VRInitError_Compositor_CreateFontSamplerState = 446,
    VRInitError_Compositor_CreateNoBlendState = 447,
    VRInitError_Compositor_CreateBlendState = 448,
    VRInitError_Compositor_CreateAlphaBlendState = 449,
    VRInitError_Compositor_CreateBlendStateMaskR = 450,
    VRInitError_Compositor_CreateBlendStateMaskG = 451,
    VRInitError_Compositor_CreateBlendStateMaskB = 452,
    VRInitError_Compositor_CreateDepthStencilState = 453,
    VRInitError_Compositor_CreateDepthStencilStateNoWrite = 454,
    VRInitError_Compositor_CreateDepthStencilStateNoDepth = 455,
    VRInitError_Compositor_CreateFlushTexture = 456,
    VRInitError_Compositor_CreateDistortionSurfaces = 457,
    VRInitError_Compositor_CreateConstantBuffer = 458,
    VRInitError_Compositor_CreateHmdPoseConstantBuffer = 459,
    VRInitError_Compositor_CreateHmdPoseStagingConstantBuffer = 460,
    VRInitError_Compositor_CreateSharedFrameInfoConstantBuffer = 461,
    VRInitError_Compositor_CreateOverlayConstantBuffer = 462,
    VRInitError_Compositor_CreateSceneTextureIndexConstantBuffer = 463,
    VRInitError_Compositor_CreateReadableSceneTextureIndexConstantBuffer = 464,
    VRInitError_Compositor_CreateLayerGraphicsTextureIndexConstantBuffer = 465,
    VRInitError_Compositor_CreateLayerComputeTextureIndexConstantBuffer = 466,
    VRInitError_Compositor_CreateLayerComputeSceneTextureIndexConstantBuffer = 467,
    VRInitError_Compositor_CreateComputeHmdPoseConstantBuffer = 468,
    VRInitError_Compositor_CreateGeomConstantBuffer = 469,
    VRInitError_Compositor_CreatePanelMaskConstantBuffer = 470,
    VRInitError_Compositor_CreatePixelSimUBO = 471,
    VRInitError_Compositor_CreateMSAARenderTextures = 472,
    VRInitError_Compositor_CreateResolveRenderTextures = 473,
    VRInitError_Compositor_CreateComputeResolveRenderTextures = 474,
    VRInitError_Compositor_CreateDriverDirectModeResolveTextures = 475,
    VRInitError_Compositor_OpenDriverDirectModeResolveTextures = 476,
    VRInitError_Compositor_CreateFallbackSyncTexture = 477,
    VRInitError_Compositor_ShareFallbackSyncTexture = 478,
    VRInitError_Compositor_CreateOverlayIndexBuffer = 479,
    VRInitError_Compositor_CreateOverlayVertexBuffer = 480,
    VRInitError_Compositor_CreateTextVertexBuffer = 481,
    VRInitError_Compositor_CreateTextIndexBuffer = 482,
    VRInitError_Compositor_CreateMirrorTextures = 483,
    VRInitError_Compositor_CreateLastFrameRenderTexture = 484,
    VRInitError_Compositor_CreateMirrorOverlay = 485,
    VRInitError_Compositor_FailedToCreateVirtualDisplayBackbuffer = 486,
    VRInitError_Compositor_DisplayModeNotSupported = 487,
    VRInitError_Compositor_CreateOverlayInvalidCall = 488,
    VRInitError_Compositor_CreateOverlayAlreadyInitialized = 489,
    VRInitError_Compositor_FailedToCreateMailbox = 490,
    VRInitError_Compositor_WindowInterfaceIsNull = 491,
    VRInitError_Compositor_SystemLayerCreateInstance = 492,
    VRInitError_Compositor_SystemLayerCreateSession = 493,
    VRInitError_Compositor_CreateInverseDistortUVs = 494,
    VRInitError_Compositor_CreateBackbufferDepth = 495,
    VRInitError_VendorSpecific_UnableToConnectToOculusRuntime = 1000,
    VRInitError_VendorSpecific_WindowsNotInDevMode = 1001,
    VRInitError_VendorSpecific_OculusLinkNotEnabled = 1002,
    VRInitError_VendorSpecific_HmdFound_CantOpenDevice = 1101,
    VRInitError_VendorSpecific_HmdFound_UnableToRequestConfigStart = 1102,
    VRInitError_VendorSpecific_HmdFound_NoStoredConfig = 1103,
    VRInitError_VendorSpecific_HmdFound_ConfigTooBig = 1104,
    VRInitError_VendorSpecific_HmdFound_ConfigTooSmall = 1105,
    VRInitError_VendorSpecific_HmdFound_UnableToInitZLib = 1106,
    VRInitError_VendorSpecific_HmdFound_CantReadFirmwareVersion = 1107,
    VRInitError_VendorSpecific_HmdFound_UnableToSendUserDataStart = 1108,
    VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataStart = 1109,
    VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataNext = 1110,
    VRInitError_VendorSpecific_HmdFound_UserDataAddressRange = 1111,
    VRInitError_VendorSpecific_HmdFound_UserDataError = 1112,
    VRInitError_VendorSpecific_HmdFound_ConfigFailedSanityCheck = 1113,
    VRInitError_VendorSpecific_OculusRuntimeBadInstall = 1114,
    VRInitError_VendorSpecific_HmdFound_UnexpectedConfiguration_1 = 1115,
    VRInitError_Steam_SteamInstallationNotFound = 2000,
    VRInitError_LastError
};
enum EVRScreenshotType {
    VRScreenshotType_None = 0,
    VRScreenshotType_Mono = 1,
    VRScreenshotType_Stereo = 2,
    VRScreenshotType_Cubemap = 3,
    VRScreenshotType_MonoPanorama = 4,
    VRScreenshotType_StereoPanorama = 5
};
enum EVRScreenshotPropertyFilenames {
    VRScreenshotPropertyFilenames_Preview = 0,
    VRScreenshotPropertyFilenames_VR = 1,
};
enum EVRTrackedCameraError {
    VRTrackedCameraError_None = 0,
    VRTrackedCameraError_OperationFailed = 100,
    VRTrackedCameraError_InvalidHandle = 101,
    VRTrackedCameraError_InvalidFrameHeaderVersion = 102,
    VRTrackedCameraError_OutOfHandles = 103,
    VRTrackedCameraError_IPCFailure = 104,
    VRTrackedCameraError_NotSupportedForThisDevice = 105,
    VRTrackedCameraError_SharedMemoryFailure = 106,
    VRTrackedCameraError_FrameBufferingFailure = 107,
    VRTrackedCameraError_StreamSetupFailure = 108,
    VRTrackedCameraError_InvalidGLTextureId = 109,
    VRTrackedCameraError_InvalidSharedTextureHandle = 110,
    VRTrackedCameraError_FailedToGetGLTextureId = 111,
    VRTrackedCameraError_SharedTextureFailure = 112,
    VRTrackedCameraError_NoFrameAvailable = 113,
    VRTrackedCameraError_InvalidArgument = 114,
    VRTrackedCameraError_InvalidFrameBufferSize = 115,
};
enum EVRTrackedCameraFrameLayout {
    EVRTrackedCameraFrameLayout_Mono = 0x0001,
    EVRTrackedCameraFrameLayout_Stereo = 0x0002,
    EVRTrackedCameraFrameLayout_VerticalLayout = 0x0010,
    EVRTrackedCameraFrameLayout_HorizontalLayout = 0x0020,
};
enum EVRTrackedCameraFrameType {
    VRTrackedCameraFrameType_Distorted = 0,
    VRTrackedCameraFrameType_Undistorted,
    VRTrackedCameraFrameType_MaximumUndistorted,
    MAX_CAMERA_FRAME_TYPES
};
enum EVRDistortionFunctionType {
    VRDistortionFunctionType_None,
    VRDistortionFunctionType_FTheta,
    VRDistortionFunctionType_Extended_FTheta,
    MAX_DISTORTION_FUNCTION_TYPES,
};
static const uint32_t k_unMaxDistortionFunctionParameters = 8;
typedef uint64_t TrackedCameraHandle_t;
struct CameraVideoStreamFrameHeader_t {
    EVRTrackedCameraFrameType eFrameType;
    uint32_t nWidth;
    uint32_t nHeight;
    uint32_t nBytesPerPixel;
    uint32_t nFrameSequence;
    TrackedDevicePose_t trackedDevicePose;
    uint64_t ulFrameExposureTime;
};
typedef uint32_t ScreenshotHandle_t;
static const uint32_t k_unScreenshotHandleInvalid = 0;
const uint32_t VRCompositor_ReprojectionReason_Cpu = 0x01;
const uint32_t VRCompositor_ReprojectionReason_Gpu = 0x02;
const uint32_t VRCompositor_ReprojectionAsync = 0x04;
const uint32_t VRCompositor_ReprojectionMotion = 0x08;
const uint32_t VRCompositor_PredictionMask = 0xF0;
const uint32_t VRCompositor_ThrottleMask = 0xF00;
struct Compositor_FrameTiming {
    uint32_t m_nSize;
    uint32_t m_nFrameIndex;
    uint32_t m_nNumFramePresents;
    uint32_t m_nNumMisPresented;
    uint32_t m_nNumDroppedFrames;
    uint32_t m_nReprojectionFlags;
    double m_flSystemTimeInSeconds;
    float m_flPreSubmitGpuMs;
    float m_flPostSubmitGpuMs;
    float m_flTotalRenderGpuMs;
    float m_flCompositorRenderGpuMs;
    float m_flCompositorRenderCpuMs;
    float m_flCompositorIdleCpuMs;
    float m_flClientFrameIntervalMs;
    float m_flPresentCallCpuMs;
    float m_flWaitForPresentCpuMs;
    float m_flSubmitFrameMs;
    float m_flWaitGetPosesCalledMs;
    float m_flNewPosesReadyMs;
    float m_flNewFrameReadyMs;
    float m_flCompositorUpdateStartMs;
    float m_flCompositorUpdateEndMs;
    float m_flCompositorRenderStartMs;
    vr::TrackedDevicePose_t m_HmdPose;
    uint32_t m_nNumVSyncsReadyForUse;
    uint32_t m_nNumVSyncsToFirstView;
};
struct Compositor_BenchmarkResults {
    float m_flMegaPixelsPerSecond;
    float m_flHmdRecommendedMegaPixelsPerSecond;
};
struct DriverDirectMode_FrameTiming {
    uint32_t m_nSize;
    uint32_t m_nNumFramePresents;
    uint32_t m_nNumMisPresented;
    uint32_t m_nNumDroppedFrames;
    uint32_t m_nReprojectionFlags;
};
const uint32_t VRCompositor_ReprojectionMotion_Enabled = 0x100;
const uint32_t VRCompositor_ReprojectionMotion_ForcedOn = 0x200;
const uint32_t VRCompositor_ReprojectionMotion_AppThrottled = 0x400;
enum EVSync {
    VSync_None,
    VSync_WaitRender,
    VSync_NoWaitRender,
};
enum EVRMuraCorrectionMode {
    EVRMuraCorrectionMode_Default = 0,
    EVRMuraCorrectionMode_NoCorrection
};
enum Imu_OffScaleFlags {
    OffScale_AccelX = 0x01,
    OffScale_AccelY = 0x02,
    OffScale_AccelZ = 0x04,
    OffScale_GyroX = 0x08,
    OffScale_GyroY = 0x10,
    OffScale_GyroZ = 0x20,
};
struct ImuSample_t {
    double fSampleTime;
    HmdVector3d_t vAccel;
    HmdVector3d_t vGyro;
    uint32_t unOffScaleFlags;
};
#pragma pack(pop)
}
namespace vr {
class IVRSystem {
public:
    virtual void GetRecommendedRenderTargetSize(uint32_t* pnWidth, uint32_t* pnHeight) = 0;
    virtual HmdMatrix44_t GetProjectionMatrix(EVREye eEye, float fNearZ, float fFarZ) = 0;
    virtual void GetProjectionRaw(EVREye eEye, float* pfLeft, float* pfRight, float* pfTop, float* pfBottom) = 0;
    virtual bool ComputeDistortion(EVREye eEye, float fU, float fV, DistortionCoordinates_t* pDistortionCoordinates) = 0;
    virtual HmdMatrix34_t GetEyeToHeadTransform(EVREye eEye) = 0;
    virtual bool GetTimeSinceLastVsync(float* pfSecondsSinceLastVsync, uint64_t* pulFrameCounter) = 0;
    virtual int32_t GetD3D9AdapterIndex() = 0;
    virtual void GetDXGIOutputInfo(int32_t* pnAdapterIndex) = 0;
    virtual void GetOutputDevice(uint64_t* pnDevice, ETextureType textureType, VkInstance_T* pInstance = nullptr) = 0;
    virtual bool IsDisplayOnDesktop() = 0;
    virtual bool SetDisplayVisibility(bool bIsVisibleOnDesktop) = 0;
    virtual void GetDeviceToAbsoluteTrackingPose(ETrackingUniverseOrigin eOrigin, float fPredictedSecondsToPhotonsFromNow, TrackedDevicePose_t* pTrackedDevicePoseArray, uint32_t unTrackedDevicePoseArrayCount) = 0;
    virtual HmdMatrix34_t GetSeatedZeroPoseToStandingAbsoluteTrackingPose() = 0;
    virtual HmdMatrix34_t GetRawZeroPoseToStandingAbsoluteTrackingPose() = 0;
    virtual uint32_t GetSortedTrackedDeviceIndicesOfClass(ETrackedDeviceClass eTrackedDeviceClass, vr::TrackedDeviceIndex_t* punTrackedDeviceIndexArray, uint32_t unTrackedDeviceIndexArrayCount, vr::TrackedDeviceIndex_t unRelativeToTrackedDeviceIndex = k_unTrackedDeviceIndex_Hmd) = 0;
    virtual EDeviceActivityLevel GetTrackedDeviceActivityLevel(vr::TrackedDeviceIndex_t unDeviceId) = 0;
    virtual void ApplyTransform(TrackedDevicePose_t* pOutputPose, const TrackedDevicePose_t* pTrackedDevicePose, const HmdMatrix34_t* pTransform) = 0;
    virtual vr::TrackedDeviceIndex_t GetTrackedDeviceIndexForControllerRole(vr::ETrackedControllerRole unDeviceType) = 0;
    virtual vr::ETrackedControllerRole GetControllerRoleForTrackedDeviceIndex(vr::TrackedDeviceIndex_t unDeviceIndex) = 0;
    virtual ETrackedDeviceClass GetTrackedDeviceClass(vr::TrackedDeviceIndex_t unDeviceIndex) = 0;
    virtual bool IsTrackedDeviceConnected(vr::TrackedDeviceIndex_t unDeviceIndex) = 0;
    virtual bool GetBoolTrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError* pError = 0L) = 0;
    virtual float GetFloatTrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError* pError = 0L) = 0;
    virtual int32_t GetInt32TrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError* pError = 0L) = 0;
    virtual uint64_t GetUint64TrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError* pError = 0L) = 0;
    virtual HmdMatrix34_t GetMatrix34TrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError* pError = 0L) = 0;
    virtual uint32_t GetArrayTrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, PropertyTypeTag_t propType, void* pBuffer, uint32_t unBufferSize, ETrackedPropertyError* pError = 0L) = 0;
    virtual uint32_t GetStringTrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, char* pchValue, uint32_t unBufferSize, ETrackedPropertyError* pError = 0L) = 0;
    virtual const char* GetPropErrorNameFromEnum(ETrackedPropertyError error) = 0;
    virtual bool PollNextEvent(VREvent_t* pEvent, uint32_t uncbVREvent) = 0;
    virtual bool PollNextEventWithPose(ETrackingUniverseOrigin eOrigin, VREvent_t* pEvent, uint32_t uncbVREvent, vr::TrackedDevicePose_t* pTrackedDevicePose) = 0;
    virtual const char* GetEventTypeNameFromEnum(EVREventType eType) = 0;
    virtual HiddenAreaMesh_t GetHiddenAreaMesh(EVREye eEye, EHiddenAreaMeshType type = k_eHiddenAreaMesh_Standard) = 0;
    virtual bool GetControllerState(vr::TrackedDeviceIndex_t unControllerDeviceIndex, vr::VRControllerState_t* pControllerState, uint32_t unControllerStateSize) = 0;
    virtual bool GetControllerStateWithPose(ETrackingUniverseOrigin eOrigin, vr::TrackedDeviceIndex_t unControllerDeviceIndex, vr::VRControllerState_t* pControllerState, uint32_t unControllerStateSize, TrackedDevicePose_t* pTrackedDevicePose) = 0;
    virtual void TriggerHapticPulse(vr::TrackedDeviceIndex_t unControllerDeviceIndex, uint32_t unAxisId, unsigned short usDurationMicroSec) = 0;
    virtual const char* GetButtonIdNameFromEnum(EVRButtonId eButtonId) = 0;
    virtual const char* GetControllerAxisTypeNameFromEnum(EVRControllerAxisType eAxisType) = 0;
    virtual bool IsInputAvailable() = 0;
    virtual bool IsSteamVRDrawingControllers() = 0;
    virtual bool ShouldApplicationPause() = 0;
    virtual bool ShouldApplicationReduceRenderingWork() = 0;
    virtual vr::EVRFirmwareError PerformFirmwareUpdate(vr::TrackedDeviceIndex_t unDeviceIndex) = 0;
    virtual void AcknowledgeQuit_Exiting() = 0;
    virtual uint32_t GetAppContainerFilePaths(char* pchBuffer, uint32_t unBufferSize) = 0;
    virtual const char* GetRuntimeVersion() = 0;
};
static const char* const IVRSystem_Version = "IVRSystem_022";
}
namespace vr {
enum EVRApplicationError {
    VRApplicationError_None = 0,
    VRApplicationError_AppKeyAlreadyExists = 100,
    VRApplicationError_NoManifest = 101,
    VRApplicationError_NoApplication = 102,
    VRApplicationError_InvalidIndex = 103,
    VRApplicationError_UnknownApplication = 104,
    VRApplicationError_IPCFailed = 105,
    VRApplicationError_ApplicationAlreadyRunning = 106,
    VRApplicationError_InvalidManifest = 107,
    VRApplicationError_InvalidApplication = 108,
    VRApplicationError_LaunchFailed = 109,
    VRApplicationError_ApplicationAlreadyStarting = 110,
    VRApplicationError_LaunchInProgress = 111,
    VRApplicationError_OldApplicationQuitting = 112,
    VRApplicationError_TransitionAborted = 113,
    VRApplicationError_IsTemplate = 114,
    VRApplicationError_SteamVRIsExiting = 115,
    VRApplicationError_BufferTooSmall = 200,
    VRApplicationError_PropertyNotSet = 201,
    VRApplicationError_UnknownProperty = 202,
    VRApplicationError_InvalidParameter = 203,
    VRApplicationError_NotImplemented = 300,
};
static const uint32_t k_unMaxApplicationKeyLength = 128;
enum EVRApplicationProperty {
    VRApplicationProperty_Name_String = 0,
    VRApplicationProperty_LaunchType_String = 11,
    VRApplicationProperty_WorkingDirectory_String = 12,
    VRApplicationProperty_BinaryPath_String = 13,
    VRApplicationProperty_Arguments_String = 14,
    VRApplicationProperty_URL_String = 15,
    VRApplicationProperty_Description_String = 50,
    VRApplicationProperty_NewsURL_String = 51,
    VRApplicationProperty_ImagePath_String = 52,
    VRApplicationProperty_Source_String = 53,
    VRApplicationProperty_ActionManifestURL_String = 54,
    VRApplicationProperty_IsDashboardOverlay_Bool = 60,
    VRApplicationProperty_IsTemplate_Bool = 61,
    VRApplicationProperty_IsInstanced_Bool = 62,
    VRApplicationProperty_IsInternal_Bool = 63,
    VRApplicationProperty_WantsCompositorPauseInStandby_Bool = 64,
    VRApplicationProperty_IsHidden_Bool = 65,
    VRApplicationProperty_LastLaunchTime_Uint64 = 70,
};
enum EVRSceneApplicationState {
    EVRSceneApplicationState_None = 0,
    EVRSceneApplicationState_Starting = 1,
    EVRSceneApplicationState_Quitting = 2,
    EVRSceneApplicationState_Running = 3,
    EVRSceneApplicationState_Waiting = 4,
};
struct AppOverrideKeys_t {
    const char* pchKey;
    const char* pchValue;
};
static const char* const k_pch_MimeType_HomeApp = "vr/home";
static const char* const k_pch_MimeType_GameTheater = "vr/game_theater";
class IVRApplications {
public:
    virtual EVRApplicationError AddApplicationManifest(const char* pchApplicationManifestFullPath, bool bTemporary = false) = 0;
    virtual EVRApplicationError RemoveApplicationManifest(const char* pchApplicationManifestFullPath) = 0;
    virtual bool IsApplicationInstalled(const char* pchAppKey) = 0;
    virtual uint32_t GetApplicationCount() = 0;
    virtual EVRApplicationError GetApplicationKeyByIndex(uint32_t unApplicationIndex, char* pchAppKeyBuffer, uint32_t unAppKeyBufferLen) = 0;
    virtual EVRApplicationError GetApplicationKeyByProcessId(uint32_t unProcessId, char* pchAppKeyBuffer, uint32_t unAppKeyBufferLen) = 0;
    virtual EVRApplicationError LaunchApplication(const char* pchAppKey) = 0;
    virtual EVRApplicationError LaunchTemplateApplication(const char* pchTemplateAppKey, const char* pchNewAppKey, const AppOverrideKeys_t* pKeys, uint32_t unKeys) = 0;
    virtual vr::EVRApplicationError LaunchApplicationFromMimeType(const char* pchMimeType, const char* pchArgs) = 0;
    virtual EVRApplicationError LaunchDashboardOverlay(const char* pchAppKey) = 0;
    virtual bool CancelApplicationLaunch(const char* pchAppKey) = 0;
    virtual EVRApplicationError IdentifyApplication(uint32_t unProcessId, const char* pchAppKey) = 0;
    virtual uint32_t GetApplicationProcessId(const char* pchAppKey) = 0;
    virtual const char* GetApplicationsErrorNameFromEnum(EVRApplicationError error) = 0;
    virtual uint32_t GetApplicationPropertyString(const char* pchAppKey, EVRApplicationProperty eProperty, char* pchPropertyValueBuffer, uint32_t unPropertyValueBufferLen, EVRApplicationError* peError = nullptr) = 0;
    virtual bool GetApplicationPropertyBool(const char* pchAppKey, EVRApplicationProperty eProperty, EVRApplicationError* peError = nullptr) = 0;
    virtual uint64_t GetApplicationPropertyUint64(const char* pchAppKey, EVRApplicationProperty eProperty, EVRApplicationError* peError = nullptr) = 0;
    virtual EVRApplicationError SetApplicationAutoLaunch(const char* pchAppKey, bool bAutoLaunch) = 0;
    virtual bool GetApplicationAutoLaunch(const char* pchAppKey) = 0;
    virtual EVRApplicationError SetDefaultApplicationForMimeType(const char* pchAppKey, const char* pchMimeType) = 0;
    virtual bool GetDefaultApplicationForMimeType(const char* pchMimeType, char* pchAppKeyBuffer, uint32_t unAppKeyBufferLen) = 0;
    virtual bool GetApplicationSupportedMimeTypes(const char* pchAppKey, char* pchMimeTypesBuffer, uint32_t unMimeTypesBuffer) = 0;
    virtual uint32_t GetApplicationsThatSupportMimeType(const char* pchMimeType, char* pchAppKeysThatSupportBuffer, uint32_t unAppKeysThatSupportBuffer) = 0;
    virtual uint32_t GetApplicationLaunchArguments(uint32_t unHandle, char* pchArgs, uint32_t unArgs) = 0;
    virtual EVRApplicationError GetStartingApplication(char* pchAppKeyBuffer, uint32_t unAppKeyBufferLen) = 0;
    virtual EVRSceneApplicationState GetSceneApplicationState() = 0;
    virtual EVRApplicationError PerformApplicationPrelaunchCheck(const char* pchAppKey) = 0;
    virtual const char* GetSceneApplicationStateNameFromEnum(EVRSceneApplicationState state) = 0;
    virtual EVRApplicationError LaunchInternalProcess(const char* pchBinaryPath, const char* pchArguments, const char* pchWorkingDirectory) = 0;
    virtual uint32_t GetCurrentSceneProcessId() = 0;
};
static const char* const IVRApplications_Version = "IVRApplications_007";
}
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4514 4820)
#pragma warning(disable : 4985)
extern "C++" {
#pragma pack(push, 8)
namespace std {
    struct nothrow_t {
        explicit nothrow_t() = default;
    };
    extern nothrow_t const nothrow;
}
[[nodiscard]] __declspec(allocator) void* __cdecl operator new(
    size_t _Size);
[[nodiscard]] __declspec(allocator) void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&) noexcept;
[[nodiscard]] __declspec(allocator) void* __cdecl operator new[](
    size_t _Size);
[[nodiscard]] __declspec(allocator) void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&) noexcept;
void __cdecl operator delete(
    void* _Block) noexcept;
void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&) noexcept;
void __cdecl operator delete[](
    void* _Block) noexcept;
void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&) noexcept;
void __cdecl operator delete(
    void* _Block,
    size_t _Size) noexcept;
void __cdecl operator delete[](
    void* _Block,
    size_t _Size) noexcept;
#pragma warning(push)
#pragma warning(disable : 4577)
#pragma warning(disable : 4514)
[[nodiscard]] [[msvc::constexpr]] inline void* __cdecl operator new(size_t _Size,
    void* _Where) noexcept
{
    (void)_Size;
    return _Where;
}
inline void __cdecl operator delete(void*, void*) noexcept
{
    return;
}
[[nodiscard]] inline void* __cdecl operator new[](size_t _Size,
    void* _Where) noexcept
{
    (void)_Size;
    return _Where;
}
inline void __cdecl operator delete[](void*, void*) noexcept
{
}
#pragma warning(pop)
#pragma pack(pop)
}
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4514 4820)
extern "C++" {
#pragma pack(push, 8)
[[nodiscard]] __declspec(allocator) void* __cdecl operator new(
    size_t _Size,
    int _BlockUse,
    char const* _FileName,
    int _LineNumber);
[[nodiscard]] __declspec(allocator) void* __cdecl operator new[](
    size_t _Size,
    int _BlockUse,
    char const* _FileName,
    int _LineNumber);
void __cdecl operator delete(
    void* _Block,
    int _BlockUse,
    char const* _FileName,
    int _LineNumber) noexcept;
void __cdecl operator delete[](
    void* _Block,
    int _BlockUse,
    char const* _FileName,
    int _LineNumber) noexcept;
#pragma pack(pop)
}
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    typedef void* _HFILE;
    typedef int(__cdecl * _CRT_REPORT_HOOK)(int, char*, int*);
    typedef int(__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t*, int*);
    typedef int(__cdecl * _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);
    typedef void(__cdecl * _CRT_DUMP_CLIENT)(void*, size_t);
    struct _CrtMemBlockHeader;
    typedef struct _CrtMemState {
        struct _CrtMemBlockHeader* pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
    } _CrtMemState;
    __declspec(dllimport) int* __cdecl __p__crtDbgFlag(void);
    __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);
    __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);
    __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK _PfnNewHook);
    __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);
    __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT _PFnNewDump);
    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);
    typedef void(__cdecl * _CrtDoForAllClientObjectsCallback)(void*, void*);
    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
        _CrtDoForAllClientObjectsCallback _Callback,
        void* _Context);
    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);
    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
        void const* _Block,
        unsigned int _Size,
        long* _RequestNumber,
        char** _FileName,
        int* _LineNumber);
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
        void const* _Pointer);
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
        void const* _Pointer,
        unsigned int _Size,
        int _ReadWrite);
    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
        _CrtMemState * _State);
    __declspec(dllimport) int __cdecl _CrtMemDifference(
        _CrtMemState * _State,
        _CrtMemState const* _OldState,
        _CrtMemState const* _NewState);
    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
        _CrtMemState const* _State);
    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
        _CrtMemState const* _State);
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
        void const* _Block);
    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
        long _NewValue);
    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
        int _NewFlag);
    __declspec(dllimport) void __cdecl _aligned_free_dbg(
        void* _Block);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
        size_t _Size,
        size_t _Alignment,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
        void* _Block,
        size_t _Alignment,
        size_t _Offset);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
        size_t _Size,
        size_t _Alignment,
        size_t _Offset,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
        void* _Block,
        size_t _Size,
        size_t _Alignment,
        size_t _Offset,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
        void* _Block,
        size_t _Count,
        size_t _Size,
        size_t _Alignment,
        size_t _Offset,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
        void* _Block,
        size_t _Size,
        size_t _Alignment,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
        void* _Block,
        size_t _Count,
        size_t _Size,
        size_t _Alignment,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
        size_t _Count,
        size_t _Size,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
        void* _Block,
        size_t _Size,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) void __cdecl _free_dbg(
        void* _Block,
        int _BlockUse);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
        size_t _Size,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) size_t __cdecl _msize_dbg(
        void* _Block,
        int _BlockUse);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
        void* _Block,
        size_t _Size,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
        void* _Block,
        size_t _Count,
        size_t _Size,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
        char** _PBuffer,
        size_t* _PBufferSizeInBytes,
        char const* _VarName,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
        char* _FullPath,
        char const* _Path,
        size_t _SizeInBytes,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
        char* _DstBuf,
        int _SizeInBytes,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
        int _Drive,
        char* _DstBuf,
        int _SizeInBytes,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
        char const* _String,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
        char const* _DirName,
        char const* _FilePrefix,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
        wchar_t const* _String,
        int _BlockUse,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
        wchar_t * *_PBuffer,
        size_t * _PBufferSizeInWords,
        wchar_t const* _VarName,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
        wchar_t * _FullPath,
        wchar_t const* _Path,
        size_t _SizeInWords,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
        wchar_t * _DstBuf,
        int _SizeInWords,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
        int _Drive,
        wchar_t* _DstBuf,
        int _SizeInWords,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
        wchar_t const* _DirName,
        wchar_t const* _FilePrefix,
        int _BlockType,
        char const* _FileName,
        int _LineNumber);
    __declspec(dllimport) int __cdecl _CrtDbgReport(
        int _ReportType,
        char const* _FileName,
        int _Linenumber,
        char const* _ModuleName,
        char const* _Format,
        ...);
    __declspec(dllimport) int __cdecl _CrtDbgReportW(
        int _ReportType,
        wchar_t const* _FileName,
        int _LineNumber,
        wchar_t const* _ModuleName,
        wchar_t const* _Format,
        ...);
    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
        int _ReportType,
        void* _ReturnAddress,
        char const* _FileName,
        int _LineNumber,
        char const* _ModuleName,
        char const* _Format,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
        int _ReportType,
        void* _ReturnAddress,
        wchar_t const* _FileName,
        int _LineNumber,
        wchar_t const* _ModuleName,
        wchar_t const* _Format,
        va_list _ArgList);
    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
        size_t _NewDebugFillThreshold);
    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);
    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
        int _ReportType,
        _HFILE _ReportFile);
    __declspec(dllimport) int __cdecl _CrtSetReportMode(
        int _ReportType,
        int _ReportMode);
    extern long _crtAssertBusy;
    __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);
    __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK _PFnNewHook);
    __declspec(dllimport) int __cdecl _CrtSetReportHook2(
        int _Mode,
        _CRT_REPORT_HOOK _PFnNewHook);
    __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
        int _Mode,
        _CRT_REPORT_HOOKW _PFnNewHook);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
#pragma detect_mismatch("_MSC_VER", "1900")
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#pragma once
#pragma comment(lib, "msvcprt" \
                     "d"       \
                     "")
    namespace std
{
    enum _Uninitialized {
        _Noinit
    };
    class __declspec(dllimport) _Lockit {
    public:
        __thiscall _Lockit() noexcept;
        explicit __thiscall _Lockit(int) noexcept;
        __thiscall ~_Lockit() noexcept;
        static void __cdecl _Lockit_ctor(int) noexcept;
        static void __cdecl _Lockit_dtor(int) noexcept;

    private:
        static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
        static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
        static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

    public:
        _Lockit(const _Lockit&) = delete;
        _Lockit& operator=(const _Lockit&) = delete;

    private:
        int _Locktype;
    };
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
#pragma warning(push)
#pragma warning(disable : 4995)
using ::_Mbstatet;
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::FILE;
using ::fopen;
using ::fpos_t;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;
using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::size_t;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vfscanf;
using ::vprintf;
using ::vscanf;
using ::vsnprintf;
using ::vsprintf;
using ::vsscanf;
#pragma warning(pop)
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
#pragma warning(push)
#pragma warning(disable : 4995)
using ::memchr;
using ::memcmp;
using ::memcpy;
using ::memmove;
using ::memset;
using ::size_t;
using ::strcat;
using ::strchr;
using ::strcmp;
using ::strcoll;
using ::strcpy;
using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;
using ::strncpy;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;
using ::strtok;
using ::strxfrm;
#pragma warning(pop)
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
        wchar_t * _Buffer,
        size_t _BufferCount,
        size_t * _SizeRead);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); }
    }
    __declspec(dllimport) int __cdecl _cputws(
        wchar_t const* _Buffer);
    __declspec(dllimport) wint_t __cdecl _getwch(void);
    __declspec(dllimport) wint_t __cdecl _getwche(void);
    __declspec(dllimport) wint_t __cdecl _putwch(wchar_t _Character);
    __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _Character);
    __declspec(dllimport) wint_t __cdecl _getwch_nolock(void);
    __declspec(dllimport) wint_t __cdecl _getwche_nolock(void);
    __declspec(dllimport) wint_t __cdecl _putwch_nolock(wchar_t _Character);
    __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(wint_t _Character);
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
        unsigned __int64 _Options,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
        unsigned __int64 _Options,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
        unsigned __int64 _Options,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __inline int __cdecl _vcwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vcwprintf(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _vcwprintf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vcwprintf_s(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _vcwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vcwprintf_p(
        const wchar_t* const _Format,
        va_list _ArgList)
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _cwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwprintf(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwprintf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwprintf_s(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwprintf_p(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
        unsigned __int64 _Options,
        wchar_t const* _Format,
        _locale_t _Locale,
        va_list _ArgList);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vcwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vcwscanf_l(wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options()),
            _Format, _Locale, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vcwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vcwscanf(wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
    __inline int __cdecl _vcwscanf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        va_list _ArgList)
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
    __inline int __cdecl _vcwscanf_s(
        wchar_t const* const _Format,
        va_list _ArgList)
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_cwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _cwscanf_l(wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_cwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _cwscanf(wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwscanf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    __inline int __cdecl _cwscanf_s(
        wchar_t const* const _Format,
        ...)
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
        wchar_t * _DstBuf,
        int _SizeInWords);
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
        int _Drive,
        wchar_t* _DstBuf,
        int _SizeInWords);
    __declspec(dllimport) int __cdecl _wchdir(
        wchar_t const* _Path);
    __declspec(dllimport) int __cdecl _wmkdir(
        wchar_t const* _Path);
    __declspec(dllimport) int __cdecl _wrmdir(
        wchar_t const* _Path);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    typedef unsigned long _fsize_t;
    struct _wfinddata32_t {
        unsigned attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };
    struct _wfinddata32i64_t {
        unsigned attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        __int64 size;
        wchar_t name[260];
    };
    struct _wfinddata64i32_t {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };
    struct _wfinddata64_t {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        __int64 size;
        wchar_t name[260];
    };
    __declspec(dllimport) int __cdecl _waccess(
        wchar_t const* _FileName,
        int _AccessMode);
    __declspec(dllimport) errno_t __cdecl _waccess_s(
        wchar_t const* _FileName,
        int _AccessMode);
    __declspec(dllimport) int __cdecl _wchmod(
        wchar_t const* _FileName,
        int _Mode);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wsopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int __cdecl _wcreat(wchar_t const* _FileName,
        int _PermissionMode);
    __declspec(dllimport) intptr_t __cdecl _wfindfirst32(
        wchar_t const* _FileName,
        struct _wfinddata32_t* _FindData);
    __declspec(dllimport) int __cdecl _wfindnext32(
        intptr_t _FindHandle,
        struct _wfinddata32_t * _FindData);
    __declspec(dllimport) int __cdecl _wunlink(
        wchar_t const* _FileName);
    __declspec(dllimport) int __cdecl _wrename(
        wchar_t const* _OldFileName,
        wchar_t const* _NewFileName);
    __declspec(dllimport) errno_t __cdecl _wmktemp_s(
        wchar_t * _TemplateName,
        size_t _SizeInWords);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wmktemp_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp(wchar_t * _TemplateName);
    __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
        wchar_t const* _FileName,
        struct _wfinddata32i64_t* _FindData);
    __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
        wchar_t const* _FileName,
        struct _wfinddata64i32_t* _FindData);
    __declspec(dllimport) intptr_t __cdecl _wfindfirst64(
        wchar_t const* _FileName,
        struct _wfinddata64_t* _FindData);
    __declspec(dllimport) int __cdecl _wfindnext32i64(
        intptr_t _FindHandle,
        struct _wfinddata32i64_t * _FindData);
    __declspec(dllimport) int __cdecl _wfindnext64i32(
        intptr_t _FindHandle,
        struct _wfinddata64i32_t * _FindData);
    __declspec(dllimport) int __cdecl _wfindnext64(
        intptr_t _FindHandle,
        struct _wfinddata64_t * _FindData);
    __declspec(dllimport) errno_t __cdecl _wsopen_s(
        int* _FileHandle,
        wchar_t const* _FileName,
        int _OpenFlag,
        int _ShareFlag,
        int _PermissionFlag);
    __declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
        wchar_t const* _FileName,
        int _OFlag,
        int _ShFlag,
        int _PMode,
        int* _PFileHandle,
        int _BSecure);
    extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                       "_wsopen_s"
                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                       "See online help for details.")) inline int __cdecl _wopen(wchar_t const* _FileName,
        int _OFlag,
        int _PMode = 0)
    {
        int _FileHandle;
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
    extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                       "_wsopen_s"
                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                       "See online help for details.")) inline int __cdecl _wsopen(wchar_t const* _FileName,
        int _OFlag,
        int _ShFlag,
        int _PMode = 0)
    {
        int _FileHandle;
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) intptr_t __cdecl _wexecl(
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wexecle(
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wexeclp(
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wexeclpe(
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wexecv(
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList);
    __declspec(dllimport) intptr_t __cdecl _wexecve(
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList,
        wchar_t const* const* _Env);
    __declspec(dllimport) intptr_t __cdecl _wexecvp(
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList);
    __declspec(dllimport) intptr_t __cdecl _wexecvpe(
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList,
        wchar_t const* const* _Env);
    __declspec(dllimport) intptr_t __cdecl _wspawnl(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wspawnle(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wspawnlp(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* _ArgList,
        ...);
    __declspec(dllimport) intptr_t __cdecl _wspawnv(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList);
    __declspec(dllimport) intptr_t __cdecl _wspawnve(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList,
        wchar_t const* const* _Env);
    __declspec(dllimport) intptr_t __cdecl _wspawnvp(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList);
    __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
        int _Mode,
        wchar_t const* _FileName,
        wchar_t const* const* _ArgList,
        wchar_t const* const* _Env);
    __declspec(dllimport) int __cdecl _wsystem(
        wchar_t const* _Command);
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
    };
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wasctime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wasctime(struct tm const* _Tm);
    __declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        struct tm const* _Tm);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); }
    }
    __declspec(dllimport) size_t __cdecl wcsftime(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        wchar_t const* _Format,
        struct tm const* _Tm);
    __declspec(dllimport) size_t __cdecl _wcsftime_l(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        wchar_t const* _Format,
        struct tm const* _Tm,
        _locale_t _Locale);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wctime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wctime32(__time32_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        __time32_t const* _Time);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wctime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wctime64(__time64_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t * _Buffer,
        size_t _SizeInWords,
        __time64_t const* _Time);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); }
    }
    __declspec(dllimport) errno_t __cdecl _wstrdate_s(
        wchar_t * _Buffer,
        size_t _SizeInWords);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wstrdate_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrdate(wchar_t * _Buffer);
    __declspec(dllimport) errno_t __cdecl _wstrtime_s(
        wchar_t * _Buffer,
        size_t _SizeInWords);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wstrtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrtime(wchar_t * _Buffer);
    static __inline wchar_t* __cdecl _wctime(
        time_t const* const _Time)
    {
        return _wctime64(_Time);
    }
    static __inline errno_t __cdecl _wctime_s(
        wchar_t* const _Buffer,
        size_t const _SizeInWords,
        time_t const* const _Time)
    {
        return _wctime64_s(_Buffer, _SizeInWords, _Time);
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    typedef unsigned short _ino_t;
typedef _ino_t ino_t;
typedef unsigned int _dev_t;
typedef _dev_t dev_t;
typedef long _off_t;
typedef _off_t off_t;
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    struct _stat32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };
    struct _stat32i64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };
    struct _stat64i32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };
    struct _stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };
    struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
    };
    __declspec(dllimport) int __cdecl _fstat32(
        int _FileHandle,
        struct _stat32* _Stat);
    __declspec(dllimport) int __cdecl _fstat32i64(
        int _FileHandle,
        struct _stat32i64* _Stat);
    __declspec(dllimport) int __cdecl _fstat64i32(
        int _FileHandle,
        struct _stat64i32* _Stat);
    __declspec(dllimport) int __cdecl _fstat64(
        int _FileHandle,
        struct _stat64* _Stat);
    __declspec(dllimport) int __cdecl _stat32(
        char const* _FileName,
        struct _stat32* _Stat);
    __declspec(dllimport) int __cdecl _stat32i64(
        char const* _FileName,
        struct _stat32i64* _Stat);
    __declspec(dllimport) int __cdecl _stat64i32(
        char const* _FileName,
        struct _stat64i32* _Stat);
    __declspec(dllimport) int __cdecl _stat64(
        char const* _FileName,
        struct _stat64* _Stat);
    __declspec(dllimport) int __cdecl _wstat32(
        wchar_t const* _FileName,
        struct _stat32* _Stat);
    __declspec(dllimport) int __cdecl _wstat32i64(
        wchar_t const* _FileName,
        struct _stat32i64* _Stat);
    __declspec(dllimport) int __cdecl _wstat64i32(
        wchar_t const* _FileName,
        struct _stat64i32* _Stat);
    __declspec(dllimport) int __cdecl _wstat64(
        wchar_t const* _FileName,
        struct _stat64* _Stat);
    static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
    {
        static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
        return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
    }
    static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
    {
        static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
        return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    typedef wchar_t _Wint_t;
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
        int _Category,
        wchar_t const* _Locale);
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
        int _Category,
        wchar_t const* _Locale);
    __declspec(dllimport) wint_t __cdecl btowc(
        int _Ch);
    __declspec(dllimport) size_t __cdecl mbrlen(
        char const* _Ch,
        size_t _SizeInBytes,
        mbstate_t* _State);
    __declspec(dllimport) size_t __cdecl mbrtowc(
        wchar_t * _DstCh,
        char const* _SrcCh,
        size_t _SizeInBytes,
        mbstate_t* _State);
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
        size_t * _Retval,
        wchar_t * _Dst,
        size_t _Size,
        char const** _PSrc,
        size_t _N,
        mbstate_t* _State);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "mbsrtowcs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs(wchar_t * _Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
        size_t * _Retval,
        char* _Dst,
        size_t _SizeInBytes,
        wchar_t _Ch,
        mbstate_t* _State);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcrtomb_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(char* _Dest, wchar_t _Source, mbstate_t* _State);
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
        size_t * _Retval,
        char* _Dst,
        size_t _SizeInBytes,
        wchar_t const** _Src,
        size_t _Size,
        mbstate_t* _State);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcsrtombs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(char* _Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);
    __declspec(dllimport) int __cdecl wctob(
        wint_t _WCh);
    errno_t __cdecl wmemcpy_s(
        wchar_t * _S1,
        rsize_t _N1,
        wchar_t const* _S2,
        rsize_t _N);
    errno_t __cdecl wmemmove_s(
        wchar_t * _S1,
        rsize_t _N1,
        wchar_t const* _S2,
        rsize_t _N);
    __inline int __cdecl fwide(
        FILE * _F,
        int _M)
    {
        (void)_F;
        return (_M);
    }
    __inline int __cdecl mbsinit(
        mbstate_t const* _P)
    {
        return _P == 0 || _P->_Wchar == 0;
    }
    __inline wchar_t const* __cdecl wmemchr(
        wchar_t const* _S,
        wchar_t _C,
        size_t _N)
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;
        return 0;
    }
    __inline int __cdecl wmemcmp(
        wchar_t const* _S1,
        wchar_t const* _S2,
        size_t _N)
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;
        return 0;
    }
    __inline wchar_t* __cdecl wmemcpy(
        wchar_t * _S1,
        wchar_t const* _S2,
        size_t _N)
    {
#pragma warning(suppress : 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N * sizeof(wchar_t));
    }
    __inline wchar_t* __cdecl wmemmove(
        wchar_t * _S1,
        wchar_t const* _S2,
        size_t _N)
    {
#pragma warning(suppress : 6386)
        return (wchar_t*)memmove(_S1, _S2, _N * sizeof(wchar_t));
    }
    __inline wchar_t* __cdecl wmemset(
        wchar_t * _S,
        wchar_t _C,
        size_t _N)
    {
        wchar_t* _Su = _S;
        for (; 0 < _N; ++_Su, --_N) {
            *_Su = _C;
        }
        return _S;
    }
    extern "C++" inline wchar_t* __cdecl wmemchr(
        wchar_t * _S,
        wchar_t _C,
        size_t _N)
    {
        wchar_t const* const _SC = _S;
        return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
    }
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
    using _Mbstatet = mbstate_t;
namespace std {
#pragma warning(push)
#pragma warning(disable : 4995)
using ::_Mbstatet;
using ::btowc;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::getwc;
using ::getwchar;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::mbstate_t;
using ::putwc;
using ::putwchar;
using ::size_t;
using ::swprintf;
using ::swscanf;
using ::tm;
using ::ungetwc;
using ::vfwprintf;
using ::vfwscanf;
using ::vswprintf;
using ::vswscanf;
using ::vwprintf;
using ::vwscanf;
using ::wcrtomb;
using ::wcscat;
using ::wcschr;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsrtombs;
using ::wcsspn;
using ::wcsstr;
using ::wcstod;
using ::wcstof;
using ::wcstok;
using ::wcstol;
using ::wcstold;
using ::wcstoll;
using ::wcstoul;
using ::wcstoull;
using ::wcsxfrm;
using ::wctob;
using ::wint_t;
using ::wmemchr;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;
#pragma warning(pop)
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;
    using value_type = _Ty;
    using type = integral_constant;
    constexpr operator value_type() const noexcept
    {
        return value;
    }
    [[nodiscard]] constexpr value_type operator()() const noexcept
    {
        return value;
    }
};
template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;
template <bool _Test, class _Ty = void>
struct enable_if {
};
template <class _Ty>
struct enable_if<true, _Ty> {
    using type = _Ty;
};
template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;
template <bool _Test, class _Ty1, class _Ty2>
struct conditional {
    using type = _Ty1;
};
template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};
template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;
template <class, class>
constexpr bool is_same_v = false;
template <class _Ty>
constexpr bool is_same_v<_Ty, _Ty> = true;
template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {
};
template <class _Ty>
struct remove_const {
    using type = _Ty;
};
template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};
template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;
template <class _Ty>
struct remove_volatile {
    using type = _Ty;
};
template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};
template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;
template <class _Ty>
struct remove_cv {
    using type = _Ty;
    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>;
};
template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;
    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};
template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;
    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};
template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;
    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};
template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;
template <bool _First_value, class _First, class... _Rest>
struct _Disjunction {
    using type = _First;
};
template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> {
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};
template <class... _Traits>
struct disjunction : false_type {
};
template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
};
template <class... _Traits>
constexpr bool disjunction_v = disjunction<_Traits...>::value;
template <class _Ty, class... _Types>
constexpr bool _Is_any_of_v = disjunction_v<is_same<_Ty, _Types>...>;
[[nodiscard]] constexpr bool _Is_constant_evaluated() noexcept
{
    return __builtin_is_constant_evaluated();
}
template <class _Ty>
constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,
    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;
template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;
template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_arithmetic_v = is_integral_v<_Ty> || is_floating_point_v<_Ty>;
template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {
};
template <class _Ty>
struct remove_reference {
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty;
};
template <class _Ty>
struct remove_reference<_Ty&> {
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};
template <class _Ty>
struct remove_reference<_Ty&&> {
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};
template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;
template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;
template <class _Ty>
using _Remove_cvref_t [[msvc::known_semantics]] = remove_cv_t<remove_reference_t<_Ty>>;
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
using ::ptrdiff_t;
using ::size_t;
using max_align_t = double;
}
using ::std::max_align_t;
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
[[nodiscard]] inline double abs(double _Xx) noexcept
{
    return ::fabs(_Xx);
}
[[nodiscard]] inline float abs(float _Xx) noexcept
{
    return ::fabsf(_Xx);
}
[[nodiscard]] inline long double abs(long double _Xx) noexcept
{
    return ::fabsl(_Xx);
}
namespace std {
using ::_Exit;
using ::abort;
using ::abs;
using ::at_quick_exit;
using ::atexit;
using ::atof;
using ::atoi;
using ::atol;
using ::atoll;
using ::bsearch;
using ::calloc;
using ::div;
using ::div_t;
using ::exit;
using ::free;
using ::getenv;
using ::labs;
using ::ldiv;
using ::ldiv_t;
using ::llabs;
using ::lldiv;
using ::lldiv_t;
using ::malloc;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::qsort;
using ::quick_exit;
using ::rand;
using ::realloc;
using ::size_t;
using ::srand;
using ::strtod;
using ::strtof;
using ::strtol;
using ::strtold;
using ::strtoll;
using ::strtoul;
using ::strtoull;
using ::system;
using ::wcstombs;
using ::wctomb;
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Elem>
class initializer_list {
public:
    using value_type = _Elem;
    using reference = const _Elem&;
    using const_reference = const _Elem&;
    using size_type = size_t;
    using iterator = const _Elem*;
    using const_iterator = const _Elem*;
    constexpr initializer_list() noexcept
        : _First(nullptr)
        , _Last(nullptr)
    {
    }
    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg)
        , _Last(_Last_arg)
    {
    }
    [[nodiscard]] constexpr const _Elem* begin() const noexcept
    {
        return _First;
    }
    [[nodiscard]] constexpr const _Elem* end() const noexcept
    {
        return _Last;
    }
    [[nodiscard]] constexpr size_t size() const noexcept
    {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};
template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept
{
    return _Ilist.begin();
}
template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept
{
    return _Ilist.end();
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class>
constexpr bool _Always_false = false;
template <class _Arg, class _Result>
struct unary_function {
    using argument_type = _Arg;
    using result_type = _Result;
};
template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
    using first_argument_type = _Arg1;
    using second_argument_type = _Arg2;
    using result_type = _Result;
};
#pragma warning(push)
#pragma warning(disable : 5215)
#pragma warning(disable : 5216)
template <class _Ty>
[[nodiscard]] _Ty _Fake_copy_init(_Ty) noexcept;
#pragma warning(pop)
template <class _Ty = void>
struct plus {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = _Ty;
    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
    {
        return _Left + _Right;
    }
};
template <class _Ty = void>
struct minus {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = _Ty;
    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
    {
        return _Left - _Right;
    }
};
template <class _Ty = void>
struct multiplies {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = _Ty;
    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
    {
        return _Left * _Right;
    }
};
template <class _Ty = void>
struct equal_to {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;
    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left == _Right)))
    {
        return _Left == _Right;
    }
};
template <class _Ty = void>
struct not_equal_to {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;
    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left != _Right)))
    {
        return _Left != _Right;
    }
};
template <class _Ty = void>
struct greater {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;
    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left > _Right)))
    {
        return _Left > _Right;
    }
};
template <class _Ty = void>
struct less {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;
    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left < _Right)))
    {
        return _Left < _Right;
    }
};
template <class _Ty = void>
struct greater_equal {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;
    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left >= _Right)))
    {
        return _Left >= _Right;
    }
};
template <class _Ty = void>
struct less_equal {
    using first_argument_type = _Ty;
    using second_argument_type = _Ty;
    using result_type = bool;
    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left <= _Right)))
    {
        return _Left <= _Right;
    }
};
template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)))
            -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))
    {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }
    using is_transparent = int;
};
template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept
{
    return __builtin_addressof(_Val);
}
template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;
template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept
{
    return ::std::addressof(*_Ptr);
}
template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept
{
    return _Ptr;
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
using streamoff = long long;
using streamsize = long long;
template <class _Statetype>
class fpos {
public:
    fpos(streamoff _Off = 0)
        : _Myoff(_Off)
        , _Fpos(0)
        , _Mystate()
    {
    }
    fpos(_Statetype _State, fpos_t _Fileposition)
        : _Myoff(_Fileposition)
        , _Fpos(0)
        , _Mystate(_State)
    {
    }
    [[nodiscard]] _Statetype state() const
    {
        return _Mystate;
    }
    void state(_Statetype _State)
    {
        _Mystate = _State;
    }
    operator streamoff() const
    {
        return _Myoff + _Fpos;
    }
    [[deprecated("warning STL4019: "
                 "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with "
                 "workarounds for old versions of Visual C++. It will be removed in a future release, and in this "
                 "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as "
                 "conversions to and from streamoff, or an integral type, instead. If you are receiving this message "
                 "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use "
                 "standards-conforming mechanisms, as it does for other compilers. You can define "
                 "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to suppress this warning, "
                 "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t
    seekpos() const noexcept
    {
        return {};
    }
    [[nodiscard]] streamoff operator-(const fpos& _Right) const
    {
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }
    fpos& operator+=(streamoff _Off)
    {
        _Myoff += _Off;
        return *this;
    }
    fpos& operator-=(streamoff _Off)
    {
        _Myoff -= _Off;
        return *this;
    }
    [[nodiscard]] fpos operator+(streamoff _Off) const
    {
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }
    [[nodiscard]] fpos operator-(streamoff _Off) const
    {
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] bool operator==(const fpos& _Right) const
    {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const fpos& _Left, const _Int _Right)
    {
        return static_cast<streamoff>(_Left) == _Right;
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const _Int _Left, const fpos& _Right)
    {
        return _Left == static_cast<streamoff>(_Right);
    }
    [[nodiscard]] bool operator!=(const fpos& _Right) const
    {
        return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator!=(const fpos& _Left, const _Int _Right)
    {
        return static_cast<streamoff>(_Left) != _Right;
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator!=(const _Int _Left, const fpos& _Right)
    {
        return _Left != static_cast<streamoff>(_Right);
    }

private:
    streamoff _Myoff;
    fpos_t _Fpos;
    _Statetype _Mystate;
};
using streampos = fpos<_Mbstatet>;
using wstreampos = streampos;
using u16streampos = streampos;
using u32streampos = streampos;
class locale;
template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);
template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;
template <class _Ty>
class allocator;
class ios_base;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;
#pragma vtordisp(push, 2)
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop)
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;
template <class _Elem, class _InIt>
class num_get;
template <class _Elem, class _OutIt>
class num_put;
template <class _Elem>
class collate;
using ios = basic_ios<char, char_traits<char>>;
using streambuf = basic_streambuf<char, char_traits<char>>;
using istream = basic_istream<char, char_traits<char>>;
using ostream = basic_ostream<char, char_traits<char>>;
using iostream = basic_iostream<char, char_traits<char>>;
using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf = basic_filebuf<char, char_traits<char>>;
using ifstream = basic_ifstream<char, char_traits<char>>;
using ofstream = basic_ofstream<char, char_traits<char>>;
using fstream = basic_fstream<char, char_traits<char>>;
using wios = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream = basic_fstream<wchar_t, char_traits<wchar_t>>;
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;
using ::intmax_t;
using ::intptr_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;
using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;
using ::uintmax_t;
using ::uintptr_t;
namespace [[deprecated("warning STL4002: "
                       "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
                       "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 {
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_fast8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::int_least8_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_fast8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uint_least8_t;
    using ::uintmax_t;
    using ::uintptr_t;
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4514 4820)
extern "C" {
unsigned char _BitScanForward(unsigned long* _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long* _Index, unsigned __int64 _Mask);
unsigned char _BitScanReverse(unsigned long* _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long* _Index, unsigned __int64 _Mask);
unsigned char _bittest(long const*, long);
long _InterlockedAnd(long volatile* _Value, long _Mask);
short _InterlockedAnd16(short volatile* _Value, short _Mask);
__int64 _InterlockedAnd64(__int64 volatile* _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile* _Value, __int64 _Mask);
char _InterlockedAnd8(char volatile* _Value, char _Mask);
long _InterlockedCompareExchange(long volatile* _Destination, long _Exchange, long _Comparand);
short _InterlockedCompareExchange16(short volatile* _Destination, short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64(__int64 volatile* _Destination, __int64 _Exchange, __int64 _Comparand);
char _InterlockedCompareExchange8(char volatile* _Destination, char _Exchange, char _Comparand);
unsigned char _InterlockedCompareExchange128(__int64 volatile* _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64* _ComparandResult);
long _InterlockedDecrement(long volatile* _Addend);
short _InterlockedDecrement16(short volatile* _Addend);
__int64 _InterlockedDecrement64(__int64 volatile* _Addend);
__int64 _interlockeddecrement64(__int64 volatile* _Addend);
long _InterlockedExchange(long volatile* _Target, long _Value);
short _InterlockedExchange16(short volatile* _Target, short _Value);
__int64 _InterlockedExchange64(__int64 volatile* _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile* _Target, __int64 _Value);
char _InterlockedExchange8(char volatile* _Target, char _Value);
long _InterlockedExchangeAdd(long volatile* _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile* _Addend, short _Value);
__int64 _InterlockedExchangeAdd64(__int64 volatile* _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile* _Addend, __int64 _Value);
char _InterlockedExchangeAdd8(char volatile* _Addend, char _Value);
long _InterlockedIncrement(long volatile* _Addend);
short _InterlockedIncrement16(short volatile* _Addend);
__int64 _InterlockedIncrement64(__int64 volatile* _Addend);
__int64 _interlockedincrement64(__int64 volatile* _Addend);
long _InterlockedOr(long volatile* _Value, long _Mask);
short _InterlockedOr16(short volatile* _Value, short _Mask);
__int64 _InterlockedOr64(__int64 volatile* _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile* _Value, __int64 _Mask);
char _InterlockedOr8(char volatile* _Value, char _Mask);
long _InterlockedXor(long volatile* _Value, long _Mask);
short _InterlockedXor16(short volatile* _Value, short _Mask);
__int64 _InterlockedXor64(__int64 volatile* _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile* _Value, __int64 _Mask);
char _InterlockedXor8(char volatile* _Value, char _Mask);
void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16*);
__int32 __iso_volatile_load32(const volatile __int32*);
__int64 __iso_volatile_load64(const volatile __int64*);
__int8 __iso_volatile_load8(const volatile __int8*);
void __iso_volatile_store16(volatile __int16*, __int16);
void __iso_volatile_store32(volatile __int32*, __int32);
void __iso_volatile_store64(volatile __int64*, __int64);
void __iso_volatile_store8(volatile __int8*, __int8);
void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned int __cdecl _rotl(unsigned int _Value, int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(unsigned int _Value, int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64* _HighProduct);
unsigned __int64 __cdecl _udiv128(unsigned __int64 _HighDividend, unsigned __int64 _LowDividend, unsigned __int64 _Divisor, unsigned __int64* _Remainder);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64*);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64*);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);
constexpr void* __cdecl __builtin_assume_aligned(const void*, size_t, ...) noexcept;
}
#pragma warning(pop)
enum ISA_AVAILABILITY {
    __ISA_AVAILABLE_X86 = 0,
    __ISA_AVAILABLE_SSE2 = 1,
    __ISA_AVAILABLE_SSE42 = 2,
    __ISA_AVAILABLE_AVX = 3,
    __ISA_AVAILABLE_ENFSTRG = 4,
    __ISA_AVAILABLE_AVX2 = 5,
    __ISA_AVAILABLE_AVX512 = 6,
    __ISA_AVAILABLE_ARMNT = 0,
    __ISA_AVAILABLE_NEON = 1,
    __ISA_AVAILABLE_NEON_ARM64 = 2,
};
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
enum float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};
enum float_round_style {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};
struct _Num_base {
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_exact = false;
    static constexpr bool is_iec559 = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_modulo = false;
    static constexpr bool is_signed = false;
    static constexpr bool is_specialized = false;
    static constexpr bool tinyness_before = false;
    static constexpr bool traps = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits = 0;
    static constexpr int digits10 = 0;
    static constexpr int max_digits10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;
    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int radix = 0;
};
template <class _Ty>
class numeric_limits : public _Num_base {
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty(max)() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty lowest() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty epsilon() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty round_error() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty denorm_min() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty infinity() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept
    {
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept
    {
        return _Ty();
    }
};
template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {
};
template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {
};
template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {
};
struct _Num_int_base : _Num_base {
    static constexpr bool is_bounded = true;
    static constexpr bool is_exact = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix = 2;
};
struct _Num_float_base : _Num_base {
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity = true;
    static constexpr bool has_quiet_NaN = true;
    static constexpr bool has_signaling_NaN = true;
    static constexpr bool is_bounded = true;
    static constexpr bool is_iec559 = true;
    static constexpr bool is_signed = true;
    static constexpr bool is_specialized = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix = 2;
};
template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept
    {
        return false;
    }
    [[nodiscard]] static constexpr bool(max)() noexcept
    {
        return true;
    }
    [[nodiscard]] static constexpr bool lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr bool epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr bool round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr bool denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr bool infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr bool quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr bool signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr int digits = 1;
};
template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept
    {
        return (-128);
    }
    [[nodiscard]] static constexpr char(max)() noexcept
    {
        return 127;
    }
    [[nodiscard]] static constexpr char lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr char epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits = 8 - ((-128) != 0);
    static constexpr int digits10 = 2;
};
template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept
    {
        return (-128);
    }
    [[nodiscard]] static constexpr signed char(max)() noexcept
    {
        return 127;
    }
    [[nodiscard]] static constexpr signed char lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr signed char epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr signed char round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr signed char denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr signed char infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits = 7;
    static constexpr int digits10 = 2;
};
template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char(max)() noexcept
    {
        return 0xff;
    }
    [[nodiscard]] static constexpr unsigned char lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned char epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 8;
    static constexpr int digits10 = 2;
};
template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char16_t(max)() noexcept
    {
        return 0xffff;
    }
    [[nodiscard]] static constexpr char16_t lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr char16_t epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char16_t round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char16_t denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char16_t infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 16;
    static constexpr int digits10 = 4;
};
template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char32_t(max)() noexcept
    {
        return 0xffffffff;
    }
    [[nodiscard]] static constexpr char32_t lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr char32_t epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char32_t round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char32_t denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char32_t infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 32;
    static constexpr int digits10 = 9;
};
template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept
    {
        return 0x0000;
    }
    [[nodiscard]] static constexpr wchar_t(max)() noexcept
    {
        return 0xffff;
    }
    [[nodiscard]] static constexpr wchar_t lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr wchar_t epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 16;
    static constexpr int digits10 = 4;
};
template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept
    {
        return (-32768);
    }
    [[nodiscard]] static constexpr short(max)() noexcept
    {
        return 32767;
    }
    [[nodiscard]] static constexpr short lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr short epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr short round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr short denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr short infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr short quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr short signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits = 15;
    static constexpr int digits10 = 4;
};
template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept
    {
        return (-2147483647 - 1);
    }
    [[nodiscard]] static constexpr int(max)() noexcept
    {
        return 2147483647;
    }
    [[nodiscard]] static constexpr int lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr int epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr int round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr int denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr int infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr int quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr int signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits = 31;
    static constexpr int digits10 = 9;
};
template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept
    {
        return (-2147483647L - 1);
    }
    [[nodiscard]] static constexpr long(max)() noexcept
    {
        return 2147483647L;
    }
    [[nodiscard]] static constexpr long lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr long epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long signaling_NaN() noexcept
    {
        return 0;
    }
    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits = 31;
    static constexpr int digits10 = 9;
};
template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept
    {
        return (-9223372036854775807i64 - 1);
    }
    [[nodiscard]] static constexpr long long(max)() noexcept
    {
        return 9223372036854775807i64;
    }
    [[nodiscard]] static constexpr long long lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr long long epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long long round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long long denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long long infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long long quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr long long signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits = 63;
    static constexpr int digits10 = 18;
};
template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short(max)() noexcept
    {
        return 0xffff;
    }
    [[nodiscard]] static constexpr unsigned short lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned short epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 16;
    static constexpr int digits10 = 4;
};
template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int(max)() noexcept
    {
        return 0xffffffff;
    }
    [[nodiscard]] static constexpr unsigned int lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned int epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 32;
    static constexpr int digits10 = 9;
};
template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long(max)() noexcept
    {
        return 0xffffffffUL;
    }
    [[nodiscard]] static constexpr unsigned long lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned long epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept
    {
        return 0;
    }
    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits = 32;
    static constexpr int digits10 = 9;
};
template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long(max)() noexcept
    {
        return 0xffffffffffffffffui64;
    }
    [[nodiscard]] static constexpr unsigned long long lowest() noexcept
    {
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long round_error() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long infinity() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept
    {
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept
    {
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits = 64;
    static constexpr int digits10 = 19;
};
template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept
    {
        return 1.175494351e-38F;
    }
    [[nodiscard]] static constexpr float(max)() noexcept
    {
        return 3.402823466e+38F;
    }
    [[nodiscard]] static constexpr float lowest() noexcept
    {
        return -(max)();
    }
    [[nodiscard]] static constexpr float epsilon() noexcept
    {
        return 1.192092896e-07F;
    }
    [[nodiscard]] static constexpr float round_error() noexcept
    {
        return 0.5F;
    }
    [[nodiscard]] static constexpr float denorm_min() noexcept
    {
        return 1.401298464e-45F;
    }
    [[nodiscard]] static constexpr float infinity() noexcept
    {
        return __builtin_huge_valf();
    }
    [[nodiscard]] static constexpr float quiet_NaN() noexcept
    {
        return __builtin_nanf("0");
    }
    [[nodiscard]] static constexpr float signaling_NaN() noexcept
    {
        return __builtin_nansf("1");
    }
    static constexpr int digits = 24;
    static constexpr int digits10 = 6;
    static constexpr int max_digits10 = 9;
    static constexpr int max_exponent = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent = (-125);
    static constexpr int min_exponent10 = (-37);
};
template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept
    {
        return 2.2250738585072014e-308;
    }
    [[nodiscard]] static constexpr double(max)() noexcept
    {
        return 1.7976931348623158e+308;
    }
    [[nodiscard]] static constexpr double lowest() noexcept
    {
        return -(max)();
    }
    [[nodiscard]] static constexpr double epsilon() noexcept
    {
        return 2.2204460492503131e-016;
    }
    [[nodiscard]] static constexpr double round_error() noexcept
    {
        return 0.5;
    }
    [[nodiscard]] static constexpr double denorm_min() noexcept
    {
        return 4.9406564584124654e-324;
    }
    [[nodiscard]] static constexpr double infinity() noexcept
    {
        return __builtin_huge_val();
    }
    [[nodiscard]] static constexpr double quiet_NaN() noexcept
    {
        return __builtin_nan("0");
    }
    [[nodiscard]] static constexpr double signaling_NaN() noexcept
    {
        return __builtin_nans("1");
    }
    static constexpr int digits = 53;
    static constexpr int digits10 = 15;
    static constexpr int max_digits10 = 17;
    static constexpr int max_exponent = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent = (-1021);
    static constexpr int min_exponent10 = (-307);
};
template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept
    {
        return 2.2250738585072014e-308;
    }
    [[nodiscard]] static constexpr long double(max)() noexcept
    {
        return 1.7976931348623158e+308;
    }
    [[nodiscard]] static constexpr long double lowest() noexcept
    {
        return -(max)();
    }
    [[nodiscard]] static constexpr long double epsilon() noexcept
    {
        return 2.2204460492503131e-016;
    }
    [[nodiscard]] static constexpr long double round_error() noexcept
    {
        return 0.5L;
    }
    [[nodiscard]] static constexpr long double denorm_min() noexcept
    {
        return 4.9406564584124654e-324;
    }
    [[nodiscard]] static constexpr long double infinity() noexcept
    {
        return __builtin_huge_val();
    }
    [[nodiscard]] static constexpr long double quiet_NaN() noexcept
    {
        return __builtin_nan("0");
    }
    [[nodiscard]] static constexpr long double signaling_NaN() noexcept
    {
        return __builtin_nans("1");
    }
    static constexpr int digits = 53;
    static constexpr int digits10 = 15;
    static constexpr int max_digits10 = 2 + 53 * 301L / 1000;
    static constexpr int max_exponent = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent = (-1021);
    static constexpr int min_exponent10 = (-307);
};
template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept
{
    _Ty _Yy = 0;
    unsigned int _Nn = numeric_limits<_Ty>::digits;
    unsigned int _Cc = numeric_limits<_Ty>::digits / 2;
    do {
        _Yy = static_cast<_Ty>(_Val >> _Cc);
        if (_Yy != 0) {
            _Nn -= _Cc;
            _Val = _Yy;
        }
        _Cc >>= 1;
    } while (_Cc != 0);
    return static_cast<int>(_Nn) - static_cast<int>(_Val);
}
template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept
{
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}
template <class _Ty>
[[nodiscard]] constexpr int _Popcount_fallback(_Ty _Val) noexcept
{
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    _Val = static_cast<_Ty>(_Val - ((_Val >> 1) & static_cast<_Ty>(0x5555'5555'5555'5555ull)));
    _Val = static_cast<_Ty>((_Val & static_cast<_Ty>(0x3333'3333'3333'3333ull))
        + ((_Val >> 2) & static_cast<_Ty>(0x3333'3333'3333'3333ull)));
    _Val = static_cast<_Ty>((_Val + (_Val >> 4)) & static_cast<_Ty>(0x0F0F'0F0F'0F0F'0F0Full));
    _Val = static_cast<_Ty>(_Val * static_cast<_Ty>(0x0101'0101'0101'0101ull));
    return static_cast<int>(_Val >> (_Digits - 8));
}
extern "C" {
extern int __isa_available;
}
template <class _Ty>
[[nodiscard]] int _Countr_zero_tzcnt(const _Ty _Val) noexcept
{
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max = (numeric_limits<_Ty>::max)();
    if constexpr (_Digits <= 32) {
        return static_cast<int>(_tzcnt_u32(static_cast<unsigned int>(~_Max | _Val)));
    } else {
        return static_cast<int>(_tzcnt_u64(_Val));
    }
}
template <class _Ty>
[[nodiscard]] int _Countr_zero_bsf(const _Ty _Val) noexcept
{
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max = (numeric_limits<_Ty>::max)();
    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        if (!_BitScanForward(&_Result, static_cast<unsigned int>(~_Max | _Val))) {
            return _Digits;
        }
    } else {
        if (!_BitScanForward64(&_Result, _Val)) {
            return _Digits;
        }
    }
    return static_cast<int>(_Result);
}
template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept
{
    const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
    if (_Definitely_have_tzcnt) {
        return _Countr_zero_tzcnt(_Val);
    } else {
        return _Countr_zero_bsf(_Val);
    }
}
template <class _Ty>
[[nodiscard]] int _Unchecked_x86_x64_popcount(const _Ty _Val) noexcept
{
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    if constexpr (_Digits <= 16) {
        return static_cast<int>(__popcnt16(_Val));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__popcnt(_Val));
    } else {
        return static_cast<int>(__popcnt64(_Val));
    }
}
template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_popcount(const _Ty _Val) noexcept
{
    const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
    if (!_Definitely_have_popcnt) {
        return _Popcount_fallback(_Val);
    }
    return _Unchecked_x86_x64_popcount(_Val);
}
template <class _Ty>
constexpr bool _Is_standard_unsigned_integer = _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] inline int _Countr_zero(const _Ty _Val) noexcept
{
    {
        return _Checked_x86_x64_countr_zero(_Val);
    }
    return _Countr_zero_fallback(_Val);
}
template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_countr_zero_impl(_Fn _Callback)
{
    return _Callback([](_Ty _Val) { return _Countr_zero_fallback(_Val); });
}
template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled = 0>
[[nodiscard]] inline int _Popcount(const _Ty _Val) noexcept
{
    {
        return _Checked_x86_x64_popcount(_Val);
    }
    return _Popcount_fallback(_Val);
}
template <class _Ty, class _Fn>
inline decltype(auto) _Select_popcount_impl(_Fn _Callback)
{
    {
        const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
        if (!_Definitely_have_popcnt) {
            return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
        }
        return _Callback([](_Ty _Val) { return _Unchecked_x86_x64_popcount(_Val); });
    }
    return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Ty, _Ty... _Vals>
struct integer_sequence {
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");
    using value_type = _Ty;
    [[nodiscard]] static constexpr size_t size() noexcept
    {
        return sizeof...(_Vals);
    }
};
template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;
template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;
template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;
template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
template <bool _First_value, class _First, class... _Rest>
struct _Conjunction {
    using type = _First;
};
template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> {
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};
template <class... _Traits>
struct conjunction : true_type {
};
template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
};
template <class... _Traits>
constexpr bool conjunction_v = conjunction<_Traits...>::value;
template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {
};
template <class _Trait>
constexpr bool negation_v = negation<_Trait>::value;
template <class _Ty>
constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;
template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {
};
template <class... _Types>
using void_t = void;
template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t [[msvc::known_semantics]] = typename _Identity<_Ty>::type;
template <class _Ty>
struct add_const {
    using type = const _Ty;
};
template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;
template <class _Ty>
struct add_volatile {
    using type = volatile _Ty;
};
template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;
template <class _Ty>
struct add_cv {
    using type = const volatile _Ty;
};
template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;
template <class _Ty, class = void>
struct _Add_reference {
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};
template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> {
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};
template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};
template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;
template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};
template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;
template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept
{
    static_assert(_Always_false<_Ty>, "Calling declval is ill-formed, see N4892 [declval]/2.");
}
template <class _Ty>
struct remove_extent {
    using type = _Ty;
};
template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};
template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};
template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;
template <class _Ty>
struct remove_all_extents {
    using type = _Ty;
};
template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};
template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};
template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;
template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};
template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};
template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};
template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};
template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};
template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;
template <class _Ty, class = void>
struct _Add_pointer {
    using type = _Ty;
};
template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> {
    using type = remove_reference_t<_Ty>*;
};
template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};
template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;
template <class>
constexpr bool is_array_v = false;
template <class _Ty, size_t _Nx>
constexpr bool is_array_v<_Ty[_Nx]> = true;
template <class _Ty>
constexpr bool is_array_v<_Ty[]> = true;
template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {
};
template <class>
constexpr bool is_lvalue_reference_v = false;
template <class _Ty>
constexpr bool is_lvalue_reference_v<_Ty&> = true;
template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {
};
template <class>
constexpr bool is_rvalue_reference_v = false;
template <class _Ty>
constexpr bool is_rvalue_reference_v<_Ty&&> = true;
template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {
};
template <class>
constexpr bool is_reference_v = false;
template <class _Ty>
constexpr bool is_reference_v<_Ty&> = true;
template <class _Ty>
constexpr bool is_reference_v<_Ty&&> = true;
template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {
};
template <class>
constexpr bool is_pointer_v = false;
template <class _Ty>
constexpr bool is_pointer_v<_Ty*> = true;
template <class _Ty>
constexpr bool is_pointer_v<_Ty* const> = true;
template <class _Ty>
constexpr bool is_pointer_v<_Ty* volatile> = true;
template <class _Ty>
constexpr bool is_pointer_v<_Ty* const volatile> = true;
template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_null_pointer_v = is_same_v<remove_cv_t<_Ty>, nullptr_t>;
template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {
};
template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {
};
template <class _Ty>
constexpr bool is_union_v = __is_union(_Ty);
template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {
};
template <class _Ty>
constexpr bool is_class_v = __is_class(_Ty);
template <class _Ty>
constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;
template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {
};
template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
};
template <class _From, class _To>
constexpr bool is_convertible_v = __is_convertible_to(_From, _To);
template <class _Ty>
struct is_convertible<_Ty&, volatile _Ty&> : true_type {
};
template <class _Ty>
struct is_convertible<volatile _Ty&, volatile _Ty&> : true_type {
};
template <class _Ty>
struct is_convertible<_Ty&, const volatile _Ty&> : true_type {
};
template <class _Ty>
struct is_convertible<volatile _Ty&, const volatile _Ty&> : true_type {
};
template <class _Ty>
constexpr bool is_convertible_v<_Ty&, volatile _Ty&> = true;
template <class _Ty>
constexpr bool is_convertible_v<volatile _Ty&, volatile _Ty&> = true;
template <class _Ty>
constexpr bool is_convertible_v<_Ty&, const volatile _Ty&> = true;
template <class _Ty>
constexpr bool is_convertible_v<volatile _Ty&, const volatile _Ty&> = true;
template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {
};
template <class _Ty>
constexpr bool is_enum_v = __is_enum(_Ty);
template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_compound_v = !is_fundamental_v<_Ty>;
template <class... _Types>
struct _Arg_types {
};
template <class _Ty1>
struct _Arg_types<_Ty1> {
    using argument_type = _Ty1;
};
template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
    using first_argument_type = _Ty1;
    using second_argument_type = _Ty2;
};
template <class _Ty>
struct _Is_memfunptr {
    using _Bool_type = false_type;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)> : _Arg_types<_Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)> : _Arg_types<_Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)&> : _Arg_types<_Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)&> : _Arg_types<_Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const&> : _Arg_types<const _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const&> : _Arg_types<const _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile&> : _Arg_types<volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile&> : _Arg_types<volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile&> : _Arg_types<const volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile&> : _Arg_types<const volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &&> : _Arg_types<_Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) &&> : _Arg_types<_Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const&&> : _Arg_types<const _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const&&> : _Arg_types<const _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile&&> : _Arg_types<volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile&&> : _Arg_types<volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile&&> : _Arg_types<const volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile&&> : _Arg_types<const volatile _Arg0*, _Types...> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ret, class _Arg0, class... _Types>
struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> {
    using _Bool_type = true_type;
    using result_type = _Ret;
    using _Class_type = _Arg0;
    using _Guide_type = enable_if<false>;
};
template <class _Ty>
constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {
};
template <class>
constexpr bool is_const_v = false;
template <class _Ty>
constexpr bool is_const_v<const _Ty> = true;
template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {
};
template <class>
constexpr bool is_volatile_v = false;
template <class _Ty>
constexpr bool is_volatile_v<volatile _Ty> = true;
template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_function_v = !is_const_v<const _Ty> && !is_reference_v<_Ty>;
template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_object_v = is_const_v<const _Ty> && !is_void_v<_Ty>;
template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {
};
template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};
template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type = _Ty2;
};
template <class _Ty>
constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {
};
template <class _Ty>
constexpr bool is_scalar_v = is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;
template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {
};
template <class _Ty>
struct is_pod : bool_constant<__is_pod(_Ty)> {
};
template <class _Ty>
constexpr bool is_pod_v = __is_pod(_Ty);
template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {
};
template <class _Ty>
constexpr bool is_empty_v = __is_empty(_Ty);
template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {
};
template <class _Ty>
constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);
template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {
};
template <class _Ty>
constexpr bool is_abstract_v = __is_abstract(_Ty);
template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {
};
template <class _Ty>
constexpr bool is_final_v = __is_final(_Ty);
template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {
};
template <class _Ty>
constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);
template <class _Ty>
struct is_literal_type : bool_constant<__is_literal_type(_Ty)> {
};
template <class _Ty>
constexpr bool is_literal_type_v = __is_literal_type(_Ty);
template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
};
template <class _Ty>
constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);
template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
};
template <class _Ty>
constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);
template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
};
template <class _Ty>
constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);
template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
};
template <class _Ty, class... _Args>
constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);
template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
};
template <class _Ty>
constexpr bool is_default_constructible_v = __is_constructible(_Ty);
template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
};
template <class _Ty>
void _Implicitly_default_construct(const _Ty&);
template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};
template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
};
template <class _Ty>
constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);
template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {
};
template <class _To, class _From>
constexpr bool is_assignable_v = __is_assignable(_To, _From);
template <class _To, class _From>
struct _Is_assignable_no_precondition_check : bool_constant<__is_assignable_no_precondition_check(_To, _From)> {
};
template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
};
template <class _Ty>
constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {
};
template <class _Ty>
constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
};
template <class _Ty>
constexpr bool is_destructible_v = __is_destructible(_Ty);
template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
};
template <class _Ty, class... _Args>
constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);
template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
};
template <class _Ty>
constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);
template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
};
template <class _Ty>
constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);
template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
};
template <class _To, class _From>
constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);
template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
};
template <class _Ty>
constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
};
template <class _Ty>
constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);
template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
};
template <class _Ty, class... _Args>
constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);
template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
};
template <class _Ty>
constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);
template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
};
template <class _Ty>
constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);
template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
};
template <class _To, class _From>
constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);
template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
};
template <class _Ty>
constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
};
template <class _Ty>
constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
};
template <class _Ty>
constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);
template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base {
    using _Uty = remove_cv_t<_Ty>;
    static constexpr bool _Signed = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};
template <class _Ty>
struct _Sign_base<_Ty, false> {
    static constexpr bool _Signed = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};
template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {
};
template <class _Ty>
constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;
template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {
};
template <class _Ty>
constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;
template <class _Ty>
constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;
template <bool>
struct _Select {
    template <class _Ty1, class>
    using _Apply = _Ty1;
};
template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};
template <size_t>
struct _Make_signed2;
template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};
template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};
template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply =
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};
template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};
template <class _Ty>
using _Make_signed1 =
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;
template <class _Ty>
struct make_signed {
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");
    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};
template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;
template <size_t>
struct _Make_unsigned2;
template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};
template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};
template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply =
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};
template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};
template <class _Ty>
using _Make_unsigned1 =
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;
template <class _Ty>
struct make_unsigned {
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");
    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};
template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;
template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)
{
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}
template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {
};
template <class _Ty>
constexpr size_t alignment_of_v = alignof(_Ty);
template <class _Ty, size_t _Len>
union _Align_type {
    _Ty _Val;
    char _Pad[_Len];
};
template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned;
template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {
    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "To suppress this error, please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to confirm that you want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming behavior.");
    using type = _Align_type<max_align_t, _Len>;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};
template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _Aligned_storage {
    using _Next = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};
template <size_t _Len, size_t _Align = alignof(max_align_t)>
using _Aligned_storage_t = typename _Aligned_storage<_Len, _Align>::type;
template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct aligned_storage {
    using type = _Aligned_storage_t<_Len, _Align>;
};
template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t = _Aligned_storage_t<_Len, _Align>;
template <size_t... _Vals>
struct _Maximum;
template <>
struct _Maximum<> : integral_constant<size_t, 0> {
};
template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {
};
template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
};
template <size_t _Len, class... _Types>
struct aligned_union {
    static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value;
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;
    using type = _Aligned_storage_t<_Max_len, alignment_value>;
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
__pragma(warning(pop)) template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};
template <class _Ty>
struct _Underlying_type<_Ty, false> {
};
template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {
};
template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;
template <class _Ty>
constexpr size_t rank_v = 0;
template <class _Ty, size_t _Nx>
constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;
template <class _Ty>
constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;
template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {
};
template <class _Ty, unsigned int _Ix = 0>
constexpr size_t extent_v = 0;
template <class _Ty, size_t _Nx>
constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;
template <class _Ty, unsigned int _Ix, size_t _Nx>
constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;
template <class _Ty, unsigned int _Ix>
constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;
template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {
};
template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
};
template <class _Base, class _Derived>
constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
template <class _Ty>
struct decay {
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};
template <class _Ty>
using decay_t = typename decay<_Ty>::type;
template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std::declval<_Ty1>() : ::std::declval<_Ty2>());
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {
};
template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};
template <class... _Ty>
struct common_type;
template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;
template <>
struct common_type<> {
};
template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {
};
template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {
};
template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {
};
template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {
};
template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {
};
template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {
};
template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {
};
template <class _Ty>
_Ty _Returns_exactly() noexcept;
template <class _Type, template <class...> class _Template>
constexpr bool _Is_specialization_v = false;
template <template <class...> class _Template, class... _Types>
constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;
template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {
};
template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept
{
    return static_cast<_Ty&&>(_Arg);
}
template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept
{
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}
template <class _Ty>
[[nodiscard]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept
{
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
template <class _Ty>
[[nodiscard]] constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&,
    _Ty&&>
move_if_noexcept(_Ty& _Arg) noexcept
{
    return ::std::move(_Arg);
}
template <class _Ty>
class reference_wrapper;
enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};
struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;
    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...))
    {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};
struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;
    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...))
    {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};
struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;
    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...))
    {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};
struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;
    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...))
    {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};
struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;
    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd)
    {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};
struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;
    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd)
    {
        return _Rw.get().*_Pmd;
    }
};
struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;
    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd)
    {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};
template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;
template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {
};
template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {
};
template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {
};
template <class _Callable>
inline auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)())
{
    return static_cast<_Callable&&>(_Obj)();
}
template <class _Callable, class _Ty1, class... _Types2>
inline auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...))
{
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        static_assert(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer, "bug in invoke");
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}
#pragma warning(push)
#pragma warning(disable : 4242)
#pragma warning(disable : 4244)
#pragma warning(disable : 4365)
template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
constexpr bool _Is_nothrow_convertible_v = noexcept(_Fake_copy_init<_To>(::std::declval<_From>()));
#pragma warning(pop)
template <class _From, class _To, bool _IsVoid>
constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;
template <class _From, class _To>
constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;
template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
};
template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {
};
template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(_Fake_copy_init<_To>(_Returns_exactly<_From>()))>> : true_type {
};
template <class _From, class _To>
struct _Invoke_nothrow_convertible : bool_constant<noexcept(_Fake_copy_init<_To>(_Returns_exactly<_From>()))> {
};
template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type = _Result;
    using _Is_invocable = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};
template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    using _Is_invocable = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};
template <class _Callable>
using _Decltype_invoke_zero = decltype(::std::declval<_Callable>()());
template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std::declval<_Callable>()())> {
};
template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    using _Is_invocable = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};
template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std::declval<_Callable>(), ::std::declval<_Ty1>(), ::std::declval<_Types2>()...));
template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std::declval<_Callable>(), ::std::declval<_Ty1>(), ::std::declval<_Types2>()...))> {
};
template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;
template <class _Fty>
struct result_of {
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};
template <class _Callable, class... _Args>
struct result_of<_Callable __cdecl(_Args...)> : _Select_invoke_traits<_Callable, _Args...> {
};
template <class _Callable, class... _Args>
struct result_of<_Callable __vectorcall(_Args...)> : _Select_invoke_traits<_Callable, _Args...> {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
using result_of_t = typename result_of<_Ty>::type;
__pragma(warning(pop)) template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;
template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;
template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
};
template <class _Ty>
struct _Function_args {
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...)> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...)> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) const> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) const> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) volatile> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) volatile> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) const volatile> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) const volatile> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...)&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...)&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) const&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) const&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) volatile&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) volatile&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) const volatile&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) const volatile&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) &&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) &&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) const&&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) const&&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) volatile&&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) volatile&&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __cdecl(_Types...) const volatile&&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret __vectorcall(_Types...) const volatile&&> : _Arg_types<_Types...> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...)> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) const> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) volatile> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) const volatile> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...)&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) const&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) volatile&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) const volatile&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) &&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) const&&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) volatile&&> {
    using result_type = _Ret;
};
template <class _Ret, class... _Types>
struct _Function_args<_Ret(_Types..., ...) const volatile&&> {
    using result_type = _Ret;
};
template <class _Ty, class = void>
struct _Weak_result_type {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> {
    using result_type = typename _Ty::result_type;
};
__pragma(warning(pop)) template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    using argument_type = typename _Ty::argument_type;
};
__pragma(warning(pop)) template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type, typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> {
    using first_argument_type = typename _Ty::first_argument_type;
    using second_argument_type = typename _Ty::second_argument_type;
};
__pragma(warning(pop)) template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;
template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {
};
template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std::declval<_Uty>()))>> : true_type {
};
template <class _Ty>
class reference_wrapper
    : public _Weak_types<_Ty> {
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");
    using type = _Ty;
    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>, _Refwrap_has_ctor_from<_Ty, _Uty>>, int> = 0>
    inline reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std::declval<_Uty>())))
    {
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr = ::std::addressof(_Ref);
    }
    inline operator _Ty&() const noexcept
    {
        return *_Ptr;
    }
    [[nodiscard]] inline _Ty& get() const noexcept
    {
        return *_Ptr;
    }

private:
    _Ty* _Ptr {};

public:
    template <class... _Types>
    inline auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std::invoke(*_Ptr, static_cast<_Types&&>(_Args)...)))
            -> decltype(::std::invoke(*_Ptr, static_cast<_Types&&>(_Args)...))
    {
        return ::std::invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};
template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(_Ty& _Val) noexcept
{
    return reference_wrapper<_Ty>(_Val);
}
template <class _Ty>
void ref(const _Ty&&) = delete;
template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept
{
    return _Val;
}
template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept
{
    return reference_wrapper<const _Ty>(_Val);
}
template <class _Ty>
void cref(const _Ty&&) = delete;
template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept
{
    return _Val;
}
template <class _Ty>
struct _Is_swappable;
template <class _Ty>
struct _Is_nothrow_swappable;
template <class _Ty, int _Enabled = 0>
inline void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);
template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);
template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {
};
template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std::declval<_Ty1>(), ::std::declval<_Ty2>()))>>
    : true_type {
};
template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
};
template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
};
template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std::declval<_Ty1>(), ::std::declval<_Ty2>()))&& noexcept(swap(::std::declval<_Ty2>(), ::std::declval<_Ty1>()))> {
};
template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
};
template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
};
namespace _Has_ADL_swap_detail {
    void swap();
    template <class, class = void>
    struct _Has_ADL_swap : false_type {
    };
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std::declval<_Ty&>(), ::std::declval<_Ty&>()))>> : true_type {
    };
}
using _Has_ADL_swap_detail::_Has_ADL_swap;
template <class _Ty>
constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;
template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
};
template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept
{
    return (_Left & _Elements) != _Bitmask {};
}
template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept
{
    return (_Left & _Elements) == _Elements;
}
constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
constexpr size_t _FNV_prime = 1099511628211ULL;
[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept
{
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }
    return _Val;
}
template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept
{
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}
template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept
{
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}
template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept
{
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}
template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept
{
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}
template <class _Kty>
struct hash;
template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash {
    using argument_type = _Kty;
    using result_type = size_t;
    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))
    {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};
template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> {
    _Conditionally_enabled_hash() = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&) = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};
template <class _Kty>
struct hash
    : _Conditionally_enabled_hash<_Kty,
          !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    static size_t _Do_hash(const _Kty& _Keyval) noexcept
    {
        return _Hash_representation(_Keyval);
    }
};
template <>
struct hash<float> {
    using argument_type = float;
    using result_type = size_t;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept
    {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval);
    }
};
template <>
struct hash<double> {
    using argument_type = double;
    using result_type = size_t;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept
    {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval);
    }
};
template <>
struct hash<long double> {
    using argument_type = long double;
    using result_type = size_t;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept
    {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval);
    }
};
template <>
struct hash<nullptr_t> {
    using argument_type = nullptr_t;
    using result_type = size_t;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept
    {
        void* _Null {};
        return _Hash_representation(_Null);
    }
};
template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {
};
template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty> {}(::std::declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty> {}(::std::declval<const _Kty&>()))> {
};
template <class _FloatingType>
struct _Floating_type_traits;
template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits = 24;
    static constexpr int32_t _Exponent_bits = 8;
    static constexpr int32_t _Maximum_binary_exponent = 127;
    static constexpr int32_t _Minimum_binary_exponent = -126;
    static constexpr int32_t _Exponent_bias = 127;
    static constexpr int32_t _Sign_shift = 31;
    static constexpr int32_t _Exponent_shift = 23;
    using _Uint_type = uint32_t;
    static constexpr uint32_t _Exponent_mask = 0x000000FFu;
    static constexpr uint32_t _Normal_mantissa_mask = 0x00FFFFFFu;
    static constexpr uint32_t _Denormal_mantissa_mask = 0x007FFFFFu;
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u;
    static constexpr uint32_t _Shifted_sign_mask = 0x80000000u;
    static constexpr uint32_t _Shifted_exponent_mask = 0x7F800000u;
};
template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits = 53;
    static constexpr int32_t _Exponent_bits = 11;
    static constexpr int32_t _Maximum_binary_exponent = 1023;
    static constexpr int32_t _Minimum_binary_exponent = -1022;
    static constexpr int32_t _Exponent_bias = 1023;
    static constexpr int32_t _Sign_shift = 63;
    static constexpr int32_t _Exponent_shift = 52;
    using _Uint_type = uint64_t;
    static constexpr uint64_t _Exponent_mask = 0x00000000000007FFu;
    static constexpr uint64_t _Normal_mantissa_mask = 0x001FFFFFFFFFFFFFu;
    static constexpr uint64_t _Denormal_mantissa_mask = 0x000FFFFFFFFFFFFFu;
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u;
    static constexpr uint64_t _Shifted_sign_mask = 0x8000000000000000u;
    static constexpr uint64_t _Shifted_exponent_mask = 0x7FF0000000000000u;
};
template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) namespace [[deprecated("warning STL4002: "
                                                                                 "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
                                                                                 "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1
{
    using ::std::add_const;
    using ::std::add_cv;
    using ::std::add_pointer;
    using ::std::add_volatile;
    using ::std::aligned_storage;
    using ::std::alignment_of;
    using ::std::conditional;
    using ::std::cref;
    using ::std::decay;
    using ::std::enable_if;
    using ::std::extent;
    using ::std::false_type;
    using ::std::has_virtual_destructor;
    using ::std::hash;
    using ::std::integral_constant;
    using ::std::is_abstract;
    using ::std::is_arithmetic;
    using ::std::is_array;
    using ::std::is_base_of;
    using ::std::is_class;
    using ::std::is_compound;
    using ::std::is_const;
    using ::std::is_convertible;
    using ::std::is_empty;
    using ::std::is_enum;
    using ::std::is_floating_point;
    using ::std::is_function;
    using ::std::is_fundamental;
    using ::std::is_integral;
    using ::std::is_member_function_pointer;
    using ::std::is_member_object_pointer;
    using ::std::is_member_pointer;
    using ::std::is_object;
    using ::std::is_pod;
    using ::std::is_pointer;
    using ::std::is_polymorphic;
    using ::std::is_reference;
    using ::std::is_same;
    using ::std::is_scalar;
    using ::std::is_signed;
    using ::std::is_union;
    using ::std::is_unsigned;
    using ::std::is_void;
    using ::std::is_volatile;
    using ::std::make_signed;
    using ::std::make_unsigned;
    using ::std::rank;
    using ::std::ref;
    using ::std::reference_wrapper;
    using ::std::remove_all_extents;
    using ::std::remove_const;
    using ::std::remove_cv;
    using ::std::remove_extent;
    using ::std::remove_pointer;
    using ::std::remove_reference;
    using ::std::remove_volatile;
    using ::std::result_of;
    using ::std::true_type;
}
__pragma(warning(pop))
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
bool __cdecl uncaught_exception() noexcept;
int __cdecl uncaught_exceptions() noexcept;
}
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    typedef struct _heapinfo {
        int* _pentry;
        size_t _size;
        int _useflag;
    } _HEAPINFO;
    void* __cdecl _alloca(size_t _Size);
    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);
    __declspec(dllimport) int __cdecl _heapmin(void);
    __declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * _EntryInfo);
    __declspec(dllimport) int __cdecl _heapchk(void);
    __declspec(dllimport) int __cdecl _resetstkoflw(void);
    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");
#pragma warning(push)
#pragma warning(disable : 6540)
    __inline void* _MarkAllocaS(void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr) {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }
    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 6014)
    __inline void __cdecl _freea(void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory) {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD) {
                free(_Memory);
            } else if (_Marker != 0xCCCC) {
                (void)((!!((("Corrupted pointer passed to _freea" && 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\malloc.h", 164, 0, L"%ls", L"(\"Corrupted pointer passed to _freea\" && 0)")) || (__debugbreak(), 0));
            }
        }
    }
#pragma warning(pop)
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
    __pragma(pack(push, 8)) extern "C"
{
    typedef void(__cdecl * terminate_handler)(void);
    typedef void(__cdecl * terminate_function)(void);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();
    __declspec(dllimport) terminate_handler __cdecl set_terminate(
        terminate_handler _NewTerminateHandler) throw();
    __declspec(dllimport) terminate_handler __cdecl _get_terminate();
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4514 4820)
    __pragma(pack(push, 8)) extern "C"
{
    typedef void(__cdecl * unexpected_handler)(void);
    typedef void(__cdecl * unexpected_function)(void);
    __declspec(noreturn) void __cdecl unexpected() noexcept(false);
    unexpected_handler __cdecl set_unexpected(
        unexpected_handler _NewUnexpectedHandler) noexcept;
    unexpected_handler __cdecl _get_unexpected() noexcept;
    struct _EXCEPTION_POINTERS;
    typedef void(__cdecl * _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
    _se_translator_function __cdecl _set_se_translator(
        _se_translator_function _NewSETranslator);
    extern "C++" {
    class type_info;
    }
    int __cdecl _is_exception_typeof(
        type_info const& _Type,
        _EXCEPTION_POINTERS* _ExceptionPtr);
    bool __cdecl __uncaught_exception();
    int __cdecl __uncaught_exceptions();
}
__pragma(pack(pop))
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable : 4514 4820)
#pragma pack(push, 8)
    __pragma(pack(push, 8)) extern "C"
{
    struct __std_exception_data {
        char const* _What;
        bool _DoFree;
    };
    void __cdecl __std_exception_copy(
        __std_exception_data const* _From,
        __std_exception_data* _To);
    void __cdecl __std_exception_destroy(
        __std_exception_data * _Data);
}
__pragma(pack(pop)) namespace std
{
#pragma warning(push)
#pragma warning(disable : 4577)
    class exception {
    public:
        exception() noexcept
            : _Data()
        {
        }
        explicit exception(char const* const _Message) noexcept
            : _Data()
        {
            __std_exception_data _InitData = { _Message, true };
            __std_exception_copy(&_InitData, &_Data);
        }
        exception(char const* const _Message, int) noexcept
            : _Data()
        {
            _Data._What = _Message;
        }
        exception(exception const& _Other) noexcept
            : _Data()
        {
            __std_exception_copy(&_Other._Data, &_Data);
        }
        exception& operator=(exception const& _Other) noexcept
        {
            if (this == &_Other) {
                return *this;
            }
            __std_exception_destroy(&_Data);
            __std_exception_copy(&_Other._Data, &_Data);
            return *this;
        }
        virtual ~exception() noexcept
        {
            __std_exception_destroy(&_Data);
        }
        [[nodiscard]] virtual char const* what() const
        {
            return _Data._What ? _Data._What : "Unknown exception";
        }

    private:
        __std_exception_data _Data;
    };
    class bad_exception
        : public exception {
    public:
        bad_exception() noexcept
            : exception("bad exception", 1)
        {
        }
    };
    class bad_alloc
        : public exception {
    public:
        bad_alloc() noexcept
            : exception("bad allocation", 1)
        {
        }

    private:
        friend class bad_array_new_length;
        bad_alloc(char const* const _Message) noexcept
            : exception(_Message, 1)
        {
        }
    };
    class bad_array_new_length
        : public bad_alloc {
    public:
        bad_array_new_length() noexcept
            : bad_alloc("bad array new length")
        {
        }
    };
#pragma warning(pop)
}
#pragma pack(pop)
#pragma warning(pop)
namespace std {
using ::set_terminate;
using ::terminate;
using ::terminate_handler;
[[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept
{
    return _get_terminate();
}
using ::set_unexpected;
using ::unexpected;
using ::unexpected_handler;
[[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept
{
    return _get_unexpected();
}
}
void __cdecl __ExceptionPtrCreate(void*) noexcept;
void __cdecl __ExceptionPtrDestroy(void*) noexcept;
void __cdecl __ExceptionPtrCopy(void*, const void*) noexcept;
void __cdecl __ExceptionPtrAssign(void*, const void*) noexcept;
bool __cdecl __ExceptionPtrCompare(const void*, const void*) noexcept;
bool __cdecl __ExceptionPtrToBool(const void*) noexcept;
void __cdecl __ExceptionPtrSwap(void*, void*) noexcept;
void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
[[noreturn]] void __cdecl __ExceptionPtrRethrow(const void*);
void __cdecl __ExceptionPtrCopyException(
    void*, const void*, const void*) noexcept;
namespace std {
class exception_ptr {
public:
    exception_ptr() noexcept
    {
        __ExceptionPtrCreate(this);
    }
    exception_ptr(nullptr_t) noexcept
    {
        __ExceptionPtrCreate(this);
    }
    ~exception_ptr() noexcept
    {
        __ExceptionPtrDestroy(this);
    }
    exception_ptr(const exception_ptr& _Rhs) noexcept
    {
        __ExceptionPtrCopy(this, &_Rhs);
    }
    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept
    {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }
    exception_ptr& operator=(nullptr_t) noexcept
    {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }
    explicit operator bool() const noexcept
    {
        return __ExceptionPtrToBool(this);
    }
    static exception_ptr _Current_exception() noexcept
    {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }
    static exception_ptr _Copy_exception(void* _Except, const void* _Ptr)
    {
        exception_ptr _Retval;
        if (!_Ptr) {
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }
    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept
    {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }
    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept
    {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }
    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept
    {
        return !_Lhs;
    }
    [[nodiscard]] friend bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept
    {
        return !_Rhs;
    }
    [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept
    {
        return !(_Lhs == _Rhs);
    }
    [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept
    {
        return !(_Lhs == _Rhs);
    }
    [[nodiscard]] friend bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept
    {
        return !(_Lhs == _Rhs);
    }

private:
    void* _Data1;
    void* _Data2;
};
[[nodiscard]] inline exception_ptr current_exception() noexcept
{
    return exception_ptr::_Current_exception();
}
[[noreturn]] inline void rethrow_exception(exception_ptr _Ptr)
{
    __ExceptionPtrRethrow(&_Ptr);
}
template <class _Ex>
void* __GetExceptionInfo(_Ex);
template <class _Ex>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; "
            "it is not useful to call this function and discard the return value.")]] exception_ptr
make_exception_ptr(_Ex _Except) noexcept
{
    return exception_ptr::_Copy_exception(::std::addressof(_Except), __GetExceptionInfo(_Except));
}
[[noreturn]] inline void _Throw_bad_array_new_length()
{
    throw bad_array_new_length {};
}
class nested_exception {
public:
    nested_exception() noexcept
        : _Exc(::std::current_exception())
    {
    }
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept { }
    [[noreturn]] void rethrow_nested() const
    {
        if (_Exc) {
            ::std::rethrow_exception(_Exc);
        } else {
            ::std::terminate();
        }
    }
    [[nodiscard]] exception_ptr nested_ptr() const noexcept
    {
        return _Exc;
    }

private:
    exception_ptr _Exc;
};
template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception {
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std::forward<_Ty>(_Arg))
        , nested_exception()
    {
    }
};
template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg)
{
    using _Uty = decay_t<_Ty>;
    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std::forward<_Ty>(_Arg));
    } else {
        throw ::std::forward<_Ty>(_Arg);
    }
}
template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg)
{
    constexpr bool _Can_use_dynamic_cast = is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>);
    if constexpr (_Can_use_dynamic_cast) {
        const auto _Nested = dynamic_cast<const nested_exception*>(::std::addressof(_Arg));
        if (_Nested) {
            _Nested->rethrow_nested();
        }
    }
}
class bad_variant_access
    : public exception {
public:
    bad_variant_access() noexcept = default;
    [[nodiscard]] const char* what() const noexcept override
    {
        return "bad variant access";
    }
};
[[noreturn]] inline void _Throw_bad_variant_access()
{
    throw bad_variant_access {};
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
using new_handler = void(__cdecl*)();
new_handler __cdecl set_new_handler(new_handler) noexcept;
[[nodiscard]] new_handler __cdecl get_new_handler() noexcept;
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
using _Atomic_counter_t = unsigned long;
template <class _Integral, class _Ty>
[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept
{
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}
template <class _Integral, class _Ty>
[[nodiscard]] const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept
{
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right)))
{
    return _Pred(_Left, _Right) ? _Right : _Left;
}
#pragma warning(push)
#pragma warning(disable : 28285)
template <class _Ty>
[[nodiscard]] constexpr const _Ty&(max)(const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))
{
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)
template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr);
template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>);
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left)))
{
    return _Pred(_Right, _Left) ? _Right : _Left;
}
#pragma warning(push)
#pragma warning(disable : 28285)
template <class _Ty>
[[nodiscard]] constexpr const _Ty&(min)(const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))
{
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)
template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr);
template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>);
template <class _FwdIt1, class _FwdIt2>
inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
{
    swap(*_Left, *_Right);
}
template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> _Enabled>
inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value)
{
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1 = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std::iter_swap(_First1, _First2);
        }
    }
}
template <class _Ty, int _Enabled>
inline void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>)
{
    _Ty _Tmp = ::std::move(_Left);
    _Left = ::std::move(_Right);
    _Right = ::std::move(_Tmp);
}
template <class _Ty>
inline void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value)
{
    swap(_Left, _Right);
}
struct piecewise_construct_t {
    explicit piecewise_construct_t() = default;
};
constexpr piecewise_construct_t piecewise_construct {};
template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {
};
template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {
};
struct allocator_arg_t {
    explicit allocator_arg_t() = default;
};
constexpr allocator_arg_t allocator_arg {};
template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
};
template <class _Ty, class _Alloc>
constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
template <class...>
class tuple;
template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;
template <class _Ty1, class _Ty2>
struct pair {
    using first_type = _Ty1;
    using second_type = _Ty2;
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>)
        pair() noexcept(
            is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>)
        : first()
        , second()
    {
    }
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
            is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>)
        : first(_Val1)
        , second(_Val2)
    {
    }
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>)
        : first(::std::forward<_Other1>(_Val1))
        , second(::std::forward<_Other2>(_Val2))
    {
    }
    pair(const pair&) = default;
    pair(pair&&) = default;
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
            int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&&
                is_nothrow_constructible_v<_Ty2, const _Other2&>)
        : first(_Right.first)
        , second(_Right.second)
    {
    }
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>)
        : first(::std::forward<_Other1>(_Right.first))
        , second(::std::forward<_Other2>(_Right.second))
    {
    }
    template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>)
        : first(_Tuple_get<_Indexes1>(::std::move(_Val1))...)
        , second(_Tuple_get<_Indexes2>(::std::move(_Val2))...)
    {
    }
    template <class... _Types1, class... _Types2>
    inline pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...> {}, index_sequence_for<_Types2...> {})
    {
    }
    pair& operator=(const volatile pair&) = delete;
    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int> = 0>
    inline pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)
    {
        first = _Right.first;
        second = _Right.second;
        return *this;
    }
    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int> = 0>
    inline pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)
    {
        first = ::std::forward<_Ty1>(_Right.first);
        second = ::std::forward<_Ty2>(_Right.second);
        return *this;
    }
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    inline pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&&
            is_nothrow_assignable_v<_Ty2&, const _Other2&>)
    {
        first = _Right.first;
        second = _Right.second;
        return *this;
    }
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    inline pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)
    {
        first = ::std::forward<_Other1>(_Right.first);
        second = ::std::forward<_Other2>(_Right.second);
        return *this;
    }
    inline void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value)
    {
        if (this != ::std::addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }
    _Ty1 first;
    _Ty2 second;
};
template <class _Ty1, class _Ty2, enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
inline void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right)))
{
    _Left.swap(_Right);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
{
    return _Left.first == _Right.first && _Left.second == _Right.second;
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
{
    return !(_Left == _Right);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
{
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
{
    return _Right < _Left;
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
{
    return !(_Right < _Left);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
{
    return !(_Left < _Right);
}
template <class _Ty>
struct _Unrefwrap_helper {
    using type = _Ty;
};
template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> {
    using type = _Ty&;
};
template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&&
        is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)
{
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std::forward<_Ty1>(_Val1), ::std::forward<_Ty2>(_Val2));
}
namespace rel_ops {
    template <class _Ty>
    [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right)
    {
        return !(_Left == _Right);
    }
    template <class _Ty>
    [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right)
    {
        return _Right < _Left;
    }
    template <class _Ty>
    [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right)
    {
        return !(_Right < _Left);
    }
    template <class _Ty>
    [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right)
    {
        return !(_Left < _Right);
    }
}
template <class _Tuple>
struct tuple_size;
template <class _Tuple, class = void>
struct _Tuple_size_sfinae {
};
template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {
};
template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {
};
template <class _Tuple>
struct tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {
};
template <class _Tuple>
struct tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {
};
template <class _Ty>
constexpr size_t tuple_size_v = tuple_size<_Ty>::value;
template <size_t _Index, class _Tuple>
struct tuple_element;
template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple>
{
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type = add_const_t<typename _Mybase::type>;
};
template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple>
{
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type = add_volatile_t<typename _Mybase::type>;
};
template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple>
{
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type = add_cv_t<typename _Mybase::type>;
};
template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;
template <class _Ty, size_t _Size>
class array;
template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {
};
template <size_t _Idx, class _Ty, size_t _Size>
struct [[msvc::known_semantics]] tuple_element<_Idx, array<_Ty, _Size>>
{
    static_assert(_Idx < _Size, "array index out of bounds");
    using type = _Ty;
};
template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {
};
template <size_t _Index>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<>>
{
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};
template <class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<0, tuple<_This, _Rest...>>
{
    using type = _This;
    using _Ttype = tuple<_This, _Rest...>;
};
template <size_t _Index, class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {};
template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {
};
template <size_t _Idx, class _Ty1, class _Ty2>
struct [[msvc::known_semantics]] tuple_element<_Idx, pair<_Ty1, _Ty2>>
{
    static_assert(_Idx < 2, "pair index out of bounds");
    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept
{
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
{
    return _Pr.first;
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
{
    return _Pr.second;
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
{
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
{
    return _Pr.first;
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
{
    return _Pr.second;
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
{
    if constexpr (_Idx == 0) {
        return ::std::forward<_Ty1>(_Pr.first);
    } else {
        return ::std::forward<_Ty2>(_Pr.second);
    }
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
{
    return ::std::forward<_Ty1>(_Pr.first);
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
{
    return ::std::forward<_Ty2>(_Pr.second);
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
{
    if constexpr (_Idx == 0) {
        return ::std::forward<const _Ty1>(_Pr.first);
    } else {
        return ::std::forward<const _Ty2>(_Pr.second);
    }
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
{
    return ::std::forward<const _Ty1>(_Pr.first);
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
{
    return ::std::forward<const _Ty2>(_Pr.second);
}
template <class _Ty, class _Other = _Ty>
inline _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>)
{
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val = static_cast<_Other&&>(_New_val);
    return _Old_val;
}
template <class _Ty>
[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
{
    return _Val;
}
template <class _Ty>
void as_const(const _Ty&&) = delete;
namespace [[deprecated("warning STL4002: "
                       "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
                       "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 {
    using ::std::get;
    using ::std::tuple_element;
    using ::std::tuple_size;
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
struct input_iterator_tag {
};
struct output_iterator_tag {
};
struct forward_iterator_tag : input_iterator_tag {
};
struct bidirectional_iterator_tag : forward_iterator_tag {
};
struct random_access_iterator_tag : bidirectional_iterator_tag {
};
template <class, class = void>
struct _Iterator_traits_base {
};
template <class _Iter>
struct _Iterator_traits_base<_Iter,
    void_t<typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type,
        typename _Iter::pointer, typename _Iter::reference>> {
    using iterator_category = typename _Iter::iterator_category;
    using value_type = typename _Iter::value_type;
    using difference_type = typename _Iter::difference_type;
    using pointer = typename _Iter::pointer;
    using reference = typename _Iter::reference;
};
template <class _Ty, bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base {
    using iterator_category = random_access_iterator_tag;
    using value_type = remove_cv_t<_Ty>;
    using difference_type = ptrdiff_t;
    using pointer = _Ty*;
    using reference = _Ty&;
};
template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> {
};
template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> {
};
template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> {
};
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
extern "C" {
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;
const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_1(const void* _First, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_2(const void* _First, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_4(const void* _First, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_8(const void* _First, uint64_t _Val) noexcept;
}
template <class _Ty, class _TVal>
__declspec(noalias) size_t __std_count_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept
{
    if constexpr (::std::is_pointer_v<_TVal> || ::std::is_null_pointer_v<_TVal>) {
        return __std_count_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return __std_count_trivial_1(_First, _Last, static_cast<uint8_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 2) {
        return __std_count_trivial_2(_First, _Last, static_cast<uint16_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 4) {
        return __std_count_trivial_4(_First, _Last, static_cast<uint32_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 8) {
        return __std_count_trivial_8(_First, _Last, static_cast<uint64_t>(_Val));
    } else {
        static_assert(::std::_Always_false<_Ty>, "Unexpected size");
    }
}
template <class _Ty, class _TVal>
_Ty* __std_find_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept
{
    if constexpr (::std::is_pointer_v<_TVal> || ::std::is_null_pointer_v<_TVal>) {
        return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std::_Always_false<_Ty>, "Unexpected size");
    }
}
template <class _Ty, class _TVal>
_Ty* __std_find_trivial_unsized(_Ty* _First, const _TVal _Val) noexcept
{
    if constexpr (::std::is_pointer_v<_TVal> || ::std::is_null_pointer_v<_TVal>) {
        return __std_find_trivial_unsized(_First, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_1(_First, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_2(_First, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_4(_First, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_8(_First, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std::_Always_false<_Ty>, "Unexpected size");
    }
}
namespace std {
template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To _Bit_cast(const _From& _Val) noexcept
{
    return __builtin_bit_cast(_To, _Val);
}
template <class _Ty>
struct _Get_first_parameter;
template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> {
    using type = _First;
};
template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;
template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> {
    using type = _Ty<_Newfirst, _Rest...>;
};
template <class _Ty, class = void>
struct _Get_element_type {
    using type = typename _Get_first_parameter<_Ty>::type;
};
template <class _Ty>
struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>> {
    using type = typename _Ty::element_type;
};
template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};
template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};
template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};
template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};
template <class _Iter>
[[nodiscard]] constexpr void* _Voidify_iter(_Iter _It) noexcept
{
    if constexpr (is_pointer_v<_Iter>) {
        return const_cast<void*>(static_cast<const volatile void*>(_It));
    } else {
        return const_cast<void*>(static_cast<const volatile void*>(::std::addressof(*_It)));
    }
}
template <class _Ty, class... _Types>
inline void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>)
{
    {
        ::new (_Voidify_iter(::std::addressof(_Obj))) _Ty(::std::forward<_Types>(_Args)...);
    }
}
template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>)
{
    ::new (_Voidify_iter(::std::addressof(_Obj))) _Ty;
}
template <class _Ty>
struct pointer_traits {
    using pointer = _Ty;
    using element_type = typename _Get_element_type<_Ty>::type;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;
    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;
    using _Reftype = conditional_t<is_void_v<element_type>, char, element_type>&;
    [[nodiscard]] static pointer pointer_to(_Reftype _Val) noexcept(noexcept(_Ty::pointer_to(_Val)))
    {
        return _Ty::pointer_to(_Val);
    }
};
template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer = _Ty*;
    using element_type = _Ty;
    using difference_type = ptrdiff_t;
    template <class _Other>
    using rebind = _Other*;
    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;
    [[nodiscard]] static inline pointer pointer_to(_Reftype _Val) noexcept
    {
        return ::std::addressof(_Val);
    }
};
template <class _Fx>
struct _Ref_fn {
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals)
    {
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std::invoke(_Fn, ::std::forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std::forward<_Args>(_Vals)...);
        }
    }
    _Fx& _Fn;
};
template <class _Fn>
constexpr bool _Pass_functor_by_value_v = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
    is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Fn _Pass_fn(_Fn _Val)
{
    return _Val;
}
template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val)
{
    return { _Val };
}
struct _Unused_parameter {
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept { }
};
using _Any_tag = _Unused_parameter;
template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;
template <class _Iter>
using _Iter_ref_t = typename iterator_traits<_Iter>::reference;
template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;
template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;
template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;
template <class _Ty, class = void>
constexpr bool _Is_iterator_v = false;
template <class _Ty>
constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;
template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {
};
template <class _Iter>
constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;
template <class _Iter>
constexpr bool _Is_ranges_input_iter_v = _Is_cpp17_input_iter_v<_Iter>;
template <class _Iter>
constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;
template <class _Iter>
constexpr bool _Is_ranges_fwd_iter_v = _Is_cpp17_fwd_iter_v<_Iter>;
template <class _Iter>
constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;
template <class _Iter>
constexpr bool _Is_ranges_bidi_iter_v = _Is_cpp17_bidi_iter_v<_Iter>;
template <class _Iter>
constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;
template <class _Iter>
constexpr bool _Is_ranges_random_iter_v = _Is_cpp17_random_iter_v<_Iter>;
template <class, class = void>
struct _Is_checked_helper {
};
template <class _Ty>
constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept
{
    do {
        if (_First <= _Last) {
        } else {
            do {
                (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 868, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0));
                ::_invalid_parameter(L"\"transposed pointer range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 868, 0);
            } while (false);
        };
    } while (false);
}
template <class _Iter, class = void>
constexpr bool _Allow_inheriting_unwrap_v = true;
template <class _Iter>
constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> = is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;
template <class _Iter, class _Sentinel = _Iter, class = void>
constexpr bool _Range_verifiable_v = false;
template <class _Iter, class _Sentinel>
constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std::declval<const _Iter&>(), ::std::declval<const _Sentinel&>()))>> = _Allow_inheriting_unwrap_v<_Iter>;
template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last)
{
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}
template <class _Iter, class = void>
constexpr bool _Unwrappable_v = false;
template <class _Iter>
constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std::declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std::declval<_Iter>()._Unwrapped()))>> = _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;
template <class _Iter, class = void>
constexpr bool _Has_nothrow_unwrapped = false;
template <class _Iter>
constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(::std::declval<_Iter>()._Unwrapped())>> = noexcept(::std::declval<_Iter>()._Unwrapped());
template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) noexcept(
    !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>)
{
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}
template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std::declval<_Iter>()))>;
template <class _Iter, class = bool>
constexpr bool _Do_unwrap_when_unverified_v = false;
template <class _Iter>
constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> = static_cast<bool>(_Iter::_Unwrap_when_unverified);
template <class _Iter>
constexpr bool _Unwrappable_for_unverified_v = _Unwrappable_v<_Iter>&& _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;
template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It)
{
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}
template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std::declval<_Iter>()))>;
struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept
    {
        return {};
    }
};
template <class _Diff>
constexpr _Diff _Max_possible_v { static_cast<make_unsigned_t<_Diff>>(-1) >> 1 };
template <class _Diff>
constexpr _Diff _Min_possible_v { -_Max_possible_v<_Diff> - 1 };
template <class _Iter, class = void>
constexpr bool _Offset_verifiable_v = false;
template <class _Iter>
constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std::declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter> {}))>> = true;
template <class _Iter>
constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter>&& _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;
template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off)
{
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        using _IDiff = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);
        do {
            if (_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>) && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 988, 0, "%s", "integer overflow")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"integer overflow\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 988, 0);
                } while (false);
            };
        } while (false);
        (void)_COff;
        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}
template <class _Iter, class _UIter, class = void>
constexpr bool _Wrapped_seekable_v = false;
template <class _Iter, class _UIter>
constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std::declval<_Iter&>()._Seek_to(::std::declval<_UIter>()))>> = true;
template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt)
{
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std::forward<_UIter>(_UIt));
    } else {
        _It = ::std::forward<_UIter>(_UIt);
    }
}
template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last)
{
    if constexpr (_Is_ranges_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown {};
    }
}
template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum {
    using type = underlying_type_t<_Elem>;
};
template <class _Elem>
struct _Unwrap_enum<_Elem, false> {
    using type = _Elem;
};
template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;
template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(
    noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left)))
{
    const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
    if (_Result) {
        do {
            if (!_Pred(_Right, _Left)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1096, 0, "%s", "invalid comparator")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"invalid comparator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1096, 0);
                } while (false);
            };
        } while (false);
    }
    return _Result;
}
template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<!is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(noexcept(_Pred(_Left, _Right)))
{
    return static_cast<bool>(_Pred(_Left, _Right));
}
template <class _InIt, class _Sentinel, class _Pr>
constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred)
{
    if constexpr (_Is_ranges_fwd_iter_v<_InIt>) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                do {
                    if (!static_cast<bool>(_Pred(*_Next, *_First))) {
                    } else {
                        do {
                            (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1115, 0, "%s", "sequence not ordered")) || (__debugbreak(), 0));
                            ::_invalid_parameter(L"\"sequence not ordered\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1115, 0);
                        } while (false);
                    };
                } while (false);
            }
        }
    }
}
template <class _OtherIt, class _InIt, class _Pr>
constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred)
{
    if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>>) {
        _Debug_order_unchecked(_First, _Last, _Pred);
    }
}
template <class _InIt, class _Diff>
inline void advance(_InIt& _Where, _Diff _Off)
{
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
            do {
                if (_Off >= 0) {
                } else {
                    do {
                        (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1137, 0, "%s", "negative advance of non-bidirectional iterator")) || (__debugbreak(), 0));
                        ::_invalid_parameter(L"\"negative advance of non-bidirectional iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1137, 0);
                    } while (false);
                };
            } while (false);
        }
        decltype(auto) _UWhere = _Get_unwrapped_n(::std::move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std::move(_Where), _Off))>;
        if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }
        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }
        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, ::std::move(_UWhere));
        }
    }
}
template <class _InIt>
[[nodiscard]] inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)
{
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        return _Last - _First;
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }
        return _Off;
    }
}
template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First)
{
    return ++_First;
}
template <class _InIt>
[[nodiscard]] inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
{
    static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");
    ::std::advance(_First, _Off);
    return _First;
}
template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First)
{
    return --_First;
}
template <class _BidIt>
[[nodiscard]] inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
{
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");
    ::std::advance(_First, -_Off);
    return _First;
}
template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;
template <class _Iter, class _Pointer>
constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> = noexcept(
    _Fake_copy_init<_Pointer>(::std::declval<_Iter>().operator->()));
template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;
    using iterator_category = _Iter_cat_t<_BidIt>;
    using value_type = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer = typename iterator_traits<_BidIt>::pointer;
    using reference = _Iter_ref_t<_BidIt>;
    template <class>
    friend class reverse_iterator;
    inline reverse_iterator() = default;
    inline explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>)
        : current(::std::move(_Right))
    {
    }
    template <class _Other>
    inline reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>)
        : current(_Right.current)
    {
    }
    template <class _Other>
    inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_BidIt&, const _Other&>)
    {
        current = _Right.current;
        return *this;
    }
    [[nodiscard]] inline _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>)
    {
        return current;
    }
    [[nodiscard]] inline reference operator*() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(*--(::std::declval<_BidIt&>())))
    {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }
    [[nodiscard]] inline pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--(::std::declval<_BidIt&>()))
            && _Has_nothrow_operator_arrow<_BidIt&, pointer>)
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }
    inline reverse_iterator& operator++() noexcept(noexcept(--current))
    {
        --current;
        return *this;
    }
    inline reverse_iterator operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--current))
    {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }
    inline reverse_iterator& operator--() noexcept(noexcept(++current))
    {
        ++current;
        return *this;
    }
    inline reverse_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(++current))
    {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }
    [[nodiscard]] inline reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off)))
    {
        return reverse_iterator(current - _Off);
    }
    inline reverse_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(current -= _Off))
    {
        current -= _Off;
        return *this;
    }
    [[nodiscard]] inline reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off)))
    {
        return reverse_iterator(current + _Off);
    }
    inline reverse_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(current += _Off))
    {
        current += _Off;
        return *this;
    }
    [[nodiscard]] inline reference operator[](const difference_type _Off) const
        noexcept(noexcept(_Fake_copy_init<reference>(current[_Off])))
    {
        return current[static_cast<difference_type>(-_Off - 1)];
    }
    using _Prevent_inheriting_unwrap = reverse_iterator;
    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(
        const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept
    {
        _Verify_range(_Last._Get_current(), _First.current);
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept
    {
        do {
            if (_Off != _Min_possible_v<difference_type>) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1364, 0, "%s", "integer overflow")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"integer overflow\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 1364, 0);
                } while (false);
            };
        } while (false);
        current._Verify_offset(-_Off);
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped())))
    {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std::move(current)._Unwrapped())))
    {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std::move(current)._Unwrapped());
    }
    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;
    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current)))
    {
        current._Seek_to(_It.current);
    }
    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept
    {
        return current;
    }

protected:
    _BidIt current {};
};
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool
operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current())))
{
    return _Left._Get_current() == _Right._Get_current();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool
operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current())))
{
    return _Left._Get_current() != _Right._Get_current();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool
operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current())))
{
    return _Left._Get_current() > _Right._Get_current();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool
operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current())))
{
    return _Left._Get_current() < _Right._Get_current();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool
operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current())))
{
    return _Left._Get_current() >= _Right._Get_current();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool
operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current())))
{
    return _Left._Get_current() <= _Right._Get_current();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline auto
operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Right._Get_current() - _Left._Get_current()))
    -> decltype(_Right._Get_current() - _Left._Get_current())
{
    return _Right._Get_current() - _Left._Get_current();
}
template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off))
{
    return _Right + _Off;
}
template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>)
{
    return reverse_iterator<_BidIt>(::std::move(_Iter));
}
template <class _Container>
[[nodiscard]] inline auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin()))
    -> decltype(_Cont.begin())
{
    return _Cont.begin();
}
template <class _Container>
[[nodiscard]] inline auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin()))
    -> decltype(_Cont.begin())
{
    return _Cont.begin();
}
template <class _Container>
[[nodiscard]] inline auto end(_Container& _Cont) noexcept(noexcept(_Cont.end()))
    -> decltype(_Cont.end())
{
    return _Cont.end();
}
template <class _Container>
[[nodiscard]] inline auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end()))
    -> decltype(_Cont.end())
{
    return _Cont.end();
}
template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept
{
    return _Array;
}
template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept
{
    return _Array + _Size;
}
template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std::begin(_Cont)))
    -> decltype(::std::begin(_Cont))
{
    return ::std::begin(_Cont);
}
template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std::end(_Cont)))
    -> decltype(::std::end(_Cont))
{
    return ::std::end(_Cont);
}
template <class _Container>
[[nodiscard]] inline auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin()))
    -> decltype(_Cont.rbegin())
{
    return _Cont.rbegin();
}
template <class _Container>
[[nodiscard]] inline auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin()))
    -> decltype(_Cont.rbegin())
{
    return _Cont.rbegin();
}
template <class _Container>
[[nodiscard]] inline auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend()))
    -> decltype(_Cont.rend())
{
    return _Cont.rend();
}
template <class _Container>
[[nodiscard]] inline auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend()))
    -> decltype(_Cont.rend())
{
    return _Cont.rend();
}
template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept
{
    return reverse_iterator<_Ty*>(_Array + _Size);
}
template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept
{
    return reverse_iterator<_Ty*>(_Array);
}
template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
{
    return reverse_iterator<const _Elem*>(_Ilist.end());
}
template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
{
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}
template <class _Container>
[[nodiscard]] inline auto crbegin(const _Container& _Cont) noexcept(noexcept(::std::rbegin(_Cont)))
    -> decltype(::std::rbegin(_Cont))
{
    return ::std::rbegin(_Cont);
}
template <class _Container>
[[nodiscard]] inline auto crend(const _Container& _Cont) noexcept(noexcept(::std::rend(_Cont)))
    -> decltype(::std::rend(_Cont))
{
    return ::std::rend(_Cont);
}
template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size()))
    -> decltype(_Cont.size())
{
    return _Cont.size();
}
template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept
{
    return _Size;
}
template <class _Container>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and "
            "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr auto
empty(const _Container& _Cont) noexcept(
    noexcept(_Cont.empty()))
    -> decltype(_Cont.empty())
{
    return _Cont.empty();
}
template <class _Ty, size_t _Size>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and "
            "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool
empty(const _Ty (&)[_Size]) noexcept
{
    return false;
}
template <class _Elem>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and "
            "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool
empty(initializer_list<_Elem> _Ilist) noexcept
{
    return _Ilist.size() == 0;
}
template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data()))
    -> decltype(_Cont.data())
{
    return _Cont.data();
}
template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data()))
    -> decltype(_Cont.data())
{
    return _Cont.data();
}
template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept
{
    return _Array;
}
template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept
{
    return _Ilist.begin();
}
struct _Container_proxy;
struct _Iterator_base12;
struct _Default_sentinel {
};
template <class _Iter>
struct _Move_iterator_category {
    using iterator_category = _Iter_cat_t<_Iter>;
};
template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
public:
    using iterator_type = _Iter;
    using value_type = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer = _Iter;
    using reference = conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
    inline move_iterator() = default;
    inline explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>)
        : _Current(::std::move(_Right))
    {
    }
    template <class _Other>
    inline move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>)
        : _Current(_Right.base())
    {
    }
    template <class _Other>
    inline move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)
    {
        _Current = _Right.base();
        return *this;
    }
    [[nodiscard]] inline iterator_type base() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)
    {
        return _Current;
    }
    [[nodiscard]] inline reference operator*() const
        noexcept(noexcept(static_cast<reference>(*_Current)))
    {
        return static_cast<reference>(*_Current);
    }
    [[nodiscard]] inline pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)
    {
        return _Current;
    }
    inline move_iterator& operator++() noexcept(noexcept(++_Current))
    {
        ++_Current;
        return *this;
    }
    inline auto operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(++_Current))
    {
        move_iterator _Tmp = *this;
        ++_Current;
        return _Tmp;
    }
    inline move_iterator& operator--() noexcept(noexcept(--_Current))
    {
        --_Current;
        return *this;
    }
    inline move_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(--_Current))
    {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }
    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std::declval<const _Iter2&>() == _Sentinel)
    {
        return _Current == _Sentinel;
    }
    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std::declval<const _Iter2&>() != _Sentinel)
    {
        return _Current != _Sentinel;
    }
    [[nodiscard]] inline move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off)))
    {
        return move_iterator(_Current + _Off);
    }
    inline move_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off))
    {
        _Current += _Off;
        return *this;
    }
    [[nodiscard]] inline move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off)))
    {
        return move_iterator(_Current - _Off);
    }
    inline move_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off))
    {
        _Current -= _Off;
        return *this;
    }
    [[nodiscard]] inline reference operator[](const difference_type _Off) const
        noexcept(noexcept(::std::move(_Current[_Off])))
    {
        return ::std::move(_Current[_Off]);
    }
    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept
    {
        _Verify_range(_First._Current, _Last._Get_current());
    }
    using _Prevent_inheriting_unwrap = move_iterator;
    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept
    {
        _Current._Verify_offset(_Off);
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped())))
    {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std::move(_Current)._Unwrapped())))
    {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std::move(_Current)._Unwrapped());
    }
    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current())))
    {
        _Current._Seek_to(_It._Get_current());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It) noexcept(
        noexcept(_Current._Seek_to(::std::move(_It)._Get_current())))
    {
        _Current._Seek_to(::std::move(_It)._Get_current());
    }
    [[nodiscard]] constexpr const iterator_type& _Get_current() const& noexcept
    {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type&& _Get_current() && noexcept
    {
        return ::std::move(_Current);
    }

private:
    iterator_type _Current {};
};
template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool
operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left.base() == _Right.base())))
{
    return _Left.base() == _Right.base();
}
template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator!=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left == _Right))
{
    return !(_Left == _Right);
}
template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool
operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left.base() < _Right.base())))
{
    return _Left.base() < _Right.base();
}
template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left))
{
    return _Right < _Left;
}
template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left))
{
    return !(_Right < _Left);
}
template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left < _Right))
{
    return !(_Left < _Right);
}
template <class _Iter1, class _Iter2>
[[nodiscard]] inline auto operator-(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() - _Right.base()))
    -> decltype(_Left.base() - _Right.base())
{
    return _Left.base() - _Right.base();
}
template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right) noexcept(
    noexcept(move_iterator<_Iter>(_Right.base() + _Off)))
{
    return move_iterator<_Iter>(_Right.base() + _Off);
}
template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> make_move_iterator(_Iter _It) noexcept(
    is_nothrow_move_constructible_v<_Iter>)
{
    return move_iterator<_Iter>(::std::move(_It));
}
template <class _Iter>
constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;
template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept
{
    ;
    return _Val;
}
template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept
{
    return _To_address(_Val.base());
}
template <class _Iter1, class _Iter2>
constexpr bool _Iterators_are_contiguous = _Iterator_is_contiguous<_Iter1>&& _Iterator_is_contiguous<_Iter2>;
template <class _Iter>
constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;
template <class _Source, class _Dest>
constexpr bool _Is_pointer_address_convertible = is_void_v<_Source> || is_void_v<_Dest> || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>;
template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t<_Source>;
    using _UDest = _Unwrap_enum_t<_Dest>;
    static constexpr bool _Same_size_and_compatible = sizeof(_Source) == sizeof(_Dest)
        && is_same_v<bool, _USource> >= is_same_v<bool, _UDest> && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>) || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>));
    static constexpr bool _Bitcopy_constructible = _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;
    static constexpr bool _Bitcopy_assignable = _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
};
template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
    static constexpr bool _Bitcopy_constructible = _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;
    static constexpr bool _Bitcopy_assignable = _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
};
struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable = false;
};
template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
                            remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {
};
template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {
};
template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {
};
template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt> && !_Iterator_is_volatile<_DestIt>>
struct _Iter_copy_cat
    : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {
};
template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {
};
template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {
};
template <class _Iter1, class _Sent1, class _Iter2>
inline void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2)
{
    if constexpr (_Iterators_are_contiguous<_Iter1, _Iter2>) {
        const auto _Offset = _Last1 - _First1;
        const auto _Ptr1Offset = _Offset * sizeof(*_To_address(_First1));
        const auto _Ptr2Offset = _Offset * sizeof(*_To_address(_First2));
        const auto _PtrFirst1 = reinterpret_cast<const volatile char*>(_To_address(_First1));
        const auto _PtrLast1 = _PtrFirst1 + _Ptr1Offset;
        const auto _PtrFirst2 = reinterpret_cast<const volatile char*>(_To_address(_First2));
        const auto _PtrLast2 = _PtrFirst2 + _Ptr2Offset;
        do {
            if (_PtrLast1 <= _PtrFirst2 || _PtrLast2 <= _PtrFirst1) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 3823, 0, "%s", "ranges should not overlap each other")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"ranges should not overlap each other\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xutility", 3823, 0);
                } while (false);
            };
        } while (false);
    }
}
template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest)
{
    auto _FirstPtr = _To_address(_First);
    auto _LastPtr = _To_address(_Last);
    auto _DestPtr = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
    ::memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}
template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest)
{
    const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return _Result;
    } else {
        return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
    }
}
template <class _It, bool _RequiresMutable = false>
constexpr bool _Is_vb_iterator = false;
template <class _InIt, class _SizeTy, class _OutIt>
inline _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest)
{
    if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
        {
            return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
        }
    }
    for (; _Count != 0; ++_Dest, (void)++_First, --_Count) {
        *_Dest = *_First;
    }
    return _Dest;
}
template <class _InIt, class _Sent, class _OutIt>
using _Sent_copy_cat = conditional_t<
    is_same_v<_Sent, _InIt>,
    _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;
template <class _InIt, class _Sent, class _OutIt>
inline _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest)
{
    if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
        {
            {
                return _Copy_memmove(_First, _Last, _Dest);
            }
        }
    }
    for (; _First != _Last; ++_Dest, (void)++_First) {
        *_Dest = *_First;
    }
    return _Dest;
}
template <class _InIt, class _OutIt>
inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _InIt, class _Diff, class _OutIt>
inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest)
{
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {
            {
                _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }
        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) {
                break;
            }
            ++_UFirst;
        }
        _Seek_wrapped(_Dest, _UDest);
    }
    return _Dest;
}
template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest)
{
    auto _FirstPtr = _To_address(_First);
    auto _LastPtr = _To_address(_Last);
    auto _DestPtr = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result = ::memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}
template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest)
{
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{
    if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }
    while (_First != _Last) {
        *--_Dest = *--_Last;
    }
    return _Dest;
}
template <class _BidIt1, class _BidIt2>
inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    const auto _UDest = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _InIt, class _OutIt>
inline _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)
{
    if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    for (; _First != _Last; ++_Dest, (void)++_First) {
        *_Dest = ::std::move(*_First);
    }
    return _Dest;
}
template <class _InIt, class _OutIt>
inline _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest)
{
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{
    if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }
    while (_First != _Last) {
        *--_Dest = ::std::move(*--_Last);
    }
    return _Dest;
}
template <class _BidIt1, class _BidIt2>
inline _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    const auto _UDest = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _Ty>
struct _Is_character : false_type {
};
template <>
struct _Is_character<char> : true_type {
};
template <>
struct _Is_character<signed char> : true_type {
};
template <>
struct _Is_character<unsigned char> : true_type {
};
template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {
};
template <>
struct _Is_character_or_bool<bool> : true_type {
};
template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {
};
template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
template <class _FwdIt, class _Ty>
constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;
template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
constexpr bool _Fill_zero_memset_is_safe = conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
template <class _FwdIt, class _Ty>
constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;
template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count)
{
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    ::memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}
template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count)
{
    ::memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}
template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val)
{
    ;
    if constexpr (is_same_v<_Ty, nullptr_t>) {
        return true;
    } else {
        constexpr _Ty _Zero {};
        return ::memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
    }
}
template <class _FwdIt, class _Ty>
inline void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val)
{
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }
        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}
template <class _OutIt, class _Diff, class _Ty>
inline _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val)
{
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }
            for (; 0 < _Count; --_Count, (void)++_UDest) {
                *_UDest = _Val;
            }
            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}
template <class _Ty1, class _Ty2, class = void>
constexpr bool _Can_compare_with_operator_equal = false;
template <class _Ty1, class _Ty2>
constexpr bool
    _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(::std::declval<_Ty1&>() == ::std::declval<_Ty2&>())>> = true;
template <class _Ty1, class _Ty2>
constexpr bool _Is_pointer_address_comparable = _Can_compare_with_operator_equal<_Ty1*,
                                                    _Ty2*> && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);
#pragma warning(push)
#pragma warning(disable : 4806)
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1>&& is_integral_v<_Elem2>>
constexpr bool _Can_memcmp_elements = is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)
template <class _Ty1, class _Ty2>
constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;
template <class _Elem1, class _Elem2>
constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;
template <class _Elem1, class _Elem2, class _Pr>
constexpr bool _Can_memcmp_elements_with_pred = false;
template <class _Elem1, class _Elem2, class _Elem3>
constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> = _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible&& _Iter_copy_cat<_Elem2*,
    _Elem3*>::_Bitcopy_constructible&& _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;
template <class _Elem1, class _Elem2>
constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> = _Can_memcmp_elements<_Elem1, _Elem2>;
template <class _Iter1, class _Iter2, class _Pr>
constexpr bool _Equal_memcmp_is_safe_helper = _Iterators_are_contiguous<_Iter1, _Iter2> && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2> && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;
template <class _Iter1, class _Iter2, class _Pr>
constexpr bool _Equal_memcmp_is_safe = _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;
template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2)
{
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _Last1_ch = reinterpret_cast<const char*>(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return ::memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}
template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count)
{
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return ::memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred)
{
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }
    for (; _UFirst1 != _ULast1; ++_UFirst1, (void)++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }
    return true;
}
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)
{
    return ::std::equal(_First1, _Last1, _First2, equal_to<> {});
}
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)
{
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }
        return ::std::equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }
            if (_UFirst2 == _ULast2) {
                return false;
            }
            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }
            ++_UFirst1;
            ++_UFirst2;
        }
    }
}
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)
{
    return ::std::equal(_First1, _Last1, _First2, _Last2, equal_to<> {});
}
template <class _Elem1, class _Elem2>
constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
    _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;
template <class _Elem1, class _Elem2, class _Pr>
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};
template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3> && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
            && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        less<int>, void>;
};
template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};
template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3> && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
            && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        greater<int>, void>;
};
template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};
template <class _It1, class _It2, class _Pr>
using _Lex_compare_memcmp_classify = conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
    typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)
{
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
    if constexpr (!is_void_v<_Memcmp_pred>) {
        {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans = _Memcmp_count(_UFirst1, _UFirst2, (::std::min)(_Num1, _Num2));
            return _Memcmp_pred {}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
        }
    }
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void)++_UFirst2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) {
            return true;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }
    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)
{
    return ::std::lexicographical_compare(_First1, _Last1, _First2, _Last2, less<> {});
}
template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _InIt&, const _Ty& _Val)
{
    if constexpr (disjunction_v<
                      is_same<_Ty, bool>, is_pointer<_Ty>, is_null_pointer<_Ty>>) {
        return true;
    } else {
        using _Elem = _Iter_value_t<_InIt>;
        if constexpr (is_same_v<_Elem, bool>) {
            return _Val == true || _Val == false;
        } else if constexpr (is_signed_v<_Elem>) {
            constexpr _Elem _Min = static_cast<_Elem>(_Elem { 1 } << (sizeof(_Elem) * 8 - 1));
            constexpr _Elem _Max = static_cast<_Elem>(~_Min);
            if constexpr (is_signed_v<_Ty>) {
                return _Min <= _Val && _Val <= _Max;
            } else {
                if constexpr (-1 == static_cast<_Ty>(-1)) {
                    return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
                } else {
                    return _Val <= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = static_cast<_Elem>(~_Elem { 0 });
            if constexpr (is_signed_v<_Ty>) {
                return 0 <= _Val && static_cast<make_unsigned_t<_Ty>>(_Val) <= _Max;
            } else {
                return _Val <= _Max;
            }
        }
    }
}
template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
constexpr bool _Vector_alg_in_find_is_safe = _Iterator_is_contiguous<_Iter> && !_Iterator_is_volatile<_Iter> && disjunction_v<conjunction<is_integral<_Ty>, is_integral<_Elem>>, conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>>;
template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val)
{
    if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
        {
            if (!_Within_limits(_First, _Val)) {
                return _Last;
            }
            const auto _First_ptr = _To_address(_First);
            const auto _Result = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
            if constexpr (is_pointer_v<_InIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }
    return _First;
}
template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val)
{
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Find_vbool(_First, _Last, _Val);
    } else {
        _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }
}
template <class _InIt, class _Ty>
[[nodiscard]] inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val)
{
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
            {
                if (!_Within_limits(_UFirst, _Val)) {
                    return 0;
                }
                return static_cast<_Iter_diff_t<_InIt>>(
                    __std_count_trivial(_To_address(_UFirst), _To_address(_ULast), _Val));
            }
        }
        _Iter_diff_t<_InIt> _Count = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }
        return _Count;
    }
}
template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred)
{
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }
    return _First;
}
template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred)
{
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }
    return _Count;
}
enum class _TrimResult : unsigned char { _KeepTrimming,
    _HaveWorkAfterTrimming,
    _ReturnFalse,
    _ReturnTrue };
template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] inline _TrimResult _Trim_equal(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred)
{
    ;
    ;
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    } else {
        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }
    for (;;) {
        if (_First1 == _Back1) {
            return _TrimResult::_ReturnFalse;
        }
        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}
template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] inline _TrimResult _Trim_reversed(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred)
{
    ;
    ;
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    } else {
        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }
    for (;;) {
        if (_First1 == _Back1) {
            return _TrimResult::_ReturnFalse;
        }
        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}
template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] inline _TrimResult _Trim_completely(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred)
{
    _TrimResult _Res = _TrimResult::_KeepTrimming;
    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        } else {
            _Res = _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }
    return _Res;
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
{
    ;
    ;
    if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        do {
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));
        if (_First1 == _Last1) {
            return false;
        }
        const _TrimResult _Res = _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);
        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }
        ++_Last1;
        ++_Last2;
    }
    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) {
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false;
            }
            _FwdIt1 _Skip1 = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false;
            }
        }
    }
    return true;
}
template <class _BidIt>
inline void reverse(const _BidIt _First, const _BidIt _Last)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast = _Get_unwrapped(_Last);
    using _Elem = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx = sizeof(_Elem);
#pragma warning(suppress : 6326)
    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }
            return;
        }
    }
    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        ::std::iter_swap(_UFirst, _ULast);
    }
}
template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
{
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std::iter_swap(_First, --_Last);
        ++_First;
    }
    return pair<_BidIt, _BidIt>(_First, _Last);
}
template <class _FwdIt>
inline _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
{
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _UMid = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }
    if (_UMid == _ULast) {
        return _First;
    }
    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        ::std::reverse(_UFirst, _UMid);
        ::std::reverse(_UMid, _ULast);
        ::std::reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        ::std::reverse(_UFirst, _UMid);
        ::std::reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std::reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do {
            ::std::iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) {
            _UNext = _UMid;
            do {
                ::std::iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }
    return _First;
}
template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std::distance(_UFirst, _Get_unwrapped(_Last));
    while (0 < _Count) {
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid = ::std::next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) {
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{
    return ::std::lower_bound(_First, _Last, _Val, less<> {});
}
template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std::distance(_UFirst, _Get_unwrapped(_Last));
    while (0 < _Count) {
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid = ::std::next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else {
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{
    return ::std::upper_bound(_First, _Last, _Val, less<> {});
}
template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2)
{
    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1> && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {
        {
            __std_swap_ranges_trivially_swappable_noalias(
                _To_address(_First1), _To_address(_Last1), _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
    for (; _First1 != _Last1; ++_First1, (void)++_First2) {
        ::std::iter_swap(_First1, _First2);
    }
    return _First2;
}
template <class _Diff, class _Urng>
class _Rng_from_urng {
public:
    using _Ty0 = make_unsigned_t<_Diff>;
    using _Ty1 = _Invoke_result_t<_Urng&>;
    using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;
    explicit _Rng_from_urng(_Urng& _Func)
        : _Ref(_Func)
        , _Bits(8 * sizeof(_Udiff))
        , _Bmask(_Udiff(-1))
    {
        for (; static_cast<_Udiff>((_Urng::max)() - (_Urng::min)()) < _Bmask; _Bmask >>= 1) {
            --_Bits;
        }
    }
    _Diff operator()(_Diff _Index)
    {
        for (;;) {
            _Udiff _Ret = 0;
            _Udiff _Mask = 0;
            while (_Mask < _Udiff(_Index - 1)) {
                _Ret <<= _Bits - 1;
                _Ret <<= 1;
                _Ret |= _Get_bits();
                _Mask <<= _Bits - 1;
                _Mask <<= 1;
                _Mask |= _Bmask;
            }
            if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {
                return static_cast<_Diff>(_Ret % _Index);
            }
        }
    }
    _Udiff _Get_all_bits()
    {
        _Udiff _Ret = 0;
        for (size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits) {
            _Ret <<= _Bits - 1;
            _Ret <<= 1;
            _Ret |= _Get_bits();
        }
        return _Ret;
    }
    _Rng_from_urng(const _Rng_from_urng&) = delete;
    _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
    _Udiff _Get_bits()
    {
        for (;;) {
            _Udiff _Val = static_cast<_Udiff>(_Ref() - (_Urng::min)());
            if (_Val <= _Bmask) {
                return _Val;
            }
        }
    }
    _Urng& _Ref;
    size_t _Bits;
    _Udiff _Bmask;
};
[[noreturn]] void __cdecl _Xbad_alloc();
[[noreturn]] void __cdecl _Xinvalid_argument(const char*);
[[noreturn]] void __cdecl _Xlength_error(const char*);
[[noreturn]] void __cdecl _Xout_of_range(const char*);
[[noreturn]] void __cdecl _Xoverflow_error(const char*);
[[noreturn]] void __cdecl _Xruntime_error(const char*);
[[noreturn]] void __cdecl _XGetLastError();
template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*, class _Reference = _Ty&>
struct iterator {
    using iterator_category = _Category;
    using value_type = _Ty;
    using difference_type = _Diff;
    using pointer = _Pointer;
    using reference = _Reference;
};
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr auto _Float_abs_bits(const _Ty& _Xx)
{
    using _Traits = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_abs(const _Ty _Xx)
{
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign)
{
    using _Traits = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_nan(const _Ty _Xx)
{
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_signaling_nan(const _Ty& _Xx)
{
    using _Traits = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_inf(const _Ty _Xx)
{
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_finite(const _Ty _Xx)
{
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Ty>
struct [[nodiscard]] _Tidy_guard
{
    _Ty* _Target;
    inline ~_Tidy_guard()
    {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};
template <class _Ty>
struct [[nodiscard]] _Tidy_deallocate_guard
{
    _Ty* _Target;
    inline ~_Tidy_deallocate_guard()
    {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};
template <class _Keycmp, class _Lhs, class _Rhs>
constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(::std::declval<const _Keycmp&>()(::std::declval<const _Lhs&>(), ::std::declval<const _Rhs&>())));
template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count)
{
    constexpr bool _Overflow_is_possible = _Ty_size > 1;
    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length();
        }
    }
    return _Count * _Ty_size;
}
template <class _Ty>
constexpr size_t _New_alignof = (::std::max)(alignof(_Ty), 16ull);
struct _Default_allocate_traits {
    __declspec(allocator) static void* _Allocate(const size_t _Bytes)
    {
        return ::operator new(_Bytes);
    }
};
constexpr bool _Is_pow_2(const size_t _Value) noexcept
{
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}
constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;
;
;
constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;
template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes)
{
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length();
    }
    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do {
        if (_Ptr_container != 0) {
        } else {
            do {
                (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 135, 0, "%s", "invalid argument")) || (__debugbreak(), 0));
                ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 135, 0);
            } while (false);
        };
    } while (false);
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;
    static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
    return _Ptr;
}
inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes)
{
    _Bytes += _Non_user_size;
    const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container = _Ptr_user[-1];
    do {
        if (_Ptr_user[-2] == _Big_allocation_sentinel) {
        } else {
            do {
                (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 154, 0, "%s", "invalid argument")) || (__debugbreak(), 0));
                ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 154, 0);
            } while (false);
        };
    } while (false);
    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do {
        if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) {
        } else {
            do {
                (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 164, 0, "%s", "invalid argument")) || (__debugbreak(), 0));
                ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 164, 0);
            } while (false);
        };
    } while (false);
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!0 || _Align <= 16ull), int> = 0>
__declspec(allocator) inline void* _Allocate(const size_t _Bytes)
{
    {
        if (_Bytes >= _Big_allocation_threshold) {
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
    }
    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }
    return nullptr;
}
template <size_t _Align, enable_if_t<(!0 || _Align <= 16ull), int> = 0>
inline void _Deallocate(void* _Ptr, size_t _Bytes) noexcept
{
    {
        if (_Bytes >= _Big_allocation_threshold) {
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
        ::operator delete(_Ptr, _Bytes);
    }
}
template <class _Ty, class... _Types>
_Ty* _Global_new(_Types&&... _Args)
{
    struct [[nodiscard]] _Guard_type
    {
        void* _Result;
        ~_Guard_type()
        {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };
    _Guard_type _Guard { _Allocate<_New_alignof<_Ty>>(sizeof(_Ty)) };
    ::new (_Guard._Result) _Ty(::std::forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std::exchange(_Guard._Result, nullptr));
}
template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;
template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept
{
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}
template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(_Pointer _Ptr) noexcept
{
    return _Ptr;
}
template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;
template <class _Ty>
inline void _Destroy_in_place(_Ty& _Obj) noexcept
{
    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    } else {
        _Obj.~_Ty();
    }
}
template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept
{
    using _Elem = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;
    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}
template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept
{
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}
template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
__pragma(warning(pop)) template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
__pragma(warning(pop)) template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type = typename pointer_traits<_Ptrty>::template rebind<void>;
};
template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};
template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type = typename pointer_traits<_Ptrty>::template rebind<const void>;
};
template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};
template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type = typename pointer_traits<_Ptrty>::difference_type;
};
template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};
template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};
template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};
template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};
template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};
template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};
template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};
template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};
template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};
template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
__pragma(warning(pop)) template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
__pragma(warning(pop)) template <class _Ty>
class allocator;
template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {
};
template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {
};
template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std::declval<_Alloc&>().construct(::std::declval<_Ptr>(), ::std::declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {
};
__pragma(warning(pop)) template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct = disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;
template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std::declval<_Alloc&>().destroy(::std::declval<_Ptr>()))>>
    : false_type {
};
__pragma(warning(pop)) template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;
template <class _Alloc, class _Ptr>
using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;
template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std::declval<_Alloc&>().allocate(
        ::std::declval<const _Size_type&>(), ::std::declval<const _Const_void_pointer&>()))>> : true_type {
};
__pragma(warning(pop)) template <class _Alloc, class = void>
struct _Has_max_size : false_type {
};
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std::declval<const _Alloc&>().max_size())>> : true_type {
};
__pragma(warning(pop)) template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {
};
template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std::declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {
};
template <class _Alloc>
struct allocator_traits;
__pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc>
struct _Normal_allocator_traits {
    using allocator_type = _Alloc;
    using value_type = typename _Alloc::value_type;
    using pointer = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;
    using size_type = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;
    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;
    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;
    [[nodiscard("This function allocates memory and returns a raw pointer. "
                "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count)
    {
        return _Al.allocate(_Count);
    }
    [[nodiscard("This function allocates memory and returns a raw pointer. "
                "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const const_void_pointer _Hint)
    {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }
    static inline void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count)
    {
        _Al.deallocate(_Ptr, _Count);
    }
    template <class _Ty, class... _Types>
    static inline void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args)
    {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
            ::new (static_cast<void*>(_Ptr)) _Ty(::std::forward<_Types>(_Args)...);
        } else {
            _Al.construct(_Ptr, ::std::forward<_Types>(_Args)...);
        }
    }
    template <class _Ty>
    static inline void destroy(_Alloc& _Al, _Ty* _Ptr)
    {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
            _Ptr->~_Ty();
        } else {
            _Al.destroy(_Ptr);
        }
    }
    [[nodiscard]] static inline size_type max_size(const _Alloc& _Al) noexcept
    {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }
    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al)
    {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
__pragma(warning(pop)) template <class _Alloc>
struct _Default_allocator_traits {
    using allocator_type = _Alloc;
    using value_type = typename _Alloc::value_type;
    using pointer = value_type*;
    using const_pointer = const value_type*;
    using void_pointer = void*;
    using const_void_pointer = const void*;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap = false_type;
    using is_always_equal = true_type;
    template <class _Other>
    using rebind_alloc = allocator<_Other>;
    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;
    [[nodiscard("This function allocates memory and returns a raw pointer. "
                "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count)
    {
        {
            (void)_Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }
    [[nodiscard("This function allocates memory and returns a raw pointer. "
                "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const_void_pointer)
    {
        {
            (void)_Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }
    static inline void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count)
    {
        {
            (void)_Al;
            _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }
    template <class _Objty, class... _Types>
    static inline void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args)
    {
        {
            ::new (_Voidify_iter(_Ptr)) _Objty(::std::forward<_Types>(_Args)...);
        }
    }
    template <class _Uty>
    static inline void destroy(_Alloc&, _Uty* const _Ptr)
    {
        _Ptr->~_Uty();
    }
    [[nodiscard]] static inline size_type max_size(const _Alloc&) noexcept
    {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }
    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al)
    {
        return _Al;
    }
};
template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {
};
template <class _Alloc>
constexpr bool _Choose_pocca_v = allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
    && !allocator_traits<_Alloc>::is_always_equal::value;
enum class _Pocma_values {
    _Equal_allocators,
    _Propagate_allocators,
    _No_propagate_allocators,
};
template <class _Alloc>
constexpr _Pocma_values
    _Choose_pocma_v
    = allocator_traits<_Alloc>::is_always_equal::value
    ? _Pocma_values::_Equal_allocators
    : (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value
            ? _Pocma_values::_Propagate_allocators
            : _Pocma_values::_No_propagate_allocators);
template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;
template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;
template <class _Alloc>
constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>&&
    is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>&&
        is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>&&
            is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;
template <class _Value_type>
struct _Simple_types {
    using value_type = _Value_type;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using pointer = value_type*;
    using const_pointer = const value_type*;
};
constexpr size_t _Asan_granularity = 8;
template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");
    using _From_primary = allocator;
    using value_type = _Ty;
    using pointer = _Ty*;
    using const_pointer = const _Ty*;
    using reference = _Ty&;
    using const_reference = const _Ty&;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal = true_type;
    template <class _Other>
    struct rebind {
        using other = allocator<_Other>;
    };
    [[nodiscard]] _Ty* address(_Ty& _Val) const noexcept
    {
        return ::std::addressof(_Val);
    }
    [[nodiscard]] const _Ty* address(const _Ty& _Val) const noexcept
    {
        return ::std::addressof(_Val);
    }
    constexpr allocator() noexcept { }
    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept { }
    inline ~allocator() = default;
    inline allocator& operator=(const allocator&) = default;
    inline void deallocate(_Ty* const _Ptr, const size_t _Count)
    {
        do {
            if (_Ptr != nullptr || _Count == 0) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 828, 0, "%s", "null pointer cannot point to a block of non-zero size")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"null pointer cannot point to a block of non-zero size\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 828, 0);
                } while (false);
            };
        } while (false);
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }
    [[nodiscard("This function allocates memory and returns a raw pointer. "
                "Discarding the return value will cause a memory leak.")]] inline __declspec(allocator) _Ty* allocate(__declspec(guard(overflow)) const size_t _Count)
    {
        static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }
    [[nodiscard("This function allocates memory and returns a raw pointer. "
                "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Ty* allocate(__declspec(guard(overflow)) const size_t _Count, const void*)
    {
        return allocate(_Count);
    }
    template <class _Objty, class... _Types>
    void construct(_Objty* const _Ptr, _Types&&... _Args)
    {
        ::new (_Voidify_iter(_Ptr)) _Objty(::std::forward<_Types>(_Args)...);
    }
    template <class _Uty>
    void destroy(_Uty* const _Ptr)
    {
        _Ptr->~_Uty();
    }
    [[nodiscard]] size_t max_size() const noexcept
    {
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
    static constexpr size_t _Minimum_allocation_alignment = _Asan_granularity;
};
template <>
class allocator<void> {
public:
    using value_type = void;
    using pointer = void*;
    using const_pointer = const void*;
    template <class _Other>
    struct rebind {
        using other = allocator<_Other>;
    };
};
template <class _Ty, class _Other>
[[nodiscard]] inline bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept
{
    return true;
}
template <class _Ty, class _Other>
[[nodiscard]] bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept
{
    return false;
}
template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;
template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;
template <class _Alloc>
inline void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept
{
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}
template <class _Alloc>
inline void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept
{
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std::move(_Right);
    }
}
template <class _Alloc>
inline void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept
{
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
        do {
            if (_Left == _Right) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 938, 0, "%s", "containers incompatible for swap")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"containers incompatible for swap\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 938, 0);
                } while (false);
            };
        } while (false);
    }
}
template <class _Alloc>
inline void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept
{
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}
template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept
{
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}
template <class _Size_type, class _Unsigned_type>
[[nodiscard]] constexpr _Size_type _Convert_size(const _Unsigned_type _Len) noexcept(
    sizeof(_Unsigned_type) <= sizeof(_Size_type))
{
    ;
    ;
    if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
        if (_Len > (numeric_limits<_Size_type>::max)()) {
            _Xlength_error("size is too long for _Size_type");
        }
    }
    return static_cast<_Size_type>(_Len);
}
template <class _Alloc>
inline void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept
{
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}
template <class _Alloc>
inline void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept
{
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _Deallocate_plain(_Al, _Ptr);
}
template <class _Alloc>
struct _Alloc_construct_ptr {
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;
    inline explicit _Alloc_construct_ptr(_Alloc& _Al_)
        : _Al(_Al_)
        , _Ptr(nullptr)
    {
    }
    [[nodiscard]] inline pointer _Release() noexcept
    {
        return ::std::exchange(_Ptr, nullptr);
    }
    inline void _Allocate()
    {
        _Ptr = nullptr;
        _Ptr = _Al.allocate(1);
    }
    inline ~_Alloc_construct_ptr()
    {
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }
    _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};
struct _Fake_allocator {
};
struct _Container_base0 {
    inline void _Orphan_all() noexcept { }
    inline void _Swap_proxy_and_iterators(_Container_base0&) noexcept { }
    inline void _Alloc_proxy(const _Fake_allocator&) noexcept { }
    inline void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept { }
};
struct _Iterator_base0 {
    inline void _Adopt(const void*) noexcept { }
    inline const _Container_base0* _Getcont() const noexcept
    {
        return nullptr;
    }
    static constexpr bool _Unwrap_when_unverified = true;
};
struct _Container_base12;
struct _Container_proxy {
    inline _Container_proxy() noexcept = default;
    inline _Container_proxy(_Container_base12* _Mycont_) noexcept
        : _Mycont(_Mycont_)
    {
    }
    const _Container_base12* _Mycont = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};
struct _Container_base12 {
public:
    inline _Container_base12() noexcept = default;
    _Container_base12(const _Container_base12&) = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;
    inline void _Orphan_all() noexcept;
    inline void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
    template <class _Alloc>
    inline void _Alloc_proxy(_Alloc&& _Al)
    {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy = _New_proxy;
        _New_proxy->_Mycont = this;
    }
    template <class _Alloc>
    inline void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc)
    {
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std::exchange(_Myproxy, _New_proxy));
    }
    _Container_proxy* _Myproxy = nullptr;

private:
    inline void _Orphan_all_unlocked_v3() noexcept;
    inline void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;
    void _Orphan_all_locked_v3() noexcept
    {
        _Lockit _Lock(3);
        _Orphan_all_unlocked_v3();
    }
    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept
    {
        _Lockit _Lock(3);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};
struct _Iterator_base12 {
public:
    inline _Iterator_base12() noexcept = default;
    inline _Iterator_base12(const _Iterator_base12& _Right) noexcept
    {
        *this = _Right;
    }
    inline _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
    {
        {
            _Assign_locked(_Right);
        }
        return *this;
    }
    inline ~_Iterator_base12() noexcept
    {
        {
            _Orphan_me_locked_v3();
        }
    }
    inline void _Adopt(const _Container_base12* _Parent) noexcept
    {
        {
            _Adopt_locked(_Parent);
        }
    }
    inline const _Container_base12* _Getcont() const noexcept
    {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }
    static constexpr bool _Unwrap_when_unverified = 2 == 0;
    mutable _Container_proxy* _Myproxy = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;

private:
    inline void _Assign_unlocked(const _Iterator_base12& _Right) noexcept
    {
        if (_Myproxy == _Right._Myproxy) {
            return;
        }
        if (_Right._Myproxy) {
            _Adopt_unlocked(_Right._Myproxy->_Mycont);
        } else {
            _Orphan_me_unlocked_v3();
        }
    }
    void _Assign_locked(const _Iterator_base12& _Right) noexcept
    {
        _Lockit _Lock(3);
        _Assign_unlocked(_Right);
    }
    inline void _Adopt_unlocked(const _Container_base12* _Parent) noexcept
    {
        if (!_Parent) {
            _Orphan_me_unlocked_v3();
            return;
        }
        _Container_proxy* _Parent_proxy = _Parent->_Myproxy;
        if (_Myproxy != _Parent_proxy) {
            if (_Myproxy) {
                _Orphan_me_unlocked_v3();
            }
            _Mynextiter = _Parent_proxy->_Myfirstiter;
            _Parent_proxy->_Myfirstiter = this;
            _Myproxy = _Parent_proxy;
        }
    }
    void _Adopt_locked(const _Container_base12* _Parent) noexcept
    {
        _Lockit _Lock(3);
        _Adopt_unlocked(_Parent);
    }
    inline void _Orphan_me_unlocked_v3() noexcept
    {
        if (!_Myproxy) {
            return;
        }
        _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;
        while (*_Pnext && *_Pnext != this) {
            _Pnext = &(*_Pnext)->_Mynextiter;
        }
        do {
            if (*_Pnext) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 1214, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"ITERATOR LIST CORRUPTED!\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xmemory", 1214, 0);
                } while (false);
            };
        } while (false);
        *_Pnext = _Mynextiter;
        _Myproxy = nullptr;
    }
    void _Orphan_me_locked_v3() noexcept
    {
        _Lockit _Lock(3);
        _Orphan_me_unlocked_v3();
    }
};
inline void _Container_base12::_Orphan_all_unlocked_v3() noexcept
{
    if (!_Myproxy) {
        return;
    }
    for (auto _Pnext = ::std::exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {
        _Pnext->_Myproxy = nullptr;
    }
}
inline void _Container_base12::_Orphan_all() noexcept
{
    {
        _Orphan_all_locked_v3();
    }
}
inline void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept
{
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy = _Right._Myproxy;
    _Right._Myproxy = _Temp;
    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }
    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}
inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept
{
    {
        _Swap_proxy_and_iterators_locked(_Right);
    }
}
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
};
struct _Fake_proxy_ptr_impl {
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept { }
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept { }
    inline void _Bind(const _Fake_allocator&, _Container_base0*) noexcept { }
    inline void _Release() noexcept { }
};
struct _Basic_container_proxy_ptr12 {
    _Container_proxy* _Ptr = nullptr;
    constexpr void _Release() noexcept
    {
        _Ptr = nullptr;
    }

protected:
    inline _Basic_container_proxy_ptr12() = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&) = delete;
};
template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    _Alloc& _Al;
    inline _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound)
        : _Al(_Al_)
    {
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }
    inline _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)
        : _Al(_Al_)
    {
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std::addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }
    inline void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept
    {
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std::exchange(_Mycont->_Myproxy, ::std::exchange(_Ptr, nullptr)));
    }
    inline ~_Container_proxy_ptr12()
    {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};
template <class _Alloc>
using _Container_proxy_ptr = _Container_proxy_ptr12<_Rebind_alloc_t<_Alloc, _Container_proxy>>;
struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
};
struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
};
template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 {
public:
    _Ty2 _Myval2;
    using _Mybase = _Ty1;
    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1()
        , _Myval2(::std::forward<_Other2>(_Val2)...)
    {
    }
    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std::forward<_Other1>(_Val1))
        , _Myval2(::std::forward<_Other2>(_Val2)...)
    {
    }
    constexpr _Ty1& _Get_first() noexcept
    {
        return *this;
    }
    constexpr const _Ty1& _Get_first() const noexcept
    {
        return *this;
    }
};
template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final {
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;
    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1()
        , _Myval2(::std::forward<_Other2>(_Val2)...)
    {
    }
    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std::forward<_Other1>(_Val1))
        , _Myval2(::std::forward<_Other2>(_Val2)...)
    {
    }
    constexpr _Ty1& _Get_first() noexcept
    {
        return _Myval1;
    }
    constexpr const _Ty1& _Get_first() const noexcept
    {
        return _Myval1;
    }
};
struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};
template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept
{
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;
            {
                _Pbuf = ::operator new(_Size, nothrow);
            }
            if (_Pbuf) {
                return { static_cast<_Ty*>(_Pbuf), _Count };
            }
        }
    }
    return { nullptr, 0 };
}
template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept
{
    {
        ::operator delete(_Pbuf);
    }
}
template <class _NoThrowFwdIt>
struct [[nodiscard]] _Uninitialized_backout
{
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;
    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest)
        : _First(_Dest)
        , _Last(_Dest)
    {
    }
    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_)
        : _First(_First_)
        , _Last(_Last_)
    {
    }
    _Uninitialized_backout(const _Uninitialized_backout&) = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;
    inline ~_Uninitialized_backout()
    {
        _Destroy_range(_First, _Last);
    }
    template <class... _Types>
    inline void _Emplace_back(_Types && ... _Vals)
    {
        _Construct_in_place(*_Last, ::std::forward<_Types>(_Vals)...);
        ++_Last;
    }
    constexpr _NoThrowFwdIt _Release()
    {
        _First = _Last;
        return _Last;
    }
};
template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest)
{
    if constexpr (_Iter_move_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout { _Dest };
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(::std::move(*_First));
    }
    return _Backout._Release();
}
template <class _Alloc>
class [[nodiscard]] _Uninitialized_backout_al
{
private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    inline _Uninitialized_backout_al(pointer _Dest, _Alloc & _Al_)
        : _First(_Dest)
        , _Last(_Dest)
        , _Al(_Al_)
    {
    }
    _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;
    inline ~_Uninitialized_backout_al()
    {
        _Destroy_range(_First, _Last, _Al);
    }
    template <class... _Types>
    inline void _Emplace_back(_Types && ... _Vals)
    {
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std::forward<_Types>(_Vals)...);
        ++_Last;
    }
    constexpr pointer _Release()
    {
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};
template <class _InIt, class _Se, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al)
{
    using _Ptrval = typename _Alloc::value_type*;
    auto _UFirst = _Get_unwrapped(::std::move(_First));
    auto _ULast = _Get_unwrapped(::std::move(_Last));
    constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
        && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
    if constexpr (_Can_memmove) {
        {
            if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
                _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
                _Dest += _ULast - _UFirst;
            } else {
                const auto _Count = static_cast<size_t>(_ULast - _UFirst);
                _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
                _Dest += _Count;
            }
            return _Dest;
        }
    }
    _Uninitialized_backout_al<_Alloc> _Backout { _Dest, _Al };
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }
    return _Backout._Release();
}
template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
    _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al)
{
    using _Ptrval = typename _Alloc::value_type*;
    auto _UFirst = _Get_unwrapped(::std::move(_First));
    constexpr bool _Can_memmove = conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
        _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
    if constexpr (_Can_memmove) {
        {
            _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
            _Dest += _Count;
            return _Dest;
        }
    }
    _Uninitialized_backout_al<_Alloc> _Backout { _Dest, _Al };
    for (; _Count != 0; ++_UFirst, (void)--_Count) {
        _Backout._Emplace_back(*_UFirst);
    }
    return _Backout._Release();
}
template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest)
{
    if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout { _Dest };
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }
    return _Backout._Release();
}
template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al)
{
    using _Ptrval = typename _Alloc::value_type*;
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std::move(*_UFirst))>>) {
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }
    _Uninitialized_backout_al<_Alloc> _Backout { _Dest, _Al };
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(::std::move(*_UFirst));
    }
    return _Backout._Release();
}
template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al)
{
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }
    _Uninitialized_backout_al<_Alloc> _Backout { _First, _Al };
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }
        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout { _UFirst };
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}
template <class _NoThrowFwdIt>
constexpr bool _Use_memset_value_construct_v = conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>, is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
    negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;
template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last)
{
    char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
    char* const _Last_ch = reinterpret_cast<char*>(_To_address(_Last));
    ::memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}
template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al)
{
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }
    _Uninitialized_backout_al<_Alloc> _Backout { _First, _Al };
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count)
{
    ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout { _UFirst };
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }
        return _Backout._Release();
    }
}
template <class _Ty>
[[nodiscard]] pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept
{
    return _Get_temporary_buffer<_Ty>(_Count);
}
template <class _Ty>
void return_temporary_buffer(_Ty* _Pbuf)
{
    _Return_temporary_buffer(_Pbuf);
}
template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    static constexpr bool _Extractable = false;
};
template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept
    {
        return _Val;
    }
};
template <class _Key, class... _Args>
struct _In_place_key_extract_map {
    static constexpr bool _Extractable = false;
};
template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept
    {
        return _Val;
    }
};
template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val)
    {
        return _Val.first;
    }
};
#pragma warning(push)
#pragma warning(disable : 4624)
template <class _Ty>
struct _Wrap {
    _Ty _Value;
};
#pragma warning(pop)
template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits = allocator_traits<_Alloc>;
    _Alloc& _Al;
    union {
        value_type _Value;
    };
    [[nodiscard]] inline value_type& _Get_value() noexcept
    {
        return _Value;
    }
    [[nodiscard]] inline const value_type& _Get_value() const noexcept
    {
        return _Value;
    }
    template <class... _Args>
    inline explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, ::std::addressof(_Get_value()), ::std::forward<_Args>(_Vals)...)))
        : _Al(_Al_)
    {
        _Traits::construct(_Al, ::std::addressof(_Get_value()), ::std::forward<_Args>(_Vals)...);
    }
    _Alloc_temporary2(const _Alloc_temporary2&) = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;
    inline ~_Alloc_temporary2()
    {
        _Traits::destroy(_Al, ::std::addressof(_Get_value()));
    }
};
template <class _Alloc>
[[nodiscard]] constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept
{
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}
template <class _FwdIt, class _Ty>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element "
            "that should be kept. You need to call container.erase(result, container.end()) afterwards. "
            "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] inline _FwdIt
remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst = _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std::move(*_UFirst);
                ++_UNext;
            }
        }
    }
    _Seek_wrapped(_First, _UNext);
    return _First;
}
template <class _FwdIt, class _Pr>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element "
            "that should be kept. You need to call container.erase(result, container.end()) afterwards. "
            "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] inline _FwdIt
remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred)
{
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst = ::std::find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std::move(*_UFirst);
                ++_UNext;
            }
        }
    }
    _Seek_wrapped(_First, _UNext);
    return _First;
}
template <class _Container, class _Uty>
inline typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val)
{
    auto _First = _Cont.begin();
    const auto _Last = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std::remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}
template <class _Container, class _Pr>
inline typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred)
{
    auto _First = _Cont.begin();
    const auto _Last = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std::remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}
template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred)
{
    auto _First = _Cont.begin();
    const auto _Last = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}
template <class _Ty1, class _Ty2>
void _Deduce_as_pair(const pair<_Ty1, _Ty2>&);
template <class _Ty, class = void>
constexpr bool _Is_deducible_as_pair = false;
template <class _Ty>
constexpr bool _Is_deducible_as_pair<_Ty, decltype(_Deduce_as_pair(::std::declval<_Ty>()))> = true;
template <class _Ty>
const _Ty& _Normally_bind(_Identity_t<const _Ty&>);
template <class _Ty>
_Ty&& _Normally_bind(_Identity_t<_Ty&&>);
template <class _Ty, class _Uty>
using _Normally_bound_ref = decltype(_Normally_bind<_Ty>(::std::declval<_Uty>()));
template <class _Ty, class _Uty, class = void>
constexpr bool _Is_normally_bindable = false;
template <class _Ty, class _Uty>
constexpr bool _Is_normally_bindable<_Ty, _Uty, void_t<_Normally_bound_ref<_Ty, _Uty>>> = true;
template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty {
private:
    using _Mybase = _Ty;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std::forward<_Other>(_Val))
    {
    }
    constexpr _Ty& _Get_val() noexcept
    {
        return *this;
    }
    constexpr const _Ty& _Get_val() const noexcept
    {
        return *this;
    }
};
template <class _Ty>
class _Ebco_base<_Ty, false> {
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std::forward<_Other>(_Val))
    {
    }
    constexpr _Ty& _Get_val() noexcept
    {
        return _Myval;
    }
    constexpr const _Ty& _Get_val() const noexcept
    {
        return _Myval;
    }
};
inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept
{
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off;
    }
    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Elem, class _Int_type>
struct _Char_traits {
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = _Mbstatet;
    static inline _Elem* copy(_Elem* const _First1,
        const _Elem* const _First2, const size_t _Count) noexcept
    {
        ::memcpy(_First1, _First2, _Count * sizeof(_Elem));
        return _First1;
    }
    static inline _Elem* _Copy_s(
        _Elem* const _First1,
        const size_t _Dest_size, const _Elem* const _First2, const size_t _Count) noexcept
    {
        do {
            if (_Count <= _Dest_size) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 74, 0, "%s", "invalid argument")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 74, 0);
                } while (false);
            };
        } while (false);
        return copy(_First1, _First2, _Count);
    }
    static inline _Elem* move(_Elem* const _First1,
        const _Elem* const _First2, const size_t _Count) noexcept
    {
        ::memmove(_First1, _First2, _Count * sizeof(_Elem));
        return _First1;
    }
    [[nodiscard]] static inline int compare(const _Elem* _First1,
        const _Elem* _First2, size_t _Count) noexcept
    {
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }
        return 0;
    }
    [[nodiscard]] static inline size_t length(const _Elem* _First) noexcept
    {
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }
        return _Count;
    }
    [[nodiscard]] static inline const _Elem* find(
        const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept
    {
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }
        return nullptr;
    }
    static inline _Elem* assign(
        _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept
    {
        {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                *_Next = _Ch;
            }
        }
        return _First;
    }
    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
    {
        {
            _Left = _Right;
        }
    }
    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
    {
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
    {
        return _Left < _Right;
    }
    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
    {
        return static_cast<_Elem>(_Meta);
    }
    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
    {
        return static_cast<int_type>(_Ch);
    }
    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
    {
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept
    {
        return _Meta != eof() ? _Meta : !eof();
    }
    [[nodiscard]] static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>((-1));
    }
};
template <class _Elem>
struct _WChar_traits : private _Char_traits<_Elem, unsigned short> {
private:
    using _Primary_char_traits = _Char_traits<_Elem, unsigned short>;

public:
    using char_type = _Elem;
    using int_type = unsigned short;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;
    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;
    [[nodiscard]] static inline int compare(const _Elem* const _First1,
        const _Elem* const _First2, const size_t _Count) noexcept
    {
        return ::wmemcmp(
            reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
    }
    [[nodiscard]] static inline size_t length(const _Elem* _First) noexcept
    {
        return ::wcslen(reinterpret_cast<const wchar_t*>(_First));
    }
    [[nodiscard]] static inline const _Elem* find(
        const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept
    {
        return reinterpret_cast<const _Elem*>(::wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));
    }
    static inline _Elem* assign(
        _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept
    {
        return reinterpret_cast<_Elem*>(::wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }
    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
    {
        _Left = _Right;
    }
    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
    {
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
    {
        return _Left < _Right;
    }
    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
    {
        return _Meta;
    }
    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
    {
        return _Ch;
    }
    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
    {
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept
    {
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }
    [[nodiscard]] static constexpr int_type eof() noexcept
    {
        return ((wint_t)(0xFFFF));
    }
};
template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {
};
template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {
};
template <>
struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {
};
template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {
};
template <class _Elem, class _Int_type>
struct _Narrow_char_traits : private _Char_traits<_Elem, _Int_type> {
private:
    using _Primary_char_traits = _Char_traits<_Elem, _Int_type>;

public:
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;
    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;
    [[nodiscard]] static inline int compare(const _Elem* const _First1,
        const _Elem* const _First2, const size_t _Count) noexcept
    {
        return ::memcmp(_First1, _First2, _Count);
    }
    [[nodiscard]] static inline size_t length(const _Elem* const _First) noexcept
    {
        return ::strlen(reinterpret_cast<const char*>(_First));
    }
    [[nodiscard]] static inline const _Elem* find(const _Elem* const _First, const size_t _Count,
        const _Elem& _Ch) noexcept
    {
        return static_cast<const _Elem*>(::memchr(_First, _Ch, _Count));
    }
    static inline _Elem* assign(
        _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept
    {
        return static_cast<_Elem*>(::memset(_First, _Ch, _Count));
    }
    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
    {
        _Left = _Right;
    }
    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
    {
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
    {
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }
    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
    {
        return static_cast<_Elem>(_Meta);
    }
    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
    {
        return static_cast<unsigned char>(_Ch);
    }
    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
    {
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept
    {
        return _Meta != eof() ? _Meta : !eof();
    }
    [[nodiscard]] static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>((-1));
    }
};
template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {
};
template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size)
{
    using _Ostr_t = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    } else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }
    const typename _Ostr_t::sentry _Ok(_Ostr);
    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else {
        try {
            if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
                for (; 0 < _Pad; --_Pad) {
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= _Ostr_t::badbit;
                        break;
                    }
                }
            }
            if (_State == _Ostr_t::goodbit
                && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
                _State |= _Ostr_t::badbit;
            } else {
                for (; 0 < _Pad; --_Pad) {
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= _Ostr_t::badbit;
                        break;
                    }
                }
            }
            _Ostr.width(0);
        } catch (...) {
            (_Ostr).setstate(_Ostr_t::badbit, true);
        }
    }
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Traits>
struct _Char_traits_eq {
    using _Elem = typename _Traits::char_type;
    bool operator()(_Elem _Left, _Elem _Right) const noexcept
    {
        return _Traits::eq(_Left, _Right);
    }
};
template <class _Traits>
struct _Char_traits_lt {
    using _Elem = typename _Traits::char_type;
    bool operator()(_Elem _Left, _Elem _Right) const noexcept
    {
        return _Traits::lt(_Left, _Right);
    }
};
template <class _Elem>
constexpr bool _Can_memcmp_elements_with_pred<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>> = _Can_memcmp_elements<_Elem, _Elem>;
template <class _Elem>
struct _Lex_compare_memcmp_classify_pred<_Elem, _Elem, _Char_traits_lt<char_traits<_Elem>>> {
    using _UElem = make_unsigned_t<_Elem>;
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_UElem, _UElem>, less<int>, void>;
};
template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;
template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;
template <class _Traits>
constexpr bool _Traits_equal(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
    const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
{
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}
template <class _Traits>
constexpr int _Traits_compare(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
    const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
{
    const int _Ans = _Traits::compare(_Left, _Right, (::std::min)(_Left_size, _Right_size));
    if (_Ans != 0) {
        return _Ans;
    }
    if (_Left_size < _Right_size) {
        return -1;
    }
    if (_Left_size > _Right_size) {
        return 1;
    }
    return 0;
}
template <class _Traits>
constexpr size_t _Traits_find(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept
{
    if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
        return static_cast<size_t>(-1);
    }
    if (_Needle_size == 0) {
        return _Start_at;
    }
    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) {
            return static_cast<size_t>(-1);
        }
        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}
template <class _Traits>
constexpr size_t _Traits_find_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept
{
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits>
constexpr size_t _Traits_rfind(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept
{
    if (_Needle_size == 0) {
        return (::std::min)(_Start_at, _Hay_size);
    }
    if (_Needle_size <= _Hay_size) {
        for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack);
            }
            if (_Match_try == _Haystack) {
                break;
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits>
constexpr size_t _Traits_rfind_ch(const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept
{
    if (_Hay_size != 0) {
        for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack);
            }
            if (_Match_try == _Haystack) {
                break;
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap {
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept
    {
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }
        return true;
    }
    constexpr bool _Match(const _Elem _Ch) const noexcept
    {
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};
template <class _Elem>
class _String_bitmap<_Elem, false> {
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept
    {
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }
            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }
        return true;
    }
    constexpr bool _Match(const _Elem _Ch) const noexcept
    {
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};
template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept
{
    if (_Needle_size != 0 && _Start_at < _Hay_size) {
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return _Traits_find_first_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        } else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept
{
    if (_Needle_size != 0 && _Hay_size != 0) {
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return _Traits_find_last_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }
            for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        } else {
            for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept
{
    if (_Start_at < _Hay_size) {
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return _Traits_find_first_not_of<_Traits, false>(
                    _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        } else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits>
constexpr size_t _Traits_find_not_ch(const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept
{
    if (_Start_at < _Hay_size) {
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack);
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept
{
    if (_Hay_size != 0) {
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) {
                return _Traits_find_last_not_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }
            for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        } else {
            for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
                if (_Match_try == _Haystack) {
                    break;
                }
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept
{
    if (_Hay_size != 0) {
        for (auto _Match_try = _Haystack + (::std::min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack);
            }
            if (_Match_try == _Haystack) {
                break;
            }
        }
    }
    return static_cast<size_t>(-1);
}
template <class _Ty>
constexpr bool _Is_EcharT = _Is_any_of_v<_Ty, char, wchar_t,
    char16_t, char32_t>;
template <class _Mystr>
class _String_const_iterator : public _Iterator_base {
public:
    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer = typename _Mystr::const_pointer;
    using reference = const value_type&;
    inline _String_const_iterator() noexcept
        : _Ptr()
    {
    }
    inline _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept
        : _Ptr(_Parg)
    {
        this->_Adopt(_Pstring);
    }
    [[nodiscard]] inline reference operator*() const noexcept
    {
        do {
            if (_Ptr) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1915, 0, "%s", "cannot dereference value-initialized string iterator")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot dereference value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1915, 0);
                } while (false);
            };
        } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do {
            if (_Mycont) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1918, 0, "%s", "cannot dereference string iterator because the iterator was"
                                                                                                                                                                                " invalidated (e.g. reallocation occurred, or the string was destroyed)"))
                        || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot dereference string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1918, 0);
                } while (false);
            };
        } while (false);
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr = _Unfancy(_Ptr);
        do {
            if (_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1922, 0, "%s", "cannot dereference string iterator because it is out of range (e.g. an end iterator)")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot dereference string iterator because it is out of range (e.g. an end iterator)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1922, 0);
                } while (false);
            };
        } while (false);
        ;
        return *_Ptr;
    }
    [[nodiscard]] inline pointer operator->() const noexcept
    {
        return pointer_traits<pointer>::pointer_to(**this);
    }
    inline _String_const_iterator& operator++() noexcept
    {
        do {
            if (_Ptr) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1935, 0, "%s", "cannot increment value-initialized string iterator")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot increment value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1935, 0);
                } while (false);
            };
        } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do {
            if (_Mycont) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1938, 0, "%s", "cannot increment string iterator because the iterator was"
                                                                                                                                                                                " invalidated (e.g. reallocation occurred, or the string was destroyed)"))
                        || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot increment string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1938, 0);
                } while (false);
            };
        } while (false);
        do {
            if (_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1939, 0, "%s", "cannot increment string iterator past end")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot increment string iterator past end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1939, 0);
                } while (false);
            };
        } while (false);
        ++_Ptr;
        return *this;
    }
    inline _String_const_iterator operator++(int) noexcept
    {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    inline _String_const_iterator& operator--() noexcept
    {
        do {
            if (_Ptr) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1954, 0, "%s", "cannot decrement value-initialized string iterator")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot decrement value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1954, 0);
                } while (false);
            };
        } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do {
            if (_Mycont) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1957, 0, "%s", "cannot decrement string iterator because the iterator was"
                                                                                                                                                                                " invalidated (e.g. reallocation occurred, or the string was destroyed)"))
                        || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot decrement string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1957, 0);
                } while (false);
            };
        } while (false);
        do {
            if (_Mycont->_Myptr() < _Unfancy(_Ptr)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1958, 0, "%s", "cannot decrement string iterator before begin")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot decrement string iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1958, 0);
                } while (false);
            };
        } while (false);
        --_Ptr;
        return *this;
    }
    inline _String_const_iterator operator--(int) noexcept
    {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    inline void _Verify_offset(const difference_type _Off) const noexcept
    {
        if (_Off == 0) {
            return;
        }
        do {
            if (_Ptr) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1977, 0, "%s", "cannot seek value-initialized string iterator")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot seek value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1977, 0);
                } while (false);
            };
        } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do {
            if (_Mycont) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1980, 0, "%s", "cannot seek string iterator because the iterator was"
                                                                                                                                                                                " invalidated (e.g. reallocation occurred, or the string was destroyed)"))
                        || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"cannot seek string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1980, 0);
                } while (false);
            };
        } while (false);
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr = _Unfancy(_Ptr);
        if (_Off < 0) {
            do {
                if (_Contptr - _Rawptr <= _Off) {
                } else {
                    do {
                        (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1985, 0, "%s", "cannot seek string iterator before begin")) || (__debugbreak(), 0));
                        ::_invalid_parameter(L"\"cannot seek string iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1985, 0);
                    } while (false);
                };
            } while (false);
        }
        if (_Off > 0) {
            using _Size_type = typename _Mystr::size_type;
            const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
            do {
                if (static_cast<_Size_type>(_Off) <= _Left) {
                } else {
                    do {
                        (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1991, 0, "%s", "cannot seek string iterator after end")) || (__debugbreak(), 0));
                        ::_invalid_parameter(L"\"cannot seek string iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 1991, 0);
                    } while (false);
                };
            } while (false);
        }
    }
    inline _String_const_iterator& operator+=(const difference_type _Off) noexcept
    {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }
    [[nodiscard]] inline _String_const_iterator operator+(const difference_type _Off) const noexcept
    {
        _String_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }
    [[nodiscard]] friend inline _String_const_iterator operator+(
        const difference_type _Off, _String_const_iterator _Next) noexcept
    {
        _Next += _Off;
        return _Next;
    }
    inline _String_const_iterator& operator-=(const difference_type _Off) noexcept
    {
        return *this += -_Off;
    }
    [[nodiscard]] inline _String_const_iterator operator-(const difference_type _Off) const noexcept
    {
        _String_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] inline difference_type operator-(const _String_const_iterator& _Right) const noexcept
    {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }
    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept
    {
        return *(*this + _Off);
    }
    [[nodiscard]] inline bool operator==(const _String_const_iterator& _Right) const noexcept
    {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }
    [[nodiscard]] bool operator!=(const _String_const_iterator& _Right) const noexcept
    {
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const _String_const_iterator& _Right) const noexcept
    {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }
    [[nodiscard]] bool operator>(const _String_const_iterator& _Right) const noexcept
    {
        return _Right < *this;
    }
    [[nodiscard]] bool operator<=(const _String_const_iterator& _Right) const noexcept
    {
        return !(_Right < *this);
    }
    [[nodiscard]] bool operator>=(const _String_const_iterator& _Right) const noexcept
    {
        return !(*this < _Right);
    }
    inline void _Compat(const _String_const_iterator& _Right) const noexcept
    {
        do {
            if (this->_Getcont() == _Right._Getcont()) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 2074, 0, "%s", "string iterators incompatible (e.g."
                                                                                                                                                                                " point to different string instances)"))
                        || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible (e.g.\" \" point to different string instances)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 2074, 0);
                } while (false);
            };
        } while (false);
    }
    friend inline void _Verify_range(
        const _String_const_iterator& _First, const _String_const_iterator& _Last) noexcept
    {
        do {
            if (_First._Getcont() == _Last._Getcont()) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 2083, 0, "%s", "string iterators in range are from different containers")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators in range are from different containers\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 2083, 0);
                } while (false);
            };
        } while (false);
        do {
            if (_First._Ptr <= _Last._Ptr) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 2084, 0, "%s", "string iterator range transposed")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterator range transposed\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 2084, 0);
                } while (false);
            };
        } while (false);
    }
    using _Prevent_inheriting_unwrap = _String_const_iterator;
    [[nodiscard]] inline const value_type* _Unwrapped() const noexcept
    {
        return _Unfancy(_Ptr);
    }
    inline void _Seek_to(const value_type* _It) noexcept
    {
        _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
    }
    pointer _Ptr;
};
template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> {
public:
    using _Mybase = _String_const_iterator<_Mystr>;
    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer = typename _Mystr::pointer;
    using reference = value_type&;
    using _Mybase::_Mybase;
    [[nodiscard]] inline reference operator*() const noexcept
    {
        return const_cast<reference>(_Mybase::operator*());
    }
    [[nodiscard]] inline pointer operator->() const noexcept
    {
        return pointer_traits<pointer>::pointer_to(**this);
    }
    inline _String_iterator& operator++() noexcept
    {
        _Mybase::operator++();
        return *this;
    }
    inline _String_iterator operator++(int) noexcept
    {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }
    inline _String_iterator& operator--() noexcept
    {
        _Mybase::operator--();
        return *this;
    }
    inline _String_iterator operator--(int) noexcept
    {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }
    inline _String_iterator& operator+=(const difference_type _Off) noexcept
    {
        _Mybase::operator+=(_Off);
        return *this;
    }
    [[nodiscard]] inline _String_iterator operator+(const difference_type _Off) const noexcept
    {
        _String_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }
    [[nodiscard]] friend inline _String_iterator operator+(
        const difference_type _Off, _String_iterator _Next) noexcept
    {
        _Next += _Off;
        return _Next;
    }
    inline _String_iterator& operator-=(const difference_type _Off) noexcept
    {
        _Mybase::operator-=(_Off);
        return *this;
    }
    using _Mybase::operator-;
    [[nodiscard]] inline _String_iterator operator-(const difference_type _Off) const noexcept
    {
        _String_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept
    {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }
    using _Prevent_inheriting_unwrap = _String_iterator;
    [[nodiscard]] inline value_type* _Unwrapped() const noexcept
    {
        return const_cast<value_type*>(_Unfancy(this->_Ptr));
    }
};
template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _String_iter_types {
    using value_type = _Value_type;
    using size_type = _Size_type;
    using difference_type = _Difference_type;
    using pointer = _Pointer;
    using const_pointer = _Const_pointer;
};
template <class _Val_types>
class _String_val : public _Container_base {
public:
    using value_type = typename _Val_types::value_type;
    using size_type = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer = typename _Val_types::pointer;
    using const_pointer = typename _Val_types::const_pointer;
    using reference = value_type&;
    using const_reference = const value_type&;
    inline _String_val() noexcept
        : _Bx()
    {
    }
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
                                                                     : sizeof(value_type) <= 2 ? 7
                                                                                               : sizeof(value_type) <= 4 ? 3
                                                                                                                         : sizeof(value_type) <= 8 ? 1
                                                                                                                                                   : 0;
    inline value_type* _Myptr() noexcept
    {
        value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }
        return _Result;
    }
    inline const value_type* _Myptr() const noexcept
    {
        const value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }
        return _Result;
    }
    inline bool _Large_string_engaged() const noexcept
    {
        return _BUF_SIZE <= _Myres;
    }
    constexpr void _Activate_SSO_buffer() noexcept
    {
    }
    inline void _Check_offset(const size_type _Off) const
    {
        if (_Mysize < _Off) {
            _Xran();
        }
    }
    inline void _Check_offset_exclusive(const size_type _Off) const
    {
        if (_Mysize <= _Off) {
            _Xran();
        }
    }
    [[noreturn]] static void _Xran()
    {
        _Xout_of_range("invalid string position");
    }
    inline size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
    {
        return (::std::min)(_Size, _Mysize - _Off);
    }
    union _Bxty {
        inline _Bxty() noexcept
            : _Buf()
        {
        }
        inline ~_Bxty() noexcept { }
        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE];
    } _Bx;
    size_type _Mysize = 0;
    size_type _Myres = 0;
};
template <class _Ty>
constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);
struct _String_constructor_concat_tag {
    explicit _String_constructor_concat_tag() = default;
};
struct _String_constructor_rvalue_allocator_tag {
    explicit _String_constructor_rvalue_allocator_tag() = default;
};
[[noreturn]] inline void _Xlen_string()
{
    _Xlength_error("string too long");
}
#pragma detect_mismatch("annotate_string", "0")
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string {
private:
    friend _Tidy_deallocate_guard<basic_string>;
    friend basic_stringbuf<_Elem, _Traits, _Alloc>;
    using _Alty = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;
    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
    static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>"
        " requires that Allocator's value_type match "
        "T"
        " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)"
        " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0"
        " to suppress this error.");
    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4910 23.4.3.2 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");
    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4910 "
        "23.1 [strings.general]/1.");

public:
    using traits_type = _Traits;
    using allocator_type = _Alloc;
    using value_type = _Elem;
    using size_type = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer = typename _Alty_traits::pointer;
    using const_pointer = typename _Alty_traits::const_pointer;
    using reference = value_type&;
    using const_reference = const value_type&;
    using iterator = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;
    using reverse_iterator = ::std::reverse_iterator<iterator>;
    using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;

private:
    static constexpr auto _BUF_SIZE = _Scary_val::_BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size = sizeof(_Scary_val) - _Memcpy_val_offset;
    template <class _Iter>
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;

public:
    inline basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t {})
    {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }
    inline explicit basic_string(const _Alloc& _Al) noexcept
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }
    inline basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t {}, _Alty_traits::select_on_container_copy_construction(_Right._Getal()))
    {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    inline basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    inline basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, npos));
    }
    inline basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }
    inline basic_string(const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t {})
    {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }
    inline basic_string(
        const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }
    inline basic_string(const _Elem* const _Ptr)
        : _Mypair(_Zero_then_variadic_args_t {})
    {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    inline basic_string(const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    inline basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t {})
    {
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }
    inline basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast = _Get_unwrapped(_Last);
        if (_UFirst == _ULast) {
            _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
            _Tidy_init();
        } else {
            if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
                _Construct<_Construct_strategy::_From_ptr>(
                    _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
                const auto _Length = static_cast<size_t>(::std::distance(_UFirst, _ULast));
                const auto _Count = _Convert_size<size_type>(_Length);
                _Construct_from_iter(::std::move(_UFirst), ::std::move(_ULast), _Count);
            } else {
                _Construct_from_iter(::std::move(_UFirst), ::std::move(_ULast));
            }
        }
    }

private:
    enum class _Construct_strategy : uint8_t { _From_char,
        _From_ptr,
        _From_string };
    template <_Construct_strategy _Strat, class _Char_or_ptr>
    inline void _Construct(const _Char_or_ptr _Arg, __declspec(guard(overflow)) const size_type _Count)
    {
        auto& _My_data = _Mypair._Myval2;
        ;
        ;
        if constexpr (_Strat == _Construct_strategy::_From_char) {
            ;
        } else {
            ;
        }
        if (_Count > max_size()) {
            _Xlen_string();
        }
        auto& _Al = _Getal();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Count < _BUF_SIZE) {
            _My_data._Mysize = _Count;
            _My_data._Myres = _BUF_SIZE - 1;
            if constexpr (_Strat == _Construct_strategy::_From_char) {
                _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
            } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
                _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
            } else {
                _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
            };
            _Proxy._Release();
            return;
        }
        _My_data._Myres = _BUF_SIZE - 1;
        const size_type _New_capacity = _Calculate_growth(_Count);
        const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        _My_data._Mysize = _Count;
        _My_data._Myres = _New_capacity;
        if constexpr (_Strat == _Construct_strategy::_From_char) {
            _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        } else {
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
        };
        _Proxy._Release();
    }
    template <class _Iter, class _Sent, class _Size = nullptr_t>
    inline void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {})
    {
        auto& _My_data = _Mypair._Myval2;
        auto& _Al = _Getal();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        _My_data._Mysize = 0;
        _My_data._Myres = _BUF_SIZE - 1;
        if constexpr (is_same_v<_Size, size_type>) {
            if (_Count > max_size()) {
                _Xlen_string();
            }
            if (_Count >= _BUF_SIZE) {
                const size_type _New_capacity = _Calculate_growth(_Count);
                const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
                _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                _My_data._Myres = _New_capacity;
            }
        }
        _Tidy_deallocate_guard<basic_string> _Guard { this };
        for (; _First != _Last; ++_First) {
            if constexpr (!is_same_v<_Size, size_type>) {
                if (_My_data._Mysize == _My_data._Myres) {
                    if (_My_data._Mysize == max_size()) {
                        _Xlen_string();
                    }
                    const auto _Old_ptr = _My_data._Myptr();
                    const size_type _New_capacity = _Calculate_growth(_My_data._Mysize);
                    const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
                    _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
                    if (_My_data._Myres >= _BUF_SIZE) {
                        _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
                        _My_data._Bx._Ptr = _New_ptr;
                    } else {
                        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                    }
                    _My_data._Myres = _New_capacity;
                }
            }
            _Elem* const _Ptr = _My_data._Myptr();
            _Traits::assign(_Ptr[_My_data._Mysize], *_First);
            ++_My_data._Mysize;
        }
        _Elem* const _Ptr = _My_data._Myptr();
        _Traits::assign(_Ptr[_My_data._Mysize], _Elem());
        ;
        _Guard._Target = nullptr;
        _Proxy._Release();
    }

public:
    inline basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t {}, ::std::move(_Right._Getal()))
    {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Take_contents(_Right);
    }
    inline basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value)
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Construct<_Construct_strategy::_From_string>(
                    _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return;
            }
        }
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Take_contents(_Right);
    }
    inline basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
        const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
        const size_type _Right_size)
        : _Mypair(
            _One_then_variadic_args_t {}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal()))
    {
        ;
        ;
        ;
        const auto _New_size = static_cast<size_type>(_Left_size + _Right_size);
        size_type _New_capacity = _BUF_SIZE - 1;
        auto& _My_data = _Mypair._Myval2;
        _Elem* _Ptr = _My_data._Bx._Buf;
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_New_capacity < _New_size) {
            _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());
            const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1);
            _Ptr = _Unfancy(_Fancyptr);
            _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        }
        _My_data._Mysize = _New_size;
        _My_data._Myres = _New_capacity;
        _Traits::copy(_Ptr, _Left_ptr, _Left_size);
        _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
        _Traits::assign(_Ptr[_New_size], _Elem());
        ;
        _Proxy._Release();
    }
    inline basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t {}, _Left._Getal())
    {
        auto& _My_data = _Mypair._Myval2;
        auto& _Left_data = _Left._Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Left_data._Orphan_all();
        _Right_data._Orphan_all();
        const auto _Left_size = _Left_data._Mysize;
        const auto _Right_size = _Right_data._Mysize;
        const auto _Left_capacity = _Left_data._Myres;
        const auto _Right_capacity = _Right_data._Myres;
        const auto _New_size = static_cast<size_type>(_Left_size + _Right_size);
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
            _My_data._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
            _Take_contents(_Left);
            const auto _Ptr = _My_data._Myptr();
            ;
            _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
            _My_data._Mysize = _New_size;
            return;
        }
        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
            ;
            _My_data._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
            _Take_contents(_Right);
            const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
            ;
            _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
            _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
            _My_data._Mysize = _New_size;
            return;
        }
        const auto _Max = max_size();
        if (_Max - _Left_size < _Right_size) {
            _Xlen_string();
        }
        const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1);
        _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        _My_data._Mysize = _New_size;
        _My_data._Myres = _New_capacity;
        const auto _Ptr = _Unfancy(_Fancyptr);
        _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
        _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
        ;
        _Proxy._Release();
    }
    inline basic_string& operator=(basic_string&& _Right) noexcept(
        _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators)
    {
        if (this == ::std::addressof(_Right)) {
            return *this;
        }
        auto& _Al = _Getal();
        auto& _Right_al = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                _Mypair._Myval2._Orphan_all();
                _Mypair._Myval2._Reload_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right_al));
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return *this;
            }
        }
        _Tidy_deallocate();
        _Pocma(_Al, _Right_al);
        _Take_contents(_Right);
        return *this;
    }
    inline basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std::move(_Right)))
    {
        *this = ::std::move(_Right);
        return *this;
    }

private:
    void _Memcpy_val_from(const basic_string& _Right) noexcept
    {
        ;
        const auto _My_data_mem = reinterpret_cast<unsigned char*>(::std::addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem = reinterpret_cast<const unsigned char*>(::std::addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        ::memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    }
    inline void _Take_contents(basic_string& _Right) noexcept
    {
        auto& _My_data = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        if constexpr (_Can_memcpy_val) {
            {
                if (_Right_data._Large_string_engaged()) {
                    _Swap_proxy_and_iterators(_Right);
                } else {
                    _Right_data._Orphan_all();
                }
                _Memcpy_val_from(_Right);
                _Right._Tidy_init();
                return;
            }
        }
        if (_Right_data._Large_string_engaged()) {
            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = nullptr;
            _Swap_proxy_and_iterators(_Right);
        } else {
            _My_data._Activate_SSO_buffer();
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right_data._Orphan_all();
        }
        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres = _Right_data._Myres;
        _Right._Tidy_init();
    }

public:
    inline basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t {}, _Al)
    {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }
    inline basic_string& operator=(initializer_list<_Elem> _Ilist)
    {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    inline basic_string& operator+=(initializer_list<_Elem> _Ilist)
    {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    inline basic_string& assign(initializer_list<_Elem> _Ilist)
    {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    inline basic_string& append(initializer_list<_Elem> _Ilist)
    {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    inline iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist)
    {
        do {
            if (_Where._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3248, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3248, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist)
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3260, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3260, 0);
                } while (false);
            };
        } while (false);
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    inline ~basic_string() noexcept
    {
        _Tidy_deallocate();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        const auto _To_delete = _Mypair._Myval2._Myproxy;
        _Mypair._Myval2._Myproxy = nullptr;
        _Delete_plain_internal(_Alproxy, _To_delete);
    }
    static constexpr auto npos { static_cast<size_type>(-1) };

private:
    inline void _Copy_assign_val_from_small(const basic_string& _Right)
    {
        _Tidy_deallocate();
        if constexpr (_Can_memcpy_val) {
            {
                _Memcpy_val_from(_Right);
                return;
            }
        }
        auto& _My_data = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres = _Right_data._Myres;
    }

public:
    inline basic_string& operator=(const basic_string& _Right)
    {
        if (this == ::std::addressof(_Right)) {
            return *this;
        }
        auto& _Al = _Getal();
        const auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alty>) {
            if (_Al != _Right_al) {
                auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
                auto&& _Right_alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right_al);
                _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound {});
                if (_Right._Mypair._Myval2._Large_string_engaged()) {
                    const auto _New_size = _Right._Mypair._Myval2._Mysize;
                    const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
                    auto _Right_al_non_const = _Right_al;
                    const auto _New_ptr = _Right_al_non_const.allocate(_New_capacity + 1);
                    _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
                    _Tidy_deallocate();
                    _Mypair._Myval2._Bx._Ptr = _New_ptr;
                    _Mypair._Myval2._Mysize = _New_size;
                    _Mypair._Myval2._Myres = _New_capacity;
                } else {
                    _Copy_assign_val_from_small(_Right);
                }
                _Pocca(_Al, _Right_al);
                _New_proxy._Bind(_Alproxy, ::std::addressof(_Mypair._Myval2));
                return *this;
            }
        }
        _Pocca(_Al, _Right_al);
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        return *this;
    }
    inline basic_string& operator=(const _Elem* const _Ptr)
    {
        return assign(_Ptr);
    }
    inline basic_string& operator=(const _Elem _Ch)
    {
        ;
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }
    inline basic_string& operator+=(const basic_string& _Right)
    {
        return append(_Right);
    }
    inline basic_string& operator+=(const _Elem* const _Ptr)
    {
        return append(_Ptr);
    }
    inline basic_string& operator+=(_Elem _Ch)
    {
        push_back(_Ch);
        return *this;
    }
    inline basic_string& append(const basic_string& _Right)
    {
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    inline basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
    {
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
    inline basic_string& append(
        const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count)
    {
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }
        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }
    inline basic_string& append(const _Elem* const _Ptr)
    {
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    inline basic_string& append(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
    {
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }
        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& append(const _Iter _First, const _Iter _Last)
    {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }
    inline basic_string& assign(const basic_string& _Right)
    {
        *this = _Right;
        return *this;
    }
    inline basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
    {
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
    inline basic_string& assign(
        const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count)
    {
        if (_Count <= _Mypair._Myval2._Myres) {
            ;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }
        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }
    inline basic_string& assign(const _Elem* const _Ptr)
    {
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    inline basic_string& assign(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
    {
        if (_Count <= _Mypair._Myval2._Myres) {
            ;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }
        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& assign(const _Iter _First, const _Iter _Last)
    {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }
    inline basic_string& insert(const size_type _Off, const basic_string& _Right)
    {
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    inline basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
    {
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
    inline basic_string& insert(
        const size_type _Off, const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count)
    {
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
        if (_Check_overlap) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                _Ptr_shifted_after = _Count;
            } else if (_Insert_at <= _Ptr) {
                _Ptr_shifted_after = 0;
            } else {
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1);
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }
        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }
    inline basic_string& insert(const size_type _Off, const _Elem* const _Ptr)
    {
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    inline basic_string& insert(
        const size_type _Off, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
    {
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }
        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }
    inline iterator insert(const const_iterator _Where, const _Elem _Ch)
    {
        do {
            if (_Where._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3719, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3719, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }
    inline iterator insert(
        const const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
    {
        do {
            if (_Where._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3730, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3730, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last)
    {
        do {
            if (_Where._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3741, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3741, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
        return begin() + static_cast<difference_type>(_Off);
    }
    inline basic_string& erase(const size_type _Off = 0)
    {
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

private:
    inline basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept
    {
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1);
        ;
        _Mypair._Myval2._Mysize = _New_size;
        return *this;
    }

public:
    inline basic_string& erase(const size_type _Off, const size_type _Count)
    {
        _Mypair._Myval2._Check_offset(_Off);
        return _Erase_noexcept(_Off, _Count);
    }
    inline iterator erase(const const_iterator _Where) noexcept
    {
        do {
            if (_Where._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3805, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3805, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }
    inline iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3816, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3816, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }
    inline void clear() noexcept
    {
        _Eos(0);
    }
    inline basic_string& replace(const size_type _Off, const size_type _Nx, const basic_string& _Right)
    {
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    inline basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
        const size_type _Roff, size_type _Count = npos)
    {
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
    inline basic_string& replace(
        const size_type _Off, size_type _Nx, const _Elem* const _Ptr, const size_type _Count)
    {
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Nx == _Count) {
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if (_Count < _Nx) {
            _Mypair._Myval2._Mysize = _Old_size - (_Nx - _Count);
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);
            return *this;
        }
        const size_type _Growth = static_cast<size_type>(_Count - _Nx);
        {
            if (_Growth <= _Mypair._Myval2._Myres - _Old_size) {
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _Nx;
                size_type _Ptr_shifted_after;
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }
                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                _Traits::copy(
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }
        }
        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Ptr, _Count);
    }
    inline basic_string& replace(const size_type _Off, const size_type _Nx, const _Elem* const _Ptr)
    {
        return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    inline basic_string& replace(const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch)
    {
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Count == _Nx) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count - _Nx;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }
        return _Reallocate_grow_by(
            _Count - _Nx,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Count, _Ch);
    }
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const basic_string& _Right)
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3967, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3967, 0);
                } while (false);
            };
        } while (false);
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }
    inline basic_string& replace(const const_iterator _First, const const_iterator _Last,
        const _Elem* const _Ptr, const size_type _Count)
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3992, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 3992, 0);
                } while (false);
            };
        } while (false);
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Elem* const _Ptr)
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4003, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4003, 0);
                } while (false);
            };
        } while (false);
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch)
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4014, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4014, 0);
                } while (false);
            };
        } while (false);
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2)
    {
        _Adl_verify_range(_First, _Last);
        do {
            if (_First._Getcont() == ::std::addressof(_Mypair._Myval2)) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4026, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4026, 0);
                } while (false);
            };
        } while (false);
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2 = _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        } else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }
    [[nodiscard]] inline iterator begin() noexcept
    {
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std::addressof(_Mypair._Myval2));
    }
    [[nodiscard]] inline const_iterator begin() const noexcept
    {
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std::addressof(_Mypair._Myval2));
    }
    [[nodiscard]] inline iterator end() noexcept
    {
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std::addressof(_Mypair._Myval2));
    }
    [[nodiscard]] inline const_iterator end() const noexcept
    {
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std::addressof(_Mypair._Myval2));
    }
    [[nodiscard]] inline _Elem* _Unchecked_begin() noexcept
    {
        return _Mypair._Myval2._Myptr();
    }
    [[nodiscard]] inline const _Elem* _Unchecked_begin() const noexcept
    {
        return _Mypair._Myval2._Myptr();
    }
    [[nodiscard]] inline _Elem* _Unchecked_end() noexcept
    {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }
    [[nodiscard]] inline const _Elem* _Unchecked_end() const noexcept
    {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }
    [[nodiscard]] inline reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }
    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept
    {
        return const_reverse_iterator(end());
    }
    [[nodiscard]] inline reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }
    [[nodiscard]] inline const_reverse_iterator rend() const noexcept
    {
        return const_reverse_iterator(begin());
    }
    [[nodiscard]] inline const_iterator cbegin() const noexcept
    {
        return begin();
    }
    [[nodiscard]] inline const_iterator cend() const noexcept
    {
        return end();
    }
    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept
    {
        return rbegin();
    }
    [[nodiscard]] inline const_reverse_iterator crend() const noexcept
    {
        return rend();
    }
    inline void shrink_to_fit()
    {
        auto& _My_data = _Mypair._Myval2;
        if (!_My_data._Large_string_engaged()) {
            return;
        }
        if (_My_data._Mysize < _BUF_SIZE) {
            _Become_small();
            return;
        }
        const size_type _Target_capacity = (::std::min)(_My_data._Mysize | _ALLOC_MASK, max_size());
        if (_Target_capacity < _My_data._Myres) {
            auto& _Al = _Getal();
            const pointer _New_ptr = _Al.allocate(_Target_capacity + 1);
            ;
            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres = _Target_capacity;
            ;
        }
    }
    [[nodiscard]] inline reference at(const size_type _Off)
    {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }
    [[nodiscard]] inline const_reference at(const size_type _Off) const
    {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }
    [[nodiscard]] inline reference operator[](const size_type _Off) noexcept
    {
        do {
            if (_Off <= _Mypair._Myval2._Mysize) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4174, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4174, 0);
                } while (false);
            };
        } while (false);
        return _Mypair._Myval2._Myptr()[_Off];
    }
    [[nodiscard]] inline const_reference operator[](const size_type _Off) const noexcept
    {
        do {
            if (_Off <= _Mypair._Myval2._Mysize) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4182, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"string subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4182, 0);
                } while (false);
            };
        } while (false);
        return _Mypair._Myval2._Myptr()[_Off];
    }
    inline void push_back(const _Elem _Ch)
    {
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }
        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }
    inline void pop_back() noexcept
    {
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        do {
            if (_Old_size != 0) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4218, 0, "%s", "invalid to pop_back empty string")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"invalid to pop_back empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4218, 0);
                } while (false);
            };
        } while (false);
        _Eos(_Old_size - 1);
    }
    [[nodiscard]] inline reference front() noexcept
    {
        do {
            if (_Mypair._Myval2._Mysize != 0) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4225, 0, "%s", "front() called on empty string")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"front() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4225, 0);
                } while (false);
            };
        } while (false);
        return _Mypair._Myval2._Myptr()[0];
    }
    [[nodiscard]] inline const_reference front() const noexcept
    {
        do {
            if (_Mypair._Myval2._Mysize != 0) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4233, 0, "%s", "front() called on empty string")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"front() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4233, 0);
                } while (false);
            };
        } while (false);
        return _Mypair._Myval2._Myptr()[0];
    }
    [[nodiscard]] inline reference back() noexcept
    {
        do {
            if (_Mypair._Myval2._Mysize != 0) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4241, 0, "%s", "back() called on empty string")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"back() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4241, 0);
                } while (false);
            };
        } while (false);
        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }
    [[nodiscard]] inline const_reference back() const noexcept
    {
        do {
            if (_Mypair._Myval2._Mysize != 0) {
            } else {
                do {
                    (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4249, 0, "%s", "back() called on empty string")) || (__debugbreak(), 0));
                    ::_invalid_parameter(L"\"back() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 4249, 0);
                } while (false);
            };
        } while (false);
        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }
    [[nodiscard]] inline const _Elem* c_str() const noexcept
    {
        return _Mypair._Myval2._Myptr();
    }
    [[nodiscard]] inline const _Elem* data() const noexcept
    {
        return _Mypair._Myval2._Myptr();
    }
    [[nodiscard]] inline size_type length() const noexcept
    {
        return _Mypair._Myval2._Mysize;
    }
    [[nodiscard]] inline size_type size() const noexcept
    {
        return _Mypair._Myval2._Mysize;
    }
    [[nodiscard]] inline size_type max_size() const noexcept
    {
        const size_type _Alloc_max = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = (::std::max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return (::std::min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1);
    }
    inline void resize(__declspec(guard(overflow)) const size_type _New_size, const _Elem _Ch = _Elem())
    {
        const size_type _Old_size = size();
        if (_New_size <= _Old_size) {
            _Eos(_New_size);
        } else {
            append(_New_size - _Old_size, _Ch);
        }
    }
    [[nodiscard]] inline size_type capacity() const noexcept
    {
        return _Mypair._Myval2._Myres;
    }
    void reserve(__declspec(guard(overflow)) const size_type _Newcap = 0)
    {
        if (_Mypair._Myval2._Mysize > _Newcap) {
            return;
        }
        if (_Mypair._Myval2._Myres == _Newcap) {
            return;
        }
        if (_Mypair._Myval2._Myres < _Newcap) {
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            _Reallocate_grow_by(
                _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                });
            _Mypair._Myval2._Mysize = _Old_size;
            return;
        }
        if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {
            _Become_small();
            return;
        }
    }
    [[nodiscard("This member function returns a bool indicating whether the container is empty and has no other effects. "
                "It is not useful to call this member function and discard the return value. "
                "Use the 'clear()' member function if you want to erase all elements.")]] inline bool
    empty() const noexcept
    {
        return _Mypair._Myval2._Mysize == 0;
    }
    inline size_type copy(
        _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const
    {
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }
    inline size_type
    _Copy_s(_Elem* const _Dest, const size_type _Dest_size, size_type _Count,
        const size_type _Off = 0) const
    {
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }
    static inline void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) noexcept
    {
        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Destroy_in_place(_Starts_large._Bx._Ptr);
        _Starts_large._Activate_SSO_buffer();
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }
    inline void _Swap_data(basic_string& _Right)
    {
        auto& _My_data = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        const bool _My_large = _My_data._Large_string_engaged();
        const bool _Right_large = _Right_data._Large_string_engaged();
        if constexpr (_Can_memcpy_val) {
            {
                const auto _My_data_mem = reinterpret_cast<unsigned char*>(::std::addressof(_My_data)) + _Memcpy_val_offset;
                const auto _Right_data_mem = reinterpret_cast<unsigned char*>(::std::addressof(_Right_data)) + _Memcpy_val_offset;
                unsigned char _Temp_mem[_Memcpy_val_size];
                ::memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
                ::memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
                ::memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);
                return;
            }
        }
        if (_My_large && _Right_large) {
            _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
        } else if (_My_large) {
            _Swap_bx_large_with_small(_My_data, _Right_data);
            ;
        } else if (_Right_large) {
            _Swap_bx_large_with_small(_Right_data, _My_data);
            ;
        } else {
            _Elem _Temp_buf[_BUF_SIZE];
            _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _My_data._Mysize + 1);
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _My_data._Mysize + 1);
            ;
            ;
        }
        ::std::swap(_My_data._Mysize, _Right_data._Mysize);
        ::std::swap(_My_data._Myres, _Right_data._Myres);
    }
    inline void swap(basic_string& _Right) noexcept
    {
        if (this != ::std::addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            auto& _My_data = _Mypair._Myval2;
            auto& _Right_data = _Right._Mypair._Myval2;
            if (!_My_data._Large_string_engaged()) {
                _My_data._Orphan_all();
            }
            if (!_Right_data._Large_string_engaged()) {
                _Right_data._Orphan_all();
            }
            _My_data._Swap_proxy_and_iterators(_Right_data);
            _Swap_data(_Right);
        }
    }
    [[nodiscard]] inline size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }
    [[nodiscard]] inline size_type find(const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] inline size_type find(const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] inline size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }
    [[nodiscard]] inline size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }
    [[nodiscard]] inline size_type rfind(const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept
    {
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] inline size_type rfind(const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] inline size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }
    [[nodiscard]] inline size_type find_first_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }
    [[nodiscard]] inline size_type find_first_of(const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] inline size_type find_first_of(
        const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] inline size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }
    [[nodiscard]] inline size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }
    [[nodiscard]] inline size_type find_last_of(const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] inline size_type find_last_of(
        const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] inline size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }
    [[nodiscard]] inline size_type find_first_not_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }
    [[nodiscard]] inline size_type find_first_not_of(const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] inline size_type find_first_not_of(
        const _Elem* const _Ptr, size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] inline size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }
    [[nodiscard]] inline size_type find_last_not_of(
        const basic_string& _Right, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }
    [[nodiscard]] inline size_type find_last_not_of(const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept
    {
        return static_cast<size_type>(
            _Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] inline size_type find_last_not_of(
        const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] inline size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
    {
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }
    [[nodiscard]] inline basic_string substr(const size_type _Off = 0, const size_type _Count = npos)
        const
    {
        return basic_string { *this, _Off, _Count };
    }
    inline bool _Equal(const basic_string& _Right) const noexcept
    {
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    inline bool _Equal(const _Elem* const _Ptr) const noexcept
    {
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] inline int compare(const basic_string& _Right) const noexcept
    {
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    [[nodiscard]] inline int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const
    {
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }
    [[nodiscard]] inline int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
        const size_type _Roff, const size_type _Count = npos) const
    {
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }
    [[nodiscard]] inline int compare(const _Elem* const _Ptr) const noexcept
    {
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] inline int compare(
        const size_type _Off, const size_type _Nx, const _Elem* const _Ptr) const
    {
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] inline int compare(const size_type _Off, const size_type _Nx,
        const _Elem* const _Ptr, const size_type _Count) const
    {
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    }
    [[nodiscard]] inline allocator_type get_allocator() const noexcept
    {
        return static_cast<allocator_type>(_Getal());
    }

private:
    [[nodiscard]] static inline size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept
    {
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if (_Masked > _Max) {
            return _Max;
        }
        if (_Old > _Max - _Old / 2) {
            return _Max;
        }
        return (::std::max)(_Masked, _Old + _Old / 2);
    }
    [[nodiscard]] inline size_type _Calculate_growth(const size_type _Requested) const noexcept
    {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }
    template <class _Fty, class... _ArgTys>
    inline basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args)
    {
        if (_New_size > max_size()) {
            _Xlen_string();
        }
        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al = _Getal();
        const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
        _Mypair._Myval2._Orphan_all();
        ;
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_BUF_SIZE <= _Old_capacity) {
            _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        } else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        };
        return *this;
    }
    template <class _Fty, class... _ArgTys>
    inline basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args)
    {
        auto& _My_data = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen_string();
        }
        const size_type _New_size = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al = _Getal();
        const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
        _My_data._Orphan_all();
        ;
        _My_data._Mysize = _New_size;
        _My_data._Myres = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_BUF_SIZE <= _Old_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Al.deallocate(_Old_ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        };
        return *this;
    }
    inline void _Become_small()
    {
        auto& _My_data = _Mypair._Myval2;
        ;
        ;
        _My_data._Orphan_all();
        ;
        const pointer _Ptr = _My_data._Bx._Ptr;
        auto& _Al = _Getal();
        _Destroy_in_place(_My_data._Bx._Ptr);
        _My_data._Activate_SSO_buffer();
        _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
        _Al.deallocate(_Ptr, _My_data._Myres + 1);
        _My_data._Myres = _BUF_SIZE - 1;
        ;
    }
    inline void _Eos(const size_type _New_size)
    {
        ;
        _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());
    }
    inline void _Tidy_init() noexcept
    {
        auto& _My_data = _Mypair._Myval2;
        _My_data._Mysize = 0;
        _My_data._Myres = _BUF_SIZE - 1;
        _My_data._Activate_SSO_buffer();
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
        ;
    }
    inline void _Tidy_deallocate() noexcept
    {
        auto& _My_data = _Mypair._Myval2;
        _My_data._Orphan_all();
        ;
        if (_My_data._Large_string_engaged()) {
            const pointer _Ptr = _My_data._Bx._Ptr;
            auto& _Al = _Getal();
            _Destroy_in_place(_My_data._Bx._Ptr);
            _My_data._Activate_SSO_buffer();
            _Al.deallocate(_Ptr, _My_data._Myres + 1);
        }
        _My_data._Mysize = 0;
        _My_data._Myres = _BUF_SIZE - 1;
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

public:
    inline void _Orphan_all() noexcept
    {
        _Mypair._Myval2._Orphan_all();
    }

private:
    inline void _Swap_proxy_and_iterators(basic_string& _Right)
    {
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }
    inline _Alty& _Getal() noexcept
    {
        return _Mypair._Get_first();
    }
    inline const _Alty& _Getal() const noexcept
    {
        return _Mypair._Get_first();
    }
    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};
template <class _Elem, class _Traits, class _Alloc>
inline void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    _Left.swap(_Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    const auto _Left_size = _Left.size();
    const auto _Right_size = _Right.size();
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }
    return { _String_constructor_concat_tag {}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size };
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    using _Size_type = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size = _Convert_size<_Size_type>(_Traits::length(_Left));
    const auto _Right_size = _Right.size();
    if (_Right.max_size() - _Right_size < _Left_size) {
        _Xlen_string();
    }
    return { _String_constructor_concat_tag {}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size };
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    const auto _Right_size = _Right.size();
    if (_Right_size == _Right.max_size()) {
        _Xlen_string();
    }
    return { _String_constructor_concat_tag {}, _Right, ::std::addressof(_Left), 1, _Right.c_str(), _Right_size };
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    using _Size_type = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size = _Left.size();
    const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }
    return { _String_constructor_concat_tag {}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size };
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right)
{
    const auto _Left_size = _Left.size();
    if (_Left_size == _Left.max_size()) {
        _Xlen_string();
    }
    return { _String_constructor_concat_tag {}, _Left, _Left.c_str(), _Left_size, ::std::addressof(_Right), 1 };
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
{
    return ::std::move(_Right.insert(0, _Left));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return ::std::move(_Left.append(_Right));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
{
    do {
        if (::std::addressof(_Left) != ::std::addressof(_Right)) {
        } else {
            do {
                (void)((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 5153, 0, "%s", "You cannot concatenate the same moved string to itself. See N4910 16.4.5.9 [res.on.arguments]/1.3: "
                                                                                                                                                                            "If a function argument is bound to an rvalue reference parameter, the implementation may assume that "
                                                                                                                                                                            "this parameter is a unique reference to this argument, except that the argument passed to "
                                                                                                                                                                            "a move-assignment operator may be a reference to *this (16.4.6.15 [lib.types.movedfrom])."))
                    || (__debugbreak(), 0));
                ::_invalid_parameter(L"\"You cannot concatenate the same moved string to itself. See N4910 16.4.5.9 [res.on.arguments]/1.3: \" \"If a function argument is bound to an rvalue reference parameter, the implementation may assume that \" \"this parameter is a unique reference to this argument, except that the argument passed to \" \"a move-assignment operator may be a reference to *this (16.4.6.15 [lib.types.movedfrom]).\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include\\xstring", 5153, 0);
            } while (false);
        };
    } while (false);
    return { _String_constructor_concat_tag {}, _Left, _Right };
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
{
    return ::std::move(_Right.insert(0, _Left));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
{
    return ::std::move(_Right.insert(0, 1, _Left));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem* const _Right)
{
    return ::std::move(_Left.append(_Right));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right)
{
    _Left.push_back(_Right);
    return ::std::move(_Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    return _Left._Equal(_Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    return _Left._Equal(_Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator==(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return _Right._Equal(_Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    return !(_Left == _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return !(_Left == _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    return !(_Left == _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    return _Left.compare(_Right) < 0;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return _Right.compare(_Left) > 0;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    return _Left.compare(_Right) < 0;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    return _Right < _Left;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return _Right < _Left;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    return _Right < _Left;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    return !(_Right < _Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return !(_Right < _Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    return !(_Right < _Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
{
    return !(_Left < _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
{
    return !(_Left < _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
{
    return !(_Left < _Right);
}
using string = basic_string<char, char_traits<char>, allocator<char>>;
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;
template <class _Elem, class _Alloc>
struct hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>>
    : _Conditionally_enabled_hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>, _Is_EcharT<_Elem>> {
    [[nodiscard]] static size_t _Do_hash(const basic_string<_Elem, char_traits<_Elem>, _Alloc>& _Keyval) noexcept
    {
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};
template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
{
    using _Myis = basic_istream<_Elem, _Traits>;
    using _Ctype = typename _Myis::_Ctype;
    using _Mystr = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;
    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed = false;
    const typename _Myis::sentry _Ok(_Istr);
    if (_Ok) {
        const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();
        try {
            _Mysizt _Size;
            if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
                _Size = static_cast<_Mysizt>(_Istr.width());
            } else {
                _Size = _Str.max_size();
            }
            typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();
            for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    _State |= _Myis::eofbit;
                    break;
                } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                    break;
                } else {
                    _Str.push_back(_Traits::to_char_type(_Meta));
                    _Changed = true;
                }
            }
        } catch (...) {
            (_Istr).setstate(_Myis::badbit, true);
        }
    }
    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}
template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str)
{
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}
inline namespace literals {
    inline namespace string_literals {
        [[nodiscard]] inline string operator"" s(const char* _Str, size_t _Len)
        {
            return string { _Str, _Len };
        }
        [[nodiscard]] inline wstring operator"" s(const wchar_t* _Str, size_t _Len)
        {
            return wstring { _Str, _Len };
        }
        [[nodiscard]] inline u16string operator"" s(const char16_t* _Str, size_t _Len)
        {
            return u16string { _Str, _Len };
        }
        [[nodiscard]] inline u32string operator"" s(const char32_t* _Str, size_t _Len)
        {
            return u32string { _Str, _Len };
        }
    }
}
}
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294 4984 5053)
namespace std {
template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim)
{
    using _Myis = basic_istream<_Elem, _Traits>;
    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed = false;
    const typename _Myis::sentry _Ok(_Istr, true);
    if (_Ok) {
        try {
            _Str.erase();
            const typename _Traits::int_type _Metadelim = _Traits::to_int_type(_Delim);
            typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();
            for (;; _Meta = _Istr.rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    _State |= _Myis::eofbit;
                    break;
                } else if (_Traits::eq_int_type(_Meta, _Metadelim)) {
                    _Changed = true;
                    _Istr.rdbuf()->sbumpc();
                    break;
                } else if (_Str.max_size() <= _Str.size()) {
                    _State |= _Myis::failbit;
                    break;
                } else {
                    _Str += _Traits::to_char_type(_Meta);
                    _Changed = true;
                }
            }
        } catch (...) {
            (_Istr).setstate(_Myis::badbit, true);
        }
    }
    if (!_Changed) {
        _State |= _Myis::failbit;
    }
    _Istr.setstate(_State);
    return static_cast<basic_istream<_Elem, _Traits>&>(_Istr);
}
template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
{
    return getline(_Istr, _Str, _Istr.widen('\n'));
}
template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim)
{
    return getline(::std::move(_Istr), _Str, _Delim);
}
template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
{
    return getline(::std::move(_Istr), _Str, _Istr.widen('\n'));
}
[[nodiscard]] inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const long _Ans = ::strtol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoi argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoi argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return static_cast<int>(_Ans);
}
[[nodiscard]] inline long stol(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const long _Ans = ::strtol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stol argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stol argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline unsigned long stoul(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const unsigned long _Ans = ::strtoul(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoul argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoul argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline long long stoll(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const long long _Ans = ::strtoll(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoll argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoll argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline unsigned long long stoull(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const unsigned long long _Ans = ::strtoull(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoull argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoull argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline float stof(const string& _Str, size_t* _Idx = nullptr)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const float _Ans = ::strtof(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stof argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stof argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline double stod(const string& _Str, size_t* _Idx = nullptr)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const double _Ans = ::strtod(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stod argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stod argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline long double stold(const string& _Str, size_t* _Idx = nullptr)
{
    int& _Errno_ref = (*_errno());
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref = 0;
    const long double _Ans = ::strtold(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stold argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stold argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline int stoi(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const long _Ans = ::wcstol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoi argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoi argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return static_cast<int>(_Ans);
}
[[nodiscard]] inline long stol(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const long _Ans = ::wcstol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stol argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stol argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline unsigned long stoul(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const unsigned long _Ans = ::wcstoul(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoul argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoul argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline long long stoll(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const long long _Ans = ::wcstoll(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoll argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoll argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline unsigned long long stoull(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const unsigned long long _Ans = ::wcstoull(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoull argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoull argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline float stof(const wstring& _Str, size_t* _Idx = nullptr)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const float _Ans = ::wcstof(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stof argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stof argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline double stod(const wstring& _Str, size_t* _Idx = nullptr)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const double _Ans = ::wcstod(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stod argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stod argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
[[nodiscard]] inline long double stold(const wstring& _Str, size_t* _Idx = nullptr)
{
    int& _Errno_ref = (*_errno());
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref = 0;
    const long double _Ans = ::wcstold(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stold argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stold argument out of range");
    }
    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }
    return _Ans;
}
template <class _Elem, class _UTy>
[[nodiscard]] _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal)
{
    static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
    auto _UVal_trunc = _UVal;
    do {
        *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
        _UVal_trunc /= 10;
    } while (_UVal_trunc != 0);
    return _RNext;
}
template <class _Elem, class _Ty>
[[nodiscard]] basic_string<_Elem> _Integral_to_string(const _Ty _Val)
{
    static_assert(is_integral_v<_Ty>, "_Ty must be integral");
    using _UTy = make_unsigned_t<_Ty>;
    _Elem _Buff[21];
    _Elem* const _Buff_end = ::std::end(_Buff);
    _Elem* _RNext = _Buff_end;
    const auto _UVal = static_cast<_UTy>(_Val);
    if (_Val < 0) {
        _RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
        *--_RNext = '-';
    } else {
        _RNext = _UIntegral_to_buff(_RNext, _UVal);
    }
    return basic_string<_Elem>(_RNext, _Buff_end);
}
template <class _Elem, class _Ty>
[[nodiscard]] basic_string<_Elem> _UIntegral_to_string(const _Ty _Val)
{
    static_assert(is_integral_v<_Ty>, "_Ty must be integral");
    static_assert(is_unsigned_v<_Ty>, "_Ty must be unsigned");
    _Elem _Buff[21];
    _Elem* const _Buff_end = ::std::end(_Buff);
    _Elem* const _RNext = _UIntegral_to_buff(_Buff_end, _Val);
    return basic_string<_Elem>(_RNext, _Buff_end);
}
[[nodiscard]] inline string to_string(int _Val)
{
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(unsigned int _Val)
{
    return _UIntegral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(long _Val)
{
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(unsigned long _Val)
{
    return _UIntegral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(long long _Val)
{
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(unsigned long long _Val)
{
    return _UIntegral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(double _Val)
{
    const auto _Len = static_cast<size_t>(::_scprintf("%f", _Val));
    string _Str(_Len, '\0');
    ::sprintf_s(&_Str[0], _Len + 1, "%f", _Val);
    return _Str;
}
[[nodiscard]] inline string to_string(float _Val)
{
    return ::std::to_string(static_cast<double>(_Val));
}
[[nodiscard]] inline string to_string(long double _Val)
{
    return ::std::to_string(static_cast<double>(_Val));
}
[[nodiscard]] inline wstring to_wstring(int _Val)
{
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(unsigned int _Val)
{
    return _UIntegral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(long _Val)
{
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(unsigned long _Val)
{
    return _UIntegral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(long long _Val)
{
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(unsigned long long _Val)
{
    return _UIntegral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(double _Val)
{
    const auto _Len = static_cast<size_t>(::_scwprintf(L"%f", _Val));
    wstring _Str(_Len, L'\0');
    ::swprintf_s(&_Str[0], _Len + 1, L"%f", _Val);
    return _Str;
}
[[nodiscard]] inline wstring to_wstring(float _Val)
{
    return ::std::to_wstring(static_cast<double>(_Val));
}
[[nodiscard]] inline wstring to_wstring(long double _Val)
{
    return ::std::to_wstring(static_cast<double>(_Val));
}
}
#pragma warning(pop)
#pragma pack(pop)
namespace vr {
enum EVRSettingsError {
    VRSettingsError_None = 0,
    VRSettingsError_IPCFailed = 1,
    VRSettingsError_WriteFailed = 2,
    VRSettingsError_ReadFailed = 3,
    VRSettingsError_JsonParseFailed = 4,
    VRSettingsError_UnsetSettingHasNoDefault = 5,
};
static const uint32_t k_unMaxSettingsKeyLength = 128;
class IVRSettings {
public:
    virtual const char* GetSettingsErrorNameFromEnum(EVRSettingsError eError) = 0;
    virtual void SetBool(const char* pchSection, const char* pchSettingsKey, bool bValue, EVRSettingsError* peError = nullptr) = 0;
    virtual void SetInt32(const char* pchSection, const char* pchSettingsKey, int32_t nValue, EVRSettingsError* peError = nullptr) = 0;
    virtual void SetFloat(const char* pchSection, const char* pchSettingsKey, float flValue, EVRSettingsError* peError = nullptr) = 0;
    virtual void SetString(const char* pchSection, const char* pchSettingsKey, const char* pchValue, EVRSettingsError* peError = nullptr) = 0;
    virtual bool GetBool(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr) = 0;
    virtual int32_t GetInt32(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr) = 0;
    virtual float GetFloat(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr) = 0;
    virtual void GetString(const char* pchSection, const char* pchSettingsKey, char* pchValue, uint32_t unValueLen, EVRSettingsError* peError = nullptr) = 0;
    virtual void RemoveSection(const char* pchSection, EVRSettingsError* peError = nullptr) = 0;
    virtual void RemoveKeyInSection(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr) = 0;
};
static const char* const IVRSettings_Version = "IVRSettings_003";
class CVRSettingHelper {
    IVRSettings* m_pSettings;

public:
    CVRSettingHelper(IVRSettings* pSettings)
    {
        m_pSettings = pSettings;
    }
    const char* GetSettingsErrorNameFromEnum(EVRSettingsError eError)
    {
        return m_pSettings->GetSettingsErrorNameFromEnum(eError);
    }
    void SetBool(const char* pchSection, const char* pchSettingsKey, bool bValue, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->SetBool(pchSection, pchSettingsKey, bValue, peError);
    }
    void SetInt32(const char* pchSection, const char* pchSettingsKey, int32_t nValue, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->SetInt32(pchSection, pchSettingsKey, nValue, peError);
    }
    void SetFloat(const char* pchSection, const char* pchSettingsKey, float flValue, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->SetFloat(pchSection, pchSettingsKey, flValue, peError);
    }
    void SetString(const char* pchSection, const char* pchSettingsKey, const char* pchValue, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->SetString(pchSection, pchSettingsKey, pchValue, peError);
    }
    void SetString(const std::string& sSection, const std::string& sSettingsKey, const std::string& sValue, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->SetString(sSection.c_str(), sSettingsKey.c_str(), sValue.c_str(), peError);
    }
    bool GetBool(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr)
    {
        return m_pSettings->GetBool(pchSection, pchSettingsKey, peError);
    }
    int32_t GetInt32(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr)
    {
        return m_pSettings->GetInt32(pchSection, pchSettingsKey, peError);
    }
    float GetFloat(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr)
    {
        return m_pSettings->GetFloat(pchSection, pchSettingsKey, peError);
    }
    void GetString(const char* pchSection, const char* pchSettingsKey, char* pchValue, uint32_t unValueLen, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->GetString(pchSection, pchSettingsKey, pchValue, unValueLen, peError);
    }
    std::string GetString(const std::string& sSection, const std::string& sSettingsKey, EVRSettingsError* peError = nullptr)
    {
        char buf[4096];
        vr::EVRSettingsError eError;
        m_pSettings->GetString(sSection.c_str(), sSettingsKey.c_str(), buf, sizeof(buf), &eError);
        if (peError)
            *peError = eError;
        if (eError == vr::VRSettingsError_None)
            return buf;
        else
            return "";
    }
    void RemoveSection(const char* pchSection, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->RemoveSection(pchSection, peError);
    }
    void RemoveKeyInSection(const char* pchSection, const char* pchSettingsKey, EVRSettingsError* peError = nullptr)
    {
        m_pSettings->RemoveKeyInSection(pchSection, pchSettingsKey, peError);
    }
};
static const char* const k_pch_SteamVR_Section = "steamvr";
static const char* const k_pch_SteamVR_RequireHmd_String = "requireHmd";
static const char* const k_pch_SteamVR_ForcedDriverKey_String = "forcedDriver";
static const char* const k_pch_SteamVR_ForcedHmdKey_String = "forcedHmd";
static const char* const k_pch_SteamVR_DisplayDebug_Bool = "displayDebug";
static const char* const k_pch_SteamVR_DebugProcessPipe_String = "debugProcessPipe";
static const char* const k_pch_SteamVR_DisplayDebugX_Int32 = "displayDebugX";
static const char* const k_pch_SteamVR_DisplayDebugY_Int32 = "displayDebugY";
static const char* const k_pch_SteamVR_SendSystemButtonToAllApps_Bool = "sendSystemButtonToAllApps";
static const char* const k_pch_SteamVR_LogLevel_Int32 = "loglevel";
static const char* const k_pch_SteamVR_IPD_Float = "ipd";
static const char* const k_pch_SteamVR_Background_String = "background";
static const char* const k_pch_SteamVR_BackgroundUseDomeProjection_Bool = "backgroundUseDomeProjection";
static const char* const k_pch_SteamVR_BackgroundCameraHeight_Float = "backgroundCameraHeight";
static const char* const k_pch_SteamVR_BackgroundDomeRadius_Float = "backgroundDomeRadius";
static const char* const k_pch_SteamVR_GridColor_String = "gridColor";
static const char* const k_pch_SteamVR_PlayAreaColor_String = "playAreaColor";
static const char* const k_pch_SteamVR_TrackingLossColor_String = "trackingLossColor";
static const char* const k_pch_SteamVR_ShowStage_Bool = "showStage";
static const char* const k_pch_SteamVR_DrawTrackingReferences_Bool = "drawTrackingReferences";
static const char* const k_pch_SteamVR_ActivateMultipleDrivers_Bool = "activateMultipleDrivers";
static const char* const k_pch_SteamVR_UsingSpeakers_Bool = "usingSpeakers";
static const char* const k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float = "speakersForwardYawOffsetDegrees";
static const char* const k_pch_SteamVR_BaseStationPowerManagement_Int32 = "basestationPowerManagement";
static const char* const k_pch_SteamVR_ShowBaseStationPowerManagementTip_Int32 = "ShowBaseStationPowerManagementTip";
static const char* const k_pch_SteamVR_NeverKillProcesses_Bool = "neverKillProcesses";
static const char* const k_pch_SteamVR_SupersampleScale_Float = "supersampleScale";
static const char* const k_pch_SteamVR_MaxRecommendedResolution_Int32 = "maxRecommendedResolution";
static const char* const k_pch_SteamVR_MotionSmoothing_Bool = "motionSmoothing";
static const char* const k_pch_SteamVR_MotionSmoothingOverride_Int32 = "motionSmoothingOverride";
static const char* const k_pch_SteamVR_FramesToThrottle_Int32 = "framesToThrottle";
static const char* const k_pch_SteamVR_AdditionalFramesToPredict_Int32 = "additionalFramesToPredict";
static const char* const k_pch_SteamVR_WorldScale_Float = "worldScale";
static const char* const k_pch_SteamVR_FovScale_Int32 = "fovScale";
static const char* const k_pch_SteamVR_DisableAsyncReprojection_Bool = "disableAsync";
static const char* const k_pch_SteamVR_ForceFadeOnBadTracking_Bool = "forceFadeOnBadTracking";
static const char* const k_pch_SteamVR_DefaultMirrorView_Int32 = "mirrorView";
static const char* const k_pch_SteamVR_ShowLegacyMirrorView_Bool = "showLegacyMirrorView";
static const char* const k_pch_SteamVR_MirrorViewVisibility_Bool = "showMirrorView";
static const char* const k_pch_SteamVR_MirrorViewDisplayMode_Int32 = "mirrorViewDisplayMode";
static const char* const k_pch_SteamVR_MirrorViewEye_Int32 = "mirrorViewEye";
static const char* const k_pch_SteamVR_MirrorViewGeometry_String = "mirrorViewGeometry";
static const char* const k_pch_SteamVR_MirrorViewGeometryMaximized_String = "mirrorViewGeometryMaximized";
static const char* const k_pch_SteamVR_PerfGraphVisibility_Bool = "showPerfGraph";
static const char* const k_pch_SteamVR_StartMonitorFromAppLaunch = "startMonitorFromAppLaunch";
static const char* const k_pch_SteamVR_StartCompositorFromAppLaunch_Bool = "startCompositorFromAppLaunch";
static const char* const k_pch_SteamVR_StartDashboardFromAppLaunch_Bool = "startDashboardFromAppLaunch";
static const char* const k_pch_SteamVR_StartOverlayAppsFromDashboard_Bool = "startOverlayAppsFromDashboard";
static const char* const k_pch_SteamVR_EnableHomeApp = "enableHomeApp";
static const char* const k_pch_SteamVR_CycleBackgroundImageTimeSec_Int32 = "CycleBackgroundImageTimeSec";
static const char* const k_pch_SteamVR_RetailDemo_Bool = "retailDemo";
static const char* const k_pch_SteamVR_IpdOffset_Float = "ipdOffset";
static const char* const k_pch_SteamVR_AllowSupersampleFiltering_Bool = "allowSupersampleFiltering";
static const char* const k_pch_SteamVR_SupersampleManualOverride_Bool = "supersampleManualOverride";
static const char* const k_pch_SteamVR_EnableLinuxVulkanAsync_Bool = "enableLinuxVulkanAsync";
static const char* const k_pch_SteamVR_AllowDisplayLockedMode_Bool = "allowDisplayLockedMode";
static const char* const k_pch_SteamVR_HaveStartedTutorialForNativeChaperoneDriver_Bool = "haveStartedTutorialForNativeChaperoneDriver";
static const char* const k_pch_SteamVR_ForceWindows32bitVRMonitor = "forceWindows32BitVRMonitor";
static const char* const k_pch_SteamVR_DebugInputBinding = "debugInputBinding";
static const char* const k_pch_SteamVR_DoNotFadeToGrid = "doNotFadeToGrid";
static const char* const k_pch_SteamVR_RenderCameraMode = "renderCameraMode";
static const char* const k_pch_SteamVR_EnableSharedResourceJournaling = "enableSharedResourceJournaling";
static const char* const k_pch_SteamVR_EnableSafeMode = "enableSafeMode";
static const char* const k_pch_SteamVR_PreferredRefreshRate = "preferredRefreshRate";
static const char* const k_pch_SteamVR_LastVersionNotice = "lastVersionNotice";
static const char* const k_pch_SteamVR_LastVersionNoticeDate = "lastVersionNoticeDate";
static const char* const k_pch_SteamVR_HmdDisplayColorGainR_Float = "hmdDisplayColorGainR";
static const char* const k_pch_SteamVR_HmdDisplayColorGainG_Float = "hmdDisplayColorGainG";
static const char* const k_pch_SteamVR_HmdDisplayColorGainB_Float = "hmdDisplayColorGainB";
static const char* const k_pch_SteamVR_CustomIconStyle_String = "customIconStyle";
static const char* const k_pch_SteamVR_CustomOffIconStyle_String = "customOffIconStyle";
static const char* const k_pch_SteamVR_CustomIconForceUpdate_String = "customIconForceUpdate";
static const char* const k_pch_SteamVR_AllowGlobalActionSetPriority = "globalActionSetPriority";
static const char* const k_pch_SteamVR_OverlayRenderQuality = "overlayRenderQuality_2";
static const char* const k_pch_SteamVR_BlockOculusSDKOnOpenVRLaunchOption_Bool = "blockOculusSDKOnOpenVRLaunchOption";
static const char* const k_pch_SteamVR_BlockOculusSDKOnAllLaunches_Bool = "blockOculusSDKOnAllLaunches";
static const char* const k_pch_SteamVR_HDCPLegacyCompatibility_Bool = "hdcp14legacyCompatibility";
static const char* const k_pch_SteamVR_DisplayPortTrainingMode_Int = "displayPortTrainingMode";
static const char* const k_pch_SteamVR_UsePrism_Bool = "usePrism";
static const char* const k_pch_DirectMode_Section = "direct_mode";
static const char* const k_pch_DirectMode_Enable_Bool = "enable";
static const char* const k_pch_DirectMode_Count_Int32 = "count";
static const char* const k_pch_DirectMode_EdidVid_Int32 = "edidVid";
static const char* const k_pch_DirectMode_EdidPid_Int32 = "edidPid";
static const char* const k_pch_Lighthouse_Section = "driver_lighthouse";
static const char* const k_pch_Lighthouse_DisableIMU_Bool = "disableimu";
static const char* const k_pch_Lighthouse_DisableIMUExceptHMD_Bool = "disableimuexcepthmd";
static const char* const k_pch_Lighthouse_UseDisambiguation_String = "usedisambiguation";
static const char* const k_pch_Lighthouse_DisambiguationDebug_Int32 = "disambiguationdebug";
static const char* const k_pch_Lighthouse_PrimaryBasestation_Int32 = "primarybasestation";
static const char* const k_pch_Lighthouse_DBHistory_Bool = "dbhistory";
static const char* const k_pch_Lighthouse_EnableBluetooth_Bool = "enableBluetooth";
static const char* const k_pch_Lighthouse_PowerManagedBaseStations_String = "PowerManagedBaseStations";
static const char* const k_pch_Lighthouse_PowerManagedBaseStations2_String = "PowerManagedBaseStations2";
static const char* const k_pch_Lighthouse_InactivityTimeoutForBaseStations_Int32 = "InactivityTimeoutForBaseStations";
static const char* const k_pch_Lighthouse_EnableImuFallback_Bool = "enableImuFallback";
static const char* const k_pch_Null_Section = "driver_null";
static const char* const k_pch_Null_SerialNumber_String = "serialNumber";
static const char* const k_pch_Null_ModelNumber_String = "modelNumber";
static const char* const k_pch_Null_WindowX_Int32 = "windowX";
static const char* const k_pch_Null_WindowY_Int32 = "windowY";
static const char* const k_pch_Null_WindowWidth_Int32 = "windowWidth";
static const char* const k_pch_Null_WindowHeight_Int32 = "windowHeight";
static const char* const k_pch_Null_RenderWidth_Int32 = "renderWidth";
static const char* const k_pch_Null_RenderHeight_Int32 = "renderHeight";
static const char* const k_pch_Null_SecondsFromVsyncToPhotons_Float = "secondsFromVsyncToPhotons";
static const char* const k_pch_Null_DisplayFrequency_Float = "displayFrequency";
static const char* const k_pch_WindowsMR_Section = "driver_holographic";
static const char* const k_pch_UserInterface_Section = "userinterface";
static const char* const k_pch_UserInterface_StatusAlwaysOnTop_Bool = "StatusAlwaysOnTop";
static const char* const k_pch_UserInterface_MinimizeToTray_Bool = "MinimizeToTray";
static const char* const k_pch_UserInterface_HidePopupsWhenStatusMinimized_Bool = "HidePopupsWhenStatusMinimized";
static const char* const k_pch_UserInterface_Screenshots_Bool = "screenshots";
static const char* const k_pch_UserInterface_ScreenshotType_Int = "screenshotType";
static const char* const k_pch_Notifications_Section = "notifications";
static const char* const k_pch_Notifications_DoNotDisturb_Bool = "DoNotDisturb";
static const char* const k_pch_Keyboard_Section = "keyboard";
static const char* const k_pch_Keyboard_TutorialCompletions = "TutorialCompletions";
static const char* const k_pch_Keyboard_ScaleX = "ScaleX";
static const char* const k_pch_Keyboard_ScaleY = "ScaleY";
static const char* const k_pch_Keyboard_OffsetLeftX = "OffsetLeftX";
static const char* const k_pch_Keyboard_OffsetRightX = "OffsetRightX";
static const char* const k_pch_Keyboard_OffsetY = "OffsetY";
static const char* const k_pch_Keyboard_Smoothing = "Smoothing";
static const char* const k_pch_Perf_Section = "perfcheck";
static const char* const k_pch_Perf_PerfGraphInHMD_Bool = "perfGraphInHMD";
static const char* const k_pch_Perf_AllowTimingStore_Bool = "allowTimingStore";
static const char* const k_pch_Perf_SaveTimingsOnExit_Bool = "saveTimingsOnExit";
static const char* const k_pch_Perf_TestData_Float = "perfTestData";
static const char* const k_pch_Perf_GPUProfiling_Bool = "GPUProfiling";
static const char* const k_pch_CollisionBounds_Section = "collisionBounds";
static const char* const k_pch_CollisionBounds_Style_Int32 = "CollisionBoundsStyle";
static const char* const k_pch_CollisionBounds_GroundPerimeterOn_Bool = "CollisionBoundsGroundPerimeterOn";
static const char* const k_pch_CollisionBounds_CenterMarkerOn_Bool = "CollisionBoundsCenterMarkerOn";
static const char* const k_pch_CollisionBounds_PlaySpaceOn_Bool = "CollisionBoundsPlaySpaceOn";
static const char* const k_pch_CollisionBounds_FadeDistance_Float = "CollisionBoundsFadeDistance";
static const char* const k_pch_CollisionBounds_WallHeight_Float = "CollisionBoundsWallHeight";
static const char* const k_pch_CollisionBounds_ColorGammaR_Int32 = "CollisionBoundsColorGammaR";
static const char* const k_pch_CollisionBounds_ColorGammaG_Int32 = "CollisionBoundsColorGammaG";
static const char* const k_pch_CollisionBounds_ColorGammaB_Int32 = "CollisionBoundsColorGammaB";
static const char* const k_pch_CollisionBounds_ColorGammaA_Int32 = "CollisionBoundsColorGammaA";
static const char* const k_pch_CollisionBounds_EnableDriverImport = "enableDriverBoundsImport";
static const char* const k_pch_Camera_Section = "camera";
static const char* const k_pch_Camera_EnableCamera_Bool = "enableCamera";
static const char* const k_pch_Camera_ShowOnController_Bool = "showOnController";
static const char* const k_pch_Camera_EnableCameraForCollisionBounds_Bool = "enableCameraForCollisionBounds";
static const char* const k_pch_Camera_RoomView_Int32 = "roomView";
static const char* const k_pch_Camera_BoundsColorGammaR_Int32 = "cameraBoundsColorGammaR";
static const char* const k_pch_Camera_BoundsColorGammaG_Int32 = "cameraBoundsColorGammaG";
static const char* const k_pch_Camera_BoundsColorGammaB_Int32 = "cameraBoundsColorGammaB";
static const char* const k_pch_Camera_BoundsColorGammaA_Int32 = "cameraBoundsColorGammaA";
static const char* const k_pch_Camera_BoundsStrength_Int32 = "cameraBoundsStrength";
static const char* const k_pch_Camera_RoomViewStyle_Int32 = "roomViewStyle";
static const char* const k_pch_audio_Section = "audio";
static const char* const k_pch_audio_SetOsDefaultPlaybackDevice_Bool = "setOsDefaultPlaybackDevice";
static const char* const k_pch_audio_EnablePlaybackDeviceOverride_Bool = "enablePlaybackDeviceOverride";
static const char* const k_pch_audio_PlaybackDeviceOverride_String = "playbackDeviceOverride";
static const char* const k_pch_audio_PlaybackDeviceOverrideName_String = "playbackDeviceOverrideName";
static const char* const k_pch_audio_SetOsDefaultRecordingDevice_Bool = "setOsDefaultRecordingDevice";
static const char* const k_pch_audio_EnableRecordingDeviceOverride_Bool = "enableRecordingDeviceOverride";
static const char* const k_pch_audio_RecordingDeviceOverride_String = "recordingDeviceOverride";
static const char* const k_pch_audio_RecordingDeviceOverrideName_String = "recordingDeviceOverrideName";
static const char* const k_pch_audio_EnablePlaybackMirror_Bool = "enablePlaybackMirror";
static const char* const k_pch_audio_PlaybackMirrorDevice_String = "playbackMirrorDevice";
static const char* const k_pch_audio_PlaybackMirrorDeviceName_String = "playbackMirrorDeviceName";
static const char* const k_pch_audio_OldPlaybackMirrorDevice_String = "onPlaybackMirrorDevice";
static const char* const k_pch_audio_ActiveMirrorDevice_String = "activePlaybackMirrorDevice";
static const char* const k_pch_audio_EnablePlaybackMirrorIndependentVolume_Bool = "enablePlaybackMirrorIndependentVolume";
static const char* const k_pch_audio_LastHmdPlaybackDeviceId_String = "lastHmdPlaybackDeviceId";
static const char* const k_pch_audio_VIVEHDMIGain = "viveHDMIGain";
static const char* const k_pch_audio_DualSpeakerAndJackOutput_Bool = "dualSpeakerAndJackOutput";
static const char* const k_pch_audio_MuteMicMonitor_Bool = "muteMicMonitor";
static const char* const k_pch_Power_Section = "power";
static const char* const k_pch_Power_PowerOffOnExit_Bool = "powerOffOnExit";
static const char* const k_pch_Power_TurnOffScreensTimeout_Float = "turnOffScreensTimeout";
static const char* const k_pch_Power_TurnOffControllersTimeout_Float = "turnOffControllersTimeout";
static const char* const k_pch_Power_ReturnToWatchdogTimeout_Float = "returnToWatchdogTimeout";
static const char* const k_pch_Power_AutoLaunchSteamVROnButtonPress = "autoLaunchSteamVROnButtonPress";
static const char* const k_pch_Power_PauseCompositorOnStandby_Bool = "pauseCompositorOnStandby";
static const char* const k_pch_Dashboard_Section = "dashboard";
static const char* const k_pch_Dashboard_EnableDashboard_Bool = "enableDashboard";
static const char* const k_pch_Dashboard_ArcadeMode_Bool = "arcadeMode";
static const char* const k_pch_Dashboard_Position = "position";
static const char* const k_pch_Dashboard_DesktopScale = "desktopScale";
static const char* const k_pch_Dashboard_DashboardScale = "dashboardScale";
static const char* const k_pch_Dashboard_UseStandaloneSystemLayer = "standaloneSystemLayer";
static const char* const k_pch_Dashboard_StickyDashboard = "stickyDashboard";
static const char* const k_pch_modelskin_Section = "modelskins";
static const char* const k_pch_Driver_Enable_Bool = "enable";
static const char* const k_pch_Driver_BlockedBySafemode_Bool = "blocked_by_safe_mode";
static const char* const k_pch_Driver_LoadPriority_Int32 = "loadPriority";
static const char* const k_pch_WebInterface_Section = "WebInterface";
static const char* const k_pch_VRWebHelper_Section = "VRWebHelper";
static const char* const k_pch_VRWebHelper_DebuggerEnabled_Bool = "DebuggerEnabled";
static const char* const k_pch_VRWebHelper_DebuggerPort_Int32 = "DebuggerPort";
static const char* const k_pch_TrackingOverride_Section = "TrackingOverrides";
static const char* const k_pch_App_BindingAutosaveURLSuffix_String = "AutosaveURL";
static const char* const k_pch_App_BindingLegacyAPISuffix_String = "_legacy";
static const char* const k_pch_App_BindingSteamVRInputAPISuffix_String = "_steamvrinput";
static const char* const k_pch_App_BindingCurrentURLSuffix_String = "CurrentURL";
static const char* const k_pch_App_BindingPreviousURLSuffix_String = "PreviousURL";
static const char* const k_pch_App_NeedToUpdateAutosaveSuffix_Bool = "NeedToUpdateAutosave";
static const char* const k_pch_App_DominantHand_Int32 = "DominantHand";
static const char* const k_pch_App_BlockOculusSDK_Bool = "blockOculusSDK";
static const char* const k_pch_Trackers_Section = "trackers";
static const char* const k_pch_DesktopUI_Section = "DesktopUI";
static const char* const k_pch_LastKnown_Section = "LastKnown";
static const char* const k_pch_LastKnown_HMDManufacturer_String = "HMDManufacturer";
static const char* const k_pch_LastKnown_HMDModel_String = "HMDModel";
static const char* const k_pch_DismissedWarnings_Section = "DismissedWarnings";
static const char* const k_pch_Input_Section = "input";
static const char* const k_pch_Input_LeftThumbstickRotation_Float = "leftThumbstickRotation";
static const char* const k_pch_Input_RightThumbstickRotation_Float = "rightThumbstickRotation";
static const char* const k_pch_Input_ThumbstickDeadzone_Float = "thumbstickDeadzone";
static const char* const k_pch_GpuSpeed_Section = "GpuSpeed";
}
namespace vr {
#pragma pack(push, 8)
enum ChaperoneCalibrationState {
    ChaperoneCalibrationState_OK = 1,
    ChaperoneCalibrationState_Warning = 100,
    ChaperoneCalibrationState_Warning_BaseStationMayHaveMoved = 101,
    ChaperoneCalibrationState_Warning_BaseStationRemoved = 102,
    ChaperoneCalibrationState_Warning_SeatedBoundsInvalid = 103,
    ChaperoneCalibrationState_Error = 200,
    ChaperoneCalibrationState_Error_BaseStationUninitialized = 201,
    ChaperoneCalibrationState_Error_BaseStationConflict = 202,
    ChaperoneCalibrationState_Error_PlayAreaInvalid = 203,
    ChaperoneCalibrationState_Error_CollisionBoundsInvalid = 204,
};
class IVRChaperone {
public:
    virtual ChaperoneCalibrationState GetCalibrationState() = 0;
    virtual bool GetPlayAreaSize(float* pSizeX, float* pSizeZ) = 0;
    virtual bool GetPlayAreaRect(HmdQuad_t* rect) = 0;
    virtual void ReloadInfo(void) = 0;
    virtual void SetSceneColor(HmdColor_t color) = 0;
    virtual void GetBoundsColor(HmdColor_t* pOutputColorArray, int nNumOutputColors, float flCollisionBoundsFadeDistance, HmdColor_t* pOutputCameraColor) = 0;
    virtual bool AreBoundsVisible() = 0;
    virtual void ForceBoundsVisible(bool bForce) = 0;
    virtual void ResetZeroPose(ETrackingUniverseOrigin eTrackingUniverseOrigin) = 0;
};
static const char* const IVRChaperone_Version = "IVRChaperone_004";
#pragma pack(pop)
}
namespace vr {
enum EChaperoneConfigFile {
    EChaperoneConfigFile_Live = 1,
    EChaperoneConfigFile_Temp = 2,
};
enum EChaperoneImportFlags {
    EChaperoneImport_BoundsOnly = 0x0001,
};
class IVRChaperoneSetup {
public:
    virtual bool CommitWorkingCopy(EChaperoneConfigFile configFile) = 0;
    virtual void RevertWorkingCopy() = 0;
    virtual bool GetWorkingPlayAreaSize(float* pSizeX, float* pSizeZ) = 0;
    virtual bool GetWorkingPlayAreaRect(HmdQuad_t* rect) = 0;
    virtual bool GetWorkingCollisionBoundsInfo(HmdQuad_t* pQuadsBuffer, uint32_t* punQuadsCount) = 0;
    virtual bool GetLiveCollisionBoundsInfo(HmdQuad_t* pQuadsBuffer, uint32_t* punQuadsCount) = 0;
    virtual bool GetWorkingSeatedZeroPoseToRawTrackingPose(HmdMatrix34_t* pmatSeatedZeroPoseToRawTrackingPose) = 0;
    virtual bool GetWorkingStandingZeroPoseToRawTrackingPose(HmdMatrix34_t* pmatStandingZeroPoseToRawTrackingPose) = 0;
    virtual void SetWorkingPlayAreaSize(float sizeX, float sizeZ) = 0;
    virtual void SetWorkingCollisionBoundsInfo(HmdQuad_t* pQuadsBuffer, uint32_t unQuadsCount) = 0;
    virtual void SetWorkingPerimeter(HmdVector2_t* pPointBuffer, uint32_t unPointCount) = 0;
    virtual void SetWorkingSeatedZeroPoseToRawTrackingPose(const HmdMatrix34_t* pMatSeatedZeroPoseToRawTrackingPose) = 0;
    virtual void SetWorkingStandingZeroPoseToRawTrackingPose(const HmdMatrix34_t* pMatStandingZeroPoseToRawTrackingPose) = 0;
    virtual void ReloadFromDisk(EChaperoneConfigFile configFile) = 0;
    virtual bool GetLiveSeatedZeroPoseToRawTrackingPose(HmdMatrix34_t* pmatSeatedZeroPoseToRawTrackingPose) = 0;
    virtual bool ExportLiveToBuffer(char* pBuffer, uint32_t* pnBufferLength) = 0;
    virtual bool ImportFromBufferToWorking(const char* pBuffer, uint32_t nImportFlags) = 0;
    virtual void ShowWorkingSetPreview() = 0;
    virtual void HideWorkingSetPreview() = 0;
    virtual void RoomSetupStarting() = 0;
};
static const char* const IVRChaperoneSetup_Version = "IVRChaperoneSetup_006";
}
namespace vr {
#pragma pack(push, 8)
enum EVRCompositorError {
    VRCompositorError_None = 0,
    VRCompositorError_RequestFailed = 1,
    VRCompositorError_IncompatibleVersion = 100,
    VRCompositorError_DoNotHaveFocus = 101,
    VRCompositorError_InvalidTexture = 102,
    VRCompositorError_IsNotSceneApplication = 103,
    VRCompositorError_TextureIsOnWrongDevice = 104,
    VRCompositorError_TextureUsesUnsupportedFormat = 105,
    VRCompositorError_SharedTexturesNotSupported = 106,
    VRCompositorError_IndexOutOfRange = 107,
    VRCompositorError_AlreadySubmitted = 108,
    VRCompositorError_InvalidBounds = 109,
    VRCompositorError_AlreadySet = 110,
};
enum EVRCompositorTimingMode {
    VRCompositorTimingMode_Implicit = 0,
    VRCompositorTimingMode_Explicit_RuntimePerformsPostPresentHandoff = 1,
    VRCompositorTimingMode_Explicit_ApplicationPerformsPostPresentHandoff = 2,
};
struct Compositor_CumulativeStats {
    uint32_t m_nPid;
    uint32_t m_nNumFramePresents;
    uint32_t m_nNumDroppedFrames;
    uint32_t m_nNumReprojectedFrames;
    uint32_t m_nNumFramePresentsOnStartup;
    uint32_t m_nNumDroppedFramesOnStartup;
    uint32_t m_nNumReprojectedFramesOnStartup;
    uint32_t m_nNumLoading;
    uint32_t m_nNumFramePresentsLoading;
    uint32_t m_nNumDroppedFramesLoading;
    uint32_t m_nNumReprojectedFramesLoading;
    uint32_t m_nNumTimedOut;
    uint32_t m_nNumFramePresentsTimedOut;
    uint32_t m_nNumDroppedFramesTimedOut;
    uint32_t m_nNumReprojectedFramesTimedOut;
};
struct Compositor_StageRenderSettings {
    HmdColor_t m_PrimaryColor;
    HmdColor_t m_SecondaryColor;
    float m_flVignetteInnerRadius;
    float m_flVignetteOuterRadius;
    float m_flFresnelStrength;
    bool m_bBackfaceCulling;
    bool m_bGreyscale;
    bool m_bWireframe;
};
static inline Compositor_StageRenderSettings DefaultStageRenderSettings()
{
    Compositor_StageRenderSettings settings;
    settings.m_PrimaryColor.r = 1.0f;
    settings.m_PrimaryColor.g = 1.0f;
    settings.m_PrimaryColor.b = 1.0f;
    settings.m_PrimaryColor.a = 1.0f;
    settings.m_SecondaryColor.r = 1.0f;
    settings.m_SecondaryColor.g = 1.0f;
    settings.m_SecondaryColor.b = 1.0f;
    settings.m_SecondaryColor.a = 1.0f;
    settings.m_flVignetteInnerRadius = 0.0f;
    settings.m_flVignetteOuterRadius = 0.0f;
    settings.m_flFresnelStrength = 0.0f;
    settings.m_bBackfaceCulling = false;
    settings.m_bGreyscale = false;
    settings.m_bWireframe = false;
    return settings;
}
#pragma pack(pop)
class IVRCompositor {
public:
    virtual void SetTrackingSpace(ETrackingUniverseOrigin eOrigin) = 0;
    virtual ETrackingUniverseOrigin GetTrackingSpace() = 0;
    virtual EVRCompositorError WaitGetPoses(TrackedDevicePose_t* pRenderPoseArray, uint32_t unRenderPoseArrayCount,
        TrackedDevicePose_t* pGamePoseArray, uint32_t unGamePoseArrayCount)
        = 0;
    virtual EVRCompositorError GetLastPoses(TrackedDevicePose_t* pRenderPoseArray, uint32_t unRenderPoseArrayCount,
        TrackedDevicePose_t* pGamePoseArray, uint32_t unGamePoseArrayCount)
        = 0;
    virtual EVRCompositorError GetLastPoseForTrackedDeviceIndex(TrackedDeviceIndex_t unDeviceIndex, TrackedDevicePose_t* pOutputPose, TrackedDevicePose_t* pOutputGamePose) = 0;
    virtual EVRCompositorError Submit(EVREye eEye, const Texture_t* pTexture, const VRTextureBounds_t* pBounds = 0, EVRSubmitFlags nSubmitFlags = Submit_Default) = 0;
    virtual void ClearLastSubmittedFrame() = 0;
    virtual void PostPresentHandoff() = 0;
    virtual bool GetFrameTiming(Compositor_FrameTiming* pTiming, uint32_t unFramesAgo = 0) = 0;
    virtual uint32_t GetFrameTimings(Compositor_FrameTiming* pTiming, uint32_t nFrames) = 0;
    virtual float GetFrameTimeRemaining() = 0;
    virtual void GetCumulativeStats(Compositor_CumulativeStats* pStats, uint32_t nStatsSizeInBytes) = 0;
    virtual void FadeToColor(float fSeconds, float fRed, float fGreen, float fBlue, float fAlpha, bool bBackground = false) = 0;
    virtual HmdColor_t GetCurrentFadeColor(bool bBackground = false) = 0;
    virtual void FadeGrid(float fSeconds, bool bFadeGridIn) = 0;
    virtual float GetCurrentGridAlpha() = 0;
    virtual EVRCompositorError SetSkyboxOverride(const Texture_t* pTextures, uint32_t unTextureCount) = 0;
    virtual void ClearSkyboxOverride() = 0;
    virtual void CompositorBringToFront() = 0;
    virtual void CompositorGoToBack() = 0;
    virtual void CompositorQuit() = 0;
    virtual bool IsFullscreen() = 0;
    virtual uint32_t GetCurrentSceneFocusProcess() = 0;
    virtual uint32_t GetLastFrameRenderer() = 0;
    virtual bool CanRenderScene() = 0;
    virtual void ShowMirrorWindow() = 0;
    virtual void HideMirrorWindow() = 0;
    virtual bool IsMirrorWindowVisible() = 0;
    virtual void CompositorDumpImages() = 0;
    virtual bool ShouldAppRenderWithLowResources() = 0;
    virtual void ForceInterleavedReprojectionOn(bool bOverride) = 0;
    virtual void ForceReconnectProcess() = 0;
    virtual void SuspendRendering(bool bSuspend) = 0;
    virtual vr::EVRCompositorError GetMirrorTextureD3D11(vr::EVREye eEye, void* pD3D11DeviceOrResource, void** ppD3D11ShaderResourceView) = 0;
    virtual void ReleaseMirrorTextureD3D11(void* pD3D11ShaderResourceView) = 0;
    virtual vr::EVRCompositorError GetMirrorTextureGL(vr::EVREye eEye, vr::glUInt_t* pglTextureId, vr::glSharedTextureHandle_t* pglSharedTextureHandle) = 0;
    virtual bool ReleaseSharedGLTexture(vr::glUInt_t glTextureId, vr::glSharedTextureHandle_t glSharedTextureHandle) = 0;
    virtual void LockGLSharedTextureForAccess(vr::glSharedTextureHandle_t glSharedTextureHandle) = 0;
    virtual void UnlockGLSharedTextureForAccess(vr::glSharedTextureHandle_t glSharedTextureHandle) = 0;
    virtual uint32_t GetVulkanInstanceExtensionsRequired(char* pchValue, uint32_t unBufferSize) = 0;
    virtual uint32_t GetVulkanDeviceExtensionsRequired(VkPhysicalDevice_T* pPhysicalDevice, char* pchValue, uint32_t unBufferSize) = 0;
    virtual void SetExplicitTimingMode(EVRCompositorTimingMode eTimingMode) = 0;
    virtual EVRCompositorError SubmitExplicitTimingData() = 0;
    virtual bool IsMotionSmoothingEnabled() = 0;
    virtual bool IsMotionSmoothingSupported() = 0;
    virtual bool IsCurrentSceneFocusAppLoading() = 0;
    virtual EVRCompositorError SetStageOverride_Async(const char* pchRenderModelPath, const HmdMatrix34_t* pTransform = 0,
        const Compositor_StageRenderSettings* pRenderSettings = 0, uint32_t nSizeOfRenderSettings = 0)
        = 0;
    virtual void ClearStageOverride() = 0;
    virtual bool GetCompositorBenchmarkResults(Compositor_BenchmarkResults* pBenchmarkResults, uint32_t nSizeOfBenchmarkResults) = 0;
    virtual EVRCompositorError GetLastPosePredictionIDs(uint32_t* pRenderPosePredictionID, uint32_t* pGamePosePredictionID) = 0;
    virtual EVRCompositorError GetPosesForFrame(uint32_t unPosePredictionID, TrackedDevicePose_t* pPoseArray, uint32_t unPoseArrayCount) = 0;
};
static const char* const IVRCompositor_Version = "IVRCompositor_027";
}
namespace vr {
enum HeadsetViewMode_t {
    HeadsetViewMode_Left = 0,
    HeadsetViewMode_Right,
    HeadsetViewMode_Both
};
class IVRHeadsetView {
public:
    virtual void SetHeadsetViewSize(uint32_t nWidth, uint32_t nHeight) = 0;
    virtual void GetHeadsetViewSize(uint32_t* pnWidth, uint32_t* pnHeight) = 0;
    virtual void SetHeadsetViewMode(HeadsetViewMode_t eHeadsetViewMode) = 0;
    virtual HeadsetViewMode_t GetHeadsetViewMode() = 0;
    virtual void SetHeadsetViewCropped(bool bCropped) = 0;
    virtual bool GetHeadsetViewCropped() = 0;
    virtual float GetHeadsetViewAspectRatio() = 0;
    virtual void SetHeadsetViewBlendRange(float flStartPct, float flEndPct) = 0;
    virtual void GetHeadsetViewBlendRange(float* pStartPct, float* pEndPct) = 0;
};
static const uint32_t k_unHeadsetViewMaxWidth = 3840;
static const uint32_t k_unHeadsetViewMaxHeight = 2160;
static const char* const k_pchHeadsetViewOverlayKey = "system.HeadsetView";
static const char* const IVRHeadsetView_Version = "IVRHeadsetView_001";
extern "C" __declspec(dllimport) vr::IVRHeadsetView* __cdecl VRHeadsetView();
}
namespace vr {
#pragma pack(push, 8)
struct NotificationBitmap_t {
    NotificationBitmap_t()
        : m_pImageData(nullptr)
        , m_nWidth(0)
        , m_nHeight(0)
        , m_nBytesPerPixel(0)
    {
    }
    void* m_pImageData;
    int32_t m_nWidth;
    int32_t m_nHeight;
    int32_t m_nBytesPerPixel;
};
enum EVRNotificationType {
    EVRNotificationType_Transient = 0,
    EVRNotificationType_Persistent = 1,
    EVRNotificationType_Transient_SystemWithUserValue = 2,
};
enum EVRNotificationStyle {
    EVRNotificationStyle_None = 0,
    EVRNotificationStyle_Application = 100,
    EVRNotificationStyle_Contact_Disabled = 200,
    EVRNotificationStyle_Contact_Enabled = 201,
    EVRNotificationStyle_Contact_Active = 202,
};
static const uint32_t k_unNotificationTextMaxSize = 256;
typedef uint32_t VRNotificationId;
#pragma pack(pop)
class IVRNotifications {
public:
    virtual EVRNotificationError CreateNotification(VROverlayHandle_t ulOverlayHandle, uint64_t ulUserValue, EVRNotificationType type, const char* pchText, EVRNotificationStyle style, const NotificationBitmap_t* pImage, VRNotificationId* pNotificationId) = 0;
    virtual EVRNotificationError RemoveNotification(VRNotificationId notificationId) = 0;
};
static const char* const IVRNotifications_Version = "IVRNotifications_002";
}
namespace vr {
static const uint32_t k_unVROverlayMaxKeyLength = 128;
static const uint32_t k_unVROverlayMaxNameLength = 128;
static const uint32_t k_unMaxOverlayCount = 128;
static const uint32_t k_unMaxOverlayIntersectionMaskPrimitivesCount = 32;
enum VROverlayInputMethod {
    VROverlayInputMethod_None = 0,
    VROverlayInputMethod_Mouse = 1,
};
enum VROverlayTransformType {
    VROverlayTransform_Invalid = -1,
    VROverlayTransform_Absolute = 0,
    VROverlayTransform_TrackedDeviceRelative = 1,
    VROverlayTransform_SystemOverlay = 2,
    VROverlayTransform_TrackedComponent = 3,
    VROverlayTransform_Cursor = 4,
    VROverlayTransform_DashboardTab = 5,
    VROverlayTransform_DashboardThumb = 6,
    VROverlayTransform_Mountable = 7,
    VROverlayTransform_Projection = 8,
};
enum VROverlayFlags {
    VROverlayFlags_NoDashboardTab = 1 << 3,
    VROverlayFlags_SendVRDiscreteScrollEvents = 1 << 6,
    VROverlayFlags_SendVRTouchpadEvents = 1 << 7,
    VROverlayFlags_ShowTouchPadScrollWheel = 1 << 8,
    VROverlayFlags_TransferOwnershipToInternalProcess = 1 << 9,
    VROverlayFlags_SideBySide_Parallel = 1 << 10,
    VROverlayFlags_SideBySide_Crossed = 1 << 11,
    VROverlayFlags_Panorama = 1 << 12,
    VROverlayFlags_StereoPanorama = 1 << 13,
    VROverlayFlags_SortWithNonSceneOverlays = 1 << 14,
    VROverlayFlags_VisibleInDashboard = 1 << 15,
    VROverlayFlags_MakeOverlaysInteractiveIfVisible = 1 << 16,
    VROverlayFlags_SendVRSmoothScrollEvents = 1 << 17,
    VROverlayFlags_ProtectedContent = 1 << 18,
    VROverlayFlags_HideLaserIntersection = 1 << 19,
    VROverlayFlags_WantsModalBehavior = 1 << 20,
    VROverlayFlags_IsPremultiplied = 1 << 21,
    VROverlayFlags_IgnoreTextureAlpha = 1 << 22,
};
enum VRMessageOverlayResponse {
    VRMessageOverlayResponse_ButtonPress_0 = 0,
    VRMessageOverlayResponse_ButtonPress_1 = 1,
    VRMessageOverlayResponse_ButtonPress_2 = 2,
    VRMessageOverlayResponse_ButtonPress_3 = 3,
    VRMessageOverlayResponse_CouldntFindSystemOverlay = 4,
    VRMessageOverlayResponse_CouldntFindOrCreateClientOverlay = 5,
    VRMessageOverlayResponse_ApplicationQuit = 6
};
struct VROverlayIntersectionParams_t {
    HmdVector3_t vSource;
    HmdVector3_t vDirection;
    ETrackingUniverseOrigin eOrigin;
};
struct VROverlayIntersectionResults_t {
    HmdVector3_t vPoint;
    HmdVector3_t vNormal;
    HmdVector2_t vUVs;
    float fDistance;
};
enum EGamepadTextInputMode {
    k_EGamepadTextInputModeNormal = 0,
    k_EGamepadTextInputModePassword = 1,
    k_EGamepadTextInputModeSubmit = 2,
};
enum EGamepadTextInputLineMode {
    k_EGamepadTextInputLineModeSingleLine = 0,
    k_EGamepadTextInputLineModeMultipleLines = 1
};
enum EVROverlayIntersectionMaskPrimitiveType {
    OverlayIntersectionPrimitiveType_Rectangle,
    OverlayIntersectionPrimitiveType_Circle,
};
struct IntersectionMaskRectangle_t {
    float m_flTopLeftX;
    float m_flTopLeftY;
    float m_flWidth;
    float m_flHeight;
};
struct IntersectionMaskCircle_t {
    float m_flCenterX;
    float m_flCenterY;
    float m_flRadius;
};
typedef union {
    IntersectionMaskRectangle_t m_Rectangle;
    IntersectionMaskCircle_t m_Circle;
} VROverlayIntersectionMaskPrimitive_Data_t;
struct VROverlayIntersectionMaskPrimitive_t {
    EVROverlayIntersectionMaskPrimitiveType m_nPrimitiveType;
    VROverlayIntersectionMaskPrimitive_Data_t m_Primitive;
};
enum EKeyboardFlags {
    KeyboardFlag_Minimal = 1 << 0,
    KeyboardFlag_Modal = 2 << 0,
};
struct VROverlayProjection_t {
    float fLeft;
    float fRight;
    float fTop;
    float fBottom;
};
class IVROverlay {
public:
    virtual EVROverlayError FindOverlay(const char* pchOverlayKey, VROverlayHandle_t* pOverlayHandle) = 0;
    virtual EVROverlayError CreateOverlay(const char* pchOverlayKey, const char* pchOverlayName, VROverlayHandle_t* pOverlayHandle) = 0;
    virtual EVROverlayError DestroyOverlay(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual uint32_t GetOverlayKey(VROverlayHandle_t ulOverlayHandle, char* pchValue, uint32_t unBufferSize, EVROverlayError* pError = 0L) = 0;
    virtual uint32_t GetOverlayName(VROverlayHandle_t ulOverlayHandle, char* pchValue, uint32_t unBufferSize, EVROverlayError* pError = 0L) = 0;
    virtual EVROverlayError SetOverlayName(VROverlayHandle_t ulOverlayHandle, const char* pchName) = 0;
    virtual EVROverlayError GetOverlayImageData(VROverlayHandle_t ulOverlayHandle, void* pvBuffer, uint32_t unBufferSize, uint32_t* punWidth, uint32_t* punHeight) = 0;
    virtual const char* GetOverlayErrorNameFromEnum(EVROverlayError error) = 0;
    virtual EVROverlayError SetOverlayRenderingPid(VROverlayHandle_t ulOverlayHandle, uint32_t unPID) = 0;
    virtual uint32_t GetOverlayRenderingPid(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError SetOverlayFlag(VROverlayHandle_t ulOverlayHandle, VROverlayFlags eOverlayFlag, bool bEnabled) = 0;
    virtual EVROverlayError GetOverlayFlag(VROverlayHandle_t ulOverlayHandle, VROverlayFlags eOverlayFlag, bool* pbEnabled) = 0;
    virtual EVROverlayError GetOverlayFlags(VROverlayHandle_t ulOverlayHandle, uint32_t* pFlags) = 0;
    virtual EVROverlayError SetOverlayColor(VROverlayHandle_t ulOverlayHandle, float fRed, float fGreen, float fBlue) = 0;
    virtual EVROverlayError GetOverlayColor(VROverlayHandle_t ulOverlayHandle, float* pfRed, float* pfGreen, float* pfBlue) = 0;
    virtual EVROverlayError SetOverlayAlpha(VROverlayHandle_t ulOverlayHandle, float fAlpha) = 0;
    virtual EVROverlayError GetOverlayAlpha(VROverlayHandle_t ulOverlayHandle, float* pfAlpha) = 0;
    virtual EVROverlayError SetOverlayTexelAspect(VROverlayHandle_t ulOverlayHandle, float fTexelAspect) = 0;
    virtual EVROverlayError GetOverlayTexelAspect(VROverlayHandle_t ulOverlayHandle, float* pfTexelAspect) = 0;
    virtual EVROverlayError SetOverlaySortOrder(VROverlayHandle_t ulOverlayHandle, uint32_t unSortOrder) = 0;
    virtual EVROverlayError GetOverlaySortOrder(VROverlayHandle_t ulOverlayHandle, uint32_t* punSortOrder) = 0;
    virtual EVROverlayError SetOverlayWidthInMeters(VROverlayHandle_t ulOverlayHandle, float fWidthInMeters) = 0;
    virtual EVROverlayError GetOverlayWidthInMeters(VROverlayHandle_t ulOverlayHandle, float* pfWidthInMeters) = 0;
    virtual EVROverlayError SetOverlayCurvature(VROverlayHandle_t ulOverlayHandle, float fCurvature) = 0;
    virtual EVROverlayError GetOverlayCurvature(VROverlayHandle_t ulOverlayHandle, float* pfCurvature) = 0;
    virtual EVROverlayError SetOverlayPreCurvePitch(VROverlayHandle_t ulOverlayHandle, float fRadians) = 0;
    virtual EVROverlayError GetOverlayPreCurvePitch(VROverlayHandle_t ulOverlayHandle, float* pfRadians) = 0;
    virtual EVROverlayError SetOverlayTextureColorSpace(VROverlayHandle_t ulOverlayHandle, EColorSpace eTextureColorSpace) = 0;
    virtual EVROverlayError GetOverlayTextureColorSpace(VROverlayHandle_t ulOverlayHandle, EColorSpace* peTextureColorSpace) = 0;
    virtual EVROverlayError SetOverlayTextureBounds(VROverlayHandle_t ulOverlayHandle, const VRTextureBounds_t* pOverlayTextureBounds) = 0;
    virtual EVROverlayError GetOverlayTextureBounds(VROverlayHandle_t ulOverlayHandle, VRTextureBounds_t* pOverlayTextureBounds) = 0;
    virtual EVROverlayError GetOverlayTransformType(VROverlayHandle_t ulOverlayHandle, VROverlayTransformType* peTransformType) = 0;
    virtual EVROverlayError SetOverlayTransformAbsolute(VROverlayHandle_t ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, const HmdMatrix34_t* pmatTrackingOriginToOverlayTransform) = 0;
    virtual EVROverlayError GetOverlayTransformAbsolute(VROverlayHandle_t ulOverlayHandle, ETrackingUniverseOrigin* peTrackingOrigin, HmdMatrix34_t* pmatTrackingOriginToOverlayTransform) = 0;
    virtual EVROverlayError SetOverlayTransformTrackedDeviceRelative(VROverlayHandle_t ulOverlayHandle, TrackedDeviceIndex_t unTrackedDevice, const HmdMatrix34_t* pmatTrackedDeviceToOverlayTransform) = 0;
    virtual EVROverlayError GetOverlayTransformTrackedDeviceRelative(VROverlayHandle_t ulOverlayHandle, TrackedDeviceIndex_t* punTrackedDevice, HmdMatrix34_t* pmatTrackedDeviceToOverlayTransform) = 0;
    virtual EVROverlayError SetOverlayTransformTrackedDeviceComponent(VROverlayHandle_t ulOverlayHandle, TrackedDeviceIndex_t unDeviceIndex, const char* pchComponentName) = 0;
    virtual EVROverlayError GetOverlayTransformTrackedDeviceComponent(VROverlayHandle_t ulOverlayHandle, TrackedDeviceIndex_t* punDeviceIndex, char* pchComponentName, uint32_t unComponentNameSize) = 0;
    virtual vr::EVROverlayError GetOverlayTransformOverlayRelative(VROverlayHandle_t ulOverlayHandle, VROverlayHandle_t* ulOverlayHandleParent, HmdMatrix34_t* pmatParentOverlayToOverlayTransform) = 0;
    virtual vr::EVROverlayError SetOverlayTransformOverlayRelative(VROverlayHandle_t ulOverlayHandle, VROverlayHandle_t ulOverlayHandleParent, const HmdMatrix34_t* pmatParentOverlayToOverlayTransform) = 0;
    virtual EVROverlayError SetOverlayTransformCursor(VROverlayHandle_t ulCursorOverlayHandle, const HmdVector2_t* pvHotspot) = 0;
    virtual vr::EVROverlayError GetOverlayTransformCursor(VROverlayHandle_t ulOverlayHandle, HmdVector2_t* pvHotspot) = 0;
    virtual vr::EVROverlayError SetOverlayTransformProjection(VROverlayHandle_t ulOverlayHandle,
        ETrackingUniverseOrigin eTrackingOrigin, const HmdMatrix34_t* pmatTrackingOriginToOverlayTransform,
        const VROverlayProjection_t* pProjection, vr::EVREye eEye)
        = 0;
    virtual EVROverlayError ShowOverlay(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError HideOverlay(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual bool IsOverlayVisible(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError GetTransformForOverlayCoordinates(VROverlayHandle_t ulOverlayHandle, ETrackingUniverseOrigin eTrackingOrigin, HmdVector2_t coordinatesInOverlay, HmdMatrix34_t* pmatTransform) = 0;
    virtual EVROverlayError WaitFrameSync(uint32_t nTimeoutMs) = 0;
    virtual bool PollNextOverlayEvent(VROverlayHandle_t ulOverlayHandle, VREvent_t* pEvent, uint32_t uncbVREvent) = 0;
    virtual EVROverlayError GetOverlayInputMethod(VROverlayHandle_t ulOverlayHandle, VROverlayInputMethod* peInputMethod) = 0;
    virtual EVROverlayError SetOverlayInputMethod(VROverlayHandle_t ulOverlayHandle, VROverlayInputMethod eInputMethod) = 0;
    virtual EVROverlayError GetOverlayMouseScale(VROverlayHandle_t ulOverlayHandle, HmdVector2_t* pvecMouseScale) = 0;
    virtual EVROverlayError SetOverlayMouseScale(VROverlayHandle_t ulOverlayHandle, const HmdVector2_t* pvecMouseScale) = 0;
    virtual bool ComputeOverlayIntersection(VROverlayHandle_t ulOverlayHandle, const VROverlayIntersectionParams_t* pParams, VROverlayIntersectionResults_t* pResults) = 0;
    virtual bool IsHoverTargetOverlay(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError SetOverlayIntersectionMask(VROverlayHandle_t ulOverlayHandle, VROverlayIntersectionMaskPrimitive_t* pMaskPrimitives, uint32_t unNumMaskPrimitives, uint32_t unPrimitiveSize = sizeof(VROverlayIntersectionMaskPrimitive_t)) = 0;
    virtual EVROverlayError TriggerLaserMouseHapticVibration(VROverlayHandle_t ulOverlayHandle, float fDurationSeconds, float fFrequency, float fAmplitude) = 0;
    virtual EVROverlayError SetOverlayCursor(VROverlayHandle_t ulOverlayHandle, VROverlayHandle_t ulCursorHandle) = 0;
    virtual EVROverlayError SetOverlayCursorPositionOverride(VROverlayHandle_t ulOverlayHandle, const HmdVector2_t* pvCursor) = 0;
    virtual EVROverlayError ClearOverlayCursorPositionOverride(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError SetOverlayTexture(VROverlayHandle_t ulOverlayHandle, const Texture_t* pTexture) = 0;
    virtual EVROverlayError ClearOverlayTexture(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError SetOverlayRaw(VROverlayHandle_t ulOverlayHandle, void* pvBuffer, uint32_t unWidth, uint32_t unHeight, uint32_t unBytesPerPixel) = 0;
    virtual EVROverlayError SetOverlayFromFile(VROverlayHandle_t ulOverlayHandle, const char* pchFilePath) = 0;
    virtual EVROverlayError GetOverlayTexture(VROverlayHandle_t ulOverlayHandle, void** pNativeTextureHandle, void* pNativeTextureRef, uint32_t* pWidth, uint32_t* pHeight, uint32_t* pNativeFormat, ETextureType* pAPIType, EColorSpace* pColorSpace, VRTextureBounds_t* pTextureBounds) = 0;
    virtual EVROverlayError ReleaseNativeOverlayHandle(VROverlayHandle_t ulOverlayHandle, void* pNativeTextureHandle) = 0;
    virtual EVROverlayError GetOverlayTextureSize(VROverlayHandle_t ulOverlayHandle, uint32_t* pWidth, uint32_t* pHeight) = 0;
    virtual EVROverlayError CreateDashboardOverlay(const char* pchOverlayKey, const char* pchOverlayFriendlyName, VROverlayHandle_t* pMainHandle, VROverlayHandle_t* pThumbnailHandle) = 0;
    virtual bool IsDashboardVisible() = 0;
    virtual bool IsActiveDashboardOverlay(VROverlayHandle_t ulOverlayHandle) = 0;
    virtual EVROverlayError SetDashboardOverlaySceneProcess(VROverlayHandle_t ulOverlayHandle, uint32_t unProcessId) = 0;
    virtual EVROverlayError GetDashboardOverlaySceneProcess(VROverlayHandle_t ulOverlayHandle, uint32_t* punProcessId) = 0;
    virtual void ShowDashboard(const char* pchOverlayToShow) = 0;
    virtual vr::TrackedDeviceIndex_t GetPrimaryDashboardDevice() = 0;
    virtual EVROverlayError ShowKeyboard(EGamepadTextInputMode eInputMode, EGamepadTextInputLineMode eLineInputMode, uint32_t unFlags,
        const char* pchDescription, uint32_t unCharMax, const char* pchExistingText, uint64_t uUserValue)
        = 0;
    virtual EVROverlayError ShowKeyboardForOverlay(VROverlayHandle_t ulOverlayHandle, EGamepadTextInputMode eInputMode,
        EGamepadTextInputLineMode eLineInputMode, uint32_t unFlags, const char* pchDescription, uint32_t unCharMax,
        const char* pchExistingText, uint64_t uUserValue)
        = 0;
    virtual uint32_t GetKeyboardText(char* pchText, uint32_t cchText) = 0;
    virtual void HideKeyboard() = 0;
    virtual void SetKeyboardTransformAbsolute(ETrackingUniverseOrigin eTrackingOrigin, const HmdMatrix34_t* pmatTrackingOriginToKeyboardTransform) = 0;
    virtual void SetKeyboardPositionForOverlay(VROverlayHandle_t ulOverlayHandle, HmdRect2_t avoidRect) = 0;
    virtual VRMessageOverlayResponse ShowMessageOverlay(const char* pchText, const char* pchCaption, const char* pchButton0Text, const char* pchButton1Text = nullptr, const char* pchButton2Text = nullptr, const char* pchButton3Text = nullptr) = 0;
    virtual void CloseMessageOverlay() = 0;
};
static const char* const IVROverlay_Version = "IVROverlay_026";
}
namespace vr {
struct VROverlayView_t {
    VROverlayHandle_t overlayHandle;
    Texture_t texture;
    VRTextureBounds_t textureBounds;
};
enum EDeviceType {
    DeviceType_Invalid = -1,
    DeviceType_DirectX11 = 0,
    DeviceType_Vulkan = 1,
};
struct VRVulkanDevice_t {
    VkInstance_T* m_pInstance;
    VkDevice_T* m_pDevice;
    VkPhysicalDevice_T* m_pPhysicalDevice;
    VkQueue_T* m_pQueue;
    uint32_t m_uQueueFamilyIndex;
};
struct VRNativeDevice_t {
    void* handle;
    EDeviceType eType;
};
class IVROverlayView {
public:
    virtual EVROverlayError AcquireOverlayView(VROverlayHandle_t ulOverlayHandle, VRNativeDevice_t* pNativeDevice, VROverlayView_t* pOverlayView, uint32_t unOverlayViewSize) = 0;
    virtual EVROverlayError ReleaseOverlayView(VROverlayView_t* pOverlayView) = 0;
    virtual void PostOverlayEvent(VROverlayHandle_t ulOverlayHandle, const VREvent_t* pvrEvent) = 0;
    virtual bool IsViewingPermitted(VROverlayHandle_t ulOverlayHandle) = 0;
};
static const char* const IVROverlayView_Version = "IVROverlayView_003";
}
namespace vr {
static const char* const k_pch_Controller_Component_GDC2015 = "gdc2015";
static const char* const k_pch_Controller_Component_Base = "base";
static const char* const k_pch_Controller_Component_Tip = "tip";
static const char* const k_pch_Controller_Component_HandGrip = "handgrip";
static const char* const k_pch_Controller_Component_Status = "status";
#pragma pack(push, 8)
enum EVRRenderModelError {
    VRRenderModelError_None = 0,
    VRRenderModelError_Loading = 100,
    VRRenderModelError_NotSupported = 200,
    VRRenderModelError_InvalidArg = 300,
    VRRenderModelError_InvalidModel = 301,
    VRRenderModelError_NoShapes = 302,
    VRRenderModelError_MultipleShapes = 303,
    VRRenderModelError_TooManyVertices = 304,
    VRRenderModelError_MultipleTextures = 305,
    VRRenderModelError_BufferTooSmall = 306,
    VRRenderModelError_NotEnoughNormals = 307,
    VRRenderModelError_NotEnoughTexCoords = 308,
    VRRenderModelError_InvalidTexture = 400,
};
enum EVRRenderModelTextureFormat {
    VRRenderModelTextureFormat_RGBA8_SRGB = 0,
    VRRenderModelTextureFormat_BC2,
    VRRenderModelTextureFormat_BC4,
    VRRenderModelTextureFormat_BC7,
    VRRenderModelTextureFormat_BC7_SRGB,
    VRRenderModelTextureFormat_RGBA16_FLOAT,
};
struct RenderModel_Vertex_t {
    HmdVector3_t vPosition;
    HmdVector3_t vNormal;
    float rfTextureCoord[2];
};
struct RenderModel_TextureMap_t {
    uint16_t unWidth, unHeight;
    const uint8_t* rubTextureMapData;
    EVRRenderModelTextureFormat format;
    uint16_t unMipLevels;
};
typedef int32_t TextureID_t;
const TextureID_t INVALID_TEXTURE_ID = -1;
struct RenderModel_t {
    const RenderModel_Vertex_t* rVertexData;
    uint32_t unVertexCount;
    const uint16_t* rIndexData;
    uint32_t unTriangleCount;
    TextureID_t diffuseTextureId;
};
struct RenderModel_ControllerMode_State_t {
    bool bScrollWheelVisible;
};
#pragma pack(pop)
class IVRRenderModels {
public:
    virtual EVRRenderModelError LoadRenderModel_Async(const char* pchRenderModelName, RenderModel_t** ppRenderModel) = 0;
    virtual void FreeRenderModel(RenderModel_t* pRenderModel) = 0;
    virtual EVRRenderModelError LoadTexture_Async(TextureID_t textureId, RenderModel_TextureMap_t** ppTexture) = 0;
    virtual void FreeTexture(RenderModel_TextureMap_t* pTexture) = 0;
    virtual EVRRenderModelError LoadTextureD3D11_Async(TextureID_t textureId, void* pD3D11Device, void** ppD3D11Texture2D) = 0;
    virtual EVRRenderModelError LoadIntoTextureD3D11_Async(TextureID_t textureId, void* pDstTexture) = 0;
    virtual void FreeTextureD3D11(void* pD3D11Texture2D) = 0;
    virtual uint32_t GetRenderModelName(uint32_t unRenderModelIndex, char* pchRenderModelName, uint32_t unRenderModelNameLen) = 0;
    virtual uint32_t GetRenderModelCount() = 0;
    virtual uint32_t GetComponentCount(const char* pchRenderModelName) = 0;
    virtual uint32_t GetComponentName(const char* pchRenderModelName, uint32_t unComponentIndex, char* pchComponentName, uint32_t unComponentNameLen) = 0;
    virtual uint64_t GetComponentButtonMask(const char* pchRenderModelName, const char* pchComponentName) = 0;
    virtual uint32_t GetComponentRenderModelName(const char* pchRenderModelName, const char* pchComponentName, char* pchComponentRenderModelName, uint32_t unComponentRenderModelNameLen) = 0;
    virtual bool GetComponentStateForDevicePath(const char* pchRenderModelName, const char* pchComponentName, vr::VRInputValueHandle_t devicePath, const vr::RenderModel_ControllerMode_State_t* pState, vr::RenderModel_ComponentState_t* pComponentState) = 0;
    virtual bool GetComponentState(const char* pchRenderModelName, const char* pchComponentName, const vr::VRControllerState_t* pControllerState, const RenderModel_ControllerMode_State_t* pState, RenderModel_ComponentState_t* pComponentState) = 0;
    virtual bool RenderModelHasComponent(const char* pchRenderModelName, const char* pchComponentName) = 0;
    virtual uint32_t GetRenderModelThumbnailURL(const char* pchRenderModelName, char* pchThumbnailURL, uint32_t unThumbnailURLLen, vr::EVRRenderModelError* peError) = 0;
    virtual uint32_t GetRenderModelOriginalPath(const char* pchRenderModelName, char* pchOriginalPath, uint32_t unOriginalPathLen, vr::EVRRenderModelError* peError) = 0;
    virtual const char* GetRenderModelErrorNameFromEnum(vr::EVRRenderModelError error) = 0;
};
static const char* const IVRRenderModels_Version = "IVRRenderModels_006";
}
namespace vr {
class IVRExtendedDisplay {
public:
    virtual void GetWindowBounds(int32_t* pnX, int32_t* pnY, uint32_t* pnWidth, uint32_t* pnHeight) = 0;
    virtual void GetEyeOutputViewport(EVREye eEye, uint32_t* pnX, uint32_t* pnY, uint32_t* pnWidth, uint32_t* pnHeight) = 0;
    virtual void GetDXGIOutputInfo(int32_t* pnAdapterIndex, int32_t* pnAdapterOutputIndex) = 0;
};
static const char* const IVRExtendedDisplay_Version = "IVRExtendedDisplay_001";
}
namespace vr {
class IVRTrackedCamera {
public:
    virtual const char* GetCameraErrorNameFromEnum(vr::EVRTrackedCameraError eCameraError) = 0;
    virtual vr::EVRTrackedCameraError HasCamera(vr::TrackedDeviceIndex_t nDeviceIndex, bool* pHasCamera) = 0;
    virtual vr::EVRTrackedCameraError GetCameraFrameSize(vr::TrackedDeviceIndex_t nDeviceIndex, vr::EVRTrackedCameraFrameType eFrameType, uint32_t* pnWidth, uint32_t* pnHeight, uint32_t* pnFrameBufferSize) = 0;
    virtual vr::EVRTrackedCameraError GetCameraIntrinsics(vr::TrackedDeviceIndex_t nDeviceIndex, uint32_t nCameraIndex, vr::EVRTrackedCameraFrameType eFrameType, vr::HmdVector2_t* pFocalLength, vr::HmdVector2_t* pCenter) = 0;
    virtual vr::EVRTrackedCameraError GetCameraProjection(vr::TrackedDeviceIndex_t nDeviceIndex, uint32_t nCameraIndex, vr::EVRTrackedCameraFrameType eFrameType, float flZNear, float flZFar, vr::HmdMatrix44_t* pProjection) = 0;
    virtual vr::EVRTrackedCameraError AcquireVideoStreamingService(vr::TrackedDeviceIndex_t nDeviceIndex, vr::TrackedCameraHandle_t* pHandle) = 0;
    virtual vr::EVRTrackedCameraError ReleaseVideoStreamingService(vr::TrackedCameraHandle_t hTrackedCamera) = 0;
    virtual vr::EVRTrackedCameraError GetVideoStreamFrameBuffer(vr::TrackedCameraHandle_t hTrackedCamera, vr::EVRTrackedCameraFrameType eFrameType, void* pFrameBuffer, uint32_t nFrameBufferSize, vr::CameraVideoStreamFrameHeader_t* pFrameHeader, uint32_t nFrameHeaderSize) = 0;
    virtual vr::EVRTrackedCameraError GetVideoStreamTextureSize(vr::TrackedDeviceIndex_t nDeviceIndex, vr::EVRTrackedCameraFrameType eFrameType, vr::VRTextureBounds_t* pTextureBounds, uint32_t* pnWidth, uint32_t* pnHeight) = 0;
    virtual vr::EVRTrackedCameraError GetVideoStreamTextureD3D11(vr::TrackedCameraHandle_t hTrackedCamera, vr::EVRTrackedCameraFrameType eFrameType, void* pD3D11DeviceOrResource, void** ppD3D11ShaderResourceView, vr::CameraVideoStreamFrameHeader_t* pFrameHeader, uint32_t nFrameHeaderSize) = 0;
    virtual vr::EVRTrackedCameraError GetVideoStreamTextureGL(vr::TrackedCameraHandle_t hTrackedCamera, vr::EVRTrackedCameraFrameType eFrameType, vr::glUInt_t* pglTextureId, vr::CameraVideoStreamFrameHeader_t* pFrameHeader, uint32_t nFrameHeaderSize) = 0;
    virtual vr::EVRTrackedCameraError ReleaseVideoStreamTextureGL(vr::TrackedCameraHandle_t hTrackedCamera, vr::glUInt_t glTextureId) = 0;
    virtual void SetCameraTrackingSpace(vr::ETrackingUniverseOrigin eUniverse) = 0;
    virtual vr::ETrackingUniverseOrigin GetCameraTrackingSpace() = 0;
};
static const char* const IVRTrackedCamera_Version = "IVRTrackedCamera_006";
}
namespace vr {
enum EVRScreenshotError {
    VRScreenshotError_None = 0,
    VRScreenshotError_RequestFailed = 1,
    VRScreenshotError_IncompatibleVersion = 100,
    VRScreenshotError_NotFound = 101,
    VRScreenshotError_BufferTooSmall = 102,
    VRScreenshotError_ScreenshotAlreadyInProgress = 108,
};
class IVRScreenshots {
public:
    virtual vr::EVRScreenshotError RequestScreenshot(vr::ScreenshotHandle_t* pOutScreenshotHandle, vr::EVRScreenshotType type, const char* pchPreviewFilename, const char* pchVRFilename) = 0;
    virtual vr::EVRScreenshotError HookScreenshot(const vr::EVRScreenshotType* pSupportedTypes, int numTypes) = 0;
    virtual vr::EVRScreenshotType GetScreenshotPropertyType(vr::ScreenshotHandle_t screenshotHandle, vr::EVRScreenshotError* pError) = 0;
    virtual uint32_t GetScreenshotPropertyFilename(vr::ScreenshotHandle_t screenshotHandle, vr::EVRScreenshotPropertyFilenames filenameType, char* pchFilename, uint32_t cchFilename, vr::EVRScreenshotError* pError) = 0;
    virtual vr::EVRScreenshotError UpdateScreenshotProgress(vr::ScreenshotHandle_t screenshotHandle, float flProgress) = 0;
    virtual vr::EVRScreenshotError TakeStereoScreenshot(vr::ScreenshotHandle_t* pOutScreenshotHandle, const char* pchPreviewFilename, const char* pchVRFilename) = 0;
    virtual vr::EVRScreenshotError SubmitScreenshot(vr::ScreenshotHandle_t screenshotHandle, vr::EVRScreenshotType type, const char* pchSourcePreviewFilename, const char* pchSourceVRFilename) = 0;
};
static const char* const IVRScreenshots_Version = "IVRScreenshots_001";
}
namespace vr {
class IVRResources {
public:
    virtual uint32_t LoadSharedResource(const char* pchResourceName, char* pchBuffer, uint32_t unBufferLen) = 0;
    virtual uint32_t GetResourceFullPath(const char* pchResourceName, const char* pchResourceTypeDirectory, char* pchPathBuffer, uint32_t unBufferLen) = 0;
};
static const char* const IVRResources_Version = "IVRResources_001";
}
namespace vr {
class IVRDriverManager {
public:
    virtual uint32_t GetDriverCount() const = 0;
    virtual uint32_t GetDriverName(vr::DriverId_t nDriver, char* pchValue, uint32_t unBufferSize) = 0;
    virtual DriverHandle_t GetDriverHandle(const char* pchDriverName) = 0;
    virtual bool IsEnabled(vr::DriverId_t nDriver) const = 0;
};
static const char* const IVRDriverManager_Version = "IVRDriverManager_001";
}
namespace vr {
static const uint32_t k_unMaxActionNameLength = 64;
static const uint32_t k_unMaxActionSetNameLength = 64;
static const uint32_t k_unMaxActionOriginCount = 16;
static const uint32_t k_unMaxBoneNameLength = 32;
enum EVRSkeletalTransformSpace {
    VRSkeletalTransformSpace_Model = 0,
    VRSkeletalTransformSpace_Parent = 1
};
enum EVRSkeletalReferencePose {
    VRSkeletalReferencePose_BindPose = 0,
    VRSkeletalReferencePose_OpenHand,
    VRSkeletalReferencePose_Fist,
    VRSkeletalReferencePose_GripLimit
};
enum EVRFinger {
    VRFinger_Thumb = 0,
    VRFinger_Index,
    VRFinger_Middle,
    VRFinger_Ring,
    VRFinger_Pinky,
    VRFinger_Count
};
enum EVRFingerSplay {
    VRFingerSplay_Thumb_Index = 0,
    VRFingerSplay_Index_Middle,
    VRFingerSplay_Middle_Ring,
    VRFingerSplay_Ring_Pinky,
    VRFingerSplay_Count
};
enum EVRSummaryType {
    VRSummaryType_FromAnimation = 0,
    VRSummaryType_FromDevice = 1,
};
enum EVRInputFilterCancelType {
    VRInputFilterCancel_Timers = 0,
    VRInputFilterCancel_Momentum = 1,
};
enum EVRInputStringBits {
    VRInputString_Hand = 0x01,
    VRInputString_ControllerType = 0x02,
    VRInputString_InputSource = 0x04,
    VRInputString_All = 0xFFFFFFFF
};
struct InputAnalogActionData_t {
    bool bActive;
    VRInputValueHandle_t activeOrigin;
    float x, y, z;
    float deltaX, deltaY, deltaZ;
    float fUpdateTime;
};
struct InputDigitalActionData_t {
    bool bActive;
    VRInputValueHandle_t activeOrigin;
    bool bState;
    bool bChanged;
    float fUpdateTime;
};
struct InputPoseActionData_t {
    bool bActive;
    VRInputValueHandle_t activeOrigin;
    TrackedDevicePose_t pose;
};
struct InputSkeletalActionData_t {
    bool bActive;
    VRInputValueHandle_t activeOrigin;
};
struct InputOriginInfo_t {
    VRInputValueHandle_t devicePath;
    TrackedDeviceIndex_t trackedDeviceIndex;
    char rchRenderModelComponentName[128];
};
struct InputBindingInfo_t {
    char rchDevicePathName[128];
    char rchInputPathName[128];
    char rchModeName[128];
    char rchSlotName[128];
    char rchInputSourceType[32];
};
static const int32_t k_nActionSetOverlayGlobalPriorityMin = 0x01000000;
static const int32_t k_nActionSetOverlayGlobalPriorityMax = 0x01FFFFFF;
static const int32_t k_nActionSetPriorityReservedMin = 0x02000000;
struct VRActiveActionSet_t {
    VRActionSetHandle_t ulActionSet;
    VRInputValueHandle_t ulRestrictedToDevice;
    VRActionSetHandle_t ulSecondaryActionSet;
    uint32_t unPadding;
    int32_t nPriority;
};
struct VRSkeletalSummaryData_t {
    float flFingerCurl[VRFinger_Count];
    float flFingerSplay[VRFingerSplay_Count];
};
class IVRInput {
public:
    virtual EVRInputError SetActionManifestPath(const char* pchActionManifestPath) = 0;
    virtual EVRInputError GetActionSetHandle(const char* pchActionSetName, VRActionSetHandle_t* pHandle) = 0;
    virtual EVRInputError GetActionHandle(const char* pchActionName, VRActionHandle_t* pHandle) = 0;
    virtual EVRInputError GetInputSourceHandle(const char* pchInputSourcePath, VRInputValueHandle_t* pHandle) = 0;
    virtual EVRInputError UpdateActionState(VRActiveActionSet_t* pSets, uint32_t unSizeOfVRSelectedActionSet_t, uint32_t unSetCount) = 0;
    virtual EVRInputError GetDigitalActionData(VRActionHandle_t action, InputDigitalActionData_t* pActionData, uint32_t unActionDataSize, VRInputValueHandle_t ulRestrictToDevice) = 0;
    virtual EVRInputError GetAnalogActionData(VRActionHandle_t action, InputAnalogActionData_t* pActionData, uint32_t unActionDataSize, VRInputValueHandle_t ulRestrictToDevice) = 0;
    virtual EVRInputError GetPoseActionDataRelativeToNow(VRActionHandle_t action, ETrackingUniverseOrigin eOrigin, float fPredictedSecondsFromNow, InputPoseActionData_t* pActionData, uint32_t unActionDataSize, VRInputValueHandle_t ulRestrictToDevice) = 0;
    virtual EVRInputError GetPoseActionDataForNextFrame(VRActionHandle_t action, ETrackingUniverseOrigin eOrigin, InputPoseActionData_t* pActionData, uint32_t unActionDataSize, VRInputValueHandle_t ulRestrictToDevice) = 0;
    virtual EVRInputError GetSkeletalActionData(VRActionHandle_t action, InputSkeletalActionData_t* pActionData, uint32_t unActionDataSize) = 0;
    virtual EVRInputError GetDominantHand(ETrackedControllerRole* peDominantHand) = 0;
    virtual EVRInputError SetDominantHand(ETrackedControllerRole eDominantHand) = 0;
    virtual EVRInputError GetBoneCount(VRActionHandle_t action, uint32_t* pBoneCount) = 0;
    virtual EVRInputError GetBoneHierarchy(VRActionHandle_t action, BoneIndex_t* pParentIndices, uint32_t unIndexArayCount) = 0;
    virtual EVRInputError GetBoneName(VRActionHandle_t action, BoneIndex_t nBoneIndex, char* pchBoneName, uint32_t unNameBufferSize) = 0;
    virtual EVRInputError GetSkeletalReferenceTransforms(VRActionHandle_t action, EVRSkeletalTransformSpace eTransformSpace, EVRSkeletalReferencePose eReferencePose, VRBoneTransform_t* pTransformArray, uint32_t unTransformArrayCount) = 0;
    virtual EVRInputError GetSkeletalTrackingLevel(VRActionHandle_t action, EVRSkeletalTrackingLevel* pSkeletalTrackingLevel) = 0;
    virtual EVRInputError GetSkeletalBoneData(VRActionHandle_t action, EVRSkeletalTransformSpace eTransformSpace, EVRSkeletalMotionRange eMotionRange, VRBoneTransform_t* pTransformArray, uint32_t unTransformArrayCount) = 0;
    virtual EVRInputError GetSkeletalSummaryData(VRActionHandle_t action, EVRSummaryType eSummaryType, VRSkeletalSummaryData_t* pSkeletalSummaryData) = 0;
    virtual EVRInputError GetSkeletalBoneDataCompressed(VRActionHandle_t action, EVRSkeletalMotionRange eMotionRange, void* pvCompressedData, uint32_t unCompressedSize, uint32_t* punRequiredCompressedSize) = 0;
    virtual EVRInputError DecompressSkeletalBoneData(const void* pvCompressedBuffer, uint32_t unCompressedBufferSize, EVRSkeletalTransformSpace eTransformSpace, VRBoneTransform_t* pTransformArray, uint32_t unTransformArrayCount) = 0;
    virtual EVRInputError TriggerHapticVibrationAction(VRActionHandle_t action, float fStartSecondsFromNow, float fDurationSeconds, float fFrequency, float fAmplitude, VRInputValueHandle_t ulRestrictToDevice) = 0;
    virtual EVRInputError GetActionOrigins(VRActionSetHandle_t actionSetHandle, VRActionHandle_t digitalActionHandle, VRInputValueHandle_t* originsOut, uint32_t originOutCount) = 0;
    virtual EVRInputError GetOriginLocalizedName(VRInputValueHandle_t origin, char* pchNameArray, uint32_t unNameArraySize, int32_t unStringSectionsToInclude) = 0;
    virtual EVRInputError GetOriginTrackedDeviceInfo(VRInputValueHandle_t origin, InputOriginInfo_t* pOriginInfo, uint32_t unOriginInfoSize) = 0;
    virtual EVRInputError GetActionBindingInfo(VRActionHandle_t action, InputBindingInfo_t* pOriginInfo, uint32_t unBindingInfoSize, uint32_t unBindingInfoCount, uint32_t* punReturnedBindingInfoCount) = 0;
    virtual EVRInputError ShowActionOrigins(VRActionSetHandle_t actionSetHandle, VRActionHandle_t ulActionHandle) = 0;
    virtual EVRInputError ShowBindingsForActionSet(VRActiveActionSet_t* pSets, uint32_t unSizeOfVRSelectedActionSet_t, uint32_t unSetCount, VRInputValueHandle_t originToHighlight) = 0;
    virtual EVRInputError GetComponentStateForBinding(const char* pchRenderModelName, const char* pchComponentName,
        const InputBindingInfo_t* pOriginInfo, uint32_t unBindingInfoSize, uint32_t unBindingInfoCount,
        vr::RenderModel_ComponentState_t* pComponentState)
        = 0;
    virtual bool IsUsingLegacyInput() = 0;
    virtual EVRInputError OpenBindingUI(const char* pchAppKey, VRActionSetHandle_t ulActionSetHandle, VRInputValueHandle_t ulDeviceHandle, bool bShowOnDesktop) = 0;
    virtual EVRInputError GetBindingVariant(vr::VRInputValueHandle_t ulDevicePath,
        char* pchVariantArray, uint32_t unVariantArraySize)
        = 0;
};
static const char* const IVRInput_Version = "IVRInput_010";
}
namespace vr {
typedef uint64_t IOBufferHandle_t;
static const uint64_t k_ulInvalidIOBufferHandle = 0;
enum EIOBufferError {
    IOBuffer_Success = 0,
    IOBuffer_OperationFailed = 100,
    IOBuffer_InvalidHandle = 101,
    IOBuffer_InvalidArgument = 102,
    IOBuffer_PathExists = 103,
    IOBuffer_PathDoesNotExist = 104,
    IOBuffer_Permission = 105,
};
enum EIOBufferMode {
    IOBufferMode_Read = 0x0001,
    IOBufferMode_Write = 0x0002,
    IOBufferMode_Create = 0x0200,
};
class IVRIOBuffer {
public:
    virtual vr::EIOBufferError Open(const char* pchPath, vr::EIOBufferMode mode, uint32_t unElementSize, uint32_t unElements, vr::IOBufferHandle_t* pulBuffer) = 0;
    virtual vr::EIOBufferError Close(vr::IOBufferHandle_t ulBuffer) = 0;
    virtual vr::EIOBufferError Read(vr::IOBufferHandle_t ulBuffer, void* pDst, uint32_t unBytes, uint32_t* punRead) = 0;
    virtual vr::EIOBufferError Write(vr::IOBufferHandle_t ulBuffer, void* pSrc, uint32_t unBytes) = 0;
    virtual vr::PropertyContainerHandle_t PropertyContainer(vr::IOBufferHandle_t ulBuffer) = 0;
    virtual bool HasReaders(vr::IOBufferHandle_t ulBuffer) = 0;
};
static const char* IVRIOBuffer_Version = "IVRIOBuffer_002";
}
namespace vr {
static const SpatialAnchorHandle_t k_ulInvalidSpatialAnchorHandle = 0;
struct SpatialAnchorPose_t {
    HmdMatrix34_t mAnchorToAbsoluteTracking;
};
class IVRSpatialAnchors {
public:
    virtual EVRSpatialAnchorError CreateSpatialAnchorFromDescriptor(const char* pchDescriptor, SpatialAnchorHandle_t* pHandleOut) = 0;
    virtual EVRSpatialAnchorError CreateSpatialAnchorFromPose(TrackedDeviceIndex_t unDeviceIndex, ETrackingUniverseOrigin eOrigin, SpatialAnchorPose_t* pPose, SpatialAnchorHandle_t* pHandleOut) = 0;
    virtual EVRSpatialAnchorError GetSpatialAnchorPose(SpatialAnchorHandle_t unHandle, ETrackingUniverseOrigin eOrigin, SpatialAnchorPose_t* pPoseOut) = 0;
    virtual EVRSpatialAnchorError GetSpatialAnchorDescriptor(SpatialAnchorHandle_t unHandle, char* pchDescriptorOut, uint32_t* punDescriptorBufferLenInOut) = 0;
};
static const char* const IVRSpatialAnchors_Version = "IVRSpatialAnchors_001";
}
namespace vr {
enum EVRDebugError {
    VRDebugError_Success = 0,
    VRDebugError_BadParameter
};
typedef uint64_t VrProfilerEventHandle_t;
class IVRDebug {
public:
    virtual EVRDebugError EmitVrProfilerEvent(const char* pchMessage) = 0;
    virtual EVRDebugError BeginVrProfilerEvent(VrProfilerEventHandle_t* pHandleOut) = 0;
    virtual EVRDebugError FinishVrProfilerEvent(VrProfilerEventHandle_t hHandle, const char* pchMessage) = 0;
    virtual uint32_t DriverDebugRequest(vr::TrackedDeviceIndex_t unDeviceIndex, const char* pchRequest, char* pchResponseBuffer, uint32_t unResponseBufferSize) = 0;
};
static const char* const IVRDebug_Version = "IVRDebug_001";
}
namespace vr {
inline IVRSystem* VR_Init(EVRInitError* peError, EVRApplicationType eApplicationType, const char* pStartupInfo = nullptr);
inline void VR_Shutdown();
extern "C" __declspec(dllimport) bool __cdecl VR_IsHmdPresent();
extern "C" __declspec(dllimport) bool __cdecl VR_IsRuntimeInstalled();
extern "C" __declspec(dllimport) bool VR_GetRuntimePath(char* pchPathBuffer, uint32_t unBufferSize, uint32_t* punRequiredBufferSize);
extern "C" __declspec(dllimport) const char* __cdecl VR_GetVRInitErrorAsSymbol(EVRInitError error);
extern "C" __declspec(dllimport) const char* __cdecl VR_GetVRInitErrorAsEnglishDescription(EVRInitError error);
extern "C" __declspec(dllimport) void* __cdecl VR_GetGenericInterface(const char* pchInterfaceVersion, EVRInitError* peError);
extern "C" __declspec(dllimport) bool __cdecl VR_IsInterfaceVersionValid(const char* pchInterfaceVersion);
extern "C" __declspec(dllimport) uint32_t __cdecl VR_GetInitToken();
typedef EVRInitError HmdError;
typedef EVREye Hmd_Eye;
typedef EColorSpace ColorSpace;
typedef ETrackingResult HmdTrackingResult;
typedef ETrackedDeviceClass TrackedDeviceClass;
typedef ETrackingUniverseOrigin TrackingUniverseOrigin;
typedef ETrackedDeviceProperty TrackedDeviceProperty;
typedef ETrackedPropertyError TrackedPropertyError;
typedef EVRSubmitFlags VRSubmitFlags_t;
typedef EVRState VRState_t;
typedef ECollisionBoundsStyle CollisionBoundsStyle_t;
typedef EVROverlayError VROverlayError;
typedef EVRFirmwareError VRFirmwareError;
typedef EVRCompositorError VRCompositorError;
typedef EVRScreenshotError VRScreenshotsError;
inline uint32_t& VRToken()
{
    static uint32_t token;
    return token;
}
class COpenVRContext {
public:
    COpenVRContext() { Clear(); }
    void Clear();
    inline void CheckClear()
    {
        if (VRToken() != VR_GetInitToken()) {
            Clear();
            VRToken() = VR_GetInitToken();
        }
    }
    IVRSystem* VRSystem()
    {
        CheckClear();
        if (m_pVRSystem == nullptr) {
            EVRInitError eError;
            m_pVRSystem = (IVRSystem*)VR_GetGenericInterface(IVRSystem_Version, &eError);
        }
        return m_pVRSystem;
    }
    IVRChaperone* VRChaperone()
    {
        CheckClear();
        if (m_pVRChaperone == nullptr) {
            EVRInitError eError;
            m_pVRChaperone = (IVRChaperone*)VR_GetGenericInterface(IVRChaperone_Version, &eError);
        }
        return m_pVRChaperone;
    }
    IVRChaperoneSetup* VRChaperoneSetup()
    {
        CheckClear();
        if (m_pVRChaperoneSetup == nullptr) {
            EVRInitError eError;
            m_pVRChaperoneSetup = (IVRChaperoneSetup*)VR_GetGenericInterface(IVRChaperoneSetup_Version, &eError);
        }
        return m_pVRChaperoneSetup;
    }
    IVRCompositor* VRCompositor()
    {
        CheckClear();
        if (m_pVRCompositor == nullptr) {
            EVRInitError eError;
            m_pVRCompositor = (IVRCompositor*)VR_GetGenericInterface(IVRCompositor_Version, &eError);
        }
        return m_pVRCompositor;
    }
    IVROverlay* VROverlay()
    {
        CheckClear();
        if (m_pVROverlay == nullptr) {
            EVRInitError eError;
            m_pVROverlay = (IVROverlay*)VR_GetGenericInterface(IVROverlay_Version, &eError);
        }
        return m_pVROverlay;
    }
    IVROverlayView* VROverlayView()
    {
        CheckClear();
        if (m_pVROverlayView == nullptr) {
            EVRInitError eError;
            m_pVROverlayView = (IVROverlayView*)VR_GetGenericInterface(IVROverlayView_Version, &eError);
        }
        return m_pVROverlayView;
    }
    IVRHeadsetView* VRHeadsetView()
    {
        CheckClear();
        if (m_pVRHeadsetView == nullptr) {
            EVRInitError eError;
            m_pVRHeadsetView = (IVRHeadsetView*)VR_GetGenericInterface(IVRHeadsetView_Version, &eError);
        }
        return m_pVRHeadsetView;
    }
    IVRResources* VRResources()
    {
        CheckClear();
        if (m_pVRResources == nullptr) {
            EVRInitError eError;
            m_pVRResources = (IVRResources*)VR_GetGenericInterface(IVRResources_Version, &eError);
        }
        return m_pVRResources;
    }
    IVRScreenshots* VRScreenshots()
    {
        CheckClear();
        if (m_pVRScreenshots == nullptr) {
            EVRInitError eError;
            m_pVRScreenshots = (IVRScreenshots*)VR_GetGenericInterface(IVRScreenshots_Version, &eError);
        }
        return m_pVRScreenshots;
    }
    IVRRenderModels* VRRenderModels()
    {
        CheckClear();
        if (m_pVRRenderModels == nullptr) {
            EVRInitError eError;
            m_pVRRenderModels = (IVRRenderModels*)VR_GetGenericInterface(IVRRenderModels_Version, &eError);
        }
        return m_pVRRenderModels;
    }
    IVRExtendedDisplay* VRExtendedDisplay()
    {
        CheckClear();
        if (m_pVRExtendedDisplay == nullptr) {
            EVRInitError eError;
            m_pVRExtendedDisplay = (IVRExtendedDisplay*)VR_GetGenericInterface(IVRExtendedDisplay_Version, &eError);
        }
        return m_pVRExtendedDisplay;
    }
    IVRSettings* VRSettings()
    {
        CheckClear();
        if (m_pVRSettings == nullptr) {
            EVRInitError eError;
            m_pVRSettings = (IVRSettings*)VR_GetGenericInterface(IVRSettings_Version, &eError);
        }
        return m_pVRSettings;
    }
    IVRApplications* VRApplications()
    {
        CheckClear();
        if (m_pVRApplications == nullptr) {
            EVRInitError eError;
            m_pVRApplications = (IVRApplications*)VR_GetGenericInterface(IVRApplications_Version, &eError);
        }
        return m_pVRApplications;
    }
    IVRTrackedCamera* VRTrackedCamera()
    {
        CheckClear();
        if (m_pVRTrackedCamera == nullptr) {
            EVRInitError eError;
            m_pVRTrackedCamera = (IVRTrackedCamera*)VR_GetGenericInterface(IVRTrackedCamera_Version, &eError);
        }
        return m_pVRTrackedCamera;
    }
    IVRDriverManager* VRDriverManager()
    {
        CheckClear();
        if (!m_pVRDriverManager) {
            EVRInitError eError;
            m_pVRDriverManager = (IVRDriverManager*)VR_GetGenericInterface(IVRDriverManager_Version, &eError);
        }
        return m_pVRDriverManager;
    }
    IVRInput* VRInput()
    {
        CheckClear();
        if (!m_pVRInput) {
            EVRInitError eError;
            m_pVRInput = (IVRInput*)VR_GetGenericInterface(IVRInput_Version, &eError);
        }
        return m_pVRInput;
    }
    IVRIOBuffer* VRIOBuffer()
    {
        if (!m_pVRIOBuffer) {
            EVRInitError eError;
            m_pVRIOBuffer = (IVRIOBuffer*)VR_GetGenericInterface(IVRIOBuffer_Version, &eError);
        }
        return m_pVRIOBuffer;
    }
    IVRSpatialAnchors* VRSpatialAnchors()
    {
        CheckClear();
        if (!m_pVRSpatialAnchors) {
            EVRInitError eError;
            m_pVRSpatialAnchors = (IVRSpatialAnchors*)VR_GetGenericInterface(IVRSpatialAnchors_Version, &eError);
        }
        return m_pVRSpatialAnchors;
    }
    IVRDebug* VRDebug()
    {
        CheckClear();
        if (!m_pVRDebug) {
            EVRInitError eError;
            m_pVRDebug = (IVRDebug*)VR_GetGenericInterface(IVRDebug_Version, &eError);
        }
        return m_pVRDebug;
    }
    IVRNotifications* VRNotifications()
    {
        CheckClear();
        if (!m_pVRNotifications) {
            EVRInitError eError;
            m_pVRNotifications = (IVRNotifications*)VR_GetGenericInterface(IVRNotifications_Version, &eError);
        }
        return m_pVRNotifications;
    }

private:
    IVRSystem* m_pVRSystem;
    IVRChaperone* m_pVRChaperone;
    IVRChaperoneSetup* m_pVRChaperoneSetup;
    IVRCompositor* m_pVRCompositor;
    IVRHeadsetView* m_pVRHeadsetView;
    IVROverlay* m_pVROverlay;
    IVROverlayView* m_pVROverlayView;
    IVRResources* m_pVRResources;
    IVRRenderModels* m_pVRRenderModels;
    IVRExtendedDisplay* m_pVRExtendedDisplay;
    IVRSettings* m_pVRSettings;
    IVRApplications* m_pVRApplications;
    IVRTrackedCamera* m_pVRTrackedCamera;
    IVRScreenshots* m_pVRScreenshots;
    IVRDriverManager* m_pVRDriverManager;
    IVRInput* m_pVRInput;
    IVRIOBuffer* m_pVRIOBuffer;
    IVRSpatialAnchors* m_pVRSpatialAnchors;
    IVRDebug* m_pVRDebug;
    IVRNotifications* m_pVRNotifications;
};
inline COpenVRContext& OpenVRInternal_ModuleContext()
{
    static void* ctx[sizeof(COpenVRContext) / sizeof(void*)];
    return *(COpenVRContext*)ctx;
}
inline IVRSystem* __cdecl VRSystem() { return OpenVRInternal_ModuleContext().VRSystem(); }
inline IVRChaperone* __cdecl VRChaperone() { return OpenVRInternal_ModuleContext().VRChaperone(); }
inline IVRChaperoneSetup* __cdecl VRChaperoneSetup() { return OpenVRInternal_ModuleContext().VRChaperoneSetup(); }
inline IVRCompositor* __cdecl VRCompositor() { return OpenVRInternal_ModuleContext().VRCompositor(); }
inline IVROverlay* __cdecl VROverlay() { return OpenVRInternal_ModuleContext().VROverlay(); }
inline IVROverlayView* __cdecl VROverlayView() { return OpenVRInternal_ModuleContext().VROverlayView(); }
inline IVRHeadsetView* __cdecl VRHeadsetView() { return OpenVRInternal_ModuleContext().VRHeadsetView(); }
inline IVRScreenshots* __cdecl VRScreenshots() { return OpenVRInternal_ModuleContext().VRScreenshots(); }
inline IVRRenderModels* __cdecl VRRenderModels() { return OpenVRInternal_ModuleContext().VRRenderModels(); }
inline IVRApplications* __cdecl VRApplications() { return OpenVRInternal_ModuleContext().VRApplications(); }
inline IVRSettings* __cdecl VRSettings() { return OpenVRInternal_ModuleContext().VRSettings(); }
inline IVRResources* __cdecl VRResources() { return OpenVRInternal_ModuleContext().VRResources(); }
inline IVRExtendedDisplay* __cdecl VRExtendedDisplay() { return OpenVRInternal_ModuleContext().VRExtendedDisplay(); }
inline IVRTrackedCamera* __cdecl VRTrackedCamera() { return OpenVRInternal_ModuleContext().VRTrackedCamera(); }
inline IVRDriverManager* __cdecl VRDriverManager() { return OpenVRInternal_ModuleContext().VRDriverManager(); }
inline IVRInput* __cdecl VRInput() { return OpenVRInternal_ModuleContext().VRInput(); }
inline IVRIOBuffer* __cdecl VRIOBuffer() { return OpenVRInternal_ModuleContext().VRIOBuffer(); }
inline IVRSpatialAnchors* __cdecl VRSpatialAnchors() { return OpenVRInternal_ModuleContext().VRSpatialAnchors(); }
inline IVRNotifications* __cdecl VRNotifications() { return OpenVRInternal_ModuleContext().VRNotifications(); }
inline IVRDebug* __cdecl VRDebug() { return OpenVRInternal_ModuleContext().VRDebug(); }
inline void COpenVRContext::Clear()
{
    m_pVRSystem = nullptr;
    m_pVRChaperone = nullptr;
    m_pVRChaperoneSetup = nullptr;
    m_pVRCompositor = nullptr;
    m_pVROverlay = nullptr;
    m_pVROverlayView = nullptr;
    m_pVRHeadsetView = nullptr;
    m_pVRRenderModels = nullptr;
    m_pVRExtendedDisplay = nullptr;
    m_pVRSettings = nullptr;
    m_pVRApplications = nullptr;
    m_pVRTrackedCamera = nullptr;
    m_pVRResources = nullptr;
    m_pVRScreenshots = nullptr;
    m_pVRDriverManager = nullptr;
    m_pVRInput = nullptr;
    m_pVRIOBuffer = nullptr;
    m_pVRSpatialAnchors = nullptr;
    m_pVRNotifications = nullptr;
    m_pVRDebug = nullptr;
}
extern "C" __declspec(dllimport) uint32_t __cdecl VR_InitInternal2(EVRInitError* peError, EVRApplicationType eApplicationType, const char* pStartupInfo);
extern "C" __declspec(dllimport) void __cdecl VR_ShutdownInternal();
inline IVRSystem* VR_Init(EVRInitError* peError, EVRApplicationType eApplicationType, const char* pStartupInfo)
{
    IVRSystem* pVRSystem = nullptr;
    EVRInitError eError;
    VRToken() = VR_InitInternal2(&eError, eApplicationType, pStartupInfo);
    COpenVRContext& ctx = OpenVRInternal_ModuleContext();
    ctx.Clear();
    if (eError == VRInitError_None) {
        if (VR_IsInterfaceVersionValid(IVRSystem_Version)) {
            pVRSystem = VRSystem();
        } else {
            VR_ShutdownInternal();
            eError = VRInitError_Init_InterfaceNotFound;
        }
    }
    if (peError)
        *peError = eError;
    return pVRSystem;
}
inline void VR_Shutdown()
{
    VR_ShutdownInternal();
}
}
#pragma external_header(pop)
#pragma external_header(push)
#pragma warning(disable : 4049)
#pragma once
typedef struct ISurfaceProducer ISurfaceProducer;
typedef struct ISurfaceConsumer ISurfaceConsumer;
typedef struct ISurfaceQueue ISurfaceQueue;
extern "C" {
typedef struct SURFACE_QUEUE_DESC {
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    UINT NumSurfaces;
    UINT MetaDataSize;
    DWORD Flags;
} SURFACE_QUEUE_DESC;
typedef struct SURFACE_QUEUE_CLONE_DESC {
    UINT MetaDataSize;
    DWORD Flags;
} SURFACE_QUEUE_CLONE_DESC;
typedef enum SURFACE_QUEUE_FLAG { SURFACE_QUEUE_FLAG_DO_NOT_WAIT = 0x1L,
    SURFACE_QUEUE_FLAG_SINGLE_THREADED = 0x2L
} SURFACE_QUEUE_FLAG;
extern RPC_IF_HANDLE __MIDL_itf_surfacequeue_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_surfacequeue_0000_0000_v0_0_s_ifspec;
extern "C" const IID IID_ISurfaceProducer;
struct __declspec(uuid("B8B0B73B-79C1-4446-BB8A-19595018B0B7")) __declspec(novtable)
    ISurfaceProducer : public IUnknown {
public:
    virtual HRESULT __stdcall Enqueue(
        IUnknown* pSurface,
        void* pBuffer,
        UINT BufferSize,
        DWORD Flags)
        = 0;
    virtual HRESULT __stdcall Flush(
        DWORD Flags,
        UINT* NumSurfaces)
        = 0;
};
extern "C" const IID IID_ISurfaceConsumer;
struct __declspec(uuid("97E305E1-1EC7-41a6-972C-99092DE6A31E")) __declspec(novtable)
    ISurfaceConsumer : public IUnknown {
public:
    virtual HRESULT __stdcall Dequeue(
        const IID& id,
        void** ppSurface,
        void* pBuffer,
        UINT* pBufferSize,
        DWORD dwTimeout)
        = 0;
};
extern "C" const IID IID_ISurfaceQueue;
struct __declspec(uuid("1C08437F-48DF-467e-8D55-CA9268C73779")) __declspec(novtable)
    ISurfaceQueue : public IUnknown {
public:
    virtual HRESULT __stdcall OpenProducer(
        IUnknown* pDevice,
        ISurfaceProducer** ppProducer)
        = 0;
    virtual HRESULT __stdcall OpenConsumer(
        IUnknown* pDevice,
        ISurfaceConsumer** ppConsumer)
        = 0;
    virtual HRESULT __stdcall Clone(
        SURFACE_QUEUE_CLONE_DESC* pDesc,
        ISurfaceQueue** ppQueue)
        = 0;
};
HRESULT __stdcall CreateSurfaceQueue(SURFACE_QUEUE_DESC* pDesc,
    IUnknown* pDevice,
    ISurfaceQueue** ppQueue);
extern RPC_IF_HANDLE __MIDL_itf_surfacequeue_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_surfacequeue_0000_0003_v0_0_s_ifspec;
}
#pragma external_header(pop)
#pragma external_header(push)
namespace vireio {
enum RenderPosition {
    Left = 1,
    Right = 2
};
std::string retprintf(const char* fmt, ...);
void debugf(const char* fmt, ...);
void deb(const char* fmt, ...);
}
#pragma external_header(pop)
struct ID3D11Device;
struct ID3D11DeviceContext;
struct ID3D11DepthStencilView;
struct ID3D11DepthStencilState;
struct ISurfaceQueue;
struct ISurfaceConsumer;
class DX9ExDebugWindow;
class OpenVRDirectMode {
public:
    OpenVRDirectMode();
    virtual ~OpenVRDirectMode();
    virtual void Init(IDirect3DDevice9* pActualDevice);
    virtual void PrePresentEx(IDirect3DSurface9* pDirect3DSurface9);
    virtual void PostPresentEx(IDirect3DSurface9* pDirect3DSurface9);
    virtual void GetViewParameters(uint32_t* w, uint32_t* h, float* aspect, float* fov);
    virtual vr::TrackedDeviceIndex_t GetControllerIndex(vr::ETrackedControllerRole role);
    virtual vr::TrackedDevicePose_t* GetDevicePose(vr::TrackedDeviceIndex_t unDeviceIndex);
    virtual bool GetControllerState(vr::TrackedDeviceIndex_t unControllerDeviceIndex, vr::VRControllerState_t* state);
    virtual bool PollNextEvent(vr::VREvent_t* pEvent, uint32_t uncbVREvent);
    vr::IVRSystem* m_pHMD;
    vr::IVRRenderModels* m_pRenderModels;
    vr::TrackedDevicePose_t m_rTrackedDevicePose[vr::k_unMaxTrackedDeviceCount];

private:
    IDirect3DDevice9* m_pActualDevice;
    ID3D11Device* pDevice;
    ID3D11DeviceContext* pImmediateContext;
    ID3D11DepthStencilView* pDepthStencilView;
    ID3D11DepthStencilState* pDSState;
    ISurfaceQueue* g_9to11Queue;
    ISurfaceQueue* g_11to9Queue;
    ISurfaceConsumer* g_9Consumer;
    ISurfaceProducer* g_9Producer;
    ISurfaceConsumer* g_11Consumer;
    ISurfaceProducer* g_11Producer;
    D3D_DRIVER_TYPE driverType;
    D3D_FEATURE_LEVEL featureLevel;
    D3D11_VIEWPORT dx11viewport;
    uint32_t m_nRenderWidth;
    uint32_t m_nRenderHeight;
    float m_nAspect;
    float m_nFov;
    vr::VRTextureBounds_t m_sTextureBounds[2];
    int count;
    int m_iTrackedControllerCount;
    int m_iTrackedControllerCount_Last;
    int m_iValidPoseCount;
    int m_iValidPoseCount_Last;
    bool initialized;
    std::string m_strPoseClasses;
    char m_rDevClassChar[vr::k_unMaxTrackedDeviceCount];
};
#pragma external_header(pop)
extern "C" {
__declspec(dllexport) void __cdecl init();
__declspec(dllexport) float __cdecl get_float_value(int);
__declspec(dllexport) int __cdecl set_follow(int);
__declspec(dllexport) int __cdecl set_offset(float, float, float);
__declspec(dllexport) int __cdecl set_origin(float, float, float);
__declspec(dllexport) int __cdecl set_vr_active(int);
__declspec(dllexport) int __cdecl set_position_scale(float);
__declspec(dllexport) int __cdecl set_added_rotation(float);
__declspec(dllexport) int __cdecl set_scale(float, float);
__declspec(dllexport) int __cdecl set_struct_location(UINT64);
__declspec(dllexport) int __cdecl update();
}
bool HookDirectX();
IDirect3D9Ex* SharingExDx9 = 0;
IDirect3DDevice9Ex* SharingExDxDevice = 0;
BOOL __stdcall DllMain(HMODULE hModule,
    DWORD ul_reason_for_call,
    LPVOID lpReserved)
{
    switch (ul_reason_for_call) {
    case 1:
        vireio::debugf("Loaded dll");
    case 2:
    case 3:
    case 0:
        break;
    }
    return 1;
}
HANDLE* pHandle = 0;
IDirect3DSurface9* pBackBuffer = 0;
IDirect3DSurface9* pBackBufferDst = 0;
OpenVRDirectMode* forwarder;
#pragma once
#pragma warning(push)
#pragma warning(disable : 4324 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727)
__pragma(pack(push, 8)) extern "C"
{
    typedef long clock_t;
    struct _timespec32 {
        __time32_t tv_sec;
        long tv_nsec;
    };
    struct _timespec64 {
        __time64_t tv_sec;
        long tv_nsec;
    };
    struct timespec {
        time_t tv_sec;
        long tv_nsec;
    };
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_daylight"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int* __cdecl __daylight(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_dstbias"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) long* __cdecl __dstbias(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_timezone"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) long* __cdecl __timezone(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_tzname"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char** __cdecl __tzname(void);
    __declspec(dllimport) errno_t __cdecl _get_daylight(
        int* _Daylight);
    __declspec(dllimport) errno_t __cdecl _get_dstbias(
        long* _DaylightSavingsBias);
    __declspec(dllimport) errno_t __cdecl _get_timezone(
        long* _TimeZone);
    __declspec(dllimport) errno_t __cdecl _get_tzname(
        size_t * _ReturnValue,
        char* _Buffer,
        size_t _SizeInBytes,
        int _Index);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "asctime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl asctime(struct tm const* _Tm);
    __declspec(dllimport) errno_t __cdecl asctime_s(
        char* _Buffer,
        size_t _SizeInBytes,
        struct tm const* _Tm);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl asctime_s(char (&_Buffer)[_Size], struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); }
    }
    __declspec(dllimport) clock_t __cdecl clock(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ctime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ctime32(__time32_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _ctime32_s(
        char* _Buffer,
        size_t _SizeInBytes,
        __time32_t const* _Time);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ctime32_s(char (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ctime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ctime64(__time64_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _ctime64_s(
        char* _Buffer,
        size_t _SizeInBytes,
        __time64_t const* _Time);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); }
    }
    __declspec(dllimport) double __cdecl _difftime32(
        __time32_t _Time1,
        __time32_t _Time2);
    __declspec(dllimport) double __cdecl _difftime64(
        __time64_t _Time1,
        __time64_t _Time2);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_gmtime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _gmtime32(__time32_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _gmtime32_s(
        struct tm * _Tm,
        __time32_t const* _Time);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_gmtime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _gmtime64(__time64_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _gmtime64_s(
        struct tm * _Tm,
        __time64_t const* _Time);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_localtime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _localtime32(__time32_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _localtime32_s(
        struct tm * _Tm,
        __time32_t const* _Time);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_localtime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _localtime64(__time64_t const* _Time);
    __declspec(dllimport) errno_t __cdecl _localtime64_s(
        struct tm * _Tm,
        __time64_t const* _Time);
    __declspec(dllimport) __time32_t __cdecl _mkgmtime32(
        struct tm * _Tm);
    __declspec(dllimport) __time64_t __cdecl _mkgmtime64(
        struct tm * _Tm);
    __declspec(dllimport) __time32_t __cdecl _mktime32(
        struct tm * _Tm);
    __declspec(dllimport) __time64_t __cdecl _mktime64(
        struct tm * _Tm);
    __declspec(dllimport) size_t __cdecl strftime(
        char* _Buffer,
        size_t _SizeInBytes,
        char const* _Format,
        struct tm const* _Tm);
    __declspec(dllimport) size_t __cdecl _strftime_l(
        char* _Buffer,
        size_t _MaxSize,
        char const* _Format,
        struct tm const* _Tm,
        _locale_t _Locale);
    __declspec(dllimport) errno_t __cdecl _strdate_s(
        char* _Buffer,
        size_t _SizeInBytes);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strdate_s(char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strdate_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strdate(char* _Buffer);
    __declspec(dllimport) errno_t __cdecl _strtime_s(
        char* _Buffer,
        size_t _SizeInBytes);
    extern "C++" {
    template <size_t _Size>
    inline errno_t __cdecl _strtime_s(char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); }
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime(char* _Buffer);
    __declspec(dllimport) __time32_t __cdecl _time32(
        __time32_t * _Time);
    __declspec(dllimport) __time64_t __cdecl _time64(
        __time64_t * _Time);
    __declspec(dllimport) int __cdecl _timespec32_get(
        struct _timespec32 * _Ts,
        int _Base);
    __declspec(dllimport) int __cdecl _timespec64_get(
        struct _timespec64 * _Ts,
        int _Base);
    __declspec(dllimport) void __cdecl _tzset(void);
    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "GetLocalTime"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) unsigned __cdecl _getsystime(struct tm * _Tm);
    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "SetLocalTime"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) unsigned __cdecl _setsystime(struct tm * _Tm,
        unsigned _Milliseconds);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "ctime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline char* __cdecl ctime(time_t const* const _Time)
    {
        return _ctime64(_Time);
    }
    static __inline double __cdecl difftime(
        time_t const _Time1,
        time_t const _Time2)
    {
        return _difftime64(_Time1, _Time2);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "gmtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline struct tm* __cdecl gmtime(time_t const* const _Time)
    {
        return _gmtime64(_Time);
    }
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "localtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline struct tm* __cdecl localtime(time_t const* const _Time)
    {
        return _localtime64(_Time);
    }
    static __inline time_t __cdecl _mkgmtime(
        struct tm* const _Tm)
    {
        return _mkgmtime64(_Tm);
    }
    static __inline time_t __cdecl mktime(
        struct tm* const _Tm)
    {
        return _mktime64(_Tm);
    }
    static __inline time_t __cdecl time(
        time_t* const _Time)
    {
        return _time64(_Time);
    }
    static __inline int __cdecl timespec_get(
        struct timespec* const _Ts,
        int const _Base)
    {
        return _timespec64_get((struct _timespec64*)_Ts, _Base);
    }
    static __inline errno_t __cdecl ctime_s(
        char* const _Buffer,
        size_t const _SizeInBytes,
        time_t const* const _Time)
    {
        return _ctime64_s(_Buffer, _SizeInBytes, _Time);
    }
    static __inline errno_t __cdecl gmtime_s(
        struct tm* const _Tm,
        time_t const* const _Time)
    {
        return _gmtime64_s(_Tm, _Time);
    }
    static __inline errno_t __cdecl localtime_s(
        struct tm* const _Tm,
        time_t const* const _Time)
    {
        return _localtime64_s(_Tm, _Time);
    }
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_tzset"
                          ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
}
__pragma(pack(pop))
#pragma warning(pop)
    typedef struct float4 {
    float w;
    float x;
    float y;
    float z;
} float4;
typedef struct vpxint4 {
    int x;
    int y;
    int z;
    int w;
} vpxint4;
typedef struct vpxfloat3 {
    float x;
    float y;
    float z;
} vpxfloat3;
typedef struct vpxfloat4 {
    float x;
    float y;
    float z;
    float w;
} vpxfloat4;
typedef struct vpxmtx4x4 {
    float m[16];
} vpxmtx4x4;
typedef struct float3x3 {
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    float g;
    float h;
    float i;
} float3x3;
int last_s = 0;
int frames = 0;
int VorpXFrame = 0;
vpxfloat3 last_headsetrot;
vpxfloat3 last_headsetpos;
UINT64 structpos = 4545;
UINT64 structpos2 = 4545;
int vr_active = 0;
int follow_active = 0;
float height_scale = 4545;
float width_scale = 4545;
float position_scale = 1;
float added_rotation = 0;
float offset_x = 0;
float offset_y = 0;
float offset_z = 0;
float origin_x = 0;
float origin_y = 0;
float origin_z = 0;
float last_x = 0;
float last_y = 0;
float last_z = 0;
float games_x_sidevec = 0;
float games_y_sidevec = 0;
float games_z_sidevec = 0;
float games_x_upvec = 0;
float games_y_upvec = 0;
float games_z_upvec = 0;
float games_x_fwvec = 0;
float games_y_fwvec = 0;
float games_z_fwvec = 0;
float games_x = 0;
float games_y = 0;
float games_z = 0;
vr::HmdVector3d_t QuaternionToEuler(vr::HmdQuaternion_t q)
{
    vr::HmdVector3d_t e;
    double x, y, z, w;
    x = q.x;
    y = q.y;
    z = q.z;
    w = q.w;
    double test = x * y + z * w;
    if (test > 0.499) {
        e.v[0] = 2 * atan2(x, w);
        e.v[1] = 3.14159265358979323846264338327950288 / 2.0;
        e.v[2] = 0;
        return e;
    }
    if (test < -0.499) {
        e.v[0] = -2 * atan2(x, w);
        e.v[1] = -3.14159265358979323846264338327950288 / 2;
        e.v[2] = 0;
        return e;
    }
    double sqx = x * x;
    double sqy = y * y;
    double sqz = z * z;
    e.v[0] = atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz);
    e.v[1] = asin(2 * test);
    e.v[2] = atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
    return e;
}
vr::HmdQuaternion_t EulerToQuaternion(vr::HmdVector3d_t e)
{
    vr::HmdQuaternion_t q;
    double c1 = cos(e.v[0] / 2);
    double s1 = sin(e.v[0] / 2);
    double c2 = cos(e.v[1] / 2);
    double s2 = sin(e.v[1] / 2);
    double c3 = cos(e.v[2] / 2);
    double s3 = sin(e.v[2] / 2);
    double c1c2 = c1 * c2;
    double s1s2 = s1 * s2;
    q.w = c1c2 * c3 - s1s2 * s3;
    q.x = c1c2 * s3 + s1s2 * c3;
    q.y = s1 * c2 * c3 + c1 * s2 * s3;
    q.z = c1 * s2 * c3 - s1 * c2 * s3;
    return q;
}
__declspec(dllexport) float __cdecl get_float_value(int val_id)
{
    if (val_id == 0) {
        return games_x;
    }
    if (val_id == 1) {
        return games_y;
    }
    if (val_id == 2) {
        return games_z;
    }
    if (val_id == 3) {
        return games_x_sidevec;
    }
    if (val_id == 4) {
        return games_y_sidevec;
    }
    if (val_id == 5) {
        return games_z_sidevec;
    }
    if (val_id == 6) {
        return games_x_upvec;
    }
    if (val_id == 7) {
        return games_y_upvec;
    }
    if (val_id == 8) {
        return games_z_upvec;
    }
    if (val_id == 9) {
        return games_x_fwvec;
    }
    if (val_id == 10) {
        return games_y_fwvec;
    }
    if (val_id == 11) {
        return games_z_fwvec;
    }
    if (val_id == 12) {
        return last_headsetrot.x;
    }
    if (val_id == 13) {
        return last_headsetrot.y;
    }
    if (val_id == 14) {
        return last_headsetrot.z;
    }
    if (val_id == 15) {
        return last_headsetpos.x;
    }
    if (val_id == 16) {
        return last_headsetpos.y;
    }
    if (val_id == 17) {
        return last_headsetpos.z;
    }
    return 0;
}
__declspec(dllexport) int __cdecl set_follow(int follow)
{
    follow_active = follow;
    return follow_active;
}
__declspec(dllexport) int __cdecl set_offset(float x, float y, float z)
{
    offset_x = x;
    offset_y = y;
    offset_z = z;
    vireio::deb("set_offset: %f\n", offset_x);
    return 0;
}
__declspec(dllexport) int __cdecl set_origin(float x, float y, float z)
{
    origin_x = x;
    origin_y = y;
    origin_z = z;
    vireio::deb("set_origin: %f\n", origin_x);
    return 0;
}
__declspec(dllexport) int __cdecl set_vr_active(int num)
{
    vr_active = num;
    vireio::deb("set_vr_active: %i\n", vr_active);
    return 0;
}
__declspec(dllexport) int __cdecl set_position_scale(float num)
{
    position_scale = num;
    vireio::deb("position_scale: %f\n", position_scale);
    return 0;
}
__declspec(dllexport) int __cdecl set_added_rotation(float num)
{
    added_rotation = num;
    vireio::deb("added_rotation: %f\n", added_rotation);
    return 0;
}
__declspec(dllexport) int __cdecl set_scale(float width, float height)
{
    height_scale = height;
    width_scale = width;
    vireio::deb("set_scale: %f, %f\n", width_scale, height_scale);
    return 0;
}
__declspec(dllexport) int __cdecl set_struct_location(UINT64 location)
{
    if (structpos != location) {
        structpos2 = structpos;
    }
    if (location == 4545) {
        structpos2 = location;
    }
    structpos = location;
    vireio::deb("set_struct_location: %llx\n", structpos);
    float* x_pos;
    float* y_pos;
    float* z_pos;
    x_pos = (float*)structpos + (0x60 / 4);
    y_pos = (float*)structpos + (0x64 / 4);
    z_pos = (float*)structpos + (0x68 / 4);
    vireio::deb("set_struct_location: %llx\n", x_pos);
    vireio::deb("gamepos: %f %f %f\n", *x_pos, *y_pos, *z_pos);
    return 0;
}
float4 euler2quat(float ai, float aj, float ak)
{
    ai /= 2.0;
    aj /= 2.0;
    ak /= 2.0;
    float ci = cos(ai);
    float si = sin(ai);
    float cj = cos(aj);
    float sj = sin(aj);
    float ck = cos(ak);
    float sk = sin(ak);
    float cc = ci * ck;
    float cs = ci * sk;
    float sc = si * ck;
    float ss = si * sk;
    float4 q = { cj * cc + sj * ss, cj * cs - sj * sc, cj * sc - sj * cs, cj * ss + sj * cc };
    return q;
}
float4 qmult(float4 q1, float4 q2)
{
    float w1 = q1.w;
    float x1 = q1.x;
    float y1 = q1.y;
    float z1 = q1.z;
    float w2 = q2.w;
    float x2 = q2.x;
    float y2 = q2.y;
    float z2 = q2.z;
    float w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    float x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
    float y = w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2;
    float z = w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2;
    float4 q = { w, x, y, z };
    return q;
}
float3x3 quat2mat(float4 quat)
{
    float w = quat.w;
    float x = quat.x;
    float y = quat.y;
    float z = quat.z;
    float Nq = w * w + x * x + y * y + z * z;
    if (Nq < 2.220446049250313e-16) {
        float3x3 m1 = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };
        return m1;
    }
    float s = 2.0 / Nq;
    float X = x * s;
    float Y = y * s;
    float Z = z * s;
    float wX = w * X;
    float wY = w * Y;
    float wZ = w * Z;
    float xX = x * X;
    float xY = x * Y;
    float xZ = x * Z;
    float yY = y * Y;
    float yZ = y * Z;
    float zZ = z * Z;
    float3x3 m = {
        1.0 - (yY + zZ), xY - wZ, xZ + wY,
        xY + wZ, 1.0 - (xX + zZ), yZ - wX,
        xZ - wY, yZ + wX, 1.0 - (xX + yY)
    };
    return m;
}
inline float vpxDegToRad(float a) { return a * 0.0174532925f; }
float3x3 get_mat(float4 headsetrot, float rotate)
{
    float radians = vpxDegToRad(rotate);
    float4 yaw_quat = euler2quat(radians, 0, 0);
    float4 combined_quat = qmult(headsetrot, yaw_quat);
    return (quat2mat(combined_quat));
}
int apply_mat(UINT64 structp, float x, float y, float z, float3x3 mat)
{
    float* x_pos;
    float* y_pos;
    float* z_pos;
    x_pos = (float*)structp + (96 / 4);
    y_pos = (float*)structp + (100 / 4);
    z_pos = (float*)structp + (104 / 4);
    float* width_scalep;
    float* height_scalep;
    width_scalep = (float*)structp + (112 / 4);
    height_scalep = (float*)structp + (132 / 4);
    float* x_sidevec;
    float* y_sidevec;
    float* z_sidevec;
    float* x_upvec;
    float* y_upvec;
    float* z_upvec;
    float* x_fwvec;
    float* y_fwvec;
    float* z_fwvec;
    x_sidevec = (float*)structp + (48 / 4);
    y_sidevec = (float*)structp + (52 / 4);
    z_sidevec = (float*)structp + (56 / 4);
    x_upvec = (float*)structp + (64 / 4);
    y_upvec = (float*)structp + (68 / 4);
    z_upvec = (float*)structp + (72 / 4);
    x_fwvec = (float*)structp + (80 / 4);
    y_fwvec = (float*)structp + (84 / 4);
    z_fwvec = (float*)structp + (88 / 4);
    games_x = *x_pos;
    games_y = *y_pos;
    games_z = *z_pos;
    games_x_sidevec = *x_sidevec;
    games_y_sidevec = *y_sidevec;
    games_z_sidevec = *z_sidevec;
    games_x_upvec = *x_upvec;
    games_y_upvec = *y_upvec;
    games_z_upvec = *z_upvec;
    games_x_fwvec = *x_fwvec;
    games_y_fwvec = *y_fwvec;
    games_z_fwvec = *z_fwvec;
    if (vr_active == 1) {
        if (follow_active == 0) {
            *x_pos = x;
            *y_pos = y;
            *z_pos = z;
        }
        last_x = x;
        last_y = y;
        last_z = y;
        *height_scalep = height_scale;
        *width_scalep = width_scale;
        *x_sidevec = mat.a;
        *y_sidevec = mat.b;
        *z_sidevec = mat.c;
        *x_upvec = mat.d;
        *y_upvec = mat.e;
        *z_upvec = mat.f;
        *x_fwvec = mat.g;
        *y_fwvec = mat.h;
        *z_fwvec = mat.i;
    }
    return 0;
}
vpxfloat4 GetRotation(vr::HmdMatrix34_t matrix)
{
    vpxfloat4 q;
    q.w = sqrt(fmax(0, 1 + matrix.m[0][0] + matrix.m[1][1] + matrix.m[2][2])) / 2;
    q.x = sqrt(fmax(0, 1 + matrix.m[0][0] - matrix.m[1][1] - matrix.m[2][2])) / 2;
    q.y = sqrt(fmax(0, 1 - matrix.m[0][0] + matrix.m[1][1] - matrix.m[2][2])) / 2;
    q.z = sqrt(fmax(0, 1 - matrix.m[0][0] - matrix.m[1][1] + matrix.m[2][2])) / 2;
    q.x = copysign(q.x, matrix.m[2][1] - matrix.m[1][2]);
    q.y = copysign(q.y, matrix.m[0][2] - matrix.m[2][0]);
    q.z = copysign(q.z, matrix.m[1][0] - matrix.m[0][1]);
    return q;
}
__declspec(dllexport) int __cdecl update()
{
    int curVorpXFrame = 0;
    if (VorpXFrame != curVorpXFrame) {
        vpxfloat3 delta_rot;
        delta_rot.x = 0;
        delta_rot.y = 0;
        delta_rot.z = 0;
        VorpXFrame = curVorpXFrame;
    }
    if (!forwarder) {
        return 0;
    }
    vr::HmdMatrix44_t Right_Projection_matrix = forwarder->m_pHMD->GetProjectionMatrix(vr::EVREye::Eye_Right, 0.05, 500);
    float fSecondsSinceLastVsync;
    forwarder->m_pHMD->GetTimeSinceLastVsync(&fSecondsSinceLastVsync, 0);
    float fDisplayFrequency = forwarder->m_pHMD->GetFloatTrackedDeviceProperty(vr::k_unTrackedDeviceIndex_Hmd, vr::Prop_DisplayFrequency_Float);
    float fFrameDuration = 1.f / fDisplayFrequency;
    float fVsyncToPhotons = forwarder->m_pHMD->GetFloatTrackedDeviceProperty(vr::k_unTrackedDeviceIndex_Hmd, vr::Prop_SecondsFromVsyncToPhotons_Float);
    float fPredictedSecondsFromNow = fFrameDuration - fSecondsSinceLastVsync + fVsyncToPhotons;
    forwarder->m_pHMD->GetDeviceToAbsoluteTrackingPose(vr::TrackingUniverseOrigin::TrackingUniverseStanding, fPredictedSecondsFromNow, forwarder->m_rTrackedDevicePose, vr::k_unMaxTrackedDeviceCount);
    vr::TrackedDevicePose_t Pose = forwarder->m_rTrackedDevicePose[vr::k_unTrackedDeviceIndex_Hmd];
    vr::HmdMatrix34_t matPose = Pose.mDeviceToAbsoluteTracking;
    vpxfloat3 headsetpos = vpxfloat3 { matPose.m[0][3], matPose.m[1][3], matPose.m[2][3] };
    vpxfloat4 headsetrot = GetRotation(matPose);
    vr::HmdVector3d_t rot = QuaternionToEuler(vr::HmdQuaternion_t { headsetrot.w, headsetrot.x, headsetrot.y, headsetrot.z });
    last_headsetrot.x = rot.v[0];
    last_headsetrot.y = rot.v[1];
    last_headsetrot.z = rot.v[2];
    last_headsetpos.x = matPose.m[0][3];
    last_headsetpos.y = matPose.m[1][3];
    last_headsetpos.z = matPose.m[2][3];
    headsetpos.x -= offset_x;
    headsetpos.y -= offset_y;
    headsetpos.z -= offset_z;
    vpxfloat3 corected_headsetpos = headsetpos;
    float new_cam_x = origin_x + (position_scale * corected_headsetpos.x);
    float new_cam_y = origin_y + (position_scale * corected_headsetpos.y);
    float new_cam_z = origin_z - (position_scale * corected_headsetpos.z);
    if (structpos == 4545) {
        return 0;
    }
    float4 own_quat = { -headsetrot.w, headsetrot.x, headsetrot.y, headsetrot.z };
    float3x3 mat = get_mat(own_quat, added_rotation);
    apply_mat(structpos, new_cam_x, new_cam_y, new_cam_z, mat);
    if (structpos2 != 4545) {
        apply_mat(structpos2, new_cam_x, new_cam_y, new_cam_z, mat);
    }
    time_t rawtime;
    struct tm* timeinfo;
    return 1 + 3;
}
typedef HRESULT(__stdcall* IDirect3DDevice9_QueryInterface)(IDirect3DDevice9*, const IID&, void**);
IDirect3DDevice9_QueryInterface IDirect3DDevice9_QueryInterface_orig = 0;
HRESULT __stdcall IDirect3DDevice9_QueryInterface_hook(IDirect3DDevice9* pDevice, const IID& riid, void** ppvObj)
{
    vireio::debugf("IDirect3DDevice9_QueryInterface_hook: %i, %i, %i", pDevice, riid, ppvObj);
    return IDirect3DDevice9_QueryInterface_orig(pDevice, riid, ppvObj);
}
typedef ULONG(__stdcall* IDirect3DDevice9_AddRef)(IDirect3DDevice9*);
IDirect3DDevice9_AddRef IDirect3DDevice9_AddRef_orig = 0;
ULONG __stdcall IDirect3DDevice9_AddRef_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_AddRef_hook: %i", pDevice);
    return IDirect3DDevice9_AddRef_orig(pDevice);
}
typedef ULONG(__stdcall* IDirect3DDevice9_Release)(IDirect3DDevice9*);
IDirect3DDevice9_Release IDirect3DDevice9_Release_orig = 0;
ULONG __stdcall IDirect3DDevice9_Release_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_Release_hook: %i", pDevice);
    return IDirect3DDevice9_Release_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_TestCooperativeLevel)(IDirect3DDevice9*);
IDirect3DDevice9_TestCooperativeLevel IDirect3DDevice9_TestCooperativeLevel_orig = 0;
HRESULT __stdcall IDirect3DDevice9_TestCooperativeLevel_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_TestCooperativeLevel_hook: %i", pDevice);
    return IDirect3DDevice9_TestCooperativeLevel_orig(pDevice);
}
typedef UINT(__stdcall* IDirect3DDevice9_GetAvailableTextureMem)(IDirect3DDevice9*);
IDirect3DDevice9_GetAvailableTextureMem IDirect3DDevice9_GetAvailableTextureMem_orig = 0;
UINT __stdcall IDirect3DDevice9_GetAvailableTextureMem_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_GetAvailableTextureMem_hook: %i", pDevice);
    return IDirect3DDevice9_GetAvailableTextureMem_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_EvictManagedResources)(IDirect3DDevice9*);
IDirect3DDevice9_EvictManagedResources IDirect3DDevice9_EvictManagedResources_orig = 0;
HRESULT __stdcall IDirect3DDevice9_EvictManagedResources_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_EvictManagedResources_hook: %i", pDevice);
    return IDirect3DDevice9_EvictManagedResources_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetDirect3D)(IDirect3DDevice9*, IDirect3D9**);
IDirect3DDevice9_GetDirect3D IDirect3DDevice9_GetDirect3D_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetDirect3D_hook(IDirect3DDevice9* pDevice, IDirect3D9** ppD3D9)
{
    vireio::debugf("IDirect3DDevice9_GetDirect3D_hook: %i, %i", pDevice, ppD3D9);
    return IDirect3DDevice9_GetDirect3D_orig(pDevice, ppD3D9);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetDeviceCaps)(IDirect3DDevice9*, D3DCAPS9*);
IDirect3DDevice9_GetDeviceCaps IDirect3DDevice9_GetDeviceCaps_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetDeviceCaps_hook(IDirect3DDevice9* pDevice, D3DCAPS9* pCaps)
{
    vireio::debugf("IDirect3DDevice9_GetDeviceCaps_hook: %i, %i", pDevice, pCaps);
    return IDirect3DDevice9_GetDeviceCaps_orig(pDevice, pCaps);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetDisplayMode)(IDirect3DDevice9*, UINT, D3DDISPLAYMODE*);
IDirect3DDevice9_GetDisplayMode IDirect3DDevice9_GetDisplayMode_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetDisplayMode_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, D3DDISPLAYMODE* pMode)
{
    vireio::debugf("IDirect3DDevice9_GetDisplayMode_hook: %i, %i, %i", pDevice, iSwapChain, pMode);
    return IDirect3DDevice9_GetDisplayMode_orig(pDevice, iSwapChain, pMode);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetCreationParameters)(IDirect3DDevice9*, D3DDEVICE_CREATION_PARAMETERS*);
IDirect3DDevice9_GetCreationParameters IDirect3DDevice9_GetCreationParameters_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetCreationParameters_hook(IDirect3DDevice9* pDevice, D3DDEVICE_CREATION_PARAMETERS* pParameters)
{
    vireio::debugf("IDirect3DDevice9_GetCreationParameters_hook: %i, %i", pDevice, pParameters);
    return IDirect3DDevice9_GetCreationParameters_orig(pDevice, pParameters);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetCursorProperties)(IDirect3DDevice9*, UINT, UINT, IDirect3DSurface9*);
IDirect3DDevice9_SetCursorProperties IDirect3DDevice9_SetCursorProperties_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetCursorProperties_hook(IDirect3DDevice9* pDevice, UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap)
{
    vireio::debugf("IDirect3DDevice9_SetCursorProperties_hook: %i, %i, %i, %i", pDevice, XHotSpot, YHotSpot, pCursorBitmap);
    return IDirect3DDevice9_SetCursorProperties_orig(pDevice, XHotSpot, YHotSpot, pCursorBitmap);
}
typedef void(__stdcall* IDirect3DDevice9_SetCursorPosition)(IDirect3DDevice9*, int, int, DWORD);
IDirect3DDevice9_SetCursorPosition IDirect3DDevice9_SetCursorPosition_orig = 0;
void __stdcall IDirect3DDevice9_SetCursorPosition_hook(IDirect3DDevice9* pDevice, int X, int Y, DWORD Flags)
{
    vireio::debugf("IDirect3DDevice9_SetCursorPosition_hook: %i, %i, %i, %i", pDevice, X, Y, Flags);
    return IDirect3DDevice9_SetCursorPosition_orig(pDevice, X, Y, Flags);
}
typedef BOOL(__stdcall* IDirect3DDevice9_ShowCursor)(IDirect3DDevice9*, BOOL);
IDirect3DDevice9_ShowCursor IDirect3DDevice9_ShowCursor_orig = 0;
BOOL __stdcall IDirect3DDevice9_ShowCursor_hook(IDirect3DDevice9* pDevice, BOOL bShow)
{
    vireio::debugf("IDirect3DDevice9_ShowCursor_hook: %i, %i", pDevice, bShow);
    return IDirect3DDevice9_ShowCursor_orig(pDevice, bShow);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateAdditionalSwapChain)(IDirect3DDevice9*, D3DPRESENT_PARAMETERS*, IDirect3DSwapChain9**);
IDirect3DDevice9_CreateAdditionalSwapChain IDirect3DDevice9_CreateAdditionalSwapChain_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateAdditionalSwapChain_hook(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DSwapChain9** pSwapChain)
{
    vireio::debugf("IDirect3DDevice9_CreateAdditionalSwapChain_hook: %i, %i, %i", pDevice, pPresentationParameters, pSwapChain);
    return IDirect3DDevice9_CreateAdditionalSwapChain_orig(pDevice, pPresentationParameters, pSwapChain);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetSwapChain)(IDirect3DDevice9*, UINT, IDirect3DSwapChain9**);
IDirect3DDevice9_GetSwapChain IDirect3DDevice9_GetSwapChain_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetSwapChain_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, IDirect3DSwapChain9** pSwapChain)
{
    vireio::debugf("IDirect3DDevice9_GetSwapChain_hook: %i, %i, %i", pDevice, iSwapChain, pSwapChain);
    return IDirect3DDevice9_GetSwapChain_orig(pDevice, iSwapChain, pSwapChain);
}
typedef UINT(__stdcall* IDirect3DDevice9_GetNumberOfSwapChains)(IDirect3DDevice9*);
IDirect3DDevice9_GetNumberOfSwapChains IDirect3DDevice9_GetNumberOfSwapChains_orig = 0;
UINT __stdcall IDirect3DDevice9_GetNumberOfSwapChains_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_GetNumberOfSwapChains_hook: %i", pDevice);
    return IDirect3DDevice9_GetNumberOfSwapChains_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_Reset)(IDirect3DDevice9*, D3DPRESENT_PARAMETERS*);
IDirect3DDevice9_Reset IDirect3DDevice9_Reset_orig = 0;
HRESULT __stdcall IDirect3DDevice9_Reset_hook(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters)
{
    vireio::debugf("IDirect3DDevice9_Reset_hook: %i, %i", pDevice, pPresentationParameters);
    return IDirect3DDevice9_Reset_orig(pDevice, pPresentationParameters);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_Present)(IDirect3DDevice9*, const RECT*, const RECT*, HWND, const RGNDATA*);
IDirect3DDevice9_Present IDirect3DDevice9_Present_orig = 0;
HRESULT __stdcall IDirect3DDevice9_Present_hook(IDirect3DDevice9* pDevice, const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion)
{
    vireio::debugf("IDirect3DDevice9_Present_hook: %i, %i, %i, %i, %i", pDevice, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion);
    return IDirect3DDevice9_Present_orig(pDevice, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetBackBuffer)(IDirect3DDevice9*, UINT, UINT, D3DBACKBUFFER_TYPE, IDirect3DSurface9**);
IDirect3DDevice9_GetBackBuffer IDirect3DDevice9_GetBackBuffer_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetBackBuffer_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer)
{
    vireio::debugf("IDirect3DDevice9_GetBackBuffer_hook: %i, %i, %i, %i, %i", pDevice, iSwapChain, iBackBuffer, Type, ppBackBuffer);
    return IDirect3DDevice9_GetBackBuffer_orig(pDevice, iSwapChain, iBackBuffer, Type, ppBackBuffer);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetRasterStatus)(IDirect3DDevice9*, UINT, D3DRASTER_STATUS*);
IDirect3DDevice9_GetRasterStatus IDirect3DDevice9_GetRasterStatus_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetRasterStatus_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, D3DRASTER_STATUS* pRasterStatus)
{
    vireio::debugf("IDirect3DDevice9_GetRasterStatus_hook: %i, %i, %i", pDevice, iSwapChain, pRasterStatus);
    return IDirect3DDevice9_GetRasterStatus_orig(pDevice, iSwapChain, pRasterStatus);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetDialogBoxMode)(IDirect3DDevice9*, BOOL);
IDirect3DDevice9_SetDialogBoxMode IDirect3DDevice9_SetDialogBoxMode_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetDialogBoxMode_hook(IDirect3DDevice9* pDevice, BOOL bEnableDialogs)
{
    vireio::debugf("IDirect3DDevice9_SetDialogBoxMode_hook: %i, %i", pDevice, bEnableDialogs);
    return IDirect3DDevice9_SetDialogBoxMode_orig(pDevice, bEnableDialogs);
}
typedef void(__stdcall* IDirect3DDevice9_SetGammaRamp)(IDirect3DDevice9*, UINT, DWORD, const D3DGAMMARAMP*);
IDirect3DDevice9_SetGammaRamp IDirect3DDevice9_SetGammaRamp_orig = 0;
void __stdcall IDirect3DDevice9_SetGammaRamp_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, DWORD Flags, const D3DGAMMARAMP* pRamp)
{
    vireio::debugf("IDirect3DDevice9_SetGammaRamp_hook: %i, %i, %i, %i", pDevice, iSwapChain, Flags, pRamp);
    return IDirect3DDevice9_SetGammaRamp_orig(pDevice, iSwapChain, Flags, pRamp);
}
typedef void(__stdcall* IDirect3DDevice9_GetGammaRamp)(IDirect3DDevice9*, UINT, D3DGAMMARAMP*);
IDirect3DDevice9_GetGammaRamp IDirect3DDevice9_GetGammaRamp_orig = 0;
void __stdcall IDirect3DDevice9_GetGammaRamp_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, D3DGAMMARAMP* pRamp)
{
    vireio::debugf("IDirect3DDevice9_GetGammaRamp_hook: %i, %i, %i", pDevice, iSwapChain, pRamp);
    return IDirect3DDevice9_GetGammaRamp_orig(pDevice, iSwapChain, pRamp);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateTexture)(IDirect3DDevice9*, UINT, UINT, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DTexture9**, HANDLE*);
IDirect3DDevice9_CreateTexture IDirect3DDevice9_CreateTexture_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateTexture_hook(IDirect3DDevice9* pDevice, UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateTexture_hook: %i, %i, %i, %i, %i, %i, %i, %i, %i", pDevice, Width, Height, Levels, Usage, Format, Pool, ppTexture, pSharedHandle);
    return IDirect3DDevice9_CreateTexture_orig(pDevice, Width, Height, Levels, Usage, Format, Pool, ppTexture, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateVolumeTexture)(IDirect3DDevice9*, UINT, UINT, UINT, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DVolumeTexture9**, HANDLE*);
IDirect3DDevice9_CreateVolumeTexture IDirect3DDevice9_CreateVolumeTexture_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateVolumeTexture_hook(IDirect3DDevice9* pDevice, UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateVolumeTexture_hook: %i, %i, %i, %i, %i, %i, %i, %i, %i, %i", pDevice, Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture, pSharedHandle);
    return IDirect3DDevice9_CreateVolumeTexture_orig(pDevice, Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateCubeTexture)(IDirect3DDevice9*, UINT, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DCubeTexture9**, HANDLE*);
IDirect3DDevice9_CreateCubeTexture IDirect3DDevice9_CreateCubeTexture_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateCubeTexture_hook(IDirect3DDevice9* pDevice, UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateCubeTexture_hook: %i, %i, %i, %i, %i, %i, %i, %i", pDevice, EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture, pSharedHandle);
    return IDirect3DDevice9_CreateCubeTexture_orig(pDevice, EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateVertexBuffer)(IDirect3DDevice9*, UINT, DWORD, DWORD, D3DPOOL, IDirect3DVertexBuffer9**, HANDLE*);
IDirect3DDevice9_CreateVertexBuffer IDirect3DDevice9_CreateVertexBuffer_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateVertexBuffer_hook(IDirect3DDevice9* pDevice, UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateVertexBuffer_hook: %i, %i, %i, %i, %i, %i, %i", pDevice, Length, Usage, FVF, Pool, ppVertexBuffer, pSharedHandle);
    return IDirect3DDevice9_CreateVertexBuffer_orig(pDevice, Length, Usage, FVF, Pool, ppVertexBuffer, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateIndexBuffer)(IDirect3DDevice9*, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DIndexBuffer9**, HANDLE*);
IDirect3DDevice9_CreateIndexBuffer IDirect3DDevice9_CreateIndexBuffer_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateIndexBuffer_hook(IDirect3DDevice9* pDevice, UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateIndexBuffer_hook: %i, %i, %i, %i, %i, %i, %i", pDevice, Length, Usage, Format, Pool, ppIndexBuffer, pSharedHandle);
    return IDirect3DDevice9_CreateIndexBuffer_orig(pDevice, Length, Usage, Format, Pool, ppIndexBuffer, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateRenderTarget)(IDirect3DDevice9*, UINT, UINT, D3DFORMAT, D3DMULTISAMPLE_TYPE, DWORD, BOOL, IDirect3DSurface9**, HANDLE*);
IDirect3DDevice9_CreateRenderTarget IDirect3DDevice9_CreateRenderTarget_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateRenderTarget_hook(IDirect3DDevice9* pDevice, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateRenderTarget_hook: %i, %i, %i, %i, %i, %i, %i, %i, %i", pDevice, Width, Height, Format, MultiSample, MultisampleQuality, Lockable, ppSurface, pSharedHandle);
    return IDirect3DDevice9_CreateRenderTarget_orig(pDevice, Width, Height, Format, MultiSample, MultisampleQuality, Lockable, ppSurface, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateDepthStencilSurface)(IDirect3DDevice9*, UINT, UINT, D3DFORMAT, D3DMULTISAMPLE_TYPE, DWORD, BOOL, IDirect3DSurface9**, HANDLE*);
IDirect3DDevice9_CreateDepthStencilSurface IDirect3DDevice9_CreateDepthStencilSurface_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateDepthStencilSurface_hook(IDirect3DDevice9* pDevice, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateDepthStencilSurface_hook: %i, %i, %i, %i, %i, %i, %i, %i, %i", pDevice, Width, Height, Format, MultiSample, MultisampleQuality, Discard, ppSurface, pSharedHandle);
    return IDirect3DDevice9_CreateDepthStencilSurface_orig(pDevice, Width, Height, Format, MultiSample, MultisampleQuality, Discard, ppSurface, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_UpdateSurface)(IDirect3DDevice9*, IDirect3DSurface9*, const RECT*, IDirect3DSurface9*, const POINT*);
IDirect3DDevice9_UpdateSurface IDirect3DDevice9_UpdateSurface_orig = 0;
HRESULT __stdcall IDirect3DDevice9_UpdateSurface_hook(IDirect3DDevice9* pDevice, IDirect3DSurface9* pSourceSurface, const RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, const POINT* pDestPoint)
{
    vireio::debugf("IDirect3DDevice9_UpdateSurface_hook: %i, %i, %i, %i, %i", pDevice, pSourceSurface, pSourceRect, pDestinationSurface, pDestPoint);
    return IDirect3DDevice9_UpdateSurface_orig(pDevice, pSourceSurface, pSourceRect, pDestinationSurface, pDestPoint);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_UpdateTexture)(IDirect3DDevice9*, IDirect3DBaseTexture9*, IDirect3DBaseTexture9*);
IDirect3DDevice9_UpdateTexture IDirect3DDevice9_UpdateTexture_orig = 0;
HRESULT __stdcall IDirect3DDevice9_UpdateTexture_hook(IDirect3DDevice9* pDevice, IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture)
{
    vireio::debugf("IDirect3DDevice9_UpdateTexture_hook: %i, %i, %i", pDevice, pSourceTexture, pDestinationTexture);
    return IDirect3DDevice9_UpdateTexture_orig(pDevice, pSourceTexture, pDestinationTexture);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetRenderTargetData)(IDirect3DDevice9*, IDirect3DSurface9*, IDirect3DSurface9*);
IDirect3DDevice9_GetRenderTargetData IDirect3DDevice9_GetRenderTargetData_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetRenderTargetData_hook(IDirect3DDevice9* pDevice, IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface)
{
    vireio::debugf("IDirect3DDevice9_GetRenderTargetData_hook: %i, %i, %i", pDevice, pRenderTarget, pDestSurface);
    return IDirect3DDevice9_GetRenderTargetData_orig(pDevice, pRenderTarget, pDestSurface);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetFrontBufferData)(IDirect3DDevice9*, UINT, IDirect3DSurface9*);
IDirect3DDevice9_GetFrontBufferData IDirect3DDevice9_GetFrontBufferData_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetFrontBufferData_hook(IDirect3DDevice9* pDevice, UINT iSwapChain, IDirect3DSurface9* pDestSurface)
{
    vireio::debugf("IDirect3DDevice9_GetFrontBufferData_hook: %i, %i, %i", pDevice, iSwapChain, pDestSurface);
    return IDirect3DDevice9_GetFrontBufferData_orig(pDevice, iSwapChain, pDestSurface);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_StretchRect)(IDirect3DDevice9*, IDirect3DSurface9*, const RECT*, IDirect3DSurface9*, const RECT*, D3DTEXTUREFILTERTYPE);
IDirect3DDevice9_StretchRect IDirect3DDevice9_StretchRect_orig = 0;
HRESULT __stdcall IDirect3DDevice9_StretchRect_hook(IDirect3DDevice9* pDevice, IDirect3DSurface9* pSourceSurface, const RECT* pSourceRect, IDirect3DSurface9* pDestSurface, const RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter)
{
    vireio::debugf("IDirect3DDevice9_StretchRect_hook: %i, %i, %i, %i, %i, %i", pDevice, pSourceSurface, pSourceRect, pDestSurface, pDestRect, Filter);
    return IDirect3DDevice9_StretchRect_orig(pDevice, pSourceSurface, pSourceRect, pDestSurface, pDestRect, Filter);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_ColorFill)(IDirect3DDevice9*, IDirect3DSurface9*, const RECT*, D3DCOLOR);
IDirect3DDevice9_ColorFill IDirect3DDevice9_ColorFill_orig = 0;
HRESULT __stdcall IDirect3DDevice9_ColorFill_hook(IDirect3DDevice9* pDevice, IDirect3DSurface9* pSurface, const RECT* pRect, D3DCOLOR color)
{
    vireio::debugf("IDirect3DDevice9_ColorFill_hook: %i, %i, %i, %i", pDevice, pSurface, pRect, color);
    return IDirect3DDevice9_ColorFill_orig(pDevice, pSurface, pRect, color);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateOffscreenPlainSurface)(IDirect3DDevice9*, UINT, UINT, D3DFORMAT, D3DPOOL, IDirect3DSurface9**, HANDLE*);
IDirect3DDevice9_CreateOffscreenPlainSurface IDirect3DDevice9_CreateOffscreenPlainSurface_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateOffscreenPlainSurface_hook(IDirect3DDevice9* pDevice, UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
{
    vireio::debugf("IDirect3DDevice9_CreateOffscreenPlainSurface_hook: %i, %i, %i, %i, %i, %i, %i", pDevice, Width, Height, Format, Pool, ppSurface, pSharedHandle);
    return IDirect3DDevice9_CreateOffscreenPlainSurface_orig(pDevice, Width, Height, Format, Pool, ppSurface, pSharedHandle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetRenderTarget)(IDirect3DDevice9*, DWORD, IDirect3DSurface9*);
IDirect3DDevice9_SetRenderTarget IDirect3DDevice9_SetRenderTarget_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetRenderTarget_hook(IDirect3DDevice9* pDevice, DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget)
{
    vireio::debugf("IDirect3DDevice9_SetRenderTarget_hook: %i, %i, %i", pDevice, RenderTargetIndex, pRenderTarget);
    return IDirect3DDevice9_SetRenderTarget_orig(pDevice, RenderTargetIndex, pRenderTarget);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetRenderTarget)(IDirect3DDevice9*, DWORD, IDirect3DSurface9**);
IDirect3DDevice9_GetRenderTarget IDirect3DDevice9_GetRenderTarget_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetRenderTarget_hook(IDirect3DDevice9* pDevice, DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget)
{
    vireio::debugf("IDirect3DDevice9_GetRenderTarget_hook: %i, %i, %i", pDevice, RenderTargetIndex, ppRenderTarget);
    return IDirect3DDevice9_GetRenderTarget_orig(pDevice, RenderTargetIndex, ppRenderTarget);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetDepthStencilSurface)(IDirect3DDevice9*, IDirect3DSurface9*);
IDirect3DDevice9_SetDepthStencilSurface IDirect3DDevice9_SetDepthStencilSurface_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetDepthStencilSurface_hook(IDirect3DDevice9* pDevice, IDirect3DSurface9* pNewZStencil)
{
    vireio::debugf("IDirect3DDevice9_SetDepthStencilSurface_hook: %i, %i", pDevice, pNewZStencil);
    return IDirect3DDevice9_SetDepthStencilSurface_orig(pDevice, pNewZStencil);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetDepthStencilSurface)(IDirect3DDevice9*, IDirect3DSurface9**);
IDirect3DDevice9_GetDepthStencilSurface IDirect3DDevice9_GetDepthStencilSurface_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetDepthStencilSurface_hook(IDirect3DDevice9* pDevice, IDirect3DSurface9** ppZStencilSurface)
{
    vireio::debugf("IDirect3DDevice9_GetDepthStencilSurface_hook: %i, %i", pDevice, ppZStencilSurface);
    return IDirect3DDevice9_GetDepthStencilSurface_orig(pDevice, ppZStencilSurface);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_BeginScene)(IDirect3DDevice9*);
IDirect3DDevice9_BeginScene IDirect3DDevice9_BeginScene_orig = 0;
HRESULT __stdcall IDirect3DDevice9_BeginScene_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_BeginScene_hook: %i", pDevice);
    return IDirect3DDevice9_BeginScene_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_EndScene)(IDirect3DDevice9*);
IDirect3DDevice9_EndScene IDirect3DDevice9_EndScene_orig = 0;
HRESULT __stdcall IDirect3DDevice9_EndScene_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_EndScene_hook: %i", pDevice);
    return IDirect3DDevice9_EndScene_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_Clear)(IDirect3DDevice9*, DWORD, const D3DRECT*, DWORD, D3DCOLOR, float, DWORD);
IDirect3DDevice9_Clear IDirect3DDevice9_Clear_orig = 0;
HRESULT __stdcall IDirect3DDevice9_Clear_hook(IDirect3DDevice9* pDevice, DWORD Count, const D3DRECT* pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil)
{
    vireio::debugf("IDirect3DDevice9_Clear_hook: %i, %i, %i, %i, %i, %i, %i", pDevice, Count, pRects, Flags, Color, Z, Stencil);
    return IDirect3DDevice9_Clear_orig(pDevice, Count, pRects, Flags, Color, Z, Stencil);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetTransform)(IDirect3DDevice9*, D3DTRANSFORMSTATETYPE, const D3DMATRIX*);
IDirect3DDevice9_SetTransform IDirect3DDevice9_SetTransform_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetTransform_hook(IDirect3DDevice9* pDevice, D3DTRANSFORMSTATETYPE State, const D3DMATRIX* pMatrix)
{
    vireio::debugf("IDirect3DDevice9_SetTransform_hook: %i, %i, %i", pDevice, State, pMatrix);
    return IDirect3DDevice9_SetTransform_orig(pDevice, State, pMatrix);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetTransform)(IDirect3DDevice9*, D3DTRANSFORMSTATETYPE, D3DMATRIX*);
IDirect3DDevice9_GetTransform IDirect3DDevice9_GetTransform_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetTransform_hook(IDirect3DDevice9* pDevice, D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix)
{
    vireio::debugf("IDirect3DDevice9_GetTransform_hook: %i, %i, %i", pDevice, State, pMatrix);
    return IDirect3DDevice9_GetTransform_orig(pDevice, State, pMatrix);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_MultiplyTransform)(IDirect3DDevice9*, D3DTRANSFORMSTATETYPE, const D3DMATRIX*);
IDirect3DDevice9_MultiplyTransform IDirect3DDevice9_MultiplyTransform_orig = 0;
HRESULT __stdcall IDirect3DDevice9_MultiplyTransform_hook(IDirect3DDevice9* pDevice, D3DTRANSFORMSTATETYPE arg1, const D3DMATRIX* arg2)
{
    vireio::debugf("IDirect3DDevice9_MultiplyTransform_hook: %i, %i, %i", pDevice, arg1, arg2);
    return IDirect3DDevice9_MultiplyTransform_orig(pDevice, arg1, arg2);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetViewport)(IDirect3DDevice9*, const D3DVIEWPORT9*);
IDirect3DDevice9_SetViewport IDirect3DDevice9_SetViewport_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetViewport_hook(IDirect3DDevice9* pDevice, const D3DVIEWPORT9* pViewport)
{
    vireio::debugf("IDirect3DDevice9_SetViewport_hook: %i, %i", pDevice, pViewport);
    return IDirect3DDevice9_SetViewport_orig(pDevice, pViewport);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetViewport)(IDirect3DDevice9*, D3DVIEWPORT9*);
IDirect3DDevice9_GetViewport IDirect3DDevice9_GetViewport_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetViewport_hook(IDirect3DDevice9* pDevice, D3DVIEWPORT9* pViewport)
{
    vireio::debugf("IDirect3DDevice9_GetViewport_hook: %i, %i", pDevice, pViewport);
    return IDirect3DDevice9_GetViewport_orig(pDevice, pViewport);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetMaterial)(IDirect3DDevice9*, const D3DMATERIAL9*);
IDirect3DDevice9_SetMaterial IDirect3DDevice9_SetMaterial_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetMaterial_hook(IDirect3DDevice9* pDevice, const D3DMATERIAL9* pMaterial)
{
    vireio::debugf("IDirect3DDevice9_SetMaterial_hook: %i, %i", pDevice, pMaterial);
    return IDirect3DDevice9_SetMaterial_orig(pDevice, pMaterial);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetMaterial)(IDirect3DDevice9*, D3DMATERIAL9*);
IDirect3DDevice9_GetMaterial IDirect3DDevice9_GetMaterial_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetMaterial_hook(IDirect3DDevice9* pDevice, D3DMATERIAL9* pMaterial)
{
    vireio::debugf("IDirect3DDevice9_GetMaterial_hook: %i, %i", pDevice, pMaterial);
    return IDirect3DDevice9_GetMaterial_orig(pDevice, pMaterial);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetLight)(IDirect3DDevice9*, DWORD, const D3DLIGHT9*);
IDirect3DDevice9_SetLight IDirect3DDevice9_SetLight_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetLight_hook(IDirect3DDevice9* pDevice, DWORD Index, const D3DLIGHT9* arg2)
{
    vireio::debugf("IDirect3DDevice9_SetLight_hook: %i, %i, %i", pDevice, Index, arg2);
    return IDirect3DDevice9_SetLight_orig(pDevice, Index, arg2);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetLight)(IDirect3DDevice9*, DWORD, D3DLIGHT9*);
IDirect3DDevice9_GetLight IDirect3DDevice9_GetLight_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetLight_hook(IDirect3DDevice9* pDevice, DWORD Index, D3DLIGHT9* arg2)
{
    vireio::debugf("IDirect3DDevice9_GetLight_hook: %i, %i, %i", pDevice, Index, arg2);
    return IDirect3DDevice9_GetLight_orig(pDevice, Index, arg2);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_LightEnable)(IDirect3DDevice9*, DWORD, BOOL);
IDirect3DDevice9_LightEnable IDirect3DDevice9_LightEnable_orig = 0;
HRESULT __stdcall IDirect3DDevice9_LightEnable_hook(IDirect3DDevice9* pDevice, DWORD Index, BOOL Enable)
{
    vireio::debugf("IDirect3DDevice9_LightEnable_hook: %i, %i, %i", pDevice, Index, Enable);
    return IDirect3DDevice9_LightEnable_orig(pDevice, Index, Enable);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetLightEnable)(IDirect3DDevice9*, DWORD, BOOL*);
IDirect3DDevice9_GetLightEnable IDirect3DDevice9_GetLightEnable_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetLightEnable_hook(IDirect3DDevice9* pDevice, DWORD Index, BOOL* pEnable)
{
    vireio::debugf("IDirect3DDevice9_GetLightEnable_hook: %i, %i, %i", pDevice, Index, pEnable);
    return IDirect3DDevice9_GetLightEnable_orig(pDevice, Index, pEnable);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetClipPlane)(IDirect3DDevice9*, DWORD, const float*);
IDirect3DDevice9_SetClipPlane IDirect3DDevice9_SetClipPlane_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetClipPlane_hook(IDirect3DDevice9* pDevice, DWORD Index, const float* pPlane)
{
    vireio::debugf("IDirect3DDevice9_SetClipPlane_hook: %i, %i, %i", pDevice, Index, pPlane);
    return IDirect3DDevice9_SetClipPlane_orig(pDevice, Index, pPlane);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetClipPlane)(IDirect3DDevice9*, DWORD, float*);
IDirect3DDevice9_GetClipPlane IDirect3DDevice9_GetClipPlane_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetClipPlane_hook(IDirect3DDevice9* pDevice, DWORD Index, float* pPlane)
{
    vireio::debugf("IDirect3DDevice9_GetClipPlane_hook: %i, %i, %i", pDevice, Index, pPlane);
    return IDirect3DDevice9_GetClipPlane_orig(pDevice, Index, pPlane);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetRenderState)(IDirect3DDevice9*, D3DRENDERSTATETYPE, DWORD);
IDirect3DDevice9_SetRenderState IDirect3DDevice9_SetRenderState_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetRenderState_hook(IDirect3DDevice9* pDevice, D3DRENDERSTATETYPE State, DWORD Value)
{
    vireio::debugf("IDirect3DDevice9_SetRenderState_hook: %i, %i, %i", pDevice, State, Value);
    return IDirect3DDevice9_SetRenderState_orig(pDevice, State, Value);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetRenderState)(IDirect3DDevice9*, D3DRENDERSTATETYPE, DWORD*);
IDirect3DDevice9_GetRenderState IDirect3DDevice9_GetRenderState_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetRenderState_hook(IDirect3DDevice9* pDevice, D3DRENDERSTATETYPE State, DWORD* pValue)
{
    vireio::debugf("IDirect3DDevice9_GetRenderState_hook: %i, %i, %i", pDevice, State, pValue);
    return IDirect3DDevice9_GetRenderState_orig(pDevice, State, pValue);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateStateBlock)(IDirect3DDevice9*, D3DSTATEBLOCKTYPE, IDirect3DStateBlock9**);
IDirect3DDevice9_CreateStateBlock IDirect3DDevice9_CreateStateBlock_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateStateBlock_hook(IDirect3DDevice9* pDevice, D3DSTATEBLOCKTYPE Type, IDirect3DStateBlock9** ppSB)
{
    vireio::debugf("IDirect3DDevice9_CreateStateBlock_hook: %i, %i, %i", pDevice, Type, ppSB);
    return IDirect3DDevice9_CreateStateBlock_orig(pDevice, Type, ppSB);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_BeginStateBlock)(IDirect3DDevice9*);
IDirect3DDevice9_BeginStateBlock IDirect3DDevice9_BeginStateBlock_orig = 0;
HRESULT __stdcall IDirect3DDevice9_BeginStateBlock_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_BeginStateBlock_hook: %i", pDevice);
    return IDirect3DDevice9_BeginStateBlock_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_EndStateBlock)(IDirect3DDevice9*, IDirect3DStateBlock9**);
IDirect3DDevice9_EndStateBlock IDirect3DDevice9_EndStateBlock_orig = 0;
HRESULT __stdcall IDirect3DDevice9_EndStateBlock_hook(IDirect3DDevice9* pDevice, IDirect3DStateBlock9** ppSB)
{
    vireio::debugf("IDirect3DDevice9_EndStateBlock_hook: %i, %i", pDevice, ppSB);
    return IDirect3DDevice9_EndStateBlock_orig(pDevice, ppSB);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetClipStatus)(IDirect3DDevice9*, const D3DCLIPSTATUS9*);
IDirect3DDevice9_SetClipStatus IDirect3DDevice9_SetClipStatus_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetClipStatus_hook(IDirect3DDevice9* pDevice, const D3DCLIPSTATUS9* pClipStatus)
{
    vireio::debugf("IDirect3DDevice9_SetClipStatus_hook: %i, %i", pDevice, pClipStatus);
    return IDirect3DDevice9_SetClipStatus_orig(pDevice, pClipStatus);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetClipStatus)(IDirect3DDevice9*, D3DCLIPSTATUS9*);
IDirect3DDevice9_GetClipStatus IDirect3DDevice9_GetClipStatus_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetClipStatus_hook(IDirect3DDevice9* pDevice, D3DCLIPSTATUS9* pClipStatus)
{
    vireio::debugf("IDirect3DDevice9_GetClipStatus_hook: %i, %i", pDevice, pClipStatus);
    return IDirect3DDevice9_GetClipStatus_orig(pDevice, pClipStatus);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetTexture)(IDirect3DDevice9*, DWORD, IDirect3DBaseTexture9**);
IDirect3DDevice9_GetTexture IDirect3DDevice9_GetTexture_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetTexture_hook(IDirect3DDevice9* pDevice, DWORD Stage, IDirect3DBaseTexture9** ppTexture)
{
    vireio::debugf("IDirect3DDevice9_GetTexture_hook: %i, %i, %i", pDevice, Stage, ppTexture);
    return IDirect3DDevice9_GetTexture_orig(pDevice, Stage, ppTexture);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetTexture)(IDirect3DDevice9*, DWORD, IDirect3DBaseTexture9*);
IDirect3DDevice9_SetTexture IDirect3DDevice9_SetTexture_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetTexture_hook(IDirect3DDevice9* pDevice, DWORD Stage, IDirect3DBaseTexture9* pTexture)
{
    vireio::debugf("IDirect3DDevice9_SetTexture_hook: %i, %i, %i", pDevice, Stage, pTexture);
    return IDirect3DDevice9_SetTexture_orig(pDevice, Stage, pTexture);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetTextureStageState)(IDirect3DDevice9*, DWORD, D3DTEXTURESTAGESTATETYPE, DWORD*);
IDirect3DDevice9_GetTextureStageState IDirect3DDevice9_GetTextureStageState_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetTextureStageState_hook(IDirect3DDevice9* pDevice, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD* pValue)
{
    vireio::debugf("IDirect3DDevice9_GetTextureStageState_hook: %i, %i, %i, %i", pDevice, Stage, Type, pValue);
    return IDirect3DDevice9_GetTextureStageState_orig(pDevice, Stage, Type, pValue);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetTextureStageState)(IDirect3DDevice9*, DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
IDirect3DDevice9_SetTextureStageState IDirect3DDevice9_SetTextureStageState_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetTextureStageState_hook(IDirect3DDevice9* pDevice, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
{
    vireio::debugf("IDirect3DDevice9_SetTextureStageState_hook: %i, %i, %i, %i", pDevice, Stage, Type, Value);
    return IDirect3DDevice9_SetTextureStageState_orig(pDevice, Stage, Type, Value);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetSamplerState)(IDirect3DDevice9*, DWORD, D3DSAMPLERSTATETYPE, DWORD*);
IDirect3DDevice9_GetSamplerState IDirect3DDevice9_GetSamplerState_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetSamplerState_hook(IDirect3DDevice9* pDevice, DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD* pValue)
{
    vireio::debugf("IDirect3DDevice9_GetSamplerState_hook: %i, %i, %i, %i", pDevice, Sampler, Type, pValue);
    return IDirect3DDevice9_GetSamplerState_orig(pDevice, Sampler, Type, pValue);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetSamplerState)(IDirect3DDevice9*, DWORD, D3DSAMPLERSTATETYPE, DWORD);
IDirect3DDevice9_SetSamplerState IDirect3DDevice9_SetSamplerState_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetSamplerState_hook(IDirect3DDevice9* pDevice, DWORD Sampler, D3DSAMPLERSTATETYPE Type, DWORD Value)
{
    vireio::debugf("IDirect3DDevice9_SetSamplerState_hook: %i, %i, %i, %i", pDevice, Sampler, Type, Value);
    return IDirect3DDevice9_SetSamplerState_orig(pDevice, Sampler, Type, Value);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_ValidateDevice)(IDirect3DDevice9*, DWORD*);
IDirect3DDevice9_ValidateDevice IDirect3DDevice9_ValidateDevice_orig = 0;
HRESULT __stdcall IDirect3DDevice9_ValidateDevice_hook(IDirect3DDevice9* pDevice, DWORD* pNumPasses)
{
    vireio::debugf("IDirect3DDevice9_ValidateDevice_hook: %i, %i", pDevice, pNumPasses);
    return IDirect3DDevice9_ValidateDevice_orig(pDevice, pNumPasses);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetPaletteEntries)(IDirect3DDevice9*, UINT, const PALETTEENTRY*);
IDirect3DDevice9_SetPaletteEntries IDirect3DDevice9_SetPaletteEntries_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetPaletteEntries_hook(IDirect3DDevice9* pDevice, UINT PaletteNumber, const PALETTEENTRY* pEntries)
{
    vireio::debugf("IDirect3DDevice9_SetPaletteEntries_hook: %i, %i, %i", pDevice, PaletteNumber, pEntries);
    return IDirect3DDevice9_SetPaletteEntries_orig(pDevice, PaletteNumber, pEntries);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetPaletteEntries)(IDirect3DDevice9*, UINT, PALETTEENTRY*);
IDirect3DDevice9_GetPaletteEntries IDirect3DDevice9_GetPaletteEntries_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetPaletteEntries_hook(IDirect3DDevice9* pDevice, UINT PaletteNumber, PALETTEENTRY* pEntries)
{
    vireio::debugf("IDirect3DDevice9_GetPaletteEntries_hook: %i, %i, %i", pDevice, PaletteNumber, pEntries);
    return IDirect3DDevice9_GetPaletteEntries_orig(pDevice, PaletteNumber, pEntries);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetCurrentTexturePalette)(IDirect3DDevice9*, UINT);
IDirect3DDevice9_SetCurrentTexturePalette IDirect3DDevice9_SetCurrentTexturePalette_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetCurrentTexturePalette_hook(IDirect3DDevice9* pDevice, UINT PaletteNumber)
{
    vireio::debugf("IDirect3DDevice9_SetCurrentTexturePalette_hook: %i, %i", pDevice, PaletteNumber);
    return IDirect3DDevice9_SetCurrentTexturePalette_orig(pDevice, PaletteNumber);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetCurrentTexturePalette)(IDirect3DDevice9*, UINT*);
IDirect3DDevice9_GetCurrentTexturePalette IDirect3DDevice9_GetCurrentTexturePalette_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetCurrentTexturePalette_hook(IDirect3DDevice9* pDevice, UINT* PaletteNumber)
{
    vireio::debugf("IDirect3DDevice9_GetCurrentTexturePalette_hook: %i, %i", pDevice, PaletteNumber);
    return IDirect3DDevice9_GetCurrentTexturePalette_orig(pDevice, PaletteNumber);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetScissorRect)(IDirect3DDevice9*, const RECT*);
IDirect3DDevice9_SetScissorRect IDirect3DDevice9_SetScissorRect_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetScissorRect_hook(IDirect3DDevice9* pDevice, const RECT* pRect)
{
    vireio::debugf("IDirect3DDevice9_SetScissorRect_hook: %i, %i", pDevice, pRect);
    return IDirect3DDevice9_SetScissorRect_orig(pDevice, pRect);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetScissorRect)(IDirect3DDevice9*, RECT*);
IDirect3DDevice9_GetScissorRect IDirect3DDevice9_GetScissorRect_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetScissorRect_hook(IDirect3DDevice9* pDevice, RECT* pRect)
{
    vireio::debugf("IDirect3DDevice9_GetScissorRect_hook: %i, %i", pDevice, pRect);
    return IDirect3DDevice9_GetScissorRect_orig(pDevice, pRect);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetSoftwareVertexProcessing)(IDirect3DDevice9*, BOOL);
IDirect3DDevice9_SetSoftwareVertexProcessing IDirect3DDevice9_SetSoftwareVertexProcessing_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetSoftwareVertexProcessing_hook(IDirect3DDevice9* pDevice, BOOL bSoftware)
{
    vireio::debugf("IDirect3DDevice9_SetSoftwareVertexProcessing_hook: %i, %i", pDevice, bSoftware);
    return IDirect3DDevice9_SetSoftwareVertexProcessing_orig(pDevice, bSoftware);
}
typedef BOOL(__stdcall* IDirect3DDevice9_GetSoftwareVertexProcessing)(IDirect3DDevice9*);
IDirect3DDevice9_GetSoftwareVertexProcessing IDirect3DDevice9_GetSoftwareVertexProcessing_orig = 0;
BOOL __stdcall IDirect3DDevice9_GetSoftwareVertexProcessing_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_GetSoftwareVertexProcessing_hook: %i", pDevice);
    return IDirect3DDevice9_GetSoftwareVertexProcessing_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetNPatchMode)(IDirect3DDevice9*, float);
IDirect3DDevice9_SetNPatchMode IDirect3DDevice9_SetNPatchMode_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetNPatchMode_hook(IDirect3DDevice9* pDevice, float nSegments)
{
    vireio::debugf("IDirect3DDevice9_SetNPatchMode_hook: %i, %i", pDevice, nSegments);
    return IDirect3DDevice9_SetNPatchMode_orig(pDevice, nSegments);
}
typedef float(__stdcall* IDirect3DDevice9_GetNPatchMode)(IDirect3DDevice9*);
IDirect3DDevice9_GetNPatchMode IDirect3DDevice9_GetNPatchMode_orig = 0;
float __stdcall IDirect3DDevice9_GetNPatchMode_hook(IDirect3DDevice9* pDevice)
{
    vireio::debugf("IDirect3DDevice9_GetNPatchMode_hook: %i", pDevice);
    return IDirect3DDevice9_GetNPatchMode_orig(pDevice);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DrawPrimitive)(IDirect3DDevice9*, D3DPRIMITIVETYPE, UINT, UINT);
IDirect3DDevice9_DrawPrimitive IDirect3DDevice9_DrawPrimitive_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DrawPrimitive_hook(IDirect3DDevice9* pDevice, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount)
{
    vireio::debugf("IDirect3DDevice9_DrawPrimitive_hook: %i, %i, %i, %i", pDevice, PrimitiveType, StartVertex, PrimitiveCount);
    return IDirect3DDevice9_DrawPrimitive_orig(pDevice, PrimitiveType, StartVertex, PrimitiveCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DrawIndexedPrimitive)(IDirect3DDevice9*, D3DPRIMITIVETYPE, INT, UINT, UINT, UINT, UINT);
IDirect3DDevice9_DrawIndexedPrimitive IDirect3DDevice9_DrawIndexedPrimitive_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DrawIndexedPrimitive_hook(IDirect3DDevice9* pDevice, D3DPRIMITIVETYPE arg1, INT BaseVertexIndex, UINT MinVertexIndex, UINT NumVertices, UINT startIndex, UINT primCount)
{
    vireio::debugf("IDirect3DDevice9_DrawIndexedPrimitive_hook: %i, %i, %i, %i, %i, %i, %i", pDevice, arg1, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
    return IDirect3DDevice9_DrawIndexedPrimitive_orig(pDevice, arg1, BaseVertexIndex, MinVertexIndex, NumVertices, startIndex, primCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DrawPrimitiveUP)(IDirect3DDevice9*, D3DPRIMITIVETYPE, UINT, const void*, UINT);
IDirect3DDevice9_DrawPrimitiveUP IDirect3DDevice9_DrawPrimitiveUP_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DrawPrimitiveUP_hook(IDirect3DDevice9* pDevice, D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, const void* pVertexStreamZeroData, UINT VertexStreamZeroStride)
{
    vireio::debugf("IDirect3DDevice9_DrawPrimitiveUP_hook: %i, %i, %i, %i, %i", pDevice, PrimitiveType, PrimitiveCount, pVertexStreamZeroData, VertexStreamZeroStride);
    return IDirect3DDevice9_DrawPrimitiveUP_orig(pDevice, PrimitiveType, PrimitiveCount, pVertexStreamZeroData, VertexStreamZeroStride);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DrawIndexedPrimitiveUP)(IDirect3DDevice9*, D3DPRIMITIVETYPE, UINT, UINT, UINT, const void*, D3DFORMAT, const void*, UINT);
IDirect3DDevice9_DrawIndexedPrimitiveUP IDirect3DDevice9_DrawIndexedPrimitiveUP_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DrawIndexedPrimitiveUP_hook(IDirect3DDevice9* pDevice, D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertices, UINT PrimitiveCount, const void* pIndexData, D3DFORMAT IndexDataFormat, const void* pVertexStreamZeroData, UINT VertexStreamZeroStride)
{
    vireio::debugf("IDirect3DDevice9_DrawIndexedPrimitiveUP_hook: %i, %i, %i, %i, %i, %i, %i, %i, %i", pDevice, PrimitiveType, MinVertexIndex, NumVertices, PrimitiveCount, pIndexData, IndexDataFormat, pVertexStreamZeroData, VertexStreamZeroStride);
    return IDirect3DDevice9_DrawIndexedPrimitiveUP_orig(pDevice, PrimitiveType, MinVertexIndex, NumVertices, PrimitiveCount, pIndexData, IndexDataFormat, pVertexStreamZeroData, VertexStreamZeroStride);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_ProcessVertices)(IDirect3DDevice9*, UINT, UINT, UINT, IDirect3DVertexBuffer9*, IDirect3DVertexDeclaration9*, DWORD);
IDirect3DDevice9_ProcessVertices IDirect3DDevice9_ProcessVertices_orig = 0;
HRESULT __stdcall IDirect3DDevice9_ProcessVertices_hook(IDirect3DDevice9* pDevice, UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags)
{
    vireio::debugf("IDirect3DDevice9_ProcessVertices_hook: %i, %i, %i, %i, %i, %i, %i", pDevice, SrcStartIndex, DestIndex, VertexCount, pDestBuffer, pVertexDecl, Flags);
    return IDirect3DDevice9_ProcessVertices_orig(pDevice, SrcStartIndex, DestIndex, VertexCount, pDestBuffer, pVertexDecl, Flags);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateVertexDeclaration)(IDirect3DDevice9*, const D3DVERTEXELEMENT9*, IDirect3DVertexDeclaration9**);
IDirect3DDevice9_CreateVertexDeclaration IDirect3DDevice9_CreateVertexDeclaration_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateVertexDeclaration_hook(IDirect3DDevice9* pDevice, const D3DVERTEXELEMENT9* pVertexElements, IDirect3DVertexDeclaration9** ppDecl)
{
    vireio::debugf("IDirect3DDevice9_CreateVertexDeclaration_hook: %i, %i, %i", pDevice, pVertexElements, ppDecl);
    return IDirect3DDevice9_CreateVertexDeclaration_orig(pDevice, pVertexElements, ppDecl);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetVertexDeclaration)(IDirect3DDevice9*, IDirect3DVertexDeclaration9*);
IDirect3DDevice9_SetVertexDeclaration IDirect3DDevice9_SetVertexDeclaration_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetVertexDeclaration_hook(IDirect3DDevice9* pDevice, IDirect3DVertexDeclaration9* pDecl)
{
    vireio::debugf("IDirect3DDevice9_SetVertexDeclaration_hook: %i, %i", pDevice, pDecl);
    return IDirect3DDevice9_SetVertexDeclaration_orig(pDevice, pDecl);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetVertexDeclaration)(IDirect3DDevice9*, IDirect3DVertexDeclaration9**);
IDirect3DDevice9_GetVertexDeclaration IDirect3DDevice9_GetVertexDeclaration_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetVertexDeclaration_hook(IDirect3DDevice9* pDevice, IDirect3DVertexDeclaration9** ppDecl)
{
    vireio::debugf("IDirect3DDevice9_GetVertexDeclaration_hook: %i, %i", pDevice, ppDecl);
    return IDirect3DDevice9_GetVertexDeclaration_orig(pDevice, ppDecl);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetFVF)(IDirect3DDevice9*, DWORD);
IDirect3DDevice9_SetFVF IDirect3DDevice9_SetFVF_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetFVF_hook(IDirect3DDevice9* pDevice, DWORD FVF)
{
    vireio::debugf("IDirect3DDevice9_SetFVF_hook: %i, %i", pDevice, FVF);
    return IDirect3DDevice9_SetFVF_orig(pDevice, FVF);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetFVF)(IDirect3DDevice9*, DWORD*);
IDirect3DDevice9_GetFVF IDirect3DDevice9_GetFVF_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetFVF_hook(IDirect3DDevice9* pDevice, DWORD* pFVF)
{
    vireio::debugf("IDirect3DDevice9_GetFVF_hook: %i, %i", pDevice, pFVF);
    return IDirect3DDevice9_GetFVF_orig(pDevice, pFVF);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateVertexShader)(IDirect3DDevice9*, const DWORD*, IDirect3DVertexShader9**);
IDirect3DDevice9_CreateVertexShader IDirect3DDevice9_CreateVertexShader_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateVertexShader_hook(IDirect3DDevice9* pDevice, const DWORD* pFunction, IDirect3DVertexShader9** ppShader)
{
    vireio::debugf("IDirect3DDevice9_CreateVertexShader_hook: %i, %i, %i", pDevice, pFunction, ppShader);
    return IDirect3DDevice9_CreateVertexShader_orig(pDevice, pFunction, ppShader);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetVertexShader)(IDirect3DDevice9*, IDirect3DVertexShader9*);
IDirect3DDevice9_SetVertexShader IDirect3DDevice9_SetVertexShader_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetVertexShader_hook(IDirect3DDevice9* pDevice, IDirect3DVertexShader9* pShader)
{
    vireio::debugf("IDirect3DDevice9_SetVertexShader_hook: %i, %i", pDevice, pShader);
    return IDirect3DDevice9_SetVertexShader_orig(pDevice, pShader);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetVertexShader)(IDirect3DDevice9*, IDirect3DVertexShader9**);
IDirect3DDevice9_GetVertexShader IDirect3DDevice9_GetVertexShader_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetVertexShader_hook(IDirect3DDevice9* pDevice, IDirect3DVertexShader9** ppShader)
{
    vireio::debugf("IDirect3DDevice9_GetVertexShader_hook: %i, %i", pDevice, ppShader);
    return IDirect3DDevice9_GetVertexShader_orig(pDevice, ppShader);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetVertexShaderConstantF)(IDirect3DDevice9*, UINT, const float*, UINT);
IDirect3DDevice9_SetVertexShaderConstantF IDirect3DDevice9_SetVertexShaderConstantF_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetVertexShaderConstantF_hook(IDirect3DDevice9* pDevice, UINT StartRegister, const float* pConstantData, UINT Vector4fCount)
{
    vireio::debugf("IDirect3DDevice9_SetVertexShaderConstantF_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4fCount);
    return IDirect3DDevice9_SetVertexShaderConstantF_orig(pDevice, StartRegister, pConstantData, Vector4fCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetVertexShaderConstantF)(IDirect3DDevice9*, UINT, float*, UINT);
IDirect3DDevice9_GetVertexShaderConstantF IDirect3DDevice9_GetVertexShaderConstantF_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetVertexShaderConstantF_hook(IDirect3DDevice9* pDevice, UINT StartRegister, float* pConstantData, UINT Vector4fCount)
{
    vireio::debugf("IDirect3DDevice9_GetVertexShaderConstantF_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4fCount);
    return IDirect3DDevice9_GetVertexShaderConstantF_orig(pDevice, StartRegister, pConstantData, Vector4fCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetVertexShaderConstantI)(IDirect3DDevice9*, UINT, const int*, UINT);
IDirect3DDevice9_SetVertexShaderConstantI IDirect3DDevice9_SetVertexShaderConstantI_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetVertexShaderConstantI_hook(IDirect3DDevice9* pDevice, UINT StartRegister, const int* pConstantData, UINT Vector4iCount)
{
    vireio::debugf("IDirect3DDevice9_SetVertexShaderConstantI_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4iCount);
    return IDirect3DDevice9_SetVertexShaderConstantI_orig(pDevice, StartRegister, pConstantData, Vector4iCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetVertexShaderConstantI)(IDirect3DDevice9*, UINT, int*, UINT);
IDirect3DDevice9_GetVertexShaderConstantI IDirect3DDevice9_GetVertexShaderConstantI_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetVertexShaderConstantI_hook(IDirect3DDevice9* pDevice, UINT StartRegister, int* pConstantData, UINT Vector4iCount)
{
    vireio::debugf("IDirect3DDevice9_GetVertexShaderConstantI_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4iCount);
    return IDirect3DDevice9_GetVertexShaderConstantI_orig(pDevice, StartRegister, pConstantData, Vector4iCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetVertexShaderConstantB)(IDirect3DDevice9*, UINT, const BOOL*, UINT);
IDirect3DDevice9_SetVertexShaderConstantB IDirect3DDevice9_SetVertexShaderConstantB_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetVertexShaderConstantB_hook(IDirect3DDevice9* pDevice, UINT StartRegister, const BOOL* pConstantData, UINT BoolCount)
{
    vireio::debugf("IDirect3DDevice9_SetVertexShaderConstantB_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, BoolCount);
    return IDirect3DDevice9_SetVertexShaderConstantB_orig(pDevice, StartRegister, pConstantData, BoolCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetVertexShaderConstantB)(IDirect3DDevice9*, UINT, BOOL*, UINT);
IDirect3DDevice9_GetVertexShaderConstantB IDirect3DDevice9_GetVertexShaderConstantB_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetVertexShaderConstantB_hook(IDirect3DDevice9* pDevice, UINT StartRegister, BOOL* pConstantData, UINT BoolCount)
{
    vireio::debugf("IDirect3DDevice9_GetVertexShaderConstantB_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, BoolCount);
    return IDirect3DDevice9_GetVertexShaderConstantB_orig(pDevice, StartRegister, pConstantData, BoolCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetStreamSource)(IDirect3DDevice9*, UINT, IDirect3DVertexBuffer9*, UINT, UINT);
IDirect3DDevice9_SetStreamSource IDirect3DDevice9_SetStreamSource_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetStreamSource_hook(IDirect3DDevice9* pDevice, UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride)
{
    vireio::debugf("IDirect3DDevice9_SetStreamSource_hook: %i, %i, %i, %i, %i", pDevice, StreamNumber, pStreamData, OffsetInBytes, Stride);
    return IDirect3DDevice9_SetStreamSource_orig(pDevice, StreamNumber, pStreamData, OffsetInBytes, Stride);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetStreamSource)(IDirect3DDevice9*, UINT, IDirect3DVertexBuffer9**, UINT*, UINT*);
IDirect3DDevice9_GetStreamSource IDirect3DDevice9_GetStreamSource_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetStreamSource_hook(IDirect3DDevice9* pDevice, UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* pOffsetInBytes, UINT* pStride)
{
    vireio::debugf("IDirect3DDevice9_GetStreamSource_hook: %i, %i, %i, %i, %i", pDevice, StreamNumber, ppStreamData, pOffsetInBytes, pStride);
    return IDirect3DDevice9_GetStreamSource_orig(pDevice, StreamNumber, ppStreamData, pOffsetInBytes, pStride);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetStreamSourceFreq)(IDirect3DDevice9*, UINT, UINT);
IDirect3DDevice9_SetStreamSourceFreq IDirect3DDevice9_SetStreamSourceFreq_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetStreamSourceFreq_hook(IDirect3DDevice9* pDevice, UINT StreamNumber, UINT Setting)
{
    vireio::debugf("IDirect3DDevice9_SetStreamSourceFreq_hook: %i, %i, %i", pDevice, StreamNumber, Setting);
    return IDirect3DDevice9_SetStreamSourceFreq_orig(pDevice, StreamNumber, Setting);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetStreamSourceFreq)(IDirect3DDevice9*, UINT, UINT*);
IDirect3DDevice9_GetStreamSourceFreq IDirect3DDevice9_GetStreamSourceFreq_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetStreamSourceFreq_hook(IDirect3DDevice9* pDevice, UINT StreamNumber, UINT* pSetting)
{
    vireio::debugf("IDirect3DDevice9_GetStreamSourceFreq_hook: %i, %i, %i", pDevice, StreamNumber, pSetting);
    return IDirect3DDevice9_GetStreamSourceFreq_orig(pDevice, StreamNumber, pSetting);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetIndices)(IDirect3DDevice9*, IDirect3DIndexBuffer9*);
IDirect3DDevice9_SetIndices IDirect3DDevice9_SetIndices_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetIndices_hook(IDirect3DDevice9* pDevice, IDirect3DIndexBuffer9* pIndexData)
{
    vireio::debugf("IDirect3DDevice9_SetIndices_hook: %i, %i", pDevice, pIndexData);
    return IDirect3DDevice9_SetIndices_orig(pDevice, pIndexData);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetIndices)(IDirect3DDevice9*, IDirect3DIndexBuffer9**);
IDirect3DDevice9_GetIndices IDirect3DDevice9_GetIndices_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetIndices_hook(IDirect3DDevice9* pDevice, IDirect3DIndexBuffer9** ppIndexData)
{
    vireio::debugf("IDirect3DDevice9_GetIndices_hook: %i, %i", pDevice, ppIndexData);
    return IDirect3DDevice9_GetIndices_orig(pDevice, ppIndexData);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreatePixelShader)(IDirect3DDevice9*, const DWORD*, IDirect3DPixelShader9**);
IDirect3DDevice9_CreatePixelShader IDirect3DDevice9_CreatePixelShader_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreatePixelShader_hook(IDirect3DDevice9* pDevice, const DWORD* pFunction, IDirect3DPixelShader9** ppShader)
{
    vireio::debugf("IDirect3DDevice9_CreatePixelShader_hook: %i, %i, %i", pDevice, pFunction, ppShader);
    return IDirect3DDevice9_CreatePixelShader_orig(pDevice, pFunction, ppShader);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetPixelShader)(IDirect3DDevice9*, IDirect3DPixelShader9*);
IDirect3DDevice9_SetPixelShader IDirect3DDevice9_SetPixelShader_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetPixelShader_hook(IDirect3DDevice9* pDevice, IDirect3DPixelShader9* pShader)
{
    vireio::debugf("IDirect3DDevice9_SetPixelShader_hook: %i, %i", pDevice, pShader);
    return IDirect3DDevice9_SetPixelShader_orig(pDevice, pShader);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetPixelShader)(IDirect3DDevice9*, IDirect3DPixelShader9**);
IDirect3DDevice9_GetPixelShader IDirect3DDevice9_GetPixelShader_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetPixelShader_hook(IDirect3DDevice9* pDevice, IDirect3DPixelShader9** ppShader)
{
    vireio::debugf("IDirect3DDevice9_GetPixelShader_hook: %i, %i", pDevice, ppShader);
    return IDirect3DDevice9_GetPixelShader_orig(pDevice, ppShader);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetPixelShaderConstantF)(IDirect3DDevice9*, UINT, const float*, UINT);
IDirect3DDevice9_SetPixelShaderConstantF IDirect3DDevice9_SetPixelShaderConstantF_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetPixelShaderConstantF_hook(IDirect3DDevice9* pDevice, UINT StartRegister, const float* pConstantData, UINT Vector4fCount)
{
    vireio::debugf("IDirect3DDevice9_SetPixelShaderConstantF_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4fCount);
    return IDirect3DDevice9_SetPixelShaderConstantF_orig(pDevice, StartRegister, pConstantData, Vector4fCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetPixelShaderConstantF)(IDirect3DDevice9*, UINT, float*, UINT);
IDirect3DDevice9_GetPixelShaderConstantF IDirect3DDevice9_GetPixelShaderConstantF_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetPixelShaderConstantF_hook(IDirect3DDevice9* pDevice, UINT StartRegister, float* pConstantData, UINT Vector4fCount)
{
    vireio::debugf("IDirect3DDevice9_GetPixelShaderConstantF_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4fCount);
    return IDirect3DDevice9_GetPixelShaderConstantF_orig(pDevice, StartRegister, pConstantData, Vector4fCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetPixelShaderConstantI)(IDirect3DDevice9*, UINT, const int*, UINT);
IDirect3DDevice9_SetPixelShaderConstantI IDirect3DDevice9_SetPixelShaderConstantI_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetPixelShaderConstantI_hook(IDirect3DDevice9* pDevice, UINT StartRegister, const int* pConstantData, UINT Vector4iCount)
{
    vireio::debugf("IDirect3DDevice9_SetPixelShaderConstantI_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4iCount);
    return IDirect3DDevice9_SetPixelShaderConstantI_orig(pDevice, StartRegister, pConstantData, Vector4iCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetPixelShaderConstantI)(IDirect3DDevice9*, UINT, int*, UINT);
IDirect3DDevice9_GetPixelShaderConstantI IDirect3DDevice9_GetPixelShaderConstantI_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetPixelShaderConstantI_hook(IDirect3DDevice9* pDevice, UINT StartRegister, int* pConstantData, UINT Vector4iCount)
{
    vireio::debugf("IDirect3DDevice9_GetPixelShaderConstantI_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, Vector4iCount);
    return IDirect3DDevice9_GetPixelShaderConstantI_orig(pDevice, StartRegister, pConstantData, Vector4iCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_SetPixelShaderConstantB)(IDirect3DDevice9*, UINT, const BOOL*, UINT);
IDirect3DDevice9_SetPixelShaderConstantB IDirect3DDevice9_SetPixelShaderConstantB_orig = 0;
HRESULT __stdcall IDirect3DDevice9_SetPixelShaderConstantB_hook(IDirect3DDevice9* pDevice, UINT StartRegister, const BOOL* pConstantData, UINT BoolCount)
{
    vireio::debugf("IDirect3DDevice9_SetPixelShaderConstantB_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, BoolCount);
    return IDirect3DDevice9_SetPixelShaderConstantB_orig(pDevice, StartRegister, pConstantData, BoolCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_GetPixelShaderConstantB)(IDirect3DDevice9*, UINT, BOOL*, UINT);
IDirect3DDevice9_GetPixelShaderConstantB IDirect3DDevice9_GetPixelShaderConstantB_orig = 0;
HRESULT __stdcall IDirect3DDevice9_GetPixelShaderConstantB_hook(IDirect3DDevice9* pDevice, UINT StartRegister, BOOL* pConstantData, UINT BoolCount)
{
    vireio::debugf("IDirect3DDevice9_GetPixelShaderConstantB_hook: %i, %i, %i, %i", pDevice, StartRegister, pConstantData, BoolCount);
    return IDirect3DDevice9_GetPixelShaderConstantB_orig(pDevice, StartRegister, pConstantData, BoolCount);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DrawRectPatch)(IDirect3DDevice9*, UINT, const float*, const D3DRECTPATCH_INFO*);
IDirect3DDevice9_DrawRectPatch IDirect3DDevice9_DrawRectPatch_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DrawRectPatch_hook(IDirect3DDevice9* pDevice, UINT Handle, const float* pNumSegs, const D3DRECTPATCH_INFO* pRectPatchInfo)
{
    vireio::debugf("IDirect3DDevice9_DrawRectPatch_hook: %i, %i, %i, %i", pDevice, Handle, pNumSegs, pRectPatchInfo);
    return IDirect3DDevice9_DrawRectPatch_orig(pDevice, Handle, pNumSegs, pRectPatchInfo);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DrawTriPatch)(IDirect3DDevice9*, UINT, const float*, const D3DTRIPATCH_INFO*);
IDirect3DDevice9_DrawTriPatch IDirect3DDevice9_DrawTriPatch_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DrawTriPatch_hook(IDirect3DDevice9* pDevice, UINT Handle, const float* pNumSegs, const D3DTRIPATCH_INFO* pTriPatchInfo)
{
    vireio::debugf("IDirect3DDevice9_DrawTriPatch_hook: %i, %i, %i, %i", pDevice, Handle, pNumSegs, pTriPatchInfo);
    return IDirect3DDevice9_DrawTriPatch_orig(pDevice, Handle, pNumSegs, pTriPatchInfo);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_DeletePatch)(IDirect3DDevice9*, UINT);
IDirect3DDevice9_DeletePatch IDirect3DDevice9_DeletePatch_orig = 0;
HRESULT __stdcall IDirect3DDevice9_DeletePatch_hook(IDirect3DDevice9* pDevice, UINT Handle)
{
    vireio::debugf("IDirect3DDevice9_DeletePatch_hook: %i, %i", pDevice, Handle);
    return IDirect3DDevice9_DeletePatch_orig(pDevice, Handle);
}
typedef HRESULT(__stdcall* IDirect3DDevice9_CreateQuery)(IDirect3DDevice9*, D3DQUERYTYPE, IDirect3DQuery9**);
IDirect3DDevice9_CreateQuery IDirect3DDevice9_CreateQuery_orig = 0;
HRESULT __stdcall IDirect3DDevice9_CreateQuery_hook(IDirect3DDevice9* pDevice, D3DQUERYTYPE Type, IDirect3DQuery9** ppQuery)
{
    vireio::debugf("IDirect3DDevice9_CreateQuery_hook: %i, %i, %i", pDevice, Type, ppQuery);
    return IDirect3DDevice9_CreateQuery_orig(pDevice, Type, ppQuery);
}
int ScreenBufferSize = 0;
bool searching = false;
IDirect3DSurface9* surface;
typedef HMODULE(__stdcall* LoadLibraryW_)(LPCSTR name);
LoadLibraryW_ LoadLibraryW_orig = 0;
HMODULE __stdcall LoadLibraryW_hook(LPCSTR name)
{
    vireio::debugf("LoadLibraryW_hook(%ls)", name);
    return LoadLibraryW_orig(name);
}
typedef FARPROC(__stdcall* GetProcAddress_)(HMODULE hModule, LPCSTR lpProcName);
GetProcAddress_ GetProcAddress_orig = 0;
FARPROC __stdcall GetProcAddress_hook(HMODULE hModule, LPCSTR lpProcName)
{
    vireio::debugf("GetProcAddress_hook(%i, %s)", hModule, lpProcName);
    return GetProcAddress_orig(hModule, lpProcName);
}
LRESULT __stdcall MsgProcs(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case 0x0002:
        return 0;
    }
    return DefWindowProcW(hWnd, msg, wParam, lParam);
}
bool HookDirectX()
{
    if (MH_Initialize() != MH_OK) {
        MessageBoxA(0, "Failed to initialize MinHook", "Error", 0x00000000L);
        return false;
    }
    HMODULE mod = GetModuleHandleW(L"does_not_matter");
    WNDCLASSEX wc = {
        sizeof(WNDCLASSEX), 0x0040, MsgProcs, 0L, 0L,
        mod, 0, 0, 0, 0,
        L"D3DHook", 0
    };
    RegisterClassExW(&wc);
    HWND window = CreateWindowExW(0L, L"D3DHook", L"Hooking...", (0x00000000L | 0x00C00000L | 0x00080000L | 0x00040000L | 0x00020000L | 0x00010000L), 100, 100, 300, 300, 0, 0, wc.hInstance, 0);
    if (!window) {
        MessageBoxA(0, "Failed to create window", "Error", 0x00000000L);
        return false;
    }
    HRESULT res = Direct3DCreate9Ex(32, &SharingExDx9);
    if ((((HRESULT)(res)) < 0)) {
        vireio::debugf("Failed to create SharingExDx9");
        return false;
    }
    vireio::debugf("Created SharingExDx9");
    D3DPRESENT_PARAMETERS params;
    memset((&params), 0, (sizeof(params)));
    params.Windowed = 1;
    params.SwapEffect = D3DSWAPEFFECT_DISCARD;
    params.BackBufferFormat = D3DFMT_UNKNOWN;
    params.EnableAutoDepthStencil = 1;
    params.AutoDepthStencilFormat = D3DFMT_D16;
    res = SharingExDx9->CreateDeviceEx(0, D3DDEVTYPE_HAL, window,
        0x00000020L,
        &params, 0, &SharingExDxDevice);
    if ((((HRESULT)(res)) < 0)) {
        vireio::debugf("failed to create SharingExDxDevice");
        DestroyWindow(window);
        return false;
    }
    vireio::debugf("Created SharingExDxDevice");
    DWORD64* dVtable_alt = (DWORD64*)*(DWORD64*)SharingExDx9;
    DWORD64* dVtable = (DWORD64*)SharingExDxDevice;
    dVtable = (DWORD64*)dVtable[0];
    vireio::debugf("Hooking directX functions");
    if (MH_CreateHook((DWORD_PTR*)dVtable[0], &IDirect3DDevice9_QueryInterface_hook, reinterpret_cast<void**>(&IDirect3DDevice9_QueryInterface_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_QueryInterface");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[1], &IDirect3DDevice9_AddRef_hook, reinterpret_cast<void**>(&IDirect3DDevice9_AddRef_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_AddRef");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[2], &IDirect3DDevice9_Release_hook, reinterpret_cast<void**>(&IDirect3DDevice9_Release_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_Release");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[3], &IDirect3DDevice9_TestCooperativeLevel_hook, reinterpret_cast<void**>(&IDirect3DDevice9_TestCooperativeLevel_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_TestCooperativeLevel");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[4], &IDirect3DDevice9_GetAvailableTextureMem_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetAvailableTextureMem_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetAvailableTextureMem");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[5], &IDirect3DDevice9_EvictManagedResources_hook, reinterpret_cast<void**>(&IDirect3DDevice9_EvictManagedResources_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_EvictManagedResources");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[6], &IDirect3DDevice9_GetDirect3D_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetDirect3D_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetDirect3D");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[7], &IDirect3DDevice9_GetDeviceCaps_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetDeviceCaps_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetDeviceCaps");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[8], &IDirect3DDevice9_GetDisplayMode_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetDisplayMode_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetDisplayMode");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[9], &IDirect3DDevice9_GetCreationParameters_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetCreationParameters_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetCreationParameters");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[10], &IDirect3DDevice9_SetCursorProperties_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetCursorProperties_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetCursorProperties");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[11], &IDirect3DDevice9_SetCursorPosition_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetCursorPosition_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetCursorPosition");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[12], &IDirect3DDevice9_ShowCursor_hook, reinterpret_cast<void**>(&IDirect3DDevice9_ShowCursor_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_ShowCursor");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[13], &IDirect3DDevice9_CreateAdditionalSwapChain_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateAdditionalSwapChain_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateAdditionalSwapChain");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[14], &IDirect3DDevice9_GetSwapChain_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetSwapChain_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetSwapChain");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[15], &IDirect3DDevice9_GetNumberOfSwapChains_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetNumberOfSwapChains_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetNumberOfSwapChains");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[16], &IDirect3DDevice9_Reset_hook, reinterpret_cast<void**>(&IDirect3DDevice9_Reset_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_Reset");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[17], &IDirect3DDevice9_Present_hook, reinterpret_cast<void**>(&IDirect3DDevice9_Present_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_Present");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[18], &IDirect3DDevice9_GetBackBuffer_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetBackBuffer_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetBackBuffer");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[19], &IDirect3DDevice9_GetRasterStatus_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetRasterStatus_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetRasterStatus");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[20], &IDirect3DDevice9_SetDialogBoxMode_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetDialogBoxMode_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetDialogBoxMode");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[21], &IDirect3DDevice9_SetGammaRamp_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetGammaRamp_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetGammaRamp");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[22], &IDirect3DDevice9_GetGammaRamp_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetGammaRamp_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetGammaRamp");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[23], &IDirect3DDevice9_CreateTexture_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateTexture_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateTexture");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[24], &IDirect3DDevice9_CreateVolumeTexture_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateVolumeTexture_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateVolumeTexture");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[25], &IDirect3DDevice9_CreateCubeTexture_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateCubeTexture_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateCubeTexture");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[26], &IDirect3DDevice9_CreateVertexBuffer_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateVertexBuffer_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateVertexBuffer");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[27], &IDirect3DDevice9_CreateIndexBuffer_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateIndexBuffer_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateIndexBuffer");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[28], &IDirect3DDevice9_CreateRenderTarget_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateRenderTarget_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateRenderTarget");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[29], &IDirect3DDevice9_CreateDepthStencilSurface_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateDepthStencilSurface_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateDepthStencilSurface");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[30], &IDirect3DDevice9_UpdateSurface_hook, reinterpret_cast<void**>(&IDirect3DDevice9_UpdateSurface_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_UpdateSurface");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[31], &IDirect3DDevice9_UpdateTexture_hook, reinterpret_cast<void**>(&IDirect3DDevice9_UpdateTexture_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_UpdateTexture");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[32], &IDirect3DDevice9_GetRenderTargetData_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetRenderTargetData_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetRenderTargetData");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[33], &IDirect3DDevice9_GetFrontBufferData_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetFrontBufferData_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetFrontBufferData");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[34], &IDirect3DDevice9_StretchRect_hook, reinterpret_cast<void**>(&IDirect3DDevice9_StretchRect_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_StretchRect");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[35], &IDirect3DDevice9_ColorFill_hook, reinterpret_cast<void**>(&IDirect3DDevice9_ColorFill_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_ColorFill");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[36], &IDirect3DDevice9_CreateOffscreenPlainSurface_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateOffscreenPlainSurface_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateOffscreenPlainSurface");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[37], &IDirect3DDevice9_SetRenderTarget_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetRenderTarget_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetRenderTarget");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[38], &IDirect3DDevice9_GetRenderTarget_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetRenderTarget_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetRenderTarget");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[39], &IDirect3DDevice9_SetDepthStencilSurface_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetDepthStencilSurface_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetDepthStencilSurface");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[40], &IDirect3DDevice9_GetDepthStencilSurface_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetDepthStencilSurface_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetDepthStencilSurface");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[41], &IDirect3DDevice9_BeginScene_hook, reinterpret_cast<void**>(&IDirect3DDevice9_BeginScene_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_BeginScene");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[42], &IDirect3DDevice9_EndScene_hook, reinterpret_cast<void**>(&IDirect3DDevice9_EndScene_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_EndScene");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[43], &IDirect3DDevice9_Clear_hook, reinterpret_cast<void**>(&IDirect3DDevice9_Clear_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_Clear");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[44], &IDirect3DDevice9_SetTransform_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetTransform_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetTransform");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[45], &IDirect3DDevice9_GetTransform_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetTransform_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetTransform");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[46], &IDirect3DDevice9_MultiplyTransform_hook, reinterpret_cast<void**>(&IDirect3DDevice9_MultiplyTransform_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_MultiplyTransform");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[47], &IDirect3DDevice9_SetViewport_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetViewport_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetViewport");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[48], &IDirect3DDevice9_GetViewport_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetViewport_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetViewport");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[49], &IDirect3DDevice9_SetMaterial_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetMaterial_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetMaterial");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[50], &IDirect3DDevice9_GetMaterial_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetMaterial_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetMaterial");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[51], &IDirect3DDevice9_SetLight_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetLight_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetLight");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[52], &IDirect3DDevice9_GetLight_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetLight_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetLight");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[53], &IDirect3DDevice9_LightEnable_hook, reinterpret_cast<void**>(&IDirect3DDevice9_LightEnable_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_LightEnable");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[54], &IDirect3DDevice9_GetLightEnable_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetLightEnable_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetLightEnable");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[55], &IDirect3DDevice9_SetClipPlane_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetClipPlane_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetClipPlane");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[56], &IDirect3DDevice9_GetClipPlane_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetClipPlane_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetClipPlane");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[57], &IDirect3DDevice9_SetRenderState_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetRenderState_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetRenderState");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[58], &IDirect3DDevice9_GetRenderState_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetRenderState_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetRenderState");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[59], &IDirect3DDevice9_CreateStateBlock_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateStateBlock_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateStateBlock");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[60], &IDirect3DDevice9_BeginStateBlock_hook, reinterpret_cast<void**>(&IDirect3DDevice9_BeginStateBlock_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_BeginStateBlock");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[61], &IDirect3DDevice9_EndStateBlock_hook, reinterpret_cast<void**>(&IDirect3DDevice9_EndStateBlock_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_EndStateBlock");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[62], &IDirect3DDevice9_SetClipStatus_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetClipStatus_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetClipStatus");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[63], &IDirect3DDevice9_GetClipStatus_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetClipStatus_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetClipStatus");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[64], &IDirect3DDevice9_GetTexture_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetTexture_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetTexture");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[65], &IDirect3DDevice9_SetTexture_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetTexture_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetTexture");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[66], &IDirect3DDevice9_GetTextureStageState_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetTextureStageState_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetTextureStageState");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[67], &IDirect3DDevice9_SetTextureStageState_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetTextureStageState_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetTextureStageState");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[68], &IDirect3DDevice9_GetSamplerState_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetSamplerState_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetSamplerState");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[69], &IDirect3DDevice9_SetSamplerState_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetSamplerState_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetSamplerState");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[70], &IDirect3DDevice9_ValidateDevice_hook, reinterpret_cast<void**>(&IDirect3DDevice9_ValidateDevice_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_ValidateDevice");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[71], &IDirect3DDevice9_SetPaletteEntries_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetPaletteEntries_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetPaletteEntries");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[72], &IDirect3DDevice9_GetPaletteEntries_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetPaletteEntries_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetPaletteEntries");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[73], &IDirect3DDevice9_SetCurrentTexturePalette_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetCurrentTexturePalette_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetCurrentTexturePalette");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[74], &IDirect3DDevice9_GetCurrentTexturePalette_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetCurrentTexturePalette_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetCurrentTexturePalette");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[75], &IDirect3DDevice9_SetScissorRect_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetScissorRect_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetScissorRect");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[76], &IDirect3DDevice9_GetScissorRect_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetScissorRect_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetScissorRect");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[77], &IDirect3DDevice9_SetSoftwareVertexProcessing_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetSoftwareVertexProcessing_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetSoftwareVertexProcessing");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[78], &IDirect3DDevice9_GetSoftwareVertexProcessing_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetSoftwareVertexProcessing_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetSoftwareVertexProcessing");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[79], &IDirect3DDevice9_SetNPatchMode_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetNPatchMode_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetNPatchMode");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[80], &IDirect3DDevice9_GetNPatchMode_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetNPatchMode_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetNPatchMode");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[81], &IDirect3DDevice9_DrawPrimitive_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DrawPrimitive_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DrawPrimitive");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[82], &IDirect3DDevice9_DrawIndexedPrimitive_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DrawIndexedPrimitive_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DrawIndexedPrimitive");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[83], &IDirect3DDevice9_DrawPrimitiveUP_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DrawPrimitiveUP_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DrawPrimitiveUP");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[84], &IDirect3DDevice9_DrawIndexedPrimitiveUP_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DrawIndexedPrimitiveUP_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DrawIndexedPrimitiveUP");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[85], &IDirect3DDevice9_ProcessVertices_hook, reinterpret_cast<void**>(&IDirect3DDevice9_ProcessVertices_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_ProcessVertices");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[86], &IDirect3DDevice9_CreateVertexDeclaration_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateVertexDeclaration_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateVertexDeclaration");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[87], &IDirect3DDevice9_SetVertexDeclaration_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetVertexDeclaration_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetVertexDeclaration");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[88], &IDirect3DDevice9_GetVertexDeclaration_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetVertexDeclaration_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetVertexDeclaration");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[89], &IDirect3DDevice9_SetFVF_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetFVF_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetFVF");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[90], &IDirect3DDevice9_GetFVF_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetFVF_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetFVF");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[91], &IDirect3DDevice9_CreateVertexShader_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateVertexShader_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateVertexShader");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[92], &IDirect3DDevice9_SetVertexShader_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetVertexShader_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetVertexShader");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[93], &IDirect3DDevice9_GetVertexShader_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetVertexShader_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetVertexShader");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[94], &IDirect3DDevice9_SetVertexShaderConstantF_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetVertexShaderConstantF_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetVertexShaderConstantF");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[95], &IDirect3DDevice9_GetVertexShaderConstantF_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetVertexShaderConstantF_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetVertexShaderConstantF");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[96], &IDirect3DDevice9_SetVertexShaderConstantI_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetVertexShaderConstantI_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetVertexShaderConstantI");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[97], &IDirect3DDevice9_GetVertexShaderConstantI_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetVertexShaderConstantI_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetVertexShaderConstantI");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[98], &IDirect3DDevice9_SetVertexShaderConstantB_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetVertexShaderConstantB_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetVertexShaderConstantB");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[99], &IDirect3DDevice9_GetVertexShaderConstantB_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetVertexShaderConstantB_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetVertexShaderConstantB");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[100], &IDirect3DDevice9_SetStreamSource_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetStreamSource_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetStreamSource");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[101], &IDirect3DDevice9_GetStreamSource_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetStreamSource_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetStreamSource");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[102], &IDirect3DDevice9_SetStreamSourceFreq_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetStreamSourceFreq_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetStreamSourceFreq");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[103], &IDirect3DDevice9_GetStreamSourceFreq_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetStreamSourceFreq_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetStreamSourceFreq");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[104], &IDirect3DDevice9_SetIndices_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetIndices_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetIndices");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[105], &IDirect3DDevice9_GetIndices_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetIndices_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetIndices");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[106], &IDirect3DDevice9_CreatePixelShader_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreatePixelShader_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreatePixelShader");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[107], &IDirect3DDevice9_SetPixelShader_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetPixelShader_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetPixelShader");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[108], &IDirect3DDevice9_GetPixelShader_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetPixelShader_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetPixelShader");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[109], &IDirect3DDevice9_SetPixelShaderConstantF_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetPixelShaderConstantF_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetPixelShaderConstantF");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[110], &IDirect3DDevice9_GetPixelShaderConstantF_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetPixelShaderConstantF_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetPixelShaderConstantF");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[111], &IDirect3DDevice9_SetPixelShaderConstantI_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetPixelShaderConstantI_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetPixelShaderConstantI");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[112], &IDirect3DDevice9_GetPixelShaderConstantI_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetPixelShaderConstantI_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetPixelShaderConstantI");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[113], &IDirect3DDevice9_SetPixelShaderConstantB_hook, reinterpret_cast<void**>(&IDirect3DDevice9_SetPixelShaderConstantB_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_SetPixelShaderConstantB");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[114], &IDirect3DDevice9_GetPixelShaderConstantB_hook, reinterpret_cast<void**>(&IDirect3DDevice9_GetPixelShaderConstantB_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_GetPixelShaderConstantB");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[115], &IDirect3DDevice9_DrawRectPatch_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DrawRectPatch_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DrawRectPatch");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[116], &IDirect3DDevice9_DrawTriPatch_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DrawTriPatch_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DrawTriPatch");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[117], &IDirect3DDevice9_DeletePatch_hook, reinterpret_cast<void**>(&IDirect3DDevice9_DeletePatch_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_DeletePatch");
    }
    if (MH_CreateHook((DWORD_PTR*)dVtable[118], &IDirect3DDevice9_CreateQuery_hook, reinterpret_cast<void**>(&IDirect3DDevice9_CreateQuery_orig)) != MH_OK) {
        vireio::debugf("failed to hook IDirect3DDevice9_CreateQuery");
    }
    vireio::debugf("Enabeling directX hooking functions");
    if (MH_EnableHook(0) != MH_OK) {
        MessageBoxA(0, "Failed to enable hooks", "Error", 0x00000000L);
        return 0;
    }
    return true;
}
_declspec(dllexport) void __cdecl init()
{
    FILE* fp;
    fopen_s(&fp, "C:\\s4\\output.txt", "a");
    if (fp) {
        fputs("init\n", fp);
        fclose(fp);
    }
    bool OK = HookDirectX();
    D3DXMATRIX m_matView;
    D3DXMATRIX m_matProj;
    D3DXMATRIX m_matWorld;
    D3DXVECTOR3 vEyePt(0.0f, 0.0f, 1.0f);
    D3DXVECTOR3 vLookatPt(0.0f, 0.0f, 0.0f);
    D3DXVECTOR3 vUpVec(0.0f, -1.0f, 0.0f);
    D3DXMatrixLookAtLH(&m_matView, &vEyePt, &vLookatPt, &vUpVec);
    D3DXMatrixPerspectiveFovLH(&m_matProj, ((FLOAT)3.141592654f) / 4, 1.0f, 0.0f, 1.0f);
    if (OK) {
        vireio::debugf("Hooked");
    } else {
        vireio::debugf("Hooking failed");
    }
}
